<!DOCTYPE html>

<head>
    <title>WebSocket client test</title>
    <script src="../smartpro/socket.io.min.js"></script>
    <script src="../smartpro/protobuf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/aes-js/3.1.2/index.min.js"></script> -->
</head>

<body>
    <h1>WebSocket TCBS</h1>
</body>

<script language="javascript" type="text/javascript">
    function binaryReader(buffer, offset, encoding = "utf-8") {
        // create a view over first 4 bytes starting at offset
        let view = new DataView(buffer.buffer, offset, 4);
        // read those 4 bytes as int 32 (big endian, since your example is like that)
        let length = view.getInt32(0);
        // get a slice of the length we got
        let sliceWithString = buffer.slice(offset + 4, offset + 4 + length);
        let decoder = new TextDecoder(encoding);
        return decoder.decode(sliceWithString);
    }
    function base64ToArrayUnit8(g) {
        for (
            var p = window.atob(g), r = p.length, h = new Uint8Array(r), A = 0;
            A < r;
            A++
        )
            h[A] = p.charCodeAt(A);
        return h;
        // var raw = window.atob(g);
        // console.log("atob: ", raw.length);
        // var rawLength = raw.length;
        // var array = new Uint8Array(new ArrayBuffer(rawLength));

        // for (i = 0; i < rawLength; i++) {
        //     array[i] = raw.charCodeAt(i);
        // }
        // return array;
    }
    function deserializeBinary(l) {
        var g = new t.BinaryReader(l),
            p = new proto.pb.TickerMatchedPriceDerivative();
        return deserializeBinaryFromReader(p, g);
    }
    function deserializeBinaryFromReader(l, g) {
        for (; g.nextField() && !g.isEndGroup(); )
            switch (g.getFieldNumber()) {
                case 1:
                    var r = g.readString();
                    l.setSymbol(r);
                    break;
                case 2:
                    (r = g.readDouble()), l.setHigh(r);
                    break;
                case 3:
                    (r = g.readDouble()), l.setLow(r);
                    break;
                case 4:
                    (r = g.readDouble()), l.setAvg(r);
                    break;
                case 5:
                    (r = g.readDouble()), l.setOpen(r);
                    break;
                default:
                    g.skipField();
            }
        return l;
    }
    function decrypt() {
        // var ciphertext = "79a247e48ac27ed33ca3f1919067fa64";
        // var key = "6268890F-9B58-484C-8CDC-34F9C6A9";
        // var iv = "6268890F-9B58-48";

        // var ciphertextWA = CryptoJS.enc.Hex.parse(ciphertext);
        // var keyWA = CryptoJS.enc.Utf8.parse(key);
        // var ivWA = CryptoJS.enc.Utf8.parse(iv);
        // var ciphertextCP = { ciphertext: ciphertextWA };

        // var decrypted = CryptoJS.AES.decrypt(ciphertextCP, keyWA, { iv: ivWA });

        // console.log(decrypted.toString(CryptoJS.enc.Utf8)); // Apple

        var data = "Thọ";

        // var encrypted = CryptoJS.AES.encrypt(data, _getCryptoKey()).toString();

        // console.log(encrypted);
        // => 'U2FsdGVkX18K9Ch1JYnck/Jmq+WDgM49vPmodMcLTk+/SzKtFg+o3Olc38kzacKv'
        var Lt = "10000376255";
        var on = "10000376255.iVLJnFPyvMdqUFXBCwip";
        var xe = CryptoJS.enc.Utf8.parse(on);
        var mr = (on || "").substring(0, 16);
        var yt = CryptoJS.enc.Utf8.parse(mr);

        console.log("key: ", on);
        console.log("iv: ", mr);

        // var encrypted = CryptoJS.AES.encrypt("Tho", xe, {
        //     // iv: yt
        //     // padding: CryptoJS.pad.Pkcs7,
        //     // mode: CryptoJS.mode.CBC
        //     mode: CryptoJS.mode.ECB
        // }).toString();
        // console.log("enc: ", encrypted);
        // encrypted = "WeJcFMQ/8+8QJ/w0hHh+0g==";
        encrypted =
            "CglWTjMwRjIzMDIRmpmZmZlRkEAZAAAAAAAA8D8hMzMzMzNRkEApAAAAAAAACEAxmpmZmZlRkEA5AAAAAAAAN0BA6962nwY=";
        // encrypted =
        //     "CglWTjMwRjIzMDIQwNzUw+UwGZqZmZmZUZBAITMzMzMzUZBAKZqZmZmZUZBAMTMzMzMzUZBAOAlBAAAAAAAK+0BJMzMzMzMzHUBQPFlmZmZmZlvCQGEAAAP+mAqlQmlH5shbfdV8P3EAAAAAAESQQHkAAAAAAF6QQIEBAAAAAABEkEA=";
        console.log("encrypted: ", encrypted);
        // encrypted = CryptoJS.enc.Base64.parse(encrypted);
        // encrypted = atob(encrypted);
        encrypted = b64decode(encrypted);
        console.log("rawData: ", encrypted);
        var decrypted = CryptoJS.AES.decrypt(encrypted, xe, {
            iv: yt,
            padding: CryptoJS.pad.Pkcs7,
            mode: CryptoJS.mode.CBC
            // mode: CryptoJS.mode.ECB
        }).toString(CryptoJS.enc.Utf8);

        console.log("decrypted: ", decrypted);
        // => 'a JSON blob or something'
    }
    function b64decode(u) {
        let Y = "";
        if ((u = String(u).replace(/=+$/, "")).length % 4 == 1)
            throw new Error(
                "'atob' failed: The string to be decoded is not correctly encoded."
            );
        for (
            let X, y, Q = 0, x = 0;
            (y = u.charAt(x++));
            ~y && ((X = Q % 4 ? 64 * X + y : y), Q++ % 4)
                ? (Y += String.fromCharCode(255 & (X >> ((-2 * Q) & 6))))
                : 0
        )
            y = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(
                y
            );
        return Y;
    }
    function b64DecodeUnicode(u) {
        return decodeURIComponent(
            Array.prototype.map
                .call(
                    b64decode(u),
                    Z => "%" + ("00" + Z.charCodeAt(0).toString(16)).slice(-2)
                )
                .join("")
        );
        // return Array.prototype.map
        //     .call(
        //         b64decode(u),
        //         Z => "%" + ("00" + Z.charCodeAt(0).toString(16)).slice(-2)
        //     )
        //     .join("");
    }
    function _getCryptoKey() {
        // return "10000376255.iVLJnFPyvMdqUFXBCwip";
        return "10000376255"; //.iVLJ"; //nFPyvMdqUFXBCwip";
    }
    function testWebSocket() {
        var wsUri = "wss://futures-wscenter.tcbs.com.vn/wscenter/v1/stream";
        websocket = new WebSocket(wsUri);
        websocket.onopen = function(evt) {
            console.log("onopen", evt);
            // var msg = { action: "join", list: "VN30F2302" };
            // websocket.send(
            //     "42" + JSON.stringify(["regs", JSON.stringify(msg)])
            // );
            websocket.send("d|ut|C001|");
            websocket.send("d|st|C001|VN30F2302");
            websocket.send("d|st|C001|VN30F2302");
            websocket.send("d|s|VN30F2302");
        };
        websocket.onclose = function(evt) {
            console.log("onclose", evt);
            testWebSocket();
        };
        websocket.onmessage = function(evt) {
            console.log("onmessage", evt.data);
        };
        websocket.onerror = function(evt) {
            console.log("onerror", evt);
        };
    }
    // window.addEventListener("load", testWebSocket, false);
    // window.addEventListener("load", decrypt, false);

    window.addEventListener("load", () => {
        // var base64 =
        //     "CglWTjMwRjIzMDIRmpmZmZlRkEAZAAAAAAAA8D8hMzMzMzNRkEApAAAAAAAACEAxmpmZmZlRkEA5AAAAAAAAN0BA6962nwY=";
        // var base64 =
        //     "CglWTjMwRjIzMDIQwNzUw+UwGZqZmZmZUZBAITMzMzMzUZBAKZqZmZmZUZBAMTMzMzMzUZBAOAlBAAAAAAAK+0BJMzMzMzMzHUBQPFlmZmZmZlvCQGEAAAP+mAqlQmlH5shbfdV8P3EAAAAAAESQQHkAAAAAAF6QQIEBAAAAAABEkEA=";
        // console.log(base64);
        // var buffer = base64ToArrayUnit8(base64);
        // console.log(buffer);
        // console.log(binaryReader(buffer, 0, "utf-8"));

        async function encodeTestMessage(payload) {
            const root = await protobuf.load("tcbs.proto");
            const testMessage = root.lookupType("tcbs.testMessage");
            const message = testMessage.create(payload);
            return testMessage.encode(message).finish();
        }

        async function decodeTestMessage(buffer) {
            const root = await protobuf.load("tcbs.proto");
            const testMessage = root.lookupType("tcbs.testMessage");
            const err = testMessage.verify(buffer);
            if (err) {
                throw err;
            }
            const message = testMessage.decode(buffer);
            return testMessage.toObject(message);
        }

        async function testProtobuf() {
            const payload = {
                timestamp: Math.round(new Date().getTime() / 1000),
                message: "A rose by any other name would smell as sweet"
            };
            console.log("Test message:", payload);
            const buffer = await encodeTestMessage(payload);
            console.log(
                `Encoded message (${buffer.length} bytes): `,
                buffer.toString("hex")
            );
            const decodedMessage = await decodeTestMessage(buffer);
            console.log("Decoded test message:", decodedMessage);
        }

        testProtobuf();
    });
</script>
