(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[56],{

/***/ "./node_modules/devextreme-quill/dist/dx-quill.js":
/*!********************************************************!*\
  !*** ./node_modules/devextreme-quill/dist/dx-quill.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * DevExtreme-Quill Editor v.1.5.16\n * https://js.devexpress.com/\n * Copyright (c) 2020, Developer Express Inc.\n * Copyright (c) 2017, Slab\n * Copyright (c) 2014, Jason Chen\n * Copyright (c) 2013, salesforce.com\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 172);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return globalRegistry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return expandConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return overload; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Quill; });\n/* harmony import */ var quill_delta__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var quill_delta__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(quill_delta__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18);\n/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(34);\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);\n/* harmony import */ var _editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4);\n/* harmony import */ var _emitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);\n/* harmony import */ var _module__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(14);\n/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7);\n/* harmony import */ var _instances__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(41);\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(23);\n/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(53);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\n\n\n\n\nvar debug = Object(_logger__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"a\"])('quill');\nvar globalRegistry = new parchment__WEBPACK_IMPORTED_MODULE_3__[\"Registry\"]();\nparchment__WEBPACK_IMPORTED_MODULE_3__[\"ParentBlot\"].uiClass = 'ql-ui';\n\nvar Quill = /*#__PURE__*/function () {\n  function Quill(container) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Quill);\n\n    this.options = expandConfig(container, options);\n    this.container = this.options.container;\n\n    if (this.container == null) {\n      return debug.error('Invalid Quill container', container);\n    }\n\n    if (this.options.debug) {\n      Quill.debug(this.options.debug);\n    }\n\n    var html = this.container.innerHTML.trim();\n    this.container.classList.add('ql-container');\n    this.container.innerHTML = '';\n    _instances__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"].set(this.container, this);\n    this.root = this.addContainer('ql-editor');\n    this.root.classList.add('ql-blank');\n    this.scrollingContainer = this.options.scrollingContainer || this.root;\n    this.emitter = new _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"]();\n    var ScrollBlot = this.options.registry.query(parchment__WEBPACK_IMPORTED_MODULE_3__[\"ScrollBlot\"].blotName);\n    this.scroll = new ScrollBlot(this.options.registry, this.root, {\n      emitter: this.emitter,\n      toggleBlankClass: this.toggleBlankClass.bind(this)\n    });\n    this.editor = new _editor__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"](this.scroll);\n    this.selection = new _selection__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"b\"](this.scroll, this.emitter);\n    this.theme = new this.options.theme(this, this.options); // eslint-disable-line new-cap\n\n    this.keyboard = this.theme.addModule('keyboard');\n    this.clipboard = this.theme.addModule('clipboard');\n    this.history = this.theme.addModule('history');\n    this.uploader = this.theme.addModule('uploader');\n    this.theme.init();\n    this.emitter.on(_emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].events.EDITOR_CHANGE, function (type) {\n      if (type === _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].events.TEXT_CHANGE) {\n        _this.toggleBlankClass();\n      }\n    });\n    this.emitter.on(_emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].events.SCROLL_UPDATE, function (source, mutations) {\n      var oldRange = _this.selection.lastRange;\n\n      var _this$selection$getRa = _this.selection.getRange(),\n          _this$selection$getRa2 = _slicedToArray(_this$selection$getRa, 1),\n          newRange = _this$selection$getRa2[0];\n\n      var selectionInfo = oldRange && newRange ? {\n        oldRange: oldRange,\n        newRange: newRange\n      } : undefined;\n      modify.call(_this, function () {\n        return _this.editor.update(null, mutations, selectionInfo);\n      }, source);\n    });\n    this.setContents(this.getInitialContent(html));\n    this.history.clear();\n\n    if (this.options.placeholder) {\n      this.root.setAttribute('data-placeholder', this.options.placeholder);\n    }\n\n    if (this.options.readOnly) {\n      this.disable();\n    }\n\n    this.allowReadOnlyEdits = false;\n  }\n\n  _createClass(Quill, [{\n    key: \"getInitialContent\",\n    value: function getInitialContent(html) {\n      return this.clipboard.convert({\n        html: \"\".concat(html, \"<p><br></p>\"),\n        text: '\\n'\n      });\n    }\n  }, {\n    key: \"toggleBlankClass\",\n    value: function toggleBlankClass() {\n      var isComposing = this.selection.composing;\n      this.root.classList.toggle('ql-blank', this.editor.isBlank(isComposing));\n    }\n  }, {\n    key: \"addContainer\",\n    value: function addContainer(container) {\n      var refNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (typeof container === 'string') {\n        var className = container;\n        container = document.createElement('div');\n        container.classList.add(className);\n      }\n\n      this.container.insertBefore(container, refNode);\n      return container;\n    }\n  }, {\n    key: \"blur\",\n    value: function blur() {\n      this.selection.setRange(null);\n    }\n  }, {\n    key: \"deleteText\",\n    value: function deleteText(index, length, source) {\n      var _this2 = this;\n\n      var _overload = overload(index, length, source);\n\n      var _overload2 = _slicedToArray(_overload, 4);\n\n      index = _overload2[0];\n      length = _overload2[1];\n      source = _overload2[3];\n      return modify.call(this, function () {\n        return _this2.editor.deleteText(index, length);\n      }, source, index, -1 * length);\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enable(false);\n    }\n  }, {\n    key: \"editReadOnly\",\n    value: function editReadOnly(modifier) {\n      this.allowReadOnlyEdits = true;\n      var value = modifier();\n      this.allowReadOnlyEdits = false;\n      return value;\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.scroll.enable(enabled);\n      this.container.classList.toggle('ql-disabled', !enabled);\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      var scrollTop = this.scrollingContainer.scrollTop;\n      this.selection.focus();\n      this.scrollingContainer.scrollTop = scrollTop;\n      this.scrollIntoView();\n    }\n  }, {\n    key: \"format\",\n    value: function format(name, value) {\n      var _this3 = this;\n\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources.API;\n      return modify.call(this, function () {\n        var range = _this3.getSelection(true);\n\n        var change = new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a();\n        if (range == null) return change;\n\n        if (_this3.scroll.query(name, parchment__WEBPACK_IMPORTED_MODULE_3__[\"Scope\"].BLOCK)) {\n          change = _this3.editor.formatLine(range.index, range.length, _defineProperty({}, name, value));\n        } else if (range.length === 0) {\n          _this3.selection.format(name, value);\n\n          return change;\n        } else {\n          change = _this3.editor.formatText(range.index, range.length, _defineProperty({}, name, value));\n        }\n\n        _this3.setSelection(range, _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources.SILENT);\n\n        return change;\n      }, source);\n    }\n  }, {\n    key: \"formatLine\",\n    value: function formatLine(index, length, name, value, source) {\n      var _this4 = this;\n\n      var formats; // eslint-disable-next-line prefer-const\n\n      var _overload3 = overload(index, length, name, value, source);\n\n      var _overload4 = _slicedToArray(_overload3, 4);\n\n      index = _overload4[0];\n      length = _overload4[1];\n      formats = _overload4[2];\n      source = _overload4[3];\n      return modify.call(this, function () {\n        return _this4.editor.formatLine(index, length, formats);\n      }, source, index, 0);\n    }\n  }, {\n    key: \"formatText\",\n    value: function formatText(index, length, name, value, source) {\n      var _this5 = this;\n\n      var formats; // eslint-disable-next-line prefer-const\n\n      var _overload5 = overload(index, length, name, value, source);\n\n      var _overload6 = _slicedToArray(_overload5, 4);\n\n      index = _overload6[0];\n      length = _overload6[1];\n      formats = _overload6[2];\n      source = _overload6[3];\n      return modify.call(this, function () {\n        return _this5.editor.formatText(index, length, formats);\n      }, source, index, 0);\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds(index) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var bounds;\n\n      if (typeof index === 'number') {\n        bounds = this.selection.getBounds(index, length);\n      } else {\n        bounds = this.selection.getBounds(index.index, index.length);\n      }\n\n      var containerBounds = this.container.getBoundingClientRect();\n      return {\n        bottom: bounds.bottom - containerBounds.top,\n        height: bounds.height,\n        left: bounds.left - containerBounds.left,\n        right: bounds.right - containerBounds.left,\n        top: bounds.top - containerBounds.top,\n        width: bounds.width\n      };\n    }\n  }, {\n    key: \"getContents\",\n    value: function getContents() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;\n\n      var _overload7 = overload(index, length);\n\n      var _overload8 = _slicedToArray(_overload7, 2);\n\n      index = _overload8[0];\n      length = _overload8[1];\n      return this.editor.getContents(index, length);\n    }\n  }, {\n    key: \"getFormat\",\n    value: function getFormat() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSelection(true);\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (typeof index === 'number') {\n        return this.editor.getFormat(index, length);\n      }\n\n      return this.editor.getFormat(index.index, index.length);\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(blot) {\n      return blot.offset(this.scroll);\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this.scroll.length();\n    }\n  }, {\n    key: \"getLeaf\",\n    value: function getLeaf(index) {\n      return this.scroll.leaf(index);\n    }\n  }, {\n    key: \"getLine\",\n    value: function getLine(index) {\n      return this.scroll.line(index);\n    }\n  }, {\n    key: \"getLines\",\n    value: function getLines() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n\n      if (typeof index !== 'number') {\n        return this.scroll.lines(index.index, index.length);\n      }\n\n      return this.scroll.lines(index, length);\n    }\n  }, {\n    key: \"getModule\",\n    value: function getModule(name) {\n      return this.theme.modules[name];\n    }\n  }, {\n    key: \"getSelection\",\n    value: function getSelection() {\n      var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (focus) this.focus();\n      this.update(); // Make sure we access getRange with editor in consistent state\n\n      return this.selection.getRange()[0];\n    }\n  }, {\n    key: \"getSemanticHTML\",\n    value: function getSemanticHTML() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;\n\n      var _overload9 = overload(index, length);\n\n      var _overload10 = _slicedToArray(_overload9, 2);\n\n      index = _overload10[0];\n      length = _overload10[1];\n      return this.editor.getHTML(index, length);\n    }\n  }, {\n    key: \"getText\",\n    value: function getText() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;\n\n      var _overload11 = overload(index, length);\n\n      var _overload12 = _slicedToArray(_overload11, 2);\n\n      index = _overload12[0];\n      length = _overload12[1];\n      return this.editor.getText(index, length);\n    }\n  }, {\n    key: \"hasFocus\",\n    value: function hasFocus() {\n      return this.selection.hasFocus();\n    }\n  }, {\n    key: \"insertEmbed\",\n    value: function insertEmbed(index, embed, value) {\n      var _this6 = this;\n\n      var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Quill.sources.API;\n      return modify.call(this, function () {\n        return _this6.editor.insertEmbed(index, embed, value);\n      }, source, index);\n    }\n  }, {\n    key: \"insertText\",\n    value: function insertText(index, text, name, value, source) {\n      var _this7 = this;\n\n      var formats; // eslint-disable-next-line prefer-const\n\n      var _overload13 = overload(index, 0, name, value, source);\n\n      var _overload14 = _slicedToArray(_overload13, 4);\n\n      index = _overload14[0];\n      formats = _overload14[2];\n      source = _overload14[3];\n      return modify.call(this, function () {\n        return _this7.editor.insertText(index, text, formats);\n      }, source, index, text.length);\n    }\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return this.scroll.isEnabled();\n    }\n  }, {\n    key: \"off\",\n    value: function off() {\n      var _this$emitter;\n\n      return (_this$emitter = this.emitter).off.apply(_this$emitter, arguments);\n    }\n  }, {\n    key: \"on\",\n    value: function on() {\n      var _this$emitter2;\n\n      return (_this$emitter2 = this.emitter).on.apply(_this$emitter2, arguments);\n    }\n  }, {\n    key: \"once\",\n    value: function once() {\n      var _this$emitter3;\n\n      return (_this$emitter3 = this.emitter).once.apply(_this$emitter3, arguments);\n    }\n  }, {\n    key: \"removeFormat\",\n    value: function removeFormat(index, length, source) {\n      var _this8 = this;\n\n      var _overload15 = overload(index, length, source);\n\n      var _overload16 = _slicedToArray(_overload15, 4);\n\n      index = _overload16[0];\n      length = _overload16[1];\n      source = _overload16[3];\n      return modify.call(this, function () {\n        return _this8.editor.removeFormat(index, length);\n      }, source, index);\n    }\n  }, {\n    key: \"scrollIntoView\",\n    value: function scrollIntoView() {\n      this.selection.scrollIntoView(this.scrollingContainer);\n    }\n  }, {\n    key: \"setContents\",\n    value: function setContents(delta) {\n      var _this9 = this;\n\n      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources.API;\n      return modify.call(this, function () {\n        delta = new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a(delta);\n\n        var length = _this9.getLength(); // Quill will set empty editor to \\n\n\n\n        var delete1 = _this9.editor.deleteText(0, length); // delta always applied before existing content\n\n\n        var applied = _this9.editor.applyDelta(delta); // Remove extra \\n from empty editor initialization\n\n\n        var delete2 = _this9.editor.deleteText(_this9.getLength() - 1, 1);\n\n        _this9.emitter.emit(Quill.events.CONTENT_SETTED);\n\n        return delete1.compose(applied).compose(delete2);\n      }, source);\n    }\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(index, length, source) {\n      if (index == null) {\n        this.selection.setRange(null, length || Quill.sources.API);\n      } else {\n        var _overload17 = overload(index, length, source);\n\n        var _overload18 = _slicedToArray(_overload17, 4);\n\n        index = _overload18[0];\n        length = _overload18[1];\n        source = _overload18[3];\n        this.selection.setRange(new _selection__WEBPACK_IMPORTED_MODULE_7__[/* Range */ \"a\"](Math.max(0, index), length), source);\n\n        if (source !== _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources.SILENT) {\n          this.selection.scrollIntoView(this.scrollingContainer);\n        }\n      }\n    }\n  }, {\n    key: \"setText\",\n    value: function setText(text) {\n      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources.API;\n      var delta = new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a().insert(text);\n      return this.setContents(delta, source);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources.USER;\n      var change = this.scroll.update(source); // Will update selection before selection.update() does if text changes\n\n      this.selection.update(source); // TODO this is usually undefined\n\n      return change;\n    }\n  }, {\n    key: \"updateContents\",\n    value: function updateContents(delta) {\n      var _this10 = this;\n\n      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources.API;\n      return modify.call(this, function () {\n        delta = new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a(delta);\n        return _this10.editor.applyDelta(delta, source);\n      }, source, true);\n    }\n  }], [{\n    key: \"debug\",\n    value: function debug(limit) {\n      if (limit === true) {\n        limit = 'log';\n      }\n\n      _logger__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"a\"].level(limit);\n    }\n  }, {\n    key: \"find\",\n    value: function find(node) {\n      return _instances__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"].get(node) || globalRegistry.find(node);\n    }\n  }, {\n    key: \"import\",\n    value: function _import(name) {\n      if (this.imports[name] == null) {\n        debug.error(\"Cannot import \".concat(name, \". Are you sure it was registered?\"));\n      }\n\n      return this.imports[name];\n    }\n  }, {\n    key: \"register\",\n    value: function register(path, target) {\n      var _this11 = this;\n\n      var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (typeof path !== 'string') {\n        var name = path.attrName || path.blotName;\n\n        if (typeof name === 'string') {\n          // register(Blot | Attributor, overwrite)\n          this.register(\"formats/\".concat(name), path, target);\n        } else {\n          Object.keys(path).forEach(function (key) {\n            _this11.register(key, path[key], target);\n          });\n        }\n      } else {\n        if (this.imports[path] != null && !overwrite) {\n          debug.warn(\"Overwriting \".concat(path, \" with\"), target);\n        }\n\n        this.imports[path] = target;\n\n        if ((path.indexOf('blots/') === 0 || path.indexOf('formats/') === 0) && target.blotName !== 'abstract') {\n          globalRegistry.register(target);\n        }\n\n        if (typeof target.register === 'function') {\n          target.register(globalRegistry);\n        }\n      }\n    }\n  }]);\n\n  return Quill;\n}();\n\nQuill.DEFAULTS = {\n  bounds: null,\n  modules: {},\n  placeholder: '',\n  readOnly: false,\n  registry: globalRegistry,\n  scrollingContainer: null,\n  theme: 'default'\n};\nQuill.events = _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].events;\nQuill.sources = _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources; // eslint-disable-next-line no-undef\n\nQuill.version =  false ? undefined : \"1.5.16\";\nQuill.imports = {\n  delta: quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a,\n  parchment: parchment__WEBPACK_IMPORTED_MODULE_3__,\n  'core/module': _module__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"],\n  'core/theme': _theme__WEBPACK_IMPORTED_MODULE_10__[/* default */ \"a\"]\n};\n\nfunction expandConfig(container, userConfig) {\n  userConfig = lodash_merge__WEBPACK_IMPORTED_MODULE_2___default()({\n    container: container,\n    modules: {\n      clipboard: true,\n      keyboard: true,\n      history: true,\n      uploader: true\n    }\n  }, userConfig);\n\n  if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {\n    userConfig.theme = _theme__WEBPACK_IMPORTED_MODULE_10__[/* default */ \"a\"];\n  } else {\n    userConfig.theme = Quill.import(\"themes/\".concat(userConfig.theme));\n\n    if (userConfig.theme == null) {\n      throw new Error(\"Invalid theme \".concat(userConfig.theme, \". Did you register it?\"));\n    }\n  }\n\n  var themeConfig = lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1___default()(userConfig.theme.DEFAULTS);\n  [themeConfig, userConfig].forEach(function (config) {\n    config.modules = config.modules || {};\n    Object.keys(config.modules).forEach(function (module) {\n      if (config.modules[module] === true) {\n        config.modules[module] = {};\n      }\n    });\n  });\n  var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));\n  var moduleConfig = moduleNames.reduce(function (config, name) {\n    var moduleClass = Quill.import(\"modules/\".concat(name));\n\n    if (moduleClass == null) {\n      debug.error(\"Cannot load \".concat(name, \" module. Are you sure you registered it?\"));\n    } else {\n      config[name] = moduleClass.DEFAULTS || {};\n    }\n\n    return config;\n  }, {}); // Special case toolbar shorthand\n\n  if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {\n    userConfig.modules.toolbar = {\n      container: userConfig.modules.toolbar\n    };\n  }\n\n  userConfig = lodash_merge__WEBPACK_IMPORTED_MODULE_2___default()({}, Quill.DEFAULTS, {\n    modules: moduleConfig\n  }, themeConfig, userConfig);\n  ['bounds', 'container', 'scrollingContainer'].forEach(function (key) {\n    if (typeof userConfig[key] === 'string') {\n      userConfig[key] = document.querySelector(userConfig[key]);\n    }\n  });\n  userConfig.modules = Object.keys(userConfig.modules).reduce(function (config, name) {\n    if (userConfig.modules[name]) {\n      config[name] = userConfig.modules[name];\n    }\n\n    return config;\n  }, {});\n  return userConfig;\n} // Handle selection preservation and TEXT_CHANGE emission\n// common to modification APIs\n\n\nfunction modify(modifier, source, index, shift) {\n  if (!this.isEnabled() && source === _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources.USER && !this.allowReadOnlyEdits) {\n    return new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a();\n  }\n\n  var range = index == null ? null : this.getSelection();\n  var oldDelta = this.editor.delta;\n  var change = modifier();\n\n  if (range != null) {\n    if (index === true) {\n      index = range.index; // eslint-disable-line prefer-destructuring\n    }\n\n    if (shift == null) {\n      range = shiftRange(range, change, source);\n    } else if (shift !== 0) {\n      range = shiftRange(range, index, shift, source);\n    }\n\n    this.setSelection(range, _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources.SILENT);\n  }\n\n  if (change.length() > 0) {\n    var _this$emitter4;\n\n    var args = [_emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].events.TEXT_CHANGE, change, oldDelta, source];\n\n    (_this$emitter4 = this.emitter).emit.apply(_this$emitter4, [_emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].events.EDITOR_CHANGE].concat(args));\n\n    if (source !== _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources.SILENT) {\n      var _this$emitter5;\n\n      (_this$emitter5 = this.emitter).emit.apply(_this$emitter5, args);\n    }\n  }\n\n  return change;\n}\n\nfunction overload(index, length, name, value, source) {\n  var formats = {};\n\n  if (typeof index.index === 'number' && typeof index.length === 'number') {\n    // Allow for throwaway end (used by insertText/insertEmbed)\n    if (typeof length !== 'number') {\n      source = value;\n      value = name;\n      name = length;\n      length = index.length; // eslint-disable-line prefer-destructuring\n\n      index = index.index; // eslint-disable-line prefer-destructuring\n    } else {\n      length = index.length; // eslint-disable-line prefer-destructuring\n\n      index = index.index; // eslint-disable-line prefer-destructuring\n    }\n  } else if (typeof length !== 'number') {\n    source = value;\n    value = name;\n    name = length;\n    length = 0;\n  } // Handle format being object, two format name/value strings or excluded\n\n\n  if (_typeof(name) === 'object') {\n    formats = name;\n    source = value;\n  } else if (typeof name === 'string') {\n    if (value != null) {\n      formats[name] = value;\n    } else {\n      source = name;\n    }\n  } // Handle optional source\n\n\n  source = source || _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources.API;\n  return [index, length, formats, source];\n}\n\nfunction shiftRange(range, index, length, source) {\n  if (range == null) return null;\n  var start;\n  var end;\n\n  if (index instanceof quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a) {\n    var _map = [range.index, range.index + range.length].map(function (pos) {\n      return index.transformPosition(pos, source !== _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources.USER);\n    });\n\n    var _map2 = _slicedToArray(_map, 2);\n\n    start = _map2[0];\n    end = _map2[1];\n  } else {\n    var _map3 = [range.index, range.index + range.length].map(function (pos) {\n      if (pos < index || pos === index && source === _emitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].sources.USER) return pos;\n\n      if (length >= 0) {\n        return pos + length;\n      }\n\n      return Math.max(index, pos + length);\n    });\n\n    var _map4 = _slicedToArray(_map3, 2);\n\n    start = _map4[0];\n    end = _map4[1];\n  }\n\n  return new _selection__WEBPACK_IMPORTED_MODULE_7__[/* Range */ \"a\"](start, end - start);\n}\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar fast_diff_1 = __importDefault(__webpack_require__(114));\nvar lodash_clonedeep_1 = __importDefault(__webpack_require__(18));\nvar lodash_isequal_1 = __importDefault(__webpack_require__(29));\nvar AttributeMap_1 = __importDefault(__webpack_require__(115));\nvar Op_1 = __importDefault(__webpack_require__(90));\nvar NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\nvar Delta = /** @class */ (function () {\n    function Delta(ops) {\n        // Assume we are given a well formed ops\n        if (Array.isArray(ops)) {\n            this.ops = ops;\n        }\n        else if (ops != null && Array.isArray(ops.ops)) {\n            this.ops = ops.ops;\n        }\n        else {\n            this.ops = [];\n        }\n    }\n    Delta.prototype.insert = function (arg, attributes) {\n        var newOp = {};\n        if (typeof arg === 'string' && arg.length === 0) {\n            return this;\n        }\n        newOp.insert = arg;\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    };\n    Delta.prototype.delete = function (length) {\n        if (length <= 0) {\n            return this;\n        }\n        return this.push({ delete: length });\n    };\n    Delta.prototype.retain = function (length, attributes) {\n        if (length <= 0) {\n            return this;\n        }\n        var newOp = { retain: length };\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    };\n    Delta.prototype.push = function (newOp) {\n        var index = this.ops.length;\n        var lastOp = this.ops[index - 1];\n        newOp = lodash_clonedeep_1.default(newOp);\n        if (typeof lastOp === 'object') {\n            if (typeof newOp.delete === 'number' &&\n                typeof lastOp.delete === 'number') {\n                this.ops[index - 1] = { delete: lastOp.delete + newOp.delete };\n                return this;\n            }\n            // Since it does not matter if we insert before or after deleting at the same index,\n            // always prefer to insert first\n            if (typeof lastOp.delete === 'number' && newOp.insert != null) {\n                index -= 1;\n                lastOp = this.ops[index - 1];\n                if (typeof lastOp !== 'object') {\n                    this.ops.unshift(newOp);\n                    return this;\n                }\n            }\n            if (lodash_isequal_1.default(newOp.attributes, lastOp.attributes)) {\n                if (typeof newOp.insert === 'string' &&\n                    typeof lastOp.insert === 'string') {\n                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n                else if (typeof newOp.retain === 'number' &&\n                    typeof lastOp.retain === 'number') {\n                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n            }\n        }\n        if (index === this.ops.length) {\n            this.ops.push(newOp);\n        }\n        else {\n            this.ops.splice(index, 0, newOp);\n        }\n        return this;\n    };\n    Delta.prototype.chop = function () {\n        var lastOp = this.ops[this.ops.length - 1];\n        if (lastOp && lastOp.retain && !lastOp.attributes) {\n            this.ops.pop();\n        }\n        return this;\n    };\n    Delta.prototype.filter = function (predicate) {\n        return this.ops.filter(predicate);\n    };\n    Delta.prototype.forEach = function (predicate) {\n        this.ops.forEach(predicate);\n    };\n    Delta.prototype.map = function (predicate) {\n        return this.ops.map(predicate);\n    };\n    Delta.prototype.partition = function (predicate) {\n        var passed = [];\n        var failed = [];\n        this.forEach(function (op) {\n            var target = predicate(op) ? passed : failed;\n            target.push(op);\n        });\n        return [passed, failed];\n    };\n    Delta.prototype.reduce = function (predicate, initialValue) {\n        return this.ops.reduce(predicate, initialValue);\n    };\n    Delta.prototype.changeLength = function () {\n        return this.reduce(function (length, elem) {\n            if (elem.insert) {\n                return length + Op_1.default.length(elem);\n            }\n            else if (elem.delete) {\n                return length - elem.delete;\n            }\n            return length;\n        }, 0);\n    };\n    Delta.prototype.length = function () {\n        return this.reduce(function (length, elem) {\n            return length + Op_1.default.length(elem);\n        }, 0);\n    };\n    Delta.prototype.slice = function (start, end) {\n        if (start === void 0) { start = 0; }\n        if (end === void 0) { end = Infinity; }\n        var ops = [];\n        var iter = Op_1.default.iterator(this.ops);\n        var index = 0;\n        while (index < end && iter.hasNext()) {\n            var nextOp = void 0;\n            if (index < start) {\n                nextOp = iter.next(start - index);\n            }\n            else {\n                nextOp = iter.next(end - index);\n                ops.push(nextOp);\n            }\n            index += Op_1.default.length(nextOp);\n        }\n        return new Delta(ops);\n    };\n    Delta.prototype.compose = function (other) {\n        var thisIter = Op_1.default.iterator(this.ops);\n        var otherIter = Op_1.default.iterator(other.ops);\n        var ops = [];\n        var firstOther = otherIter.peek();\n        if (firstOther != null &&\n            typeof firstOther.retain === 'number' &&\n            firstOther.attributes == null) {\n            var firstLeft = firstOther.retain;\n            while (thisIter.peekType() === 'insert' &&\n                thisIter.peekLength() <= firstLeft) {\n                firstLeft -= thisIter.peekLength();\n                ops.push(thisIter.next());\n            }\n            if (firstOther.retain - firstLeft > 0) {\n                otherIter.next(firstOther.retain - firstLeft);\n            }\n        }\n        var delta = new Delta(ops);\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else if (thisIter.peekType() === 'delete') {\n                delta.push(thisIter.next());\n            }\n            else {\n                var length_1 = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                var thisOp = thisIter.next(length_1);\n                var otherOp = otherIter.next(length_1);\n                if (typeof otherOp.retain === 'number') {\n                    var newOp = {};\n                    if (typeof thisOp.retain === 'number') {\n                        newOp.retain = length_1;\n                    }\n                    else {\n                        newOp.insert = thisOp.insert;\n                    }\n                    // Preserve null when composing with a retain, otherwise remove it for inserts\n                    var attributes = AttributeMap_1.default.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');\n                    if (attributes) {\n                        newOp.attributes = attributes;\n                    }\n                    delta.push(newOp);\n                    // Optimization if rest of other is just retain\n                    if (!otherIter.hasNext() &&\n                        lodash_isequal_1.default(delta.ops[delta.ops.length - 1], newOp)) {\n                        var rest = new Delta(thisIter.rest());\n                        return delta.concat(rest).chop();\n                    }\n                    // Other op should be delete, we could be an insert or retain\n                    // Insert + delete cancels out\n                }\n                else if (typeof otherOp.delete === 'number' &&\n                    typeof thisOp.retain === 'number') {\n                    delta.push(otherOp);\n                }\n            }\n        }\n        return delta.chop();\n    };\n    Delta.prototype.concat = function (other) {\n        var delta = new Delta(this.ops.slice());\n        if (other.ops.length > 0) {\n            delta.push(other.ops[0]);\n            delta.ops = delta.ops.concat(other.ops.slice(1));\n        }\n        return delta;\n    };\n    Delta.prototype.diff = function (other, cursor) {\n        if (this.ops === other.ops) {\n            return new Delta();\n        }\n        var strings = [this, other].map(function (delta) {\n            return delta\n                .map(function (op) {\n                if (op.insert != null) {\n                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n                }\n                var prep = delta === other ? 'on' : 'with';\n                throw new Error('diff() called ' + prep + ' non-document');\n            })\n                .join('');\n        });\n        var retDelta = new Delta();\n        var diffResult = fast_diff_1.default(strings[0], strings[1], cursor);\n        var thisIter = Op_1.default.iterator(this.ops);\n        var otherIter = Op_1.default.iterator(other.ops);\n        diffResult.forEach(function (component) {\n            var length = component[1].length;\n            while (length > 0) {\n                var opLength = 0;\n                switch (component[0]) {\n                    case fast_diff_1.default.INSERT:\n                        opLength = Math.min(otherIter.peekLength(), length);\n                        retDelta.push(otherIter.next(opLength));\n                        break;\n                    case fast_diff_1.default.DELETE:\n                        opLength = Math.min(length, thisIter.peekLength());\n                        thisIter.next(opLength);\n                        retDelta.delete(opLength);\n                        break;\n                    case fast_diff_1.default.EQUAL:\n                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n                        var thisOp = thisIter.next(opLength);\n                        var otherOp = otherIter.next(opLength);\n                        if (lodash_isequal_1.default(thisOp.insert, otherOp.insert)) {\n                            retDelta.retain(opLength, AttributeMap_1.default.diff(thisOp.attributes, otherOp.attributes));\n                        }\n                        else {\n                            retDelta.push(otherOp).delete(opLength);\n                        }\n                        break;\n                }\n                length -= opLength;\n            }\n        });\n        return retDelta.chop();\n    };\n    Delta.prototype.eachLine = function (predicate, newline) {\n        if (newline === void 0) { newline = '\\n'; }\n        var iter = Op_1.default.iterator(this.ops);\n        var line = new Delta();\n        var i = 0;\n        while (iter.hasNext()) {\n            if (iter.peekType() !== 'insert') {\n                return;\n            }\n            var thisOp = iter.peek();\n            var start = Op_1.default.length(thisOp) - iter.peekLength();\n            var index = typeof thisOp.insert === 'string'\n                ? thisOp.insert.indexOf(newline, start) - start\n                : -1;\n            if (index < 0) {\n                line.push(iter.next());\n            }\n            else if (index > 0) {\n                line.push(iter.next(index));\n            }\n            else {\n                if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n                    return;\n                }\n                i += 1;\n                line = new Delta();\n            }\n        }\n        if (line.length() > 0) {\n            predicate(line, {}, i);\n        }\n    };\n    Delta.prototype.invert = function (base) {\n        var inverted = new Delta();\n        this.reduce(function (baseIndex, op) {\n            if (op.insert) {\n                inverted.delete(Op_1.default.length(op));\n            }\n            else if (op.retain && op.attributes == null) {\n                inverted.retain(op.retain);\n                return baseIndex + op.retain;\n            }\n            else if (op.delete || (op.retain && op.attributes)) {\n                var length_2 = (op.delete || op.retain);\n                var slice = base.slice(baseIndex, baseIndex + length_2);\n                slice.forEach(function (baseOp) {\n                    if (op.delete) {\n                        inverted.push(baseOp);\n                    }\n                    else if (op.retain && op.attributes) {\n                        inverted.retain(Op_1.default.length(baseOp), AttributeMap_1.default.invert(op.attributes, baseOp.attributes));\n                    }\n                });\n                return baseIndex + length_2;\n            }\n            return baseIndex;\n        }, 0);\n        return inverted.chop();\n    };\n    Delta.prototype.transform = function (arg, priority) {\n        if (priority === void 0) { priority = false; }\n        priority = !!priority;\n        if (typeof arg === 'number') {\n            return this.transformPosition(arg, priority);\n        }\n        var other = arg;\n        var thisIter = Op_1.default.iterator(this.ops);\n        var otherIter = Op_1.default.iterator(other.ops);\n        var delta = new Delta();\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (thisIter.peekType() === 'insert' &&\n                (priority || otherIter.peekType() !== 'insert')) {\n                delta.retain(Op_1.default.length(thisIter.next()));\n            }\n            else if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else {\n                var length_3 = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                var thisOp = thisIter.next(length_3);\n                var otherOp = otherIter.next(length_3);\n                if (thisOp.delete) {\n                    // Our delete either makes their delete redundant or removes their retain\n                    continue;\n                }\n                else if (otherOp.delete) {\n                    delta.push(otherOp);\n                }\n                else {\n                    // We retain either their retain or insert\n                    delta.retain(length_3, AttributeMap_1.default.transform(thisOp.attributes, otherOp.attributes, priority));\n                }\n            }\n        }\n        return delta.chop();\n    };\n    Delta.prototype.transformPosition = function (index, priority) {\n        if (priority === void 0) { priority = false; }\n        priority = !!priority;\n        var thisIter = Op_1.default.iterator(this.ops);\n        var offset = 0;\n        while (thisIter.hasNext() && offset <= index) {\n            var length_4 = thisIter.peekLength();\n            var nextType = thisIter.peekType();\n            thisIter.next();\n            if (nextType === 'delete') {\n                index -= Math.min(length_4, index - offset);\n                continue;\n            }\n            else if (nextType === 'insert' && (offset < index || !priority)) {\n                index += length_4;\n            }\n            offset += length_4;\n        }\n        return index;\n    };\n    Delta.Op = Op_1.default;\n    Delta.AttributeMap = AttributeMap_1.default;\n    return Delta;\n}());\nmodule.exports = Delta;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"ParentBlot\", function() { return /* reexport */ abstract_parent; });\n__webpack_require__.d(__webpack_exports__, \"ContainerBlot\", function() { return /* reexport */ container; });\n__webpack_require__.d(__webpack_exports__, \"LeafBlot\", function() { return /* reexport */ leaf; });\n__webpack_require__.d(__webpack_exports__, \"EmbedBlot\", function() { return /* reexport */ blot_embed; });\n__webpack_require__.d(__webpack_exports__, \"ScrollBlot\", function() { return /* reexport */ blot_scroll; });\n__webpack_require__.d(__webpack_exports__, \"BlockBlot\", function() { return /* reexport */ block; });\n__webpack_require__.d(__webpack_exports__, \"InlineBlot\", function() { return /* reexport */ inline; });\n__webpack_require__.d(__webpack_exports__, \"TextBlot\", function() { return /* reexport */ blot_text; });\n__webpack_require__.d(__webpack_exports__, \"Attributor\", function() { return /* reexport */ attributor; });\n__webpack_require__.d(__webpack_exports__, \"ClassAttributor\", function() { return /* reexport */ attributor_class; });\n__webpack_require__.d(__webpack_exports__, \"StyleAttributor\", function() { return /* reexport */ style; });\n__webpack_require__.d(__webpack_exports__, \"AttributorStore\", function() { return /* reexport */ store; });\n__webpack_require__.d(__webpack_exports__, \"Registry\", function() { return /* reexport */ registry; });\n__webpack_require__.d(__webpack_exports__, \"Scope\", function() { return /* reexport */ src_scope; });\n\n// CONCATENATED MODULE: ./node_modules/parchment/src/scope.ts\nvar Scope;\n\n(function (Scope) {\n  Scope[Scope[\"TYPE\"] = 3] = \"TYPE\";\n  Scope[Scope[\"LEVEL\"] = 12] = \"LEVEL\";\n  Scope[Scope[\"ATTRIBUTE\"] = 13] = \"ATTRIBUTE\";\n  Scope[Scope[\"BLOT\"] = 14] = \"BLOT\";\n  Scope[Scope[\"INLINE\"] = 7] = \"INLINE\";\n  Scope[Scope[\"BLOCK\"] = 11] = \"BLOCK\";\n  Scope[Scope[\"BLOCK_BLOT\"] = 10] = \"BLOCK_BLOT\";\n  Scope[Scope[\"INLINE_BLOT\"] = 6] = \"INLINE_BLOT\";\n  Scope[Scope[\"BLOCK_ATTRIBUTE\"] = 9] = \"BLOCK_ATTRIBUTE\";\n  Scope[Scope[\"INLINE_ATTRIBUTE\"] = 5] = \"INLINE_ATTRIBUTE\";\n  Scope[Scope[\"ANY\"] = 15] = \"ANY\";\n})(Scope || (Scope = {}));\n\n/* harmony default export */ var src_scope = (Scope);\n// CONCATENATED MODULE: ./node_modules/parchment/src/collection/linked-list.ts\nvar LinkedList =\n/** @class */\nfunction () {\n  function LinkedList() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  LinkedList.prototype.append = function () {\n    var nodes = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      nodes[_i] = arguments[_i];\n    }\n\n    this.insertBefore(nodes[0], null);\n\n    if (nodes.length > 1) {\n      var rest = nodes.slice(1);\n      this.append.apply(this, rest);\n    }\n  };\n\n  LinkedList.prototype.at = function (index) {\n    var next = this.iterator();\n    var cur = next();\n\n    while (cur && index > 0) {\n      index -= 1;\n      cur = next();\n    }\n\n    return cur;\n  };\n\n  LinkedList.prototype.contains = function (node) {\n    var next = this.iterator();\n    var cur = next();\n\n    while (cur) {\n      if (cur === node) {\n        return true;\n      }\n\n      cur = next();\n    }\n\n    return false;\n  };\n\n  LinkedList.prototype.indexOf = function (node) {\n    var next = this.iterator();\n    var cur = next();\n    var index = 0;\n\n    while (cur) {\n      if (cur === node) {\n        return index;\n      }\n\n      index += 1;\n      cur = next();\n    }\n\n    return -1;\n  };\n\n  LinkedList.prototype.insertBefore = function (node, refNode) {\n    if (node == null) {\n      return;\n    }\n\n    this.remove(node);\n    node.next = refNode;\n\n    if (refNode != null) {\n      node.prev = refNode.prev;\n\n      if (refNode.prev != null) {\n        refNode.prev.next = node;\n      }\n\n      refNode.prev = node;\n\n      if (refNode === this.head) {\n        this.head = node;\n      }\n    } else if (this.tail != null) {\n      this.tail.next = node;\n      node.prev = this.tail;\n      this.tail = node;\n    } else {\n      node.prev = null;\n      this.head = this.tail = node;\n    }\n\n    this.length += 1;\n  };\n\n  LinkedList.prototype.offset = function (target) {\n    var index = 0;\n    var cur = this.head;\n\n    while (cur != null) {\n      if (cur === target) {\n        return index;\n      }\n\n      index += cur.length();\n      cur = cur.next;\n    }\n\n    return -1;\n  };\n\n  LinkedList.prototype.remove = function (node) {\n    if (!this.contains(node)) {\n      return;\n    }\n\n    if (node.prev != null) {\n      node.prev.next = node.next;\n    }\n\n    if (node.next != null) {\n      node.next.prev = node.prev;\n    }\n\n    if (node === this.head) {\n      this.head = node.next;\n    }\n\n    if (node === this.tail) {\n      this.tail = node.prev;\n    }\n\n    this.length -= 1;\n  };\n\n  LinkedList.prototype.iterator = function (curNode) {\n    if (curNode === void 0) {\n      curNode = this.head;\n    } // TODO use yield when we can\n\n\n    return function () {\n      var ret = curNode;\n\n      if (curNode != null) {\n        curNode = curNode.next;\n      }\n\n      return ret;\n    };\n  };\n\n  LinkedList.prototype.find = function (index, inclusive) {\n    if (inclusive === void 0) {\n      inclusive = false;\n    }\n\n    var next = this.iterator();\n    var cur = next();\n\n    while (cur) {\n      var length = cur.length();\n\n      if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0)) {\n        return [cur, index];\n      }\n\n      index -= length;\n      cur = next();\n    }\n\n    return [null, 0];\n  };\n\n  LinkedList.prototype.forEach = function (callback) {\n    var next = this.iterator();\n    var cur = next();\n\n    while (cur) {\n      callback(cur);\n      cur = next();\n    }\n  };\n\n  LinkedList.prototype.forEachAt = function (index, length, callback) {\n    if (length <= 0) {\n      return;\n    }\n\n    var _a = this.find(index),\n        startNode = _a[0],\n        offset = _a[1];\n\n    var curIndex = index - offset;\n    var next = this.iterator(startNode);\n    var cur = next();\n\n    while (cur && curIndex < index + length) {\n      var curLength = cur.length();\n\n      if (index > curIndex) {\n        callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));\n      } else {\n        callback(cur, 0, Math.min(curLength, index + length - curIndex));\n      }\n\n      curIndex += curLength;\n      cur = next();\n    }\n  };\n\n  LinkedList.prototype.map = function (callback) {\n    return this.reduce(function (memo, cur) {\n      memo.push(callback(cur));\n      return memo;\n    }, []);\n  };\n\n  LinkedList.prototype.reduce = function (callback, memo) {\n    var next = this.iterator();\n    var cur = next();\n\n    while (cur) {\n      memo = callback(memo, cur);\n      cur = next();\n    }\n\n    return memo;\n  };\n\n  return LinkedList;\n}();\n\n/* harmony default export */ var linked_list = (LinkedList);\n// CONCATENATED MODULE: ./node_modules/parchment/src/error.ts\nvar __extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar ParchmentError =\n/** @class */\nfunction (_super) {\n  __extends(ParchmentError, _super);\n\n  function ParchmentError(message) {\n    var _this = this;\n\n    message = '[Parchment] ' + message;\n    _this = _super.call(this, message) || this;\n    _this.message = message;\n    _this.name = _this.constructor.name;\n    return _this;\n  }\n\n  return ParchmentError;\n}(Error);\n\n/* harmony default export */ var error = (ParchmentError);\n// CONCATENATED MODULE: ./node_modules/parchment/src/registry.ts\n\n\n\nvar registry_Registry =\n/** @class */\nfunction () {\n  function Registry() {\n    this.attributes = {};\n    this.classes = {};\n    this.tags = {};\n    this.types = {};\n  }\n\n  Registry.find = function (node, bubble) {\n    if (bubble === void 0) {\n      bubble = false;\n    }\n\n    if (node == null) {\n      return null;\n    }\n\n    if (this.blots.has(node)) {\n      return this.blots.get(node) || null;\n    }\n\n    if (bubble) {\n      return this.find(node.parentNode, bubble);\n    }\n\n    return null;\n  };\n\n  Registry.prototype.create = function (scroll, input, value) {\n    var match = this.query(input);\n\n    if (match == null) {\n      throw new error(\"Unable to create \" + input + \" blot\");\n    }\n\n    var blotClass = match;\n    var node = // @ts-ignore\n    input instanceof Node || input.nodeType === Node.TEXT_NODE ? input : blotClass.create(value);\n    var blot = new blotClass(scroll, node, value);\n    Registry.blots.set(blot.domNode, blot);\n    return blot;\n  };\n\n  Registry.prototype.find = function (node, bubble) {\n    if (bubble === void 0) {\n      bubble = false;\n    }\n\n    return Registry.find(node, bubble);\n  };\n\n  Registry.prototype.query = function (query, scope) {\n    var _this = this;\n\n    if (scope === void 0) {\n      scope = src_scope.ANY;\n    }\n\n    var match;\n\n    if (typeof query === 'string') {\n      match = this.types[query] || this.attributes[query]; // @ts-ignore\n    } else if (query instanceof Text || query.nodeType === Node.TEXT_NODE) {\n      match = this.types.text;\n    } else if (typeof query === 'number') {\n      if (query & src_scope.LEVEL & src_scope.BLOCK) {\n        match = this.types.block;\n      } else if (query & src_scope.LEVEL & src_scope.INLINE) {\n        match = this.types.inline;\n      }\n    } else if (query instanceof HTMLElement) {\n      var names = (query.getAttribute('class') || '').split(/\\s+/);\n      names.some(function (name) {\n        match = _this.classes[name];\n\n        if (match) {\n          return true;\n        }\n\n        return false;\n      });\n      match = match || this.tags[query.tagName];\n    }\n\n    if (match == null) {\n      return null;\n    } // @ts-ignore\n\n\n    if (scope & src_scope.LEVEL & match.scope && scope & src_scope.TYPE & match.scope) {\n      return match;\n    }\n\n    return null;\n  };\n\n  Registry.prototype.register = function () {\n    var _this = this;\n\n    var definitions = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      definitions[_i] = arguments[_i];\n    }\n\n    if (definitions.length > 1) {\n      return definitions.map(function (d) {\n        return _this.register(d);\n      });\n    }\n\n    var definition = definitions[0];\n\n    if (typeof definition.blotName !== 'string' && typeof definition.attrName !== 'string') {\n      throw new error('Invalid definition');\n    } else if (definition.blotName === 'abstract') {\n      throw new error('Cannot register abstract class');\n    }\n\n    this.types[definition.blotName || definition.attrName] = definition;\n\n    if (typeof definition.keyName === 'string') {\n      this.attributes[definition.keyName] = definition;\n    } else {\n      if (definition.className != null) {\n        this.classes[definition.className] = definition;\n      }\n\n      if (definition.tagName != null) {\n        if (Array.isArray(definition.tagName)) {\n          definition.tagName = definition.tagName.map(function (tagName) {\n            return tagName.toUpperCase();\n          });\n        } else {\n          definition.tagName = definition.tagName.toUpperCase();\n        }\n\n        var tagNames = Array.isArray(definition.tagName) ? definition.tagName : [definition.tagName];\n        tagNames.forEach(function (tag) {\n          if (_this.tags[tag] == null || definition.className == null) {\n            _this.tags[tag] = definition;\n          }\n        });\n      }\n    }\n\n    return definition;\n  };\n\n  Registry.blots = new WeakMap();\n  return Registry;\n}();\n\n/* harmony default export */ var registry = (registry_Registry);\n// CONCATENATED MODULE: ./node_modules/parchment/src/blot/abstract/shadow.ts\n\n\n\n\nvar shadow_ShadowBlot =\n/** @class */\nfunction () {\n  function ShadowBlot(scroll, domNode) {\n    this.scroll = scroll;\n    this.domNode = domNode;\n    registry.blots.set(domNode, this);\n    this.prev = null;\n    this.next = null;\n  }\n\n  ShadowBlot.create = function (value) {\n    if (this.tagName == null) {\n      throw new error('Blot definition missing tagName');\n    }\n\n    var node;\n\n    if (Array.isArray(this.tagName)) {\n      if (typeof value === 'string') {\n        value = value.toUpperCase();\n\n        if (parseInt(value, 10).toString() === value) {\n          value = parseInt(value, 10);\n        }\n      }\n\n      if (typeof value === 'number') {\n        node = document.createElement(this.tagName[value - 1]);\n      } else if (this.tagName.indexOf(value) > -1) {\n        node = document.createElement(value);\n      } else {\n        node = document.createElement(this.tagName[0]);\n      }\n    } else {\n      node = document.createElement(this.tagName);\n    }\n\n    if (this.className) {\n      node.classList.add(this.className);\n    }\n\n    return node;\n  };\n\n  Object.defineProperty(ShadowBlot.prototype, \"statics\", {\n    // Hack for accessing inherited static methods\n    get: function get() {\n      return this.constructor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ShadowBlot.prototype.attach = function () {// Nothing to do\n  };\n\n  ShadowBlot.prototype.clone = function () {\n    var domNode = this.domNode.cloneNode(false);\n    return this.scroll.create(domNode);\n  };\n\n  ShadowBlot.prototype.detach = function () {\n    if (this.parent != null) {\n      this.parent.removeChild(this);\n    }\n\n    registry.blots.delete(this.domNode);\n  };\n\n  ShadowBlot.prototype.deleteAt = function (index, length) {\n    var blot = this.isolate(index, length);\n    blot.remove();\n  };\n\n  ShadowBlot.prototype.formatAt = function (index, length, name, value) {\n    var blot = this.isolate(index, length);\n\n    if (this.scroll.query(name, src_scope.BLOT) != null && value) {\n      blot.wrap(name, value);\n    } else if (this.scroll.query(name, src_scope.ATTRIBUTE) != null) {\n      var parent = this.scroll.create(this.statics.scope);\n      blot.wrap(parent);\n      parent.format(name, value);\n    }\n  };\n\n  ShadowBlot.prototype.insertAt = function (index, value, def) {\n    var blot = def == null ? this.scroll.create('text', value) : this.scroll.create(value, def);\n    var ref = this.split(index);\n    this.parent.insertBefore(blot, ref || undefined);\n  };\n\n  ShadowBlot.prototype.isolate = function (index, length) {\n    var target = this.split(index);\n\n    if (target == null) {\n      throw new Error('Attempt to isolate at end');\n    }\n\n    target.split(length);\n    return target;\n  };\n\n  ShadowBlot.prototype.length = function () {\n    return 1;\n  };\n\n  ShadowBlot.prototype.offset = function (root) {\n    if (root === void 0) {\n      root = this.parent;\n    }\n\n    if (this.parent == null || this === root) {\n      return 0;\n    }\n\n    return this.parent.children.offset(this) + this.parent.offset(root);\n  };\n\n  ShadowBlot.prototype.optimize = function (_context) {\n    if (this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer)) {\n      this.wrap(this.statics.requiredContainer.blotName);\n    }\n  };\n\n  ShadowBlot.prototype.remove = function () {\n    if (this.domNode.parentNode != null) {\n      this.domNode.parentNode.removeChild(this.domNode);\n    }\n\n    this.detach();\n  };\n\n  ShadowBlot.prototype.replaceWith = function (name, value) {\n    var replacement = typeof name === 'string' ? this.scroll.create(name, value) : name;\n\n    if (this.parent != null) {\n      this.parent.insertBefore(replacement, this.next || undefined);\n      this.remove();\n    }\n\n    return replacement;\n  };\n\n  ShadowBlot.prototype.split = function (index, _force) {\n    return index === 0 ? this : this.next;\n  };\n\n  ShadowBlot.prototype.update = function (_mutations, _context) {// Nothing to do by default\n  };\n\n  ShadowBlot.prototype.wrap = function (name, value) {\n    var wrapper = typeof name === 'string' ? this.scroll.create(name, value) : name;\n\n    if (this.parent != null) {\n      this.parent.insertBefore(wrapper, this.next || undefined);\n    }\n\n    if (typeof wrapper.appendChild !== 'function') {\n      throw new error(\"Cannot wrap \" + name);\n    }\n\n    wrapper.appendChild(this);\n    return wrapper;\n  };\n\n  ShadowBlot.blotName = 'abstract';\n  return ShadowBlot;\n}();\n\n/* harmony default export */ var shadow = (shadow_ShadowBlot);\n// CONCATENATED MODULE: ./node_modules/parchment/src/blot/abstract/parent.ts\nvar parent_extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\n\n\nfunction makeAttachedBlot(node, scroll) {\n  var blot = scroll.find(node);\n\n  if (blot == null) {\n    try {\n      blot = scroll.create(node);\n    } catch (e) {\n      blot = scroll.create(src_scope.INLINE);\n      Array.from(node.childNodes).forEach(function (child) {\n        // @ts-ignore\n        blot.domNode.appendChild(child);\n      });\n\n      if (node.parentNode) {\n        node.parentNode.replaceChild(blot.domNode, node);\n      }\n\n      blot.attach();\n    }\n  }\n\n  return blot;\n}\n\nvar parent_ParentBlot =\n/** @class */\nfunction (_super) {\n  parent_extends(ParentBlot, _super);\n\n  function ParentBlot(scroll, domNode) {\n    var _this = _super.call(this, scroll, domNode) || this;\n\n    _this.uiNode = null;\n\n    _this.build();\n\n    return _this;\n  }\n\n  ParentBlot.prototype.appendChild = function (other) {\n    this.insertBefore(other);\n  };\n\n  ParentBlot.prototype.attach = function () {\n    _super.prototype.attach.call(this);\n\n    this.children.forEach(function (child) {\n      child.attach();\n    });\n  };\n\n  ParentBlot.prototype.attachUI = function (node) {\n    if (this.uiNode != null) {\n      this.uiNode.remove();\n    }\n\n    this.uiNode = node;\n\n    if (ParentBlot.uiClass) {\n      this.uiNode.classList.add(ParentBlot.uiClass);\n    }\n\n    this.uiNode.setAttribute('contenteditable', 'false');\n    this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n  };\n\n  ParentBlot.prototype.build = function () {\n    var _this = this;\n\n    this.children = new linked_list(); // Need to be reversed for if DOM nodes already in order\n\n    Array.from(this.domNode.childNodes).filter(function (node) {\n      return node !== _this.uiNode;\n    }).reverse().forEach(function (node) {\n      try {\n        var child = makeAttachedBlot(node, _this.scroll);\n\n        _this.insertBefore(child, _this.children.head || undefined);\n      } catch (err) {\n        if (err instanceof error) {\n          return;\n        } else {\n          throw err;\n        }\n      }\n    });\n  };\n\n  ParentBlot.prototype.deleteAt = function (index, length) {\n    if (index === 0 && length === this.length()) {\n      return this.remove();\n    }\n\n    this.children.forEachAt(index, length, function (child, offset, childLength) {\n      child.deleteAt(offset, childLength);\n    });\n  };\n\n  ParentBlot.prototype.descendant = function (criteria, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    var _a = this.children.find(index),\n        child = _a[0],\n        offset = _a[1];\n\n    if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {\n      return [child, offset];\n    } else if (child instanceof ParentBlot) {\n      return child.descendant(criteria, offset);\n    } else {\n      return [null, -1];\n    }\n  };\n\n  ParentBlot.prototype.descendants = function (criteria, index, length) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    if (length === void 0) {\n      length = Number.MAX_VALUE;\n    }\n\n    var descendants = [];\n    var lengthLeft = length;\n    this.children.forEachAt(index, length, function (child, childIndex, childLength) {\n      if (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) {\n        descendants.push(child);\n      }\n\n      if (child instanceof ParentBlot) {\n        descendants = descendants.concat(child.descendants(criteria, childIndex, lengthLeft));\n      }\n\n      lengthLeft -= childLength;\n    });\n    return descendants;\n  };\n\n  ParentBlot.prototype.detach = function () {\n    this.children.forEach(function (child) {\n      child.detach();\n    });\n\n    _super.prototype.detach.call(this);\n  };\n\n  ParentBlot.prototype.enforceAllowedChildren = function () {\n    var _this = this;\n\n    var done = false;\n    this.children.forEach(function (child) {\n      if (done) {\n        return;\n      }\n\n      var allowed = _this.statics.allowedChildren.some(function (def) {\n        return child instanceof def;\n      });\n\n      if (allowed) {\n        return;\n      }\n\n      if (child.statics.scope === src_scope.BLOCK_BLOT) {\n        if (child.next != null) {\n          _this.splitAfter(child);\n        }\n\n        if (child.prev != null) {\n          _this.splitAfter(child.prev);\n        }\n\n        child.parent.unwrap();\n        done = true;\n      } else if (child instanceof ParentBlot) {\n        child.unwrap();\n      } else {\n        child.remove();\n      }\n    });\n  };\n\n  ParentBlot.prototype.formatAt = function (index, length, name, value) {\n    this.children.forEachAt(index, length, function (child, offset, childLength) {\n      child.formatAt(offset, childLength, name, value);\n    });\n  };\n\n  ParentBlot.prototype.insertAt = function (index, value, def) {\n    var _a = this.children.find(index),\n        child = _a[0],\n        offset = _a[1];\n\n    if (child) {\n      child.insertAt(offset, value, def);\n    } else {\n      var blot = def == null ? this.scroll.create('text', value) : this.scroll.create(value, def);\n      this.appendChild(blot);\n    }\n  };\n\n  ParentBlot.prototype.insertBefore = function (childBlot, refBlot) {\n    if (childBlot.parent != null) {\n      childBlot.parent.children.remove(childBlot);\n    }\n\n    var refDomNode = null;\n    this.children.insertBefore(childBlot, refBlot || null);\n    childBlot.parent = this;\n\n    if (refBlot != null) {\n      refDomNode = refBlot.domNode;\n    }\n\n    if (this.domNode.parentNode !== childBlot.domNode || this.domNode.nextSibling !== refDomNode) {\n      this.domNode.insertBefore(childBlot.domNode, refDomNode);\n    }\n\n    childBlot.attach();\n  };\n\n  ParentBlot.prototype.length = function () {\n    return this.children.reduce(function (memo, child) {\n      return memo + child.length();\n    }, 0);\n  };\n\n  ParentBlot.prototype.moveChildren = function (targetParent, refNode) {\n    this.children.forEach(function (child) {\n      targetParent.insertBefore(child, refNode);\n    });\n  };\n\n  ParentBlot.prototype.optimize = function (context) {\n    _super.prototype.optimize.call(this, context);\n\n    this.enforceAllowedChildren();\n\n    if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {\n      this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n\n    if (this.children.length === 0) {\n      if (this.statics.defaultChild != null) {\n        var child = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(child); // TODO double check if necessary\n        // child.optimize(context);\n      } else {\n        this.remove();\n      }\n    }\n  };\n\n  ParentBlot.prototype.path = function (index, inclusive) {\n    if (inclusive === void 0) {\n      inclusive = false;\n    }\n\n    var _a = this.children.find(index, inclusive),\n        child = _a[0],\n        offset = _a[1];\n\n    var position = [[this, index]];\n\n    if (child instanceof ParentBlot) {\n      return position.concat(child.path(offset, inclusive));\n    } else if (child != null) {\n      position.push([child, offset]);\n    }\n\n    return position;\n  };\n\n  ParentBlot.prototype.removeChild = function (child) {\n    this.children.remove(child);\n  };\n\n  ParentBlot.prototype.replaceWith = function (name, value) {\n    var replacement = typeof name === 'string' ? this.scroll.create(name, value) : name;\n\n    if (replacement instanceof ParentBlot) {\n      this.moveChildren(replacement);\n    }\n\n    return _super.prototype.replaceWith.call(this, replacement);\n  };\n\n  ParentBlot.prototype.split = function (index, force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n\n    var after = this.clone();\n\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n\n    this.children.forEachAt(index, this.length(), function (child, offset, _length) {\n      var split = child.split(offset, force);\n\n      if (split != null) {\n        after.appendChild(split);\n      }\n    });\n    return after;\n  };\n\n  ParentBlot.prototype.splitAfter = function (child) {\n    var after = this.clone();\n\n    while (child.next != null) {\n      after.appendChild(child.next);\n    }\n\n    if (this.parent) {\n      this.parent.insertBefore(after, this.next || undefined);\n    }\n\n    return after;\n  };\n\n  ParentBlot.prototype.unwrap = function () {\n    if (this.parent) {\n      this.moveChildren(this.parent, this.next || undefined);\n    }\n\n    this.remove();\n  };\n\n  ParentBlot.prototype.update = function (mutations, _context) {\n    var _this = this;\n\n    var addedNodes = [];\n    var removedNodes = [];\n    mutations.forEach(function (mutation) {\n      if (mutation.target === _this.domNode && mutation.type === 'childList') {\n        addedNodes.push.apply(addedNodes, mutation.addedNodes);\n        removedNodes.push.apply(removedNodes, mutation.removedNodes);\n      }\n    });\n    removedNodes.forEach(function (node) {\n      // Check node has actually been removed\n      // One exception is Chrome does not immediately remove IFRAMEs\n      // from DOM but MutationRecord is correct in its reported removal\n      if (node.parentNode != null && // @ts-ignore\n      node.tagName !== 'IFRAME' && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n        return;\n      }\n\n      var blot = _this.scroll.find(node);\n\n      if (blot == null) {\n        return;\n      }\n\n      if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {\n        blot.detach();\n      }\n    });\n    addedNodes.filter(function (node) {\n      return node.parentNode === _this.domNode || node === _this.uiNode;\n    }).sort(function (a, b) {\n      if (a === b) {\n        return 0;\n      }\n\n      if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n        return 1;\n      }\n\n      return -1;\n    }).forEach(function (node) {\n      var refBlot = null;\n\n      if (node.nextSibling != null) {\n        refBlot = _this.scroll.find(node.nextSibling);\n      }\n\n      var blot = makeAttachedBlot(node, _this.scroll);\n\n      if (blot.next !== refBlot || blot.next == null) {\n        if (blot.parent != null) {\n          blot.parent.removeChild(_this);\n        }\n\n        _this.insertBefore(blot, refBlot || undefined);\n      }\n    });\n    this.enforceAllowedChildren();\n  };\n\n  ParentBlot.uiClass = '';\n  return ParentBlot;\n}(shadow);\n\n/* harmony default export */ var abstract_parent = (parent_ParentBlot);\n// CONCATENATED MODULE: ./node_modules/parchment/src/blot/abstract/container.ts\nvar container_extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\nvar container_ContainerBlot =\n/** @class */\nfunction (_super) {\n  container_extends(ContainerBlot, _super);\n\n  function ContainerBlot() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ContainerBlot.prototype.checkMerge = function () {\n    return this.next !== null && this.next.statics.blotName === this.statics.blotName;\n  };\n\n  ContainerBlot.prototype.deleteAt = function (index, length) {\n    _super.prototype.deleteAt.call(this, index, length);\n\n    this.enforceAllowedChildren();\n  };\n\n  ContainerBlot.prototype.formatAt = function (index, length, name, value) {\n    _super.prototype.formatAt.call(this, index, length, name, value);\n\n    this.enforceAllowedChildren();\n  };\n\n  ContainerBlot.prototype.insertAt = function (index, value, def) {\n    _super.prototype.insertAt.call(this, index, value, def);\n\n    this.enforceAllowedChildren();\n  };\n\n  ContainerBlot.prototype.optimize = function (context) {\n    _super.prototype.optimize.call(this, context);\n\n    if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n      this.next.moveChildren(this);\n      this.next.remove();\n    }\n  };\n\n  ContainerBlot.blotName = 'container';\n  ContainerBlot.scope = src_scope.BLOCK_BLOT;\n  return ContainerBlot;\n}(abstract_parent);\n\n/* harmony default export */ var container = (container_ContainerBlot);\n// CONCATENATED MODULE: ./node_modules/parchment/src/blot/abstract/leaf.ts\nvar leaf_extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\nvar leaf_LeafBlot =\n/** @class */\nfunction (_super) {\n  leaf_extends(LeafBlot, _super);\n\n  function LeafBlot() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  LeafBlot.value = function (_domNode) {\n    return true;\n  };\n\n  LeafBlot.prototype.index = function (node, offset) {\n    if (this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return Math.min(offset, 1);\n    }\n\n    return -1;\n  };\n\n  LeafBlot.prototype.position = function (index, _inclusive) {\n    var childNodes = Array.from(this.parent.domNode.childNodes);\n    var offset = childNodes.indexOf(this.domNode);\n\n    if (index > 0) {\n      offset += 1;\n    }\n\n    return [this.parent.domNode, offset];\n  };\n\n  LeafBlot.prototype.value = function () {\n    var _a;\n\n    return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;\n  };\n\n  LeafBlot.scope = src_scope.INLINE_BLOT;\n  return LeafBlot;\n}(shadow);\n\n/* harmony default export */ var leaf = (leaf_LeafBlot);\n// CONCATENATED MODULE: ./node_modules/parchment/src/attributor/attributor.ts\n\n\nvar attributor_Attributor =\n/** @class */\nfunction () {\n  function Attributor(attrName, keyName, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.attrName = attrName;\n    this.keyName = keyName;\n    var attributeBit = src_scope.TYPE & src_scope.ATTRIBUTE;\n    this.scope = options.scope != null ? // Ignore type bits, force attribute bit\n    options.scope & src_scope.LEVEL | attributeBit : src_scope.ATTRIBUTE;\n\n    if (options.whitelist != null) {\n      this.whitelist = options.whitelist;\n    }\n  }\n\n  Attributor.keys = function (node) {\n    return Array.from(node.attributes).map(function (item) {\n      return item.name;\n    });\n  };\n\n  Attributor.prototype.add = function (node, value) {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n\n    node.setAttribute(this.keyName, value);\n    return true;\n  };\n\n  Attributor.prototype.canAdd = function (_node, value) {\n    if (this.whitelist == null) {\n      return true;\n    }\n\n    if (typeof value === 'string') {\n      return this.whitelist.indexOf(value.replace(/[\"']/g, '')) > -1;\n    } else {\n      return this.whitelist.indexOf(value) > -1;\n    }\n  };\n\n  Attributor.prototype.remove = function (node) {\n    node.removeAttribute(this.keyName);\n  };\n\n  Attributor.prototype.value = function (node) {\n    var value = node.getAttribute(this.keyName);\n\n    if (this.canAdd(node, value) && value) {\n      return value;\n    }\n\n    return '';\n  };\n\n  return Attributor;\n}();\n\n/* harmony default export */ var attributor = (attributor_Attributor);\n// CONCATENATED MODULE: ./node_modules/parchment/src/attributor/class.ts\nvar class_extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\nfunction class_match(node, prefix) {\n  var className = node.getAttribute('class') || '';\n  return className.split(/\\s+/).filter(function (name) {\n    return name.indexOf(prefix + \"-\") === 0;\n  });\n}\n\nvar ClassAttributor =\n/** @class */\nfunction (_super) {\n  class_extends(ClassAttributor, _super);\n\n  function ClassAttributor() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ClassAttributor.keys = function (node) {\n    return (node.getAttribute('class') || '').split(/\\s+/).map(function (name) {\n      return name.split('-').slice(0, -1).join('-');\n    });\n  };\n\n  ClassAttributor.prototype.add = function (node, value) {\n    if (!this.canAdd(node, value)) {\n      return false;\n    }\n\n    this.remove(node);\n    node.classList.add(this.keyName + \"-\" + value);\n    return true;\n  };\n\n  ClassAttributor.prototype.remove = function (node) {\n    var matches = class_match(node, this.keyName);\n    matches.forEach(function (name) {\n      node.classList.remove(name);\n    });\n\n    if (node.classList.length === 0) {\n      node.removeAttribute('class');\n    }\n  };\n\n  ClassAttributor.prototype.value = function (node) {\n    var result = class_match(node, this.keyName)[0] || '';\n    var value = result.slice(this.keyName.length + 1); // +1 for hyphen\n\n    return this.canAdd(node, value) ? value : '';\n  };\n\n  return ClassAttributor;\n}(attributor);\n\n/* harmony default export */ var attributor_class = (ClassAttributor);\n// CONCATENATED MODULE: ./node_modules/parchment/src/attributor/style.ts\nvar style_extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\nfunction camelize(name) {\n  var parts = name.split('-');\n  var rest = parts.slice(1).map(function (part) {\n    return part[0].toUpperCase() + part.slice(1);\n  }).join('');\n  return parts[0] + rest;\n}\n\nvar StyleAttributor =\n/** @class */\nfunction (_super) {\n  style_extends(StyleAttributor, _super);\n\n  function StyleAttributor() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  StyleAttributor.keys = function (node) {\n    return (node.getAttribute('style') || '').split(';').map(function (value) {\n      var arr = value.split(':');\n      return arr[0].trim();\n    });\n  };\n\n  StyleAttributor.prototype.add = function (node, value) {\n    if (!this.canAdd(node, value)) {\n      return false;\n    } // @ts-ignore\n\n\n    node.style[camelize(this.keyName)] = value;\n    return true;\n  };\n\n  StyleAttributor.prototype.remove = function (node) {\n    // @ts-ignore\n    node.style[camelize(this.keyName)] = '';\n\n    if (!node.getAttribute('style')) {\n      node.removeAttribute('style');\n    }\n  };\n\n  StyleAttributor.prototype.value = function (node) {\n    // @ts-ignore\n    var value = node.style[camelize(this.keyName)];\n    return this.canAdd(node, value) ? value : '';\n  };\n\n  return StyleAttributor;\n}(attributor);\n\n/* harmony default export */ var style = (StyleAttributor);\n// CONCATENATED MODULE: ./node_modules/parchment/src/attributor/store.ts\n\n\n\n\n\n\nvar store_AttributorStore =\n/** @class */\nfunction () {\n  function AttributorStore(domNode) {\n    this.attributes = {};\n    this.domNode = domNode;\n    this.build();\n  }\n\n  AttributorStore.prototype.attribute = function (attribute, value) {\n    // verb\n    if (value) {\n      if (attribute.add(this.domNode, value)) {\n        if (attribute.value(this.domNode) != null) {\n          this.attributes[attribute.attrName] = attribute;\n        } else {\n          delete this.attributes[attribute.attrName];\n        }\n      }\n    } else {\n      attribute.remove(this.domNode);\n      delete this.attributes[attribute.attrName];\n    }\n  };\n\n  AttributorStore.prototype.build = function () {\n    var _this = this;\n\n    this.attributes = {};\n    var blot = registry.find(this.domNode);\n\n    if (blot == null) {\n      return;\n    }\n\n    var attributes = attributor.keys(this.domNode);\n    var classes = attributor_class.keys(this.domNode);\n    var styles = style.keys(this.domNode);\n    attributes.concat(classes).concat(styles).forEach(function (name) {\n      var attr = blot.scroll.query(name, src_scope.ATTRIBUTE);\n\n      if (attr instanceof attributor) {\n        _this.attributes[attr.attrName] = attr;\n      }\n    });\n  };\n\n  AttributorStore.prototype.copy = function (target) {\n    var _this = this;\n\n    Object.keys(this.attributes).forEach(function (key) {\n      var value = _this.attributes[key].value(_this.domNode);\n\n      target.format(key, value);\n    });\n  };\n\n  AttributorStore.prototype.move = function (target) {\n    var _this = this;\n\n    this.copy(target);\n    Object.keys(this.attributes).forEach(function (key) {\n      _this.attributes[key].remove(_this.domNode);\n    });\n    this.attributes = {};\n  };\n\n  AttributorStore.prototype.values = function () {\n    var _this = this;\n\n    return Object.keys(this.attributes).reduce(function (attributes, name) {\n      attributes[name] = _this.attributes[name].value(_this.domNode);\n      return attributes;\n    }, {});\n  };\n\n  return AttributorStore;\n}();\n\n/* harmony default export */ var store = (store_AttributorStore);\n// CONCATENATED MODULE: ./node_modules/parchment/src/blot/inline.ts\nvar inline_extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\n\n // Shallow object comparison\n\nfunction isEqual(obj1, obj2) {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n    return false;\n  } // @ts-ignore\n\n\n  for (var prop in obj1) {\n    // @ts-ignore\n    if (obj1[prop] !== obj2[prop]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar inline_InlineBlot =\n/** @class */\nfunction (_super) {\n  inline_extends(InlineBlot, _super);\n\n  function InlineBlot(scroll, domNode) {\n    var _this = _super.call(this, scroll, domNode) || this;\n\n    _this.attributes = new store(_this.domNode);\n    return _this;\n  }\n\n  InlineBlot.formats = function (domNode, scroll) {\n    var match = scroll.query(InlineBlot.blotName);\n\n    if (match != null && domNode.tagName === match.tagName) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n\n    return undefined;\n  };\n\n  InlineBlot.prototype.format = function (name, value) {\n    var _this = this;\n\n    if (name === this.statics.blotName && !value) {\n      this.children.forEach(function (child) {\n        if (!(child instanceof InlineBlot)) {\n          child = child.wrap(InlineBlot.blotName, true);\n        }\n\n        _this.attributes.copy(child);\n      });\n      this.unwrap();\n    } else {\n      var format = this.scroll.query(name, src_scope.INLINE);\n\n      if (format == null) {\n        return;\n      }\n\n      if (format instanceof attributor) {\n        this.attributes.attribute(format, value);\n      } else if (value && (name !== this.statics.blotName || this.formats()[name] !== value)) {\n        this.replaceWith(name, value);\n      }\n    }\n  };\n\n  InlineBlot.prototype.formats = function () {\n    var formats = this.attributes.values();\n    var format = this.statics.formats(this.domNode, this.scroll);\n\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n\n    return formats;\n  };\n\n  InlineBlot.prototype.formatAt = function (index, length, name, value) {\n    if (this.formats()[name] != null || this.scroll.query(name, src_scope.ATTRIBUTE)) {\n      var blot = this.isolate(index, length);\n      blot.format(name, value);\n    } else {\n      _super.prototype.formatAt.call(this, index, length, name, value);\n    }\n  };\n\n  InlineBlot.prototype.optimize = function (context) {\n    _super.prototype.optimize.call(this, context);\n\n    var formats = this.formats();\n\n    if (Object.keys(formats).length === 0) {\n      return this.unwrap(); // unformatted span\n    }\n\n    var next = this.next;\n\n    if (next instanceof InlineBlot && next.prev === this && isEqual(formats, next.formats())) {\n      next.moveChildren(this);\n      next.remove();\n    }\n  };\n\n  InlineBlot.prototype.replaceWith = function (name, value) {\n    var replacement = _super.prototype.replaceWith.call(this, name, value);\n\n    this.attributes.copy(replacement);\n    return replacement;\n  };\n\n  InlineBlot.prototype.update = function (mutations, context) {\n    var _this = this;\n\n    _super.prototype.update.call(this, mutations, context);\n\n    var attributeChanged = mutations.some(function (mutation) {\n      return mutation.target === _this.domNode && mutation.type === 'attributes';\n    });\n\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  };\n\n  InlineBlot.prototype.wrap = function (name, value) {\n    var wrapper = _super.prototype.wrap.call(this, name, value);\n\n    if (wrapper instanceof InlineBlot) {\n      this.attributes.move(wrapper);\n    }\n\n    return wrapper;\n  };\n\n  InlineBlot.allowedChildren = [InlineBlot, leaf];\n  InlineBlot.blotName = 'inline';\n  InlineBlot.scope = src_scope.INLINE_BLOT;\n  InlineBlot.tagName = 'SPAN';\n  return InlineBlot;\n}(abstract_parent);\n\n/* harmony default export */ var inline = (inline_InlineBlot);\n// CONCATENATED MODULE: ./node_modules/parchment/src/blot/block.ts\nvar block_extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\n\n\n\n\nvar block_BlockBlot =\n/** @class */\nfunction (_super) {\n  block_extends(BlockBlot, _super);\n\n  function BlockBlot(scroll, domNode) {\n    var _this = _super.call(this, scroll, domNode) || this;\n\n    _this.attributes = new store(_this.domNode);\n    return _this;\n  }\n\n  BlockBlot.formats = function (domNode, scroll) {\n    var match = scroll.query(BlockBlot.blotName);\n\n    if (match != null && domNode.tagName === match.tagName) {\n      return undefined;\n    } else if (typeof this.tagName === 'string') {\n      return true;\n    } else if (Array.isArray(this.tagName)) {\n      return domNode.tagName.toLowerCase();\n    }\n  };\n\n  BlockBlot.prototype.format = function (name, value) {\n    var format = this.scroll.query(name, src_scope.BLOCK);\n\n    if (format == null) {\n      return;\n    } else if (format instanceof attributor) {\n      this.attributes.attribute(format, value);\n    } else if (name === this.statics.blotName && !value) {\n      this.replaceWith(BlockBlot.blotName);\n    } else if (value && (name !== this.statics.blotName || this.formats()[name] !== value)) {\n      this.replaceWith(name, value);\n    }\n  };\n\n  BlockBlot.prototype.formats = function () {\n    var formats = this.attributes.values();\n    var format = this.statics.formats(this.domNode, this.scroll);\n\n    if (format != null) {\n      formats[this.statics.blotName] = format;\n    }\n\n    return formats;\n  };\n\n  BlockBlot.prototype.formatAt = function (index, length, name, value) {\n    if (this.scroll.query(name, src_scope.BLOCK) != null) {\n      this.format(name, value);\n    } else {\n      _super.prototype.formatAt.call(this, index, length, name, value);\n    }\n  };\n\n  BlockBlot.prototype.insertAt = function (index, value, def) {\n    if (def == null || this.scroll.query(value, src_scope.INLINE) != null) {\n      // Insert text or inline\n      _super.prototype.insertAt.call(this, index, value, def);\n    } else {\n      var after = this.split(index);\n\n      if (after != null) {\n        var blot = this.scroll.create(value, def);\n        after.parent.insertBefore(blot, after);\n      } else {\n        throw new Error('Attempt to insertAt after block boundaries');\n      }\n    }\n  };\n\n  BlockBlot.prototype.replaceWith = function (name, value) {\n    var replacement = _super.prototype.replaceWith.call(this, name, value);\n\n    this.attributes.copy(replacement);\n    return replacement;\n  };\n\n  BlockBlot.prototype.update = function (mutations, context) {\n    var _this = this;\n\n    _super.prototype.update.call(this, mutations, context);\n\n    var attributeChanged = mutations.some(function (mutation) {\n      return mutation.target === _this.domNode && mutation.type === 'attributes';\n    });\n\n    if (attributeChanged) {\n      this.attributes.build();\n    }\n  };\n\n  BlockBlot.blotName = 'block';\n  BlockBlot.scope = src_scope.BLOCK_BLOT;\n  BlockBlot.tagName = 'P';\n  BlockBlot.allowedChildren = [inline, BlockBlot, leaf];\n  return BlockBlot;\n}(abstract_parent);\n\n/* harmony default export */ var block = (block_BlockBlot);\n// CONCATENATED MODULE: ./node_modules/parchment/src/blot/embed.ts\nvar embed_extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\nvar EmbedBlot =\n/** @class */\nfunction (_super) {\n  embed_extends(EmbedBlot, _super);\n\n  function EmbedBlot() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  EmbedBlot.formats = function (_domNode, _scroll) {\n    return undefined;\n  };\n\n  EmbedBlot.prototype.format = function (name, value) {\n    // super.formatAt wraps, which is what we want in general,\n    // but this allows subclasses to overwrite for formats\n    // that just apply to particular embeds\n    _super.prototype.formatAt.call(this, 0, this.length(), name, value);\n  };\n\n  EmbedBlot.prototype.formatAt = function (index, length, name, value) {\n    if (index === 0 && length === this.length()) {\n      this.format(name, value);\n    } else {\n      _super.prototype.formatAt.call(this, index, length, name, value);\n    }\n  };\n\n  EmbedBlot.prototype.formats = function () {\n    return this.statics.formats(this.domNode, this.scroll);\n  };\n\n  return EmbedBlot;\n}(leaf);\n\n/* harmony default export */ var blot_embed = (EmbedBlot);\n// CONCATENATED MODULE: ./node_modules/parchment/src/blot/scroll.ts\nvar scroll_extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\n\n\nvar OBSERVER_CONFIG = {\n  attributes: true,\n  characterData: true,\n  characterDataOldValue: true,\n  childList: true,\n  subtree: true\n};\nvar MAX_OPTIMIZE_ITERATIONS = 100;\n\nvar scroll_ScrollBlot =\n/** @class */\nfunction (_super) {\n  scroll_extends(ScrollBlot, _super);\n\n  function ScrollBlot(registry, node) {\n    var _this = // @ts-ignore\n    _super.call(this, null, node) || this;\n\n    _this.registry = registry;\n    _this.scroll = _this;\n\n    _this.build();\n\n    _this.observer = new MutationObserver(function (mutations) {\n      _this.update(mutations);\n    });\n\n    _this.observer.observe(_this.domNode, OBSERVER_CONFIG);\n\n    _this.attach();\n\n    return _this;\n  }\n\n  ScrollBlot.prototype.create = function (input, value) {\n    return this.registry.create(this, input, value);\n  };\n\n  ScrollBlot.prototype.find = function (node, bubble) {\n    if (bubble === void 0) {\n      bubble = false;\n    }\n\n    return this.registry.find(node, bubble);\n  };\n\n  ScrollBlot.prototype.query = function (query, scope) {\n    if (scope === void 0) {\n      scope = src_scope.ANY;\n    }\n\n    return this.registry.query(query, scope);\n  };\n\n  ScrollBlot.prototype.register = function () {\n    var _a;\n\n    var definitions = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      definitions[_i] = arguments[_i];\n    }\n\n    return (_a = this.registry).register.apply(_a, definitions);\n  };\n\n  ScrollBlot.prototype.build = function () {\n    if (this.scroll == null) {\n      return;\n    }\n\n    _super.prototype.build.call(this);\n  };\n\n  ScrollBlot.prototype.detach = function () {\n    _super.prototype.detach.call(this);\n\n    this.observer.disconnect();\n  };\n\n  ScrollBlot.prototype.deleteAt = function (index, length) {\n    this.update();\n\n    if (index === 0 && length === this.length()) {\n      this.children.forEach(function (child) {\n        child.remove();\n      });\n    } else {\n      _super.prototype.deleteAt.call(this, index, length);\n    }\n  };\n\n  ScrollBlot.prototype.formatAt = function (index, length, name, value) {\n    this.update();\n\n    _super.prototype.formatAt.call(this, index, length, name, value);\n  };\n\n  ScrollBlot.prototype.insertAt = function (index, value, def) {\n    this.update();\n\n    _super.prototype.insertAt.call(this, index, value, def);\n  };\n\n  ScrollBlot.prototype.optimize = function (mutations, context) {\n    var _this = this;\n\n    if (mutations === void 0) {\n      mutations = [];\n    }\n\n    if (context === void 0) {\n      context = {};\n    }\n\n    _super.prototype.optimize.call(this, context);\n\n    var mutationsMap = context.mutationsMap || new WeakMap(); // We must modify mutations directly, cannot make copy and then modify\n\n    var records = Array.from(this.observer.takeRecords()); // Array.push currently seems to be implemented by a non-tail recursive function\n    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n\n    while (records.length > 0) {\n      mutations.push(records.pop());\n    }\n\n    var mark = function mark(blot, markParent) {\n      if (markParent === void 0) {\n        markParent = true;\n      }\n\n      if (blot == null || blot === _this) {\n        return;\n      }\n\n      if (blot.domNode.parentNode == null) {\n        return;\n      }\n\n      if (!mutationsMap.has(blot.domNode)) {\n        mutationsMap.set(blot.domNode, []);\n      }\n\n      if (markParent) {\n        mark(blot.parent);\n      }\n    };\n\n    var optimize = function optimize(blot) {\n      // Post-order traversal\n      if (!mutationsMap.has(blot.domNode)) {\n        return;\n      }\n\n      if (blot instanceof abstract_parent) {\n        blot.children.forEach(optimize);\n      }\n\n      mutationsMap.delete(blot.domNode);\n      blot.optimize(context);\n    };\n\n    var remaining = mutations;\n\n    for (var i = 0; remaining.length > 0; i += 1) {\n      if (i >= MAX_OPTIMIZE_ITERATIONS) {\n        throw new Error('[Parchment] Maximum optimize iterations reached');\n      }\n\n      remaining.forEach(function (mutation) {\n        var blot = _this.find(mutation.target, true);\n\n        if (blot == null) {\n          return;\n        }\n\n        if (blot.domNode === mutation.target) {\n          if (mutation.type === 'childList') {\n            mark(_this.find(mutation.previousSibling, false));\n            Array.from(mutation.addedNodes).forEach(function (node) {\n              var child = _this.find(node, false);\n\n              mark(child, false);\n\n              if (child instanceof abstract_parent) {\n                child.children.forEach(function (grandChild) {\n                  mark(grandChild, false);\n                });\n              }\n            });\n          } else if (mutation.type === 'attributes') {\n            mark(blot.prev);\n          }\n        }\n\n        mark(blot);\n      });\n      this.children.forEach(optimize);\n      remaining = Array.from(this.observer.takeRecords());\n      records = remaining.slice();\n\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n    }\n  };\n\n  ScrollBlot.prototype.update = function (mutations, context) {\n    var _this = this;\n\n    if (context === void 0) {\n      context = {};\n    }\n\n    mutations = mutations || this.observer.takeRecords();\n    var mutationsMap = new WeakMap();\n    mutations.map(function (mutation) {\n      var blot = registry.find(mutation.target, true);\n\n      if (blot == null) {\n        return null;\n      }\n\n      if (mutationsMap.has(blot.domNode)) {\n        mutationsMap.get(blot.domNode).push(mutation);\n        return null;\n      } else {\n        mutationsMap.set(blot.domNode, [mutation]);\n        return blot;\n      }\n    }).forEach(function (blot) {\n      if (blot != null && blot !== _this && mutationsMap.has(blot.domNode)) {\n        blot.update(mutationsMap.get(blot.domNode) || [], context);\n      }\n    });\n    context.mutationsMap = mutationsMap;\n\n    if (mutationsMap.has(this.domNode)) {\n      _super.prototype.update.call(this, mutationsMap.get(this.domNode), context);\n    }\n\n    this.optimize(mutations, context);\n  };\n\n  ScrollBlot.blotName = 'scroll';\n  ScrollBlot.defaultChild = block;\n  ScrollBlot.allowedChildren = [block, container];\n  ScrollBlot.scope = src_scope.BLOCK_BLOT;\n  ScrollBlot.tagName = 'DIV';\n  return ScrollBlot;\n}(abstract_parent);\n\n/* harmony default export */ var blot_scroll = (scroll_ScrollBlot);\n// CONCATENATED MODULE: ./node_modules/parchment/src/blot/text.ts\nvar text_extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\nvar text_TextBlot =\n/** @class */\nfunction (_super) {\n  text_extends(TextBlot, _super);\n\n  function TextBlot(scroll, node) {\n    var _this = _super.call(this, scroll, node) || this;\n\n    _this.text = _this.statics.value(_this.domNode);\n    return _this;\n  }\n\n  TextBlot.create = function (value) {\n    return document.createTextNode(value);\n  };\n\n  TextBlot.value = function (domNode) {\n    return domNode.data;\n  };\n\n  TextBlot.prototype.deleteAt = function (index, length) {\n    this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);\n  };\n\n  TextBlot.prototype.index = function (node, offset) {\n    if (this.domNode === node) {\n      return offset;\n    }\n\n    return -1;\n  };\n\n  TextBlot.prototype.insertAt = function (index, value, def) {\n    if (def == null) {\n      this.text = this.text.slice(0, index) + value + this.text.slice(index);\n      this.domNode.data = this.text;\n    } else {\n      _super.prototype.insertAt.call(this, index, value, def);\n    }\n  };\n\n  TextBlot.prototype.length = function () {\n    return this.text.length;\n  };\n\n  TextBlot.prototype.optimize = function (context) {\n    _super.prototype.optimize.call(this, context);\n\n    this.text = this.statics.value(this.domNode);\n\n    if (this.text.length === 0) {\n      this.remove();\n    } else if (this.next instanceof TextBlot && this.next.prev === this) {\n      this.insertAt(this.length(), this.next.value());\n      this.next.remove();\n    }\n  };\n\n  TextBlot.prototype.position = function (index, _inclusive) {\n    if (_inclusive === void 0) {\n      _inclusive = false;\n    }\n\n    return [this.domNode, index];\n  };\n\n  TextBlot.prototype.split = function (index, force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!force) {\n      if (index === 0) {\n        return this;\n      }\n\n      if (index === this.length()) {\n        return this.next;\n      }\n    }\n\n    var after = this.scroll.create(this.domNode.splitText(index));\n    this.parent.insertBefore(after, this.next || undefined);\n    this.text = this.statics.value(this.domNode);\n    return after;\n  };\n\n  TextBlot.prototype.update = function (mutations, _context) {\n    var _this = this;\n\n    if (mutations.some(function (mutation) {\n      return mutation.type === 'characterData' && mutation.target === _this.domNode;\n    })) {\n      this.text = this.statics.value(this.domNode);\n    }\n  };\n\n  TextBlot.prototype.value = function () {\n    return this.text;\n  };\n\n  TextBlot.blotName = 'text';\n  TextBlot.scope = src_scope.INLINE_BLOT;\n  return TextBlot;\n}(leaf);\n\n/* harmony default export */ var blot_text = (text_TextBlot);\n// CONCATENATED MODULE: ./node_modules/parchment/src/parchment.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91);\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_has_window__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);\n/* harmony import */ var _instances__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41);\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar debug = Object(_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])('quill:events');\nvar EVENTS = ['selectionchange', 'mousedown', 'mouseup', 'click'];\n\nif (Object(_utils_has_window__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])()) {\n  EVENTS.forEach(function (eventName) {\n    document.addEventListener(eventName, function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      Array.from(document.querySelectorAll('.ql-container')).forEach(function (node) {\n        var quill = _instances__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"].get(node);\n\n        if (quill && quill.emitter) {\n          var _quill$emitter;\n\n          (_quill$emitter = quill.emitter).handleDOM.apply(_quill$emitter, args);\n        }\n      });\n    });\n  });\n}\n\nvar Emitter = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Emitter, _EventEmitter);\n\n  var _super = _createSuper(Emitter);\n\n  function Emitter() {\n    var _this;\n\n    _classCallCheck(this, Emitter);\n\n    _this = _super.call(this);\n    _this.listeners = {};\n\n    _this.on('error', debug.error);\n\n    return _this;\n  }\n\n  _createClass(Emitter, [{\n    key: \"emit\",\n    value: function emit() {\n      var _debug$log, _get2;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      (_debug$log = debug.log).call.apply(_debug$log, [debug].concat(args));\n\n      (_get2 = _get(_getPrototypeOf(Emitter.prototype), \"emit\", this)).call.apply(_get2, [this].concat(args));\n    }\n  }, {\n    key: \"handleDOM\",\n    value: function handleDOM(event) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      (this.listeners[event.type] || []).forEach(function (_ref) {\n        var node = _ref.node,\n            handler = _ref.handler;\n\n        if (event.target === node || node.contains(event.target)) {\n          handler.apply(void 0, [event].concat(args));\n        }\n      });\n    }\n  }, {\n    key: \"listenDOM\",\n    value: function listenDOM(eventName, node, handler) {\n      if (!this.listeners[eventName]) {\n        this.listeners[eventName] = [];\n      }\n\n      this.listeners[eventName].push({\n        node: node,\n        handler: handler\n      });\n    }\n  }]);\n\n  return Emitter;\n}(eventemitter3__WEBPACK_IMPORTED_MODULE_0___default.a);\n\nEmitter.events = {\n  EDITOR_CHANGE: 'editor-change',\n  SCROLL_BEFORE_UPDATE: 'scroll-before-update',\n  SCROLL_BLOT_MOUNT: 'scroll-blot-mount',\n  SCROLL_BLOT_UNMOUNT: 'scroll-blot-unmount',\n  SCROLL_OPTIMIZE: 'scroll-optimize',\n  SCROLL_UPDATE: 'scroll-update',\n  SELECTION_CHANGE: 'selection-change',\n  TEXT_CHANGE: 'text-change',\n  CONTENT_SETTED: 'content-setted'\n};\nEmitter.sources = {\n  API: 'api',\n  SILENT: 'silent',\n  USER: 'user'\n};\n/* harmony default export */ __webpack_exports__[\"a\"] = (Emitter);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXTERNAL MODULE: ./node_modules/lodash.clonedeep/index.js\nvar lodash_clonedeep = __webpack_require__(18);\nvar lodash_clonedeep_default = /*#__PURE__*/__webpack_require__.n(lodash_clonedeep);\n\n// EXTERNAL MODULE: ./node_modules/lodash.isequal/index.js\nvar lodash_isequal = __webpack_require__(29);\nvar lodash_isequal_default = /*#__PURE__*/__webpack_require__.n(lodash_isequal);\n\n// EXTERNAL MODULE: ./node_modules/lodash.merge/index.js\nvar lodash_merge = __webpack_require__(34);\nvar lodash_merge_default = /*#__PURE__*/__webpack_require__.n(lodash_merge);\n\n// EXTERNAL MODULE: ./node_modules/quill-delta/dist/Delta.js\nvar Delta = __webpack_require__(1);\nvar Delta_default = /*#__PURE__*/__webpack_require__.n(Delta);\n\n// EXTERNAL MODULE: ./node_modules/parchment/src/parchment.ts + 17 modules\nvar parchment = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./core/selection.js\nvar selection = __webpack_require__(7);\n\n// EXTERNAL MODULE: ./blots/cursor.js\nvar cursor = __webpack_require__(24);\n\n// EXTERNAL MODULE: ./blots/block.js\nvar blots_block = __webpack_require__(6);\n\n// EXTERNAL MODULE: ./blots/break.js\nvar blots_break = __webpack_require__(12);\n\n// EXTERNAL MODULE: ./blots/text.js\nvar blots_text = __webpack_require__(11);\n\n// CONCATENATED MODULE: ./utils/remove_class.js\nfunction removeClass(node, className) {\n  node.classList.remove(className);\n\n  if (node.classList.length === 0) {\n    node.removeAttribute('class');\n  }\n}\n// CONCATENATED MODULE: ./core/editor.js\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\n\n\n\n\nvar ASCII = /^[ -~]*$/;\n\nvar editor_Editor = /*#__PURE__*/function () {\n  function Editor(scroll) {\n    _classCallCheck(this, Editor);\n\n    this.scroll = scroll;\n    this.delta = this.getDelta();\n    this.immediateFormats = new Set();\n  }\n\n  _createClass(Editor, [{\n    key: \"addImmediateFormat\",\n    value: function addImmediateFormat(name) {\n      this.immediateFormats.add(name);\n    }\n  }, {\n    key: \"applyDelta\",\n    value: function applyDelta(delta) {\n      var _this = this;\n\n      this.scroll.update();\n      var scrollLength = this.scroll.length();\n      this.scroll.batchStart();\n      var normalizedDelta = normalizeDelta(delta);\n      var deleteDelta = new Delta_default.a();\n      normalizedDelta.reduce(function (index, op) {\n        var length = Delta[\"Op\"].length(op);\n        var attributes = op.attributes || {};\n        var addedNewline = false;\n\n        if (op.insert != null) {\n          deleteDelta.retain(length);\n\n          if (typeof op.insert === 'string') {\n            var text = op.insert;\n            addedNewline = !text.endsWith('\\n') && (scrollLength <= index || _this.scroll.descendant(blots_block[\"a\" /* BlockEmbed */], index)[0]);\n\n            _this.scroll.insertAt(index, text);\n\n            var _this$scroll$line = _this.scroll.line(index),\n                _this$scroll$line2 = _slicedToArray(_this$scroll$line, 2),\n                line = _this$scroll$line2[0],\n                offset = _this$scroll$line2[1];\n\n            var formats = lodash_merge_default()({}, Object(blots_block[\"c\" /* bubbleFormats */])(line));\n\n            if (line instanceof blots_block[\"d\" /* default */]) {\n              var _line$descendant = line.descendant(parchment[\"LeafBlot\"], offset),\n                  _line$descendant2 = _slicedToArray(_line$descendant, 1),\n                  leaf = _line$descendant2[0];\n\n              formats = lodash_merge_default()(formats, Object(blots_block[\"c\" /* bubbleFormats */])(leaf));\n            }\n\n            attributes = Delta[\"AttributeMap\"].diff(formats, attributes) || {};\n          } else if (_typeof(op.insert) === 'object') {\n            var key = Object.keys(op.insert)[0]; // There should only be one key\n\n            if (key == null) return index;\n            addedNewline = _this.scroll.query(key, parchment[\"Scope\"].INLINE) != null && (scrollLength <= index || _this.scroll.descendant(blots_block[\"a\" /* BlockEmbed */], index)[0]);\n\n            _this.scroll.insertAt(index, key, op.insert[key]);\n          }\n\n          scrollLength += length;\n        } else {\n          deleteDelta.push(op);\n        }\n\n        var keys = Object.keys(attributes);\n\n        _this.immediateFormats.forEach(function (format) {\n          if (keys.indexOf(format) > -1) {\n            _this.scroll.formatAt(index, length, format, attributes[format]);\n\n            delete attributes[format];\n          }\n        });\n\n        Object.keys(attributes).forEach(function (name) {\n          _this.scroll.formatAt(index, length, name, attributes[name]);\n        });\n        var addedLength = addedNewline ? 1 : 0;\n        scrollLength += addedLength;\n        deleteDelta.delete(addedLength);\n        return index + length + addedLength;\n      }, 0);\n      deleteDelta.reduce(function (index, op) {\n        if (typeof op.delete === 'number') {\n          _this.scroll.deleteAt(index, op.delete);\n\n          return index;\n        }\n\n        return index + Delta[\"Op\"].length(op);\n      }, 0);\n      this.scroll.batchEnd();\n      this.scroll.optimize();\n      return this.update(normalizedDelta);\n    }\n  }, {\n    key: \"deleteText\",\n    value: function deleteText(index, length) {\n      this.scroll.deleteAt(index, length);\n      return this.update(new Delta_default.a().retain(index).delete(length));\n    }\n  }, {\n    key: \"formatLine\",\n    value: function formatLine(index, length) {\n      var _this2 = this;\n\n      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.scroll.update();\n      Object.keys(formats).forEach(function (format) {\n        _this2.scroll.lines(index, Math.max(length, 1)).forEach(function (line) {\n          line.format(format, formats[format]);\n        });\n      });\n      this.scroll.optimize();\n      var delta = new Delta_default.a().retain(index).retain(length, lodash_clonedeep_default()(formats));\n      return this.update(delta);\n    }\n  }, {\n    key: \"formatText\",\n    value: function formatText(index, length) {\n      var _this3 = this;\n\n      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      Object.keys(formats).forEach(function (format) {\n        _this3.scroll.formatAt(index, length, format, formats[format]);\n      });\n      var delta = new Delta_default.a().retain(index).retain(length, lodash_clonedeep_default()(formats));\n      return this.update(delta);\n    }\n  }, {\n    key: \"getContents\",\n    value: function getContents(index, length) {\n      return this.delta.slice(index, index + length);\n    }\n  }, {\n    key: \"getDelta\",\n    value: function getDelta() {\n      return this.scroll.lines().reduce(function (delta, line) {\n        return delta.concat(line.delta());\n      }, new Delta_default.a());\n    }\n  }, {\n    key: \"getFormat\",\n    value: function getFormat(index) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var lines = [];\n      var leaves = [];\n\n      if (length === 0) {\n        this.scroll.path(index).forEach(function (path) {\n          var _path = _slicedToArray(path, 1),\n              blot = _path[0];\n\n          if (blot instanceof blots_block[\"d\" /* default */]) {\n            lines.push(blot);\n          } else if (blot instanceof parchment[\"LeafBlot\"]) {\n            leaves.push(blot);\n          }\n        });\n      } else {\n        lines = this.scroll.lines(index, length);\n        leaves = this.scroll.descendants(parchment[\"LeafBlot\"], index, length);\n      }\n\n      var _map = [lines, leaves].map(function (blots) {\n        if (blots.length === 0) return {};\n        var formats = Object(blots_block[\"c\" /* bubbleFormats */])(blots.shift());\n\n        while (Object.keys(formats).length > 0) {\n          var blot = blots.shift();\n          if (blot == null) return formats;\n          formats = combineFormats(Object(blots_block[\"c\" /* bubbleFormats */])(blot), formats);\n        }\n\n        return formats;\n      });\n\n      var _map2 = _slicedToArray(_map, 2);\n\n      lines = _map2[0];\n      leaves = _map2[1];\n      return _objectSpread(_objectSpread({}, lines), leaves);\n    }\n  }, {\n    key: \"getHTML\",\n    value: function getHTML(index, length) {\n      var _this$scroll$line3 = this.scroll.line(index),\n          _this$scroll$line4 = _slicedToArray(_this$scroll$line3, 2),\n          line = _this$scroll$line4[0],\n          lineOffset = _this$scroll$line4[1];\n\n      if (line.length() >= lineOffset + length) {\n        return convertHTML(line, lineOffset, length, true);\n      }\n\n      return convertHTML(this.scroll, index, length, true);\n    }\n  }, {\n    key: \"getText\",\n    value: function getText(index, length) {\n      return this.getContents(index, length).filter(function (op) {\n        return typeof op.insert === 'string';\n      }).map(function (op) {\n        return op.insert;\n      }).join('');\n    }\n  }, {\n    key: \"insertEmbed\",\n    value: function insertEmbed(index, embed, value) {\n      this.scroll.insertAt(index, embed, value);\n      return this.update(new Delta_default.a().retain(index).insert(_defineProperty({}, embed, value)));\n    }\n  }, {\n    key: \"insertText\",\n    value: function insertText(index, text) {\n      var _this4 = this;\n\n      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n      this.scroll.insertAt(index, text);\n      Object.keys(formats).forEach(function (format) {\n        _this4.scroll.formatAt(index, text.length, format, formats[format]);\n      });\n      return this.update(new Delta_default.a().retain(index).insert(text, lodash_clonedeep_default()(formats)));\n    }\n  }, {\n    key: \"isBlank\",\n    value: function isBlank() {\n      var isComposing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.scroll.children.length === 0) return true;\n      if (isComposing) return false;\n      if (this.scroll.children.length > 1) return false;\n      var block = this.scroll.children.head;\n      if (block.statics.blotName !== blots_block[\"d\" /* default */].blotName) return false;\n      if (block.children.length > 1) return false;\n      return block.children.head instanceof blots_break[\"a\" /* default */];\n    }\n  }, {\n    key: \"removeFormat\",\n    value: function removeFormat(index, length) {\n      var text = this.getText(index, length);\n\n      var _this$scroll$line5 = this.scroll.line(index + length),\n          _this$scroll$line6 = _slicedToArray(_this$scroll$line5, 2),\n          line = _this$scroll$line6[0],\n          offset = _this$scroll$line6[1];\n\n      var suffixLength = 0;\n      var suffix = new Delta_default.a();\n\n      if (line != null) {\n        suffixLength = line.length() - offset;\n        suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\\n');\n      }\n\n      var contents = this.getContents(index, length + suffixLength);\n      var diff = contents.diff(new Delta_default.a().insert(text).concat(suffix));\n      var delta = new Delta_default.a().retain(index).concat(diff);\n      return this.applyDelta(delta);\n    }\n  }, {\n    key: \"update\",\n    value: function update(change) {\n      var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var selectionInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      var oldDelta = this.delta;\n\n      if (mutations.length === 1 && mutations[0].type === 'characterData' && mutations[0].target.data.match(ASCII) && this.scroll.find(mutations[0].target)) {\n        // Optimization for character changes\n        var textBlot = this.scroll.find(mutations[0].target);\n        var formats = Object(blots_block[\"c\" /* bubbleFormats */])(textBlot);\n        var index = textBlot.offset(this.scroll);\n        var oldValue = mutations[0].oldValue.replace(cursor[\"a\" /* default */].CONTENTS, '');\n        var oldText = new Delta_default.a().insert(oldValue);\n        var newText = new Delta_default.a().insert(textBlot.value());\n        var relativeSelectionInfo = selectionInfo && {\n          oldRange: shiftRange(selectionInfo.oldRange, -index),\n          newRange: shiftRange(selectionInfo.newRange, -index)\n        };\n        var diffDelta = new Delta_default.a().retain(index).concat(oldText.diff(newText, relativeSelectionInfo));\n        change = diffDelta.reduce(function (delta, op) {\n          if (op.insert) {\n            return delta.insert(op.insert, formats);\n          }\n\n          return delta.push(op);\n        }, new Delta_default.a());\n        this.delta = oldDelta.compose(change);\n      } else {\n        this.delta = this.getDelta();\n\n        if (!change || !lodash_isequal_default()(oldDelta.compose(change), this.delta)) {\n          change = oldDelta.diff(this.delta, selectionInfo);\n        }\n      }\n\n      return change;\n    }\n  }]);\n\n  return Editor;\n}();\n\nfunction convertListHTML(items, lastIndent, types) {\n  if (items.length === 0) {\n    var _getListType = getListType(types.pop()),\n        _getListType2 = _slicedToArray(_getListType, 1),\n        _endTag = _getListType2[0];\n\n    if (lastIndent <= 0) {\n      return \"</li></\".concat(_endTag, \">\");\n    }\n\n    return \"</li></\".concat(_endTag, \">\").concat(convertListHTML([], lastIndent - 1, types));\n  }\n\n  var _items = _toArray(items),\n      _items$ = _items[0],\n      child = _items$.child,\n      offset = _items$.offset,\n      length = _items$.length,\n      indent = _items$.indent,\n      type = _items$.type,\n      rest = _items.slice(1);\n\n  var _getListType3 = getListType(type, child),\n      _getListType4 = _slicedToArray(_getListType3, 2),\n      tag = _getListType4[0],\n      attribute = _getListType4[1];\n\n  if (indent > lastIndent) {\n    types.push(type);\n\n    if (indent === lastIndent + 1) {\n      return \"<\".concat(tag, \"><li\").concat(attribute, \">\").concat(convertHTML(child, offset, length)).concat(convertListHTML(rest, indent, types));\n    }\n\n    return \"<\".concat(tag, \"><li>\").concat(convertListHTML(items, lastIndent + 1, types));\n  }\n\n  var previousType = types[types.length - 1];\n\n  if (indent === lastIndent && type === previousType) {\n    return \"</li><li\".concat(attribute, \">\").concat(convertHTML(child, offset, length)).concat(convertListHTML(rest, indent, types));\n  }\n\n  var _getListType5 = getListType(types.pop()),\n      _getListType6 = _slicedToArray(_getListType5, 1),\n      endTag = _getListType6[0];\n\n  return \"</li></\".concat(endTag, \">\").concat(convertListHTML(items, lastIndent - 1, types));\n}\n\nfunction convertHTML(blot, index, length) {\n  var isRoot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (typeof blot.html === 'function') {\n    return blot.html(index, length);\n  }\n\n  if (blot instanceof blots_text[\"a\" /* default */]) {\n    return Object(blots_text[\"b\" /* escapeText */])(blot.value().slice(index, index + length));\n  }\n\n  if (blot.children) {\n    // TODO fix API\n    if (blot.statics.blotName === 'list-container') {\n      var items = [];\n      blot.children.forEachAt(index, length, function (child, offset, childLength) {\n        var formats = child.formats();\n        items.push({\n          child: child,\n          offset: offset,\n          length: childLength,\n          indent: formats.indent || 0,\n          type: formats.list\n        });\n      });\n      return convertListHTML(items, -1, []);\n    }\n\n    var parts = [];\n    blot.children.forEachAt(index, length, function (child, offset, childLength) {\n      parts.push(convertHTML(child, offset, childLength));\n    });\n    handleBreakLine(blot.children, parts);\n\n    if (isRoot || blot.statics.blotName === 'list') {\n      return parts.join('');\n    }\n\n    var domNode = extractNodeFromBlot(blot);\n    var outerHTML = domNode.outerHTML,\n        innerHTML = domNode.innerHTML;\n\n    var _outerHTML$split = outerHTML.split(\">\".concat(innerHTML, \"<\")),\n        _outerHTML$split2 = _slicedToArray(_outerHTML$split, 2),\n        start = _outerHTML$split2[0],\n        end = _outerHTML$split2[1];\n\n    if (start.indexOf('<table') === 0) {\n      return \"\".concat(start.replace(/(\\sdata-.+?=[\"'].*?[\"'])/g, ''), \">\").concat(parts.join('').replace(/(\\sdata-.+?=[\"'].*?[\"'])/g, ''), \"<\").concat(end);\n    }\n\n    return \"\".concat(start, \">\").concat(parts.join(''), \"<\").concat(end);\n  }\n\n  return blot.domNode.outerHTML;\n}\n\nfunction handleBreakLine(linkedList, parts) {\n  if (linkedList.length === 1 && linkedList.head instanceof blots_break[\"a\" /* default */]) {\n    parts.push('<br>');\n  }\n}\n\nfunction extractNodeFromBlot(blot) {\n  var domNode = blot.domNode.cloneNode(true);\n  return removeTableServiceClasses(blot, domNode);\n}\n\nfunction removeTableServiceClasses(blot, domNode) {\n  var BLOTS_WITH_SERVICE_CLASS = ['tableCellLine', 'tableHeaderCellLine', 'tableCell', 'tableHeaderCell'];\n\n  if (BLOTS_WITH_SERVICE_CLASS.includes(blot.statics.blotName)) {\n    removeClass(domNode, blot.statics.className);\n  }\n\n  return domNode;\n}\n\nfunction combineFormats(formats, combined) {\n  return Object.keys(combined).reduce(function (merged, name) {\n    if (formats[name] == null) return merged;\n\n    if (combined[name] === formats[name]) {\n      merged[name] = combined[name];\n    } else if (Array.isArray(combined[name])) {\n      if (combined[name].indexOf(formats[name]) < 0) {\n        merged[name] = combined[name].concat([formats[name]]);\n      }\n    } else {\n      merged[name] = [combined[name], formats[name]];\n    }\n\n    return merged;\n  }, {});\n}\n\nfunction getListType(type, child) {\n  var tag = type === 'ordered' ? 'ol' : 'ul';\n  var attributes = child ? \"\".concat(getBlotNodeAttributes(child)) : '';\n\n  switch (type) {\n    case 'checked':\n      return [tag, \"\".concat(attributes, \" data-list=\\\"checked\\\"\")];\n\n    case 'unchecked':\n      return [tag, \"\".concat(attributes, \" data-list=\\\"unchecked\\\"\")];\n\n    default:\n      return [tag, attributes];\n  }\n}\n\nfunction getBlotNodeAttributes(_ref) {\n  var domNode = _ref.domNode;\n\n  if (!domNode.hasAttributes()) {\n    return '';\n  }\n\n  var attributes = domNode.attributes;\n  var attributesString = ' ';\n\n  for (var i = 0; i < attributes.length; i += 1) {\n    var name = attributes[i].name;\n    var value = attributes[i].value;\n\n    if (name === 'class') {\n      value = removeIndentClass(value);\n    }\n\n    if (value.length && name.indexOf('data-') === -1) {\n      attributesString += \"\".concat(name, \"=\\\"\").concat(value, \"\\\"\");\n    }\n  }\n\n  return attributesString.length > 1 ? attributesString : '';\n}\n\nfunction removeIndentClass(classString) {\n  return classString.replace(/ql-indent-\\d/g, '').trim();\n}\n\nfunction normalizeDelta(delta) {\n  return delta.reduce(function (normalizedDelta, op) {\n    if (typeof op.insert === 'string') {\n      var text = op.insert.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n      return normalizedDelta.insert(text, op.attributes);\n    }\n\n    return normalizedDelta.push(op);\n  }, new Delta_default.a());\n}\n\nfunction shiftRange(_ref2, amount) {\n  var index = _ref2.index,\n      length = _ref2.length;\n  return new selection[\"a\" /* Range */](index + amount, length);\n}\n\n/* harmony default export */ var editor = __webpack_exports__[\"a\"] = (editor_Editor);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return isDefined; });\nfunction isDefined(object) {\n  return object !== null && object !== undefined;\n}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return blockDelta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return bubbleFormats; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return BlockEmbed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return Block; });\n/* harmony import */ var quill_delta__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var quill_delta__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(quill_delta__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);\n/* harmony import */ var _break__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);\n/* harmony import */ var _inline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16);\n/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\nvar NEWLINE_LENGTH = 1;\n\nvar Block = /*#__PURE__*/function (_BlockBlot) {\n  _inherits(Block, _BlockBlot);\n\n  var _super = _createSuper(Block);\n\n  function Block(scroll, domNode) {\n    var _this;\n\n    _classCallCheck(this, Block);\n\n    _this = _super.call(this, scroll, domNode);\n    _this.cache = {};\n    return _this;\n  }\n\n  _createClass(Block, [{\n    key: \"delta\",\n    value: function delta() {\n      if (this.cache.delta == null) {\n        this.cache.delta = blockDelta(this);\n      }\n\n      return this.cache.delta;\n    }\n  }, {\n    key: \"deleteAt\",\n    value: function deleteAt(index, length) {\n      _get(_getPrototypeOf(Block.prototype), \"deleteAt\", this).call(this, index, length);\n\n      this.cache = {};\n    }\n  }, {\n    key: \"formatAt\",\n    value: function formatAt(index, length, name, value) {\n      if (length <= 0) return;\n\n      if (this.scroll.query(name, parchment__WEBPACK_IMPORTED_MODULE_1__[\"Scope\"].BLOCK)) {\n        if (index + length === this.length()) {\n          this.format(name, value);\n        }\n      } else {\n        _get(_getPrototypeOf(Block.prototype), \"formatAt\", this).call(this, index, Math.min(length, this.length() - index - 1), name, value);\n      }\n\n      this.cache = {};\n    }\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(index, value, def) {\n      if (def != null) {\n        _get(_getPrototypeOf(Block.prototype), \"insertAt\", this).call(this, index, value, def);\n\n        this.cache = {};\n        return;\n      }\n\n      if (value.length === 0) return;\n      var lines = value.split('\\n');\n      var text = lines.shift();\n\n      if (text.length > 0) {\n        if (index < this.length() - 1 || this.children.tail == null) {\n          _get(_getPrototypeOf(Block.prototype), \"insertAt\", this).call(this, Math.min(index, this.length() - 1), text);\n        } else {\n          this.children.tail.insertAt(this.children.tail.length(), text);\n        }\n\n        this.cache = {};\n      }\n\n      var block = this;\n      lines.reduce(function (lineIndex, line) {\n        block = block.split(lineIndex, true);\n        block.insertAt(0, line);\n        return line.length;\n      }, index + text.length);\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(blot, ref) {\n      var head = this.children.head;\n\n      _get(_getPrototypeOf(Block.prototype), \"insertBefore\", this).call(this, blot, ref);\n\n      if (head instanceof _break__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]) {\n        head.remove();\n      }\n\n      this.cache = {};\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      if (this.cache.length == null) {\n        this.cache.length = _get(_getPrototypeOf(Block.prototype), \"length\", this).call(this) + NEWLINE_LENGTH;\n      }\n\n      return this.cache.length;\n    }\n  }, {\n    key: \"moveChildren\",\n    value: function moveChildren(target, ref) {\n      _get(_getPrototypeOf(Block.prototype), \"moveChildren\", this).call(this, target, ref);\n\n      this.cache = {};\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize(context) {\n      _get(_getPrototypeOf(Block.prototype), \"optimize\", this).call(this, context);\n\n      this.cache = {};\n    }\n  }, {\n    key: \"path\",\n    value: function path(index) {\n      return _get(_getPrototypeOf(Block.prototype), \"path\", this).call(this, index, true);\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(child) {\n      _get(_getPrototypeOf(Block.prototype), \"removeChild\", this).call(this, child);\n\n      this.cache = {};\n    }\n  }, {\n    key: \"split\",\n    value: function split(index) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {\n        var clone = this.clone();\n\n        if (index === 0) {\n          this.parent.insertBefore(clone, this);\n          return this;\n        }\n\n        this.parent.insertBefore(clone, this.next);\n        return clone;\n      }\n\n      var next = _get(_getPrototypeOf(Block.prototype), \"split\", this).call(this, index, force);\n\n      this.cache = {};\n      return next;\n    }\n  }]);\n\n  return Block;\n}(parchment__WEBPACK_IMPORTED_MODULE_1__[\"BlockBlot\"]);\n\nBlock.blotName = 'block';\nBlock.tagName = 'P';\nBlock.defaultChild = _break__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"];\nBlock.allowedChildren = [_break__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"], _inline__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"], parchment__WEBPACK_IMPORTED_MODULE_1__[\"EmbedBlot\"], _text__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"]];\n\nvar BlockEmbed = /*#__PURE__*/function (_EmbedBlot) {\n  _inherits(BlockEmbed, _EmbedBlot);\n\n  var _super2 = _createSuper(BlockEmbed);\n\n  function BlockEmbed() {\n    _classCallCheck(this, BlockEmbed);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(BlockEmbed, [{\n    key: \"attach\",\n    value: function attach() {\n      _get(_getPrototypeOf(BlockEmbed.prototype), \"attach\", this).call(this);\n\n      this.attributes = new parchment__WEBPACK_IMPORTED_MODULE_1__[\"AttributorStore\"](this.domNode);\n    }\n  }, {\n    key: \"delta\",\n    value: function delta() {\n      return new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a().insert(this.value(), _objectSpread(_objectSpread({}, this.formats()), this.attributes.values()));\n    }\n  }, {\n    key: \"format\",\n    value: function format(name, value) {\n      var attribute = this.scroll.query(name, parchment__WEBPACK_IMPORTED_MODULE_1__[\"Scope\"].BLOCK_ATTRIBUTE);\n\n      if (attribute != null) {\n        this.attributes.attribute(attribute, value);\n      }\n    }\n  }, {\n    key: \"formatAt\",\n    value: function formatAt(index, length, name, value) {\n      this.format(name, value);\n    }\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(index, value, def) {\n      if (typeof value === 'string' && value.endsWith('\\n')) {\n        var block = this.scroll.create(Block.blotName);\n        this.parent.insertBefore(block, index === 0 ? this : this.next);\n        block.insertAt(0, value.slice(0, -1));\n      } else {\n        _get(_getPrototypeOf(BlockEmbed.prototype), \"insertAt\", this).call(this, index, value, def);\n      }\n    }\n  }]);\n\n  return BlockEmbed;\n}(parchment__WEBPACK_IMPORTED_MODULE_1__[\"EmbedBlot\"]);\n\nBlockEmbed.scope = parchment__WEBPACK_IMPORTED_MODULE_1__[\"Scope\"].BLOCK_BLOT; // It is important for cursor behavior BlockEmbeds use tags that are block level elements\n\nfunction blockDelta(blot) {\n  var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return blot.descendants(parchment__WEBPACK_IMPORTED_MODULE_1__[\"LeafBlot\"]).reduce(function (delta, leaf) {\n    if (leaf.length() === 0) {\n      return delta;\n    }\n\n    return delta.insert(leaf.value(), bubbleFormats(leaf, {}, filter));\n  }, new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a()).insert('\\n', bubbleFormats(blot));\n}\n\nfunction bubbleFormats(blot) {\n  var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (blot == null) return formats;\n\n  if (typeof blot.formats === 'function') {\n    formats = _objectSpread(_objectSpread({}, formats), blot.formats());\n\n    if (filter) {\n      // exclude syntax highlighting from deltas and getFormat()\n      delete formats['code-token'];\n    }\n  }\n\n  if (blot.parent == null || blot.parent.statics.blotName === 'scroll' || blot.parent.statics.scope !== blot.statics.scope) {\n    return formats;\n  }\n\n  return bubbleFormats(blot.parent, formats, filter);\n}\n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Range; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return Selection; });\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18);\n/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29);\n/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isequal__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _emitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23);\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\n\nvar debug = Object(_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])('quill:selection');\n\nvar Range = function Range(index) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  _classCallCheck(this, Range);\n\n  this.index = index;\n  this.length = length;\n};\n\nvar Selection = /*#__PURE__*/function () {\n  function Selection(scroll, emitter) {\n    var _this = this;\n\n    _classCallCheck(this, Selection);\n\n    this.emitter = emitter;\n    this.scroll = scroll;\n    this.composing = false;\n    this.mouseDown = false;\n    this.root = this.scroll.domNode;\n    this.cursor = this.scroll.create('cursor', this); // savedRange is last non-null range\n\n    this.savedRange = new Range(0, 0);\n    this.lastRange = this.savedRange;\n    this.lastNative = null;\n    this.handleComposition();\n    this.handleDragging();\n    this.emitter.listenDOM('selectionchange', document, function () {\n      if (!_this.mouseDown && !_this.composing) {\n        setTimeout(_this.update.bind(_this, _emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.USER), 1);\n      }\n    });\n    this.emitter.on(_emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].events.SCROLL_BEFORE_UPDATE, function () {\n      if (!_this.hasFocus()) return;\n\n      var native = _this.getNativeRange();\n\n      if (native == null) return;\n      if (native.start.node === _this.cursor.textNode) return; // cursor.restore() will handle\n\n      _this.emitter.once(_emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].events.SCROLL_UPDATE, function () {\n        try {\n          if (_this.root.contains(native.start.node) && _this.root.contains(native.end.node)) {\n            _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);\n          }\n\n          _this.update(_emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.SILENT);\n        } catch (ignored) {// ignore\n        }\n      });\n    });\n    this.emitter.on(_emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].events.SCROLL_OPTIMIZE, function (mutations, context) {\n      if (context.range) {\n        var _context$range = context.range,\n            startNode = _context$range.startNode,\n            startOffset = _context$range.startOffset,\n            endNode = _context$range.endNode,\n            endOffset = _context$range.endOffset;\n\n        _this.setNativeRange(startNode, startOffset, endNode, endOffset);\n\n        _this.update(_emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.SILENT);\n      }\n    });\n    this.update(_emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.SILENT);\n  }\n\n  _createClass(Selection, [{\n    key: \"handleComposition\",\n    value: function handleComposition() {\n      var _this2 = this;\n\n      this.root.addEventListener('compositionstart', function () {\n        _this2.composing = true;\n\n        _this2.scroll.batchStart();\n      });\n      this.root.addEventListener('compositionend', function () {\n        _this2.scroll.batchEnd();\n\n        _this2.composing = false;\n\n        if (_this2.cursor.parent) {\n          var range = _this2.cursor.restore();\n\n          if (!range) return;\n          setTimeout(function () {\n            _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);\n          }, 1);\n        }\n      });\n    }\n  }, {\n    key: \"handleDragging\",\n    value: function handleDragging() {\n      var _this3 = this;\n\n      this.emitter.listenDOM('mousedown', document.body, function () {\n        _this3.mouseDown = true;\n      });\n      this.emitter.listenDOM('mouseup', document.body, function () {\n        _this3.mouseDown = false;\n\n        _this3.update(_emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.USER);\n      });\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      if (this.hasFocus()) return;\n      this.root.focus();\n      this.setRange(this.savedRange);\n    }\n  }, {\n    key: \"format\",\n    value: function format(_format, value) {\n      this.scroll.update();\n      var nativeRange = this.getNativeRange();\n      if (nativeRange == null || !nativeRange.native.collapsed || this.scroll.query(_format, parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].BLOCK)) return;\n\n      if (nativeRange.start.node !== this.cursor.textNode) {\n        var blot = this.scroll.find(nativeRange.start.node, false);\n        if (blot == null) return; // TODO Give blot ability to not split\n\n        if (blot instanceof parchment__WEBPACK_IMPORTED_MODULE_0__[\"LeafBlot\"]) {\n          var after = blot.split(nativeRange.start.offset);\n          blot.parent.insertBefore(this.cursor, after);\n        } else {\n          blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen\n        }\n\n        this.cursor.attach();\n      }\n\n      this.cursor.format(_format, value);\n      this.scroll.optimize();\n      this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);\n      this.update();\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds(index) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var scrollLength = this.scroll.length();\n      index = Math.min(index, scrollLength - 1);\n      length = Math.min(index + length, scrollLength - 1) - index;\n      var node;\n\n      var _this$scroll$leaf = this.scroll.leaf(index),\n          _this$scroll$leaf2 = _slicedToArray(_this$scroll$leaf, 2),\n          leaf = _this$scroll$leaf2[0],\n          offset = _this$scroll$leaf2[1];\n\n      if (leaf == null) return null;\n\n      var _leaf$position = leaf.position(offset, true);\n\n      var _leaf$position2 = _slicedToArray(_leaf$position, 2);\n\n      node = _leaf$position2[0];\n      offset = _leaf$position2[1];\n      var range = document.createRange();\n\n      if (length > 0) {\n        range.setStart(node, offset);\n\n        var _this$scroll$leaf3 = this.scroll.leaf(index + length);\n\n        var _this$scroll$leaf4 = _slicedToArray(_this$scroll$leaf3, 2);\n\n        leaf = _this$scroll$leaf4[0];\n        offset = _this$scroll$leaf4[1];\n        if (leaf == null) return null;\n\n        var _leaf$position3 = leaf.position(offset, true);\n\n        var _leaf$position4 = _slicedToArray(_leaf$position3, 2);\n\n        node = _leaf$position4[0];\n        offset = _leaf$position4[1];\n        range.setEnd(node, offset);\n        return range.getBoundingClientRect();\n      }\n\n      var side = 'left';\n      var rect;\n\n      if (node instanceof Text) {\n        if (offset < node.data.length) {\n          range.setStart(node, offset);\n          range.setEnd(node, offset + 1);\n        } else {\n          range.setStart(node, offset - 1);\n          range.setEnd(node, offset);\n          side = 'right';\n        }\n\n        rect = range.getBoundingClientRect();\n      } else {\n        rect = leaf.domNode.getBoundingClientRect();\n        if (offset > 0) side = 'right';\n      }\n\n      return {\n        bottom: rect.top + rect.height,\n        height: rect.height,\n        left: rect[side],\n        right: rect[side],\n        top: rect.top,\n        width: 0\n      };\n    }\n  }, {\n    key: \"getNativeRange\",\n    value: function getNativeRange() {\n      var selection = document.getSelection();\n      if (selection == null || selection.rangeCount <= 0) return null;\n      var nativeRange = selection.getRangeAt(0);\n      if (nativeRange == null) return null;\n      var range = this.normalizeNative(nativeRange);\n      debug.info('getNativeRange', range);\n      return range;\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      var normalized = this.getNativeRange();\n      if (normalized == null) return [null, null];\n      var range = this.normalizedToRange(normalized);\n      return [range, normalized];\n    }\n  }, {\n    key: \"hasFocus\",\n    value: function hasFocus() {\n      return document.activeElement === this.root || contains(this.root, document.activeElement);\n    }\n  }, {\n    key: \"normalizedToRange\",\n    value: function normalizedToRange(range) {\n      var _this4 = this;\n\n      var positions = [[range.start.node, range.start.offset]];\n\n      if (!range.native.collapsed) {\n        positions.push([range.end.node, range.end.offset]);\n      }\n\n      var indexes = positions.map(function (position) {\n        var _position = _slicedToArray(position, 2),\n            node = _position[0],\n            offset = _position[1];\n\n        var blot = _this4.scroll.find(node, true);\n\n        var index = blot.offset(_this4.scroll);\n\n        if (offset === 0) {\n          return index;\n        }\n\n        if (blot instanceof parchment__WEBPACK_IMPORTED_MODULE_0__[\"LeafBlot\"]) {\n          return index + blot.index(node, offset);\n        }\n\n        return index + blot.length();\n      });\n      var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);\n      var start = Math.min.apply(Math, [end].concat(_toConsumableArray(indexes)));\n      return new Range(start, end - start);\n    }\n  }, {\n    key: \"normalizeNative\",\n    value: function normalizeNative(nativeRange) {\n      if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {\n        return null;\n      }\n\n      var range = {\n        start: {\n          node: nativeRange.startContainer,\n          offset: nativeRange.startOffset\n        },\n        end: {\n          node: nativeRange.endContainer,\n          offset: nativeRange.endOffset\n        },\n        native: nativeRange\n      };\n      [range.start, range.end].forEach(function (position) {\n        var node = position.node,\n            offset = position.offset;\n\n        while (!(node instanceof Text) && node.childNodes.length > 0) {\n          if (node.childNodes.length > offset) {\n            node = node.childNodes[offset];\n            offset = 0;\n          } else if (node.childNodes.length === offset) {\n            node = node.lastChild;\n\n            if (node instanceof Text) {\n              offset = node.data.length;\n            } else if (node.childNodes.length > 0) {\n              // Container case\n              offset = node.childNodes.length;\n            } else {\n              // Embed case\n              offset = node.childNodes.length + 1;\n            }\n          } else {\n            break;\n          }\n        }\n\n        position.node = node;\n        position.offset = offset;\n      });\n      return range;\n    }\n  }, {\n    key: \"rangeToNative\",\n    value: function rangeToNative(range) {\n      var _this5 = this;\n\n      var indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];\n      var args = [];\n      var scrollLength = this.scroll.length();\n      indexes.forEach(function (index, i) {\n        index = Math.min(scrollLength - 1, index);\n\n        var _this5$scroll$leaf = _this5.scroll.leaf(index),\n            _this5$scroll$leaf2 = _slicedToArray(_this5$scroll$leaf, 2),\n            leaf = _this5$scroll$leaf2[0],\n            leafOffset = _this5$scroll$leaf2[1];\n\n        var _leaf$position5 = leaf.position(leafOffset, i !== 0),\n            _leaf$position6 = _slicedToArray(_leaf$position5, 2),\n            node = _leaf$position6[0],\n            offset = _leaf$position6[1];\n\n        args.push(node, offset);\n      });\n\n      if (args.length < 2) {\n        return args.concat(args);\n      }\n\n      return args;\n    }\n  }, {\n    key: \"scrollIntoView\",\n    value: function scrollIntoView(scrollingContainer) {\n      var range = this.lastRange;\n      if (range == null) return;\n      var bounds = this.getBounds(range.index, range.length);\n      if (bounds == null) return;\n      var limit = this.scroll.length() - 1;\n\n      var _this$scroll$line = this.scroll.line(Math.min(range.index, limit)),\n          _this$scroll$line2 = _slicedToArray(_this$scroll$line, 1),\n          first = _this$scroll$line2[0];\n\n      var last = first;\n\n      if (range.length > 0) {\n        var _this$scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));\n\n        var _this$scroll$line4 = _slicedToArray(_this$scroll$line3, 1);\n\n        last = _this$scroll$line4[0];\n      }\n\n      if (first == null || last == null) return;\n      var scrollBounds = scrollingContainer.getBoundingClientRect();\n\n      if (bounds.top < scrollBounds.top) {\n        scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;\n      } else if (bounds.bottom > scrollBounds.bottom) {\n        scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;\n      }\n    }\n  }, {\n    key: \"setNativeRange\",\n    value: function setNativeRange(startNode, startOffset) {\n      var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;\n      var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;\n      var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);\n\n      if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {\n        return;\n      }\n\n      var selection = document.getSelection();\n      if (selection == null) return;\n\n      if (startNode != null) {\n        if (!this.hasFocus()) this.root.focus();\n\n        var _ref = this.getNativeRange() || {},\n            native = _ref.native;\n\n        if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {\n          if (startNode.tagName === 'BR') {\n            startOffset = Array.from(startNode.parentNode.childNodes).indexOf(startNode);\n            startNode = startNode.parentNode;\n          }\n\n          if (endNode.tagName === 'BR') {\n            endOffset = Array.from(endNode.parentNode.childNodes).indexOf(endNode);\n            endNode = endNode.parentNode;\n          }\n\n          var range = document.createRange();\n          range.setStart(startNode, startOffset);\n          range.setEnd(endNode, endOffset);\n          selection.removeAllRanges();\n          selection.addRange(range);\n        }\n      } else {\n        selection.removeAllRanges();\n        this.root.blur();\n        document.body.focus(); // root.blur() not enough for IE11\n      }\n    }\n  }, {\n    key: \"setRange\",\n    value: function setRange(range) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.API;\n\n      if (typeof force === 'string') {\n        source = force;\n        force = false;\n      }\n\n      debug.info('setRange', range);\n\n      if (range != null) {\n        var args = this.rangeToNative(range);\n        this.setNativeRange.apply(this, _toConsumableArray(args).concat([force]));\n      } else {\n        this.setNativeRange(null);\n      }\n\n      this.update(source);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.USER;\n      var oldRange = this.lastRange;\n\n      var _this$getRange = this.getRange(),\n          _this$getRange2 = _slicedToArray(_this$getRange, 2),\n          lastRange = _this$getRange2[0],\n          nativeRange = _this$getRange2[1];\n\n      this.lastRange = lastRange;\n      this.lastNative = nativeRange;\n\n      if (this.lastRange != null) {\n        this.savedRange = this.lastRange;\n      }\n\n      if (!lodash_isequal__WEBPACK_IMPORTED_MODULE_2___default()(oldRange, this.lastRange)) {\n        var _this$emitter;\n\n        if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {\n          var range = this.cursor.restore();\n\n          if (range) {\n            this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);\n          }\n        }\n\n        var args = [_emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].events.SELECTION_CHANGE, lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1___default()(this.lastRange), lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1___default()(oldRange), source];\n\n        (_this$emitter = this.emitter).emit.apply(_this$emitter, [_emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].events.EDITOR_CHANGE].concat(args));\n\n        if (source !== _emitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.SILENT) {\n          var _this$emitter2;\n\n          (_this$emitter2 = this.emitter).emit.apply(_this$emitter2, args);\n        }\n      }\n    }\n  }]);\n\n  return Selection;\n}();\n\nfunction contains(parent, descendant) {\n  try {\n    // Firefox inserts inaccessible nodes around video elements\n    descendant.parentNode; // eslint-disable-line no-unused-expressions\n  } catch (e) {\n    return false;\n  } // IE11 has bug with Text nodes\n  // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect\n\n\n  if (descendant instanceof Text) {\n    descendant = descendant.parentNode;\n  }\n\n  return parent.contains(descendant);\n}\n\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return TableTextAlignStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return TableBackgroundColorStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return TableBorderStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return TableBorderStyleStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return TableBorderWidthStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return TableBorderColorStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return TableHeightStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return TableWidthStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return TableWidthAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return TableHeightAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return TABLE_FORMATS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return TABLE_ATTRIBUTORS; });\n/* harmony import */ var _prepare_attributor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);\n/* harmony import */ var _prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);\n\n\nvar tableConfig = {\n  name: 'table',\n  allowedTags: ['TABLE']\n};\nvar TableHeightAttribute = Object(_prepare_attributor__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(tableConfig, 'height');\nvar TableWidthAttribute = Object(_prepare_attributor__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(tableConfig, 'width');\nvar TableHeightStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(tableConfig, 'height');\nvar TableWidthStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(tableConfig, 'width');\nvar TableTextAlignStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(tableConfig, 'text', 'align');\nvar TableBackgroundColorStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(tableConfig, 'background', 'color');\nvar TableBorderStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(tableConfig, 'border');\nvar TableBorderStyleStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(tableConfig, 'border', 'style');\nvar TableBorderWidthStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(tableConfig, 'border', 'width');\nvar TableBorderColorStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(tableConfig, 'border', 'color');\nvar TABLE_FORMATS = {\n  tableTextAlign: TableTextAlignStyle,\n  tableBackgroundColor: TableBackgroundColorStyle,\n  tableBorder: TableBorderStyle,\n  tableBorderStyle: TableBorderStyleStyle,\n  tableBorderWidth: TableBorderWidthStyle,\n  tableBorderColor: TableBorderColorStyle,\n  tableWidth: TableWidthStyle,\n  tableHeight: TableHeightStyle\n};\nvar TABLE_ATTRIBUTORS = [TableTextAlignStyle, TableBackgroundColorStyle, TableBorderStyle, TableBorderStyleStyle, TableBorderColorStyle, TableBorderWidthStyle, TableHeightStyle, TableWidthStyle, TableWidthAttribute, TableHeightAttribute].reduce(function (memo, attr) {\n  memo[attr.keyName] = attr;\n  return memo;\n}, {});\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return CellVerticalAlignStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return CellTextAlignStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return CellBackgroundColorStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return CellBorderStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return CellBorderStyleStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return CellBorderWidthStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return CellBorderColorStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return CellPaddingStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return CellPaddingTopStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return CellPaddingBottomStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return CellPaddingLeftStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return CellPaddingRightStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return CellHeightStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r\", function() { return CellWidthStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return CellHeightAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"q\", function() { return CellWidthAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return CELL_FORMATS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return CELL_ATTRIBUTORS; });\n/* harmony import */ var _prepare_attributor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);\n/* harmony import */ var _prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);\n\n\nvar cellConfig = {\n  name: 'cell',\n  allowedTags: ['TH', 'TD']\n};\nvar CellHeightAttribute = Object(_prepare_attributor__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(cellConfig, 'height');\nvar CellWidthAttribute = Object(_prepare_attributor__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(cellConfig, 'width');\nvar CellHeightStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'height');\nvar CellWidthStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'width');\nvar CellVerticalAlignStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'vertical', 'align');\nvar CellTextAlignStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'text', 'align');\nvar CellBackgroundColorStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'background', 'color');\nvar CellBorderStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'border');\nvar CellBorderStyleStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'border', 'style');\nvar CellBorderWidthStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'border', 'width');\nvar CellBorderColorStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'border', 'color');\nvar CellPaddingStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'padding');\nvar CellPaddingTopStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'padding', 'top');\nvar CellPaddingBottomStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'padding', 'bottom');\nvar CellPaddingLeftStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'padding', 'left');\nvar CellPaddingRightStyle = Object(_prepare_style_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(cellConfig, 'padding', 'right');\nvar CELL_FORMATS = {\n  cellBorder: CellBorderStyle,\n  cellBorderStyle: CellBorderStyleStyle,\n  cellBorderWidth: CellBorderWidthStyle,\n  cellBorderColor: CellBorderColorStyle,\n  cellBackgroundColor: CellBackgroundColorStyle,\n  cellPadding: CellPaddingStyle,\n  cellPaddingTop: CellPaddingTopStyle,\n  cellPaddingBottom: CellPaddingBottomStyle,\n  cellPaddingLeft: CellPaddingLeftStyle,\n  cellPaddingRight: CellPaddingRightStyle,\n  cellVerticalAlign: CellVerticalAlignStyle,\n  cellTextAlign: CellTextAlignStyle,\n  cellWidth: CellWidthStyle,\n  cellHeight: CellHeightStyle\n};\nvar CELL_ATTRIBUTORS = [CellBackgroundColorStyle, CellBorderColorStyle, CellBorderStyle, CellBorderStyleStyle, CellBorderWidthStyle, CellPaddingBottomStyle, CellPaddingLeftStyle, CellPaddingRightStyle, CellPaddingStyle, CellPaddingTopStyle, CellVerticalAlignStyle, CellTextAlignStyle, CellHeightStyle, CellWidthStyle, CellWidthAttribute, CellHeightAttribute].reduce(function (memo, attr) {\n  memo[attr.keyName] = attr;\n  return memo;\n}, {});\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(54)))\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Text; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return escapeText; });\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar Text = /*#__PURE__*/function (_TextBlot) {\n  _inherits(Text, _TextBlot);\n\n  var _super = _createSuper(Text);\n\n  function Text() {\n    _classCallCheck(this, Text);\n\n    return _super.apply(this, arguments);\n  }\n\n  return Text;\n}(parchment__WEBPACK_IMPORTED_MODULE_0__[\"TextBlot\"]);\n\nfunction escapeText(text) {\n  return text.replace(/[&<>\"']/g, function (s) {\n    // https://lodash.com/docs#escape\n    var entityMap = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#39;'\n    };\n    return entityMap[s];\n  });\n}\n\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar Break = /*#__PURE__*/function (_EmbedBlot) {\n  _inherits(Break, _EmbedBlot);\n\n  var _super = _createSuper(Break);\n\n  function Break() {\n    _classCallCheck(this, Break);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Break, [{\n    key: \"optimize\",\n    value: function optimize() {\n      if (this.prev || this.next) {\n        this.remove();\n      }\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return 0;\n    }\n  }, {\n    key: \"value\",\n    value: function value() {\n      return '';\n    }\n  }], [{\n    key: \"value\",\n    value: function value() {\n      return undefined;\n    }\n  }]);\n\n  return Break;\n}(parchment__WEBPACK_IMPORTED_MODULE_0__[\"EmbedBlot\"]);\n\nBreak.blotName = 'break';\nBreak.tagName = 'BR';\n/* harmony default export */ __webpack_exports__[\"a\"] = (Break);\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return prepareStyleAttributor; });\n/* harmony import */ var _attributors_element_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _utils_capitalize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);\nvar _excluded = [\"name\", \"formatName\"];\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nfunction prepareStyleAttributor(_ref, propName) {\n  var name = _ref.name,\n      formatName = _ref.formatName,\n      elementConfig = _objectWithoutProperties(_ref, _excluded);\n\n  var subPropName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var fullName = \"\".concat(propName).concat(subPropName ? \"-\".concat(subPropName) : '');\n  return new _attributors_element_style__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"](\"\".concat(name).concat(Object(_utils_capitalize__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(formatName !== null && formatName !== void 0 ? formatName : propName)).concat(Object(_utils_capitalize__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(subPropName)), fullName, elementConfig);\n}\n\n/***/ }),\n/* 14 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Module = function Module(quill) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  _classCallCheck(this, Module);\n\n  this.quill = quill;\n  this.options = options;\n};\n\nModule.DEFAULTS = {};\n/* harmony default export */ __webpack_exports__[\"a\"] = (Module);\n\n/***/ }),\n/* 15 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar Container = /*#__PURE__*/function (_ContainerBlot) {\n  _inherits(Container, _ContainerBlot);\n\n  var _super = _createSuper(Container);\n\n  function Container() {\n    _classCallCheck(this, Container);\n\n    return _super.apply(this, arguments);\n  }\n\n  return Container;\n}(parchment__WEBPACK_IMPORTED_MODULE_0__[\"ContainerBlot\"]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Container);\n\n/***/ }),\n/* 16 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _break__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);\n/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\nvar Inline = /*#__PURE__*/function (_InlineBlot) {\n  _inherits(Inline, _InlineBlot);\n\n  var _super = _createSuper(Inline);\n\n  function Inline() {\n    _classCallCheck(this, Inline);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Inline, [{\n    key: \"formatAt\",\n    value: function formatAt(index, length, name, value) {\n      if (Inline.compare(this.statics.blotName, name) < 0 && this.scroll.query(name, parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].BLOT)) {\n        var blot = this.isolate(index, length);\n\n        if (value) {\n          blot.wrap(name, value);\n        }\n      } else {\n        _get(_getPrototypeOf(Inline.prototype), \"formatAt\", this).call(this, index, length, name, value);\n      }\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize(context) {\n      _get(_getPrototypeOf(Inline.prototype), \"optimize\", this).call(this, context);\n\n      if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {\n        var parent = this.parent.isolate(this.offset(), this.length());\n        this.moveChildren(parent);\n        parent.wrap(this);\n      }\n    }\n  }], [{\n    key: \"compare\",\n    value: function compare(self, other) {\n      var selfIndex = Inline.order.indexOf(self);\n      var otherIndex = Inline.order.indexOf(other);\n\n      if (selfIndex >= 0 || otherIndex >= 0) {\n        return selfIndex - otherIndex;\n      }\n\n      if (self === other) {\n        return 0;\n      }\n\n      if (self < other) {\n        return -1;\n      }\n\n      return 1;\n    }\n  }]);\n\n  return Inline;\n}(parchment__WEBPACK_IMPORTED_MODULE_0__[\"InlineBlot\"]);\n\nInline.allowedChildren = [Inline, _break__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"], parchment__WEBPACK_IMPORTED_MODULE_0__[\"EmbedBlot\"], _text__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]]; // Lower index means deeper in the DOM tree, since not found (-1) is for embeds\n\nInline.order = ['cursor', 'inline', // Must be lower\n'link', // Chrome wants <a> to be lower\n'underline', 'strike', 'italic', 'bold', 'script', 'code' // Must be higher\n];\n/* harmony default export */ __webpack_exports__[\"a\"] = (Inline);\n\n/***/ }),\n/* 17 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar hasWindow = function hasWindow() {\n  return typeof window !== 'undefined';\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (hasWindow);\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(54), __webpack_require__(61)(module)))\n\n/***/ }),\n/* 19 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Code; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return CodeBlockContainer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return CodeBlock; });\n/* harmony import */ var _blots_block__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);\n/* harmony import */ var _blots_break__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);\n/* harmony import */ var _blots_cursor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);\n/* harmony import */ var _blots_inline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16);\n/* harmony import */ var _blots_text__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);\n/* harmony import */ var _blots_container__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(15);\n/* harmony import */ var _core_quill__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\nvar CodeBlockContainer = /*#__PURE__*/function (_Container) {\n  _inherits(CodeBlockContainer, _Container);\n\n  var _super = _createSuper(CodeBlockContainer);\n\n  function CodeBlockContainer() {\n    _classCallCheck(this, CodeBlockContainer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(CodeBlockContainer, [{\n    key: \"code\",\n    value: function code(index, length) {\n      var text = this.children.map(function (child) {\n        return child.length() <= 1 ? '' : child.domNode.textContent;\n      }).join('\\n').slice(index, index + length);\n      return Object(_blots_text__WEBPACK_IMPORTED_MODULE_4__[/* escapeText */ \"b\"])(text);\n    }\n  }, {\n    key: \"html\",\n    value: function html(index, length) {\n      // `\\n`s are needed in order to support empty lines at the beginning and the end.\n      // https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions\n      return \"<pre>\\n\".concat(this.code(index, length), \"\\n</pre>\");\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var domNode = _get(_getPrototypeOf(CodeBlockContainer), \"create\", this).call(this, value);\n\n      domNode.setAttribute('spellcheck', false);\n      return domNode;\n    }\n  }]);\n\n  return CodeBlockContainer;\n}(_blots_container__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"]);\n\nvar CodeBlock = /*#__PURE__*/function (_Block) {\n  _inherits(CodeBlock, _Block);\n\n  var _super2 = _createSuper(CodeBlock);\n\n  function CodeBlock() {\n    _classCallCheck(this, CodeBlock);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(CodeBlock, null, [{\n    key: \"register\",\n    value: function register() {\n      _core_quill__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"].register(CodeBlockContainer);\n    }\n  }]);\n\n  return CodeBlock;\n}(_blots_block__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"d\"]);\n\nvar Code = /*#__PURE__*/function (_Inline) {\n  _inherits(Code, _Inline);\n\n  var _super3 = _createSuper(Code);\n\n  function Code() {\n    _classCallCheck(this, Code);\n\n    return _super3.apply(this, arguments);\n  }\n\n  return Code;\n}(_blots_inline__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"]);\n\nCode.blotName = 'code';\nCode.tagName = 'CODE';\nCodeBlock.blotName = 'code-block';\nCodeBlock.className = 'ql-code-block';\nCodeBlock.tagName = 'DIV';\nCodeBlockContainer.blotName = 'code-block-container';\nCodeBlockContainer.className = 'ql-code-block-container';\nCodeBlockContainer.tagName = 'DIV';\nCodeBlockContainer.allowedChildren = [CodeBlock];\nCodeBlock.allowedChildren = [_blots_text__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"], _blots_break__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"], _blots_cursor__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]];\nCodeBlock.requiredContainer = CodeBlockContainer;\nCodeBlock.TAB = '  ';\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _core_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var _block__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);\n/* harmony import */ var _break__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12);\n/* harmony import */ var _container__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(15);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\nfunction isLine(blot) {\n  return blot instanceof _block__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"d\"] || blot instanceof _block__WEBPACK_IMPORTED_MODULE_2__[/* BlockEmbed */ \"a\"];\n}\n\nvar Scroll = /*#__PURE__*/function (_ScrollBlot) {\n  _inherits(Scroll, _ScrollBlot);\n\n  var _super = _createSuper(Scroll);\n\n  function Scroll(registry, domNode, _ref) {\n    var _this;\n\n    var emitter = _ref.emitter,\n        toggleBlankClass = _ref.toggleBlankClass;\n\n    _classCallCheck(this, Scroll);\n\n    _this = _super.call(this, registry, domNode);\n    _this.emitter = emitter;\n    _this.toggleBlankClass = toggleBlankClass;\n    _this.batch = false;\n\n    _this.optimize();\n\n    _this.enable();\n\n    _this.domNode.addEventListener('dragstart', function (e) {\n      return _this.handleDragStart(e);\n    });\n\n    return _this;\n  }\n\n  _createClass(Scroll, [{\n    key: \"batchStart\",\n    value: function batchStart() {\n      if (!Array.isArray(this.batch)) {\n        this.batch = [];\n      }\n    }\n  }, {\n    key: \"batchEnd\",\n    value: function batchEnd() {\n      var mutations = this.batch;\n      this.batch = false;\n      this.update(mutations);\n    }\n  }, {\n    key: \"emitMount\",\n    value: function emitMount(blot) {\n      this.emitter.emit(_core_emitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].events.SCROLL_BLOT_MOUNT, blot);\n    }\n  }, {\n    key: \"emitUnmount\",\n    value: function emitUnmount(blot) {\n      this.emitter.emit(_core_emitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].events.SCROLL_BLOT_UNMOUNT, blot);\n    }\n  }, {\n    key: \"deleteAt\",\n    value: function deleteAt(index, length) {\n      var _this$line = this.line(index),\n          _this$line2 = _slicedToArray(_this$line, 2),\n          first = _this$line2[0],\n          offset = _this$line2[1];\n\n      var _this$line3 = this.line(index + length),\n          _this$line4 = _slicedToArray(_this$line3, 1),\n          last = _this$line4[0];\n\n      _get(_getPrototypeOf(Scroll.prototype), \"deleteAt\", this).call(this, index, length);\n\n      if (last != null && first !== last && offset > 0) {\n        if (first instanceof _block__WEBPACK_IMPORTED_MODULE_2__[/* BlockEmbed */ \"a\"] || last instanceof _block__WEBPACK_IMPORTED_MODULE_2__[/* BlockEmbed */ \"a\"]) {\n          this.optimize();\n          return;\n        }\n\n        var ref = last.children.head instanceof _break__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"] ? null : last.children.head;\n        first.moveChildren(last, ref);\n        first.remove();\n      }\n\n      this.optimize();\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.domNode.setAttribute('contenteditable', enabled);\n    }\n  }, {\n    key: \"formatAt\",\n    value: function formatAt(index, length, format, value) {\n      _get(_getPrototypeOf(Scroll.prototype), \"formatAt\", this).call(this, index, length, format, value);\n\n      this.optimize();\n    }\n  }, {\n    key: \"handleDragStart\",\n    value: function handleDragStart(event) {\n      event.preventDefault();\n    }\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(index, value, def) {\n      if (index >= this.length()) {\n        if (def == null || this.scroll.query(value, parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].BLOCK) == null) {\n          var blot = this.scroll.create(this.statics.defaultChild.blotName);\n          this.appendChild(blot);\n\n          if (def == null && value.endsWith('\\n')) {\n            blot.insertAt(0, value.slice(0, -1), def);\n          } else {\n            blot.insertAt(0, value, def);\n          }\n        } else {\n          var embed = this.scroll.create(value, def);\n          this.appendChild(embed);\n        }\n      } else {\n        _get(_getPrototypeOf(Scroll.prototype), \"insertAt\", this).call(this, index, value, def);\n      }\n\n      this.optimize();\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(blot, ref) {\n      if (blot.statics.scope === parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].INLINE_BLOT) {\n        var wrapper = this.scroll.create(this.statics.defaultChild.blotName);\n        wrapper.appendChild(blot);\n\n        _get(_getPrototypeOf(Scroll.prototype), \"insertBefore\", this).call(this, wrapper, ref);\n      } else {\n        _get(_getPrototypeOf(Scroll.prototype), \"insertBefore\", this).call(this, blot, ref);\n      }\n    }\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return this.domNode.getAttribute('contenteditable') === 'true';\n    }\n  }, {\n    key: \"leaf\",\n    value: function leaf(index) {\n      return this.path(index).pop() || [null, -1];\n    }\n  }, {\n    key: \"line\",\n    value: function line(index) {\n      if (index === this.length()) {\n        return this.line(index - 1);\n      }\n\n      return this.descendant(isLine, index);\n    }\n  }, {\n    key: \"lines\",\n    value: function lines() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n\n      var getLines = function getLines(blot, blotIndex, blotLength) {\n        var lines = [];\n        var lengthLeft = blotLength;\n        blot.children.forEachAt(blotIndex, blotLength, function (child, childIndex, childLength) {\n          if (isLine(child)) {\n            lines.push(child);\n          } else if (child instanceof parchment__WEBPACK_IMPORTED_MODULE_0__[\"ContainerBlot\"]) {\n            lines = lines.concat(getLines(child, childIndex, lengthLeft));\n          }\n\n          lengthLeft -= childLength;\n        });\n        return lines;\n      };\n\n      return getLines(this, index, length);\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize() {\n      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.batch) return;\n\n      _get(_getPrototypeOf(Scroll.prototype), \"optimize\", this).call(this, mutations, context);\n\n      if (mutations.length > 0) {\n        this.emitter.emit(_core_emitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].events.SCROLL_OPTIMIZE, mutations, context);\n      }\n    }\n  }, {\n    key: \"path\",\n    value: function path(index) {\n      return _get(_getPrototypeOf(Scroll.prototype), \"path\", this).call(this, index).slice(1); // Exclude self\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {// Never remove self\n    }\n  }, {\n    key: \"update\",\n    value: function update(mutations) {\n      var _this2 = this;\n\n      if (this.batch) {\n        if (Array.isArray(mutations)) {\n          this.batch = this.batch.concat(mutations);\n          this.toggleBlankClass();\n        }\n\n        return;\n      }\n\n      var source = _core_emitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].sources.USER;\n\n      if (typeof mutations === 'string') {\n        source = mutations;\n      }\n\n      if (!Array.isArray(mutations)) {\n        mutations = this.observer.takeRecords();\n      }\n\n      mutations = mutations.filter(function (_ref2) {\n        var target = _ref2.target;\n\n        var blot = _this2.find(target, true);\n\n        return blot && blot.scroll === _this2;\n      });\n\n      if (mutations.length > 0) {\n        this.emitter.emit(_core_emitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].events.SCROLL_BEFORE_UPDATE, source, mutations);\n      }\n\n      _get(_getPrototypeOf(Scroll.prototype), \"update\", this).call(this, mutations.concat([])); // pass copy\n\n\n      if (mutations.length > 0) {\n        this.emitter.emit(_core_emitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].events.SCROLL_UPDATE, source, mutations);\n      }\n    }\n  }]);\n\n  return Scroll;\n}(parchment__WEBPACK_IMPORTED_MODULE_0__[\"ScrollBlot\"]);\n\nScroll.blotName = 'scroll';\nScroll.className = 'ql-editor';\nScroll.tagName = 'DIV';\nScroll.defaultChild = _block__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"d\"];\nScroll.allowedChildren = [_block__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"d\"], _block__WEBPACK_IMPORTED_MODULE_2__[/* BlockEmbed */ \"a\"], _container__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"]];\n/* harmony default export */ __webpack_exports__[\"a\"] = (Scroll);\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\nvar FunctionPrototype = Function.prototype;\nvar bind = FunctionPrototype.bind;\nvar call = FunctionPrototype.call;\nvar callBind = bind && bind.bind(call);\n\nmodule.exports = bind ? function (fn) {\n  return fn && callBind(call, fn);\n} : function (fn) {\n  return fn && function () {\n    return call.apply(fn, arguments);\n  };\n};\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nmodule.exports = function (argument) {\n  return typeof argument == 'function';\n};\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar levels = ['error', 'warn', 'log', 'info'];\nvar level = 'warn';\n\nfunction debug(method) {\n  if (levels.indexOf(method) <= levels.indexOf(level)) {\n    var _console;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_console = console)[method].apply(_console, args); // eslint-disable-line no-console\n\n  }\n}\n\nfunction namespace(ns) {\n  return levels.reduce(function (logger, method) {\n    logger[method] = debug.bind(console, method, ns);\n    return logger;\n  }, {});\n}\n\nnamespace.level = function (newLevel) {\n  level = newLevel;\n};\n\ndebug.level = namespace.level;\n/* harmony default export */ __webpack_exports__[\"a\"] = (namespace);\n\n/***/ }),\n/* 24 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar Cursor = /*#__PURE__*/function (_EmbedBlot) {\n  _inherits(Cursor, _EmbedBlot);\n\n  var _super = _createSuper(Cursor);\n\n  function Cursor(scroll, domNode, selection) {\n    var _this;\n\n    _classCallCheck(this, Cursor);\n\n    _this = _super.call(this, scroll, domNode);\n    _this.selection = selection;\n    _this.textNode = document.createTextNode(Cursor.CONTENTS);\n\n    _this.domNode.appendChild(_this.textNode);\n\n    _this.savedLength = 0;\n    return _this;\n  }\n\n  _createClass(Cursor, [{\n    key: \"detach\",\n    value: function detach() {\n      // super.detach() will also clear domNode.__blot\n      if (this.parent != null) this.parent.removeChild(this);\n    }\n  }, {\n    key: \"format\",\n    value: function format(name, value) {\n      if (this.savedLength !== 0) {\n        _get(_getPrototypeOf(Cursor.prototype), \"format\", this).call(this, name, value);\n\n        return;\n      }\n\n      var target = this;\n      var index = 0;\n\n      while (target != null && target.statics.scope !== parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].BLOCK_BLOT) {\n        index += target.offset(target.parent);\n        target = target.parent;\n      }\n\n      if (target != null) {\n        this.savedLength = Cursor.CONTENTS.length;\n        target.optimize();\n        target.formatAt(index, Cursor.CONTENTS.length, name, value);\n        this.savedLength = 0;\n      }\n    }\n  }, {\n    key: \"index\",\n    value: function index(node, offset) {\n      if (node === this.textNode) return 0;\n      return _get(_getPrototypeOf(Cursor.prototype), \"index\", this).call(this, node, offset);\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.savedLength;\n    }\n  }, {\n    key: \"position\",\n    value: function position() {\n      return [this.textNode, this.textNode.data.length];\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      _get(_getPrototypeOf(Cursor.prototype), \"remove\", this).call(this);\n\n      this.parent = null;\n    }\n  }, {\n    key: \"restore\",\n    value: function restore() {\n      if (this.selection.composing || this.parent == null) return null;\n      var range = this.selection.getNativeRange(); // Link format will insert text outside of anchor tag\n\n      while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {\n        this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);\n      }\n\n      var prevTextBlot = this.prev instanceof _text__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"] ? this.prev : null;\n      var prevTextLength = prevTextBlot ? prevTextBlot.length() : 0;\n      var nextTextBlot = this.next instanceof _text__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"] ? this.next : null;\n      var nextText = nextTextBlot ? nextTextBlot.text : '';\n      var textNode = this.textNode; // take text from inside this blot and reset it\n\n      var newText = textNode.data.split(Cursor.CONTENTS).join('');\n      textNode.data = Cursor.CONTENTS; // proactively merge TextBlots around cursor so that optimization\n      // doesn't lose the cursor.  the reason we are here in cursor.restore\n      // could be that the user clicked in prevTextBlot or nextTextBlot, or\n      // the user typed something.\n\n      var mergedTextBlot;\n\n      if (prevTextBlot) {\n        mergedTextBlot = prevTextBlot;\n\n        if (newText || nextTextBlot) {\n          prevTextBlot.insertAt(prevTextBlot.length(), newText + nextText);\n\n          if (nextTextBlot) {\n            nextTextBlot.remove();\n          }\n        }\n      } else if (nextTextBlot) {\n        mergedTextBlot = nextTextBlot;\n        nextTextBlot.insertAt(0, newText);\n      } else {\n        var newTextNode = document.createTextNode(newText);\n        mergedTextBlot = this.scroll.create(newTextNode);\n        this.parent.insertBefore(mergedTextBlot, this);\n      }\n\n      this.remove();\n\n      if (range) {\n        // calculate selection to restore\n        var remapOffset = function remapOffset(node, offset) {\n          if (prevTextBlot && node === prevTextBlot.domNode) {\n            return offset;\n          }\n\n          if (node === textNode) {\n            return prevTextLength + offset - 1;\n          }\n\n          if (nextTextBlot && node === nextTextBlot.domNode) {\n            return prevTextLength + newText.length + offset;\n          }\n\n          return null;\n        };\n\n        var start = remapOffset(range.start.node, range.start.offset);\n        var end = remapOffset(range.end.node, range.end.offset);\n\n        if (start !== null && end !== null) {\n          return {\n            startNode: mergedTextBlot.domNode,\n            startOffset: start,\n            endNode: mergedTextBlot.domNode,\n            endOffset: end\n          };\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"update\",\n    value: function update(mutations, context) {\n      var _this2 = this;\n\n      if (mutations.some(function (mutation) {\n        return mutation.type === 'characterData' && mutation.target === _this2.textNode;\n      })) {\n        var range = this.restore();\n        if (range) context.range = range;\n      }\n    }\n  }, {\n    key: \"value\",\n    value: function value() {\n      return '';\n    }\n  }], [{\n    key: \"value\",\n    value: function value() {\n      return undefined;\n    }\n  }]);\n\n  return Cursor;\n}(parchment__WEBPACK_IMPORTED_MODULE_0__[\"EmbedBlot\"]);\n\nCursor.blotName = 'cursor';\nCursor.className = 'ql-cursor';\nCursor.tagName = 'span';\nCursor.CONTENTS = \"\\uFEFF\"; // Zero width no break space\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Cursor);\n\n/***/ }),\n/* 25 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _blots_block__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\n/* harmony import */ var _blots_break__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);\n/* harmony import */ var _blots_container__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15);\n/* harmony import */ var _blots_cursor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24);\n/* harmony import */ var _blots_embed__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(59);\n/* harmony import */ var _blots_inline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(16);\n/* harmony import */ var _blots_scroll__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(20);\n/* harmony import */ var _blots_text__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(11);\n/* harmony import */ var _modules_clipboard__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(28);\n/* harmony import */ var _modules_history__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(47);\n/* harmony import */ var _modules_keyboard__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(26);\n/* harmony import */ var _modules_uploader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(55);\n\n\n\n\n\n\n\n\n\n\n\n\n\n_core_quill__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].register({\n  'blots/block': _blots_block__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"d\"],\n  'blots/block/embed': _blots_block__WEBPACK_IMPORTED_MODULE_1__[/* BlockEmbed */ \"a\"],\n  'blots/break': _blots_break__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"],\n  'blots/container': _blots_container__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"],\n  'blots/cursor': _blots_cursor__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"],\n  'blots/embed': _blots_embed__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"],\n  'blots/inline': _blots_inline__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"],\n  'blots/scroll': _blots_scroll__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"],\n  'blots/text': _blots_text__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"],\n  'modules/clipboard': _modules_clipboard__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"b\"],\n  'modules/history': _modules_history__WEBPACK_IMPORTED_MODULE_10__[/* default */ \"a\"],\n  'modules/keyboard': _modules_keyboard__WEBPACK_IMPORTED_MODULE_11__[/* default */ \"b\"],\n  'modules/uploader': _modules_uploader__WEBPACK_IMPORTED_MODULE_12__[/* default */ \"a\"]\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (_core_quill__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"]);\n\n/***/ }),\n/* 26 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ keyboard_Keyboard; });\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ SHORTKEY; });\n__webpack_require__.d(__webpack_exports__, \"d\", function() { return /* binding */ normalize; });\n__webpack_require__.d(__webpack_exports__, \"c\", function() { return /* binding */ deleteRange; });\n\n// EXTERNAL MODULE: ./node_modules/lodash.clonedeep/index.js\nvar lodash_clonedeep = __webpack_require__(18);\nvar lodash_clonedeep_default = /*#__PURE__*/__webpack_require__.n(lodash_clonedeep);\n\n// EXTERNAL MODULE: ./node_modules/lodash.isequal/index.js\nvar lodash_isequal = __webpack_require__(29);\nvar lodash_isequal_default = /*#__PURE__*/__webpack_require__.n(lodash_isequal);\n\n// EXTERNAL MODULE: ./node_modules/quill-delta/dist/Delta.js\nvar Delta = __webpack_require__(1);\nvar Delta_default = /*#__PURE__*/__webpack_require__.n(Delta);\n\n// EXTERNAL MODULE: ./node_modules/parchment/src/parchment.ts + 17 modules\nvar parchment = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./core/quill.js\nvar core_quill = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./core/logger.js\nvar logger = __webpack_require__(23);\n\n// EXTERNAL MODULE: ./core/module.js\nvar core_module = __webpack_require__(14);\n\n// EXTERNAL MODULE: ./utils/has_window.js\nvar has_window = __webpack_require__(17);\n\n// CONCATENATED MODULE: ./utils/get_scroll_into_view_config.js\nfunction getScrollIntoViewConfig(element) {\n  var _window = window,\n      windowHeight = _window.innerHeight;\n\n  var _element$getBoundingC = element.getBoundingClientRect(),\n      elemTop = _element$getBoundingC.y,\n      elemBottom = _element$getBoundingC.bottom;\n\n  if (elemTop < 0) {\n    return true; // scroll to the top\n  }\n\n  if (elemBottom >= windowHeight) {\n    return false; // scroll to the bottom\n  }\n\n  return null;\n}\n// CONCATENATED MODULE: ./modules/keyboard.js\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\n\nvar debug = Object(logger[\"a\" /* default */])('quill:keyboard');\nvar KEY_NAMES = {\n  backspace: 'backspace',\n  tab: 'tab',\n  enter: 'enter',\n  escape: 'escape',\n  pageup: 'pageUp',\n  pagedown: 'pageDown',\n  end: 'end',\n  home: 'home',\n  arrowleft: 'leftArrow',\n  arrowup: 'upArrow',\n  arrowright: 'rightArrow',\n  arrowdown: 'downArrow',\n  delete: 'del',\n  ' ': 'space',\n  '*': 'asterisk',\n  '-': 'minus',\n  alt: 'alt',\n  control: 'control',\n  shift: 'shift',\n  // IE11:\n  left: 'leftArrow',\n  up: 'upArrow',\n  right: 'rightArrow',\n  down: 'downArrow',\n  multiply: 'asterisk',\n  spacebar: 'space',\n  del: 'del',\n  subtract: 'minus',\n  esc: 'escape'\n};\nvar KEY_CODES = {\n  // iOS 10.2 and lower didn't supports KeyboardEvent.key\n  '8': 'backspace',\n  '9': 'tab',\n  '13': 'enter',\n  '27': 'escape',\n  '33': 'pageUp',\n  '34': 'pageDown',\n  '35': 'end',\n  '36': 'home',\n  '37': 'leftArrow',\n  '38': 'upArrow',\n  '39': 'rightArrow',\n  '40': 'downArrow',\n  '46': 'del',\n  '32': 'space',\n  '106': 'asterisk',\n  '109': 'minus',\n  '189': 'minus',\n  '173': 'minus',\n  '16': 'shift',\n  '17': 'control',\n  '18': 'alt'\n};\nvar SHORTKEY = Object(has_window[\"a\" /* default */])() && /Mac/i.test(navigator.platform) ? 'metaKey' : 'ctrlKey';\n\nvar keyboard_Keyboard = /*#__PURE__*/function (_Module) {\n  _inherits(Keyboard, _Module);\n\n  var _super = _createSuper(Keyboard);\n\n  function Keyboard(quill, options) {\n    var _this;\n\n    _classCallCheck(this, Keyboard);\n\n    _this = _super.call(this, quill, options);\n    _this.bindings = {};\n    Object.keys(_this.options.bindings).forEach(function (name) {\n      if (_this.options.bindings[name]) {\n        _this.addBinding(_this.options.bindings[name]);\n      }\n    });\n\n    _this.addInternalBindings();\n\n    _this.listen();\n\n    return _this;\n  }\n\n  _createClass(Keyboard, [{\n    key: \"addInternalBindings\",\n    value: function addInternalBindings() {\n      var _this2 = this;\n\n      this.quill.once(core_quill[\"a\" /* default */].events.CONTENT_SETTED, function () {\n        _this2.addBinding({\n          key: 'enter',\n          shiftKey: null\n        }, _this2.handleEnter);\n\n        _this2.addBinding({\n          key: 'enter',\n          metaKey: null,\n          ctrlKey: null,\n          altKey: null\n        }, function () {});\n\n        if (Object(has_window[\"a\" /* default */])() && /Firefox/i.test(navigator.userAgent)) {\n          // Need to handle delete and backspace for Firefox in the general case #1171\n          _this2.addBinding({\n            key: 'backspace'\n          }, {\n            collapsed: true\n          }, _this2.handleBackspace);\n\n          _this2.addBinding({\n            key: 'del'\n          }, {\n            collapsed: true\n          }, _this2.handleDelete);\n        } else {\n          _this2.addBinding({\n            key: 'backspace'\n          }, {\n            collapsed: true,\n            prefix: /^.?$/\n          }, _this2.handleBackspace);\n\n          _this2.addBinding({\n            key: 'del'\n          }, {\n            collapsed: true,\n            suffix: /^.?$/\n          }, _this2.handleDelete);\n        }\n\n        _this2.addBinding({\n          key: 'backspace'\n        }, {\n          collapsed: false\n        }, _this2.handleDeleteRange);\n\n        _this2.addBinding({\n          key: 'del'\n        }, {\n          collapsed: false\n        }, _this2.handleDeleteRange);\n\n        _this2.addBinding({\n          key: 'backspace',\n          altKey: null,\n          ctrlKey: null,\n          metaKey: null,\n          shiftKey: null\n        }, {\n          collapsed: true,\n          offset: 0\n        }, _this2.handleBackspace);\n      });\n    }\n  }, {\n    key: \"addBinding\",\n    value: function addBinding(keyBinding) {\n      var _this3 = this;\n\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var binding = normalize(keyBinding);\n\n      if (binding == null) {\n        debug.warn('Attempted to add invalid keyboard binding', binding);\n        return;\n      }\n\n      if (typeof context === 'function') {\n        context = {\n          handler: context\n        };\n      }\n\n      if (typeof handler === 'function') {\n        handler = {\n          handler: handler\n        };\n      }\n\n      var keyPropery = binding.which ? 'which' : 'key';\n      var keys = Array.isArray(binding[keyPropery]) ? binding[keyPropery] : [binding[keyPropery]];\n      keys.forEach(function (key) {\n        var singleBinding = _objectSpread(_objectSpread(_objectSpread({}, binding), {}, {\n          key: key\n        }, context), handler);\n\n        _this3.bindings[singleBinding.key] = _this3.bindings[singleBinding.key] || [];\n\n        _this3.bindings[singleBinding.key].push(singleBinding);\n      });\n    }\n  }, {\n    key: \"listen\",\n    value: function listen() {\n      var _this4 = this;\n\n      this.quill.root.addEventListener('keydown', function (evt) {\n        if (evt.defaultPrevented || evt.isComposing) return;\n\n        _this4.raiseOnKeydownCallback(evt);\n\n        var keyName = Keyboard.normalizeKeyName(evt);\n        var bindings = (_this4.bindings[keyName] || []).concat(_this4.bindings[evt.which] || []);\n        var matches = bindings.filter(function (binding) {\n          return Keyboard.match(evt, binding);\n        });\n        if (matches.length === 0) return;\n\n        var range = _this4.quill.getSelection();\n\n        if (range == null || !_this4.quill.hasFocus()) return;\n\n        var _this4$quill$getLine = _this4.quill.getLine(range.index),\n            _this4$quill$getLine2 = _slicedToArray(_this4$quill$getLine, 2),\n            line = _this4$quill$getLine2[0],\n            offset = _this4$quill$getLine2[1];\n\n        var _this4$quill$getLeaf = _this4.quill.getLeaf(range.index),\n            _this4$quill$getLeaf2 = _slicedToArray(_this4$quill$getLeaf, 2),\n            leafStart = _this4$quill$getLeaf2[0],\n            offsetStart = _this4$quill$getLeaf2[1];\n\n        var _ref = range.length === 0 ? [leafStart, offsetStart] : _this4.quill.getLeaf(range.index + range.length),\n            _ref2 = _slicedToArray(_ref, 2),\n            leafEnd = _ref2[0],\n            offsetEnd = _ref2[1];\n\n        var prefixText = leafStart instanceof parchment[\"TextBlot\"] ? leafStart.value().slice(0, offsetStart) : '';\n        var suffixText = leafEnd instanceof parchment[\"TextBlot\"] ? leafEnd.value().slice(offsetEnd) : '';\n        var curContext = {\n          collapsed: range.length === 0,\n          empty: range.length === 0 && line.length() <= 1,\n          format: _this4.quill.getFormat(range),\n          line: line,\n          offset: offset,\n          prefix: prefixText,\n          suffix: suffixText,\n          event: evt\n        };\n        var prevented = false;\n        matches.some(function (binding) {\n          if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) {\n            return false;\n          }\n\n          if (binding.empty != null && binding.empty !== curContext.empty) {\n            return false;\n          }\n\n          if (binding.offset != null && binding.offset !== curContext.offset) {\n            return false;\n          }\n\n          if (Array.isArray(binding.format)) {\n            // any format is present\n            if (binding.format.every(function (name) {\n              return curContext.format[name] == null;\n            })) {\n              return false;\n            }\n          } else if (_typeof(binding.format) === 'object') {\n            // all formats must match\n            if (!Object.keys(binding.format).every(function (name) {\n              if (binding.format[name] === true) return curContext.format[name] != null;\n              if (binding.format[name] === false) return curContext.format[name] == null;\n              return lodash_isequal_default()(binding.format[name], curContext.format[name]);\n            })) {\n              return false;\n            }\n          }\n\n          if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) {\n            return false;\n          }\n\n          if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) {\n            return false;\n          }\n\n          var handlerResult = binding.handler.call(_this4, range, curContext, binding);\n          var preventAfterAllMatches = handlerResult === null || handlerResult === void 0 ? void 0 : handlerResult.preventAfterAllMatches;\n          prevented = handlerResult !== true || preventAfterAllMatches;\n          return prevented && !preventAfterAllMatches;\n        });\n\n        if (prevented) {\n          evt.preventDefault();\n        }\n      });\n    }\n  }, {\n    key: \"raiseOnKeydownCallback\",\n    value: function raiseOnKeydownCallback(event) {\n      var callback = this.options.onKeydown;\n\n      if (callback && typeof callback === 'function') {\n        callback(event);\n      }\n    }\n  }, {\n    key: \"handleBackspace\",\n    value: function handleBackspace(range, context) {\n      // Check for astral symbols\n      var length = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]$/.test(context.prefix) ? 2 : 1;\n      if (range.index === 0 || this.quill.getLength() <= 1) return;\n      var formats = {};\n\n      var _this$quill$getLine = this.quill.getLine(range.index),\n          _this$quill$getLine2 = _slicedToArray(_this$quill$getLine, 1),\n          line = _this$quill$getLine2[0];\n\n      var delta = new Delta_default.a().retain(range.index - length).delete(length);\n\n      if (context.offset === 0) {\n        // Always deleting newline here, length always 1\n        var _this$quill$getLine3 = this.quill.getLine(range.index - 1),\n            _this$quill$getLine4 = _slicedToArray(_this$quill$getLine3, 1),\n            prev = _this$quill$getLine4[0];\n\n        if (prev) {\n          var isPrevLineEmpty = prev.statics.blotName === 'block' && prev.length() <= 1;\n\n          if (!isPrevLineEmpty) {\n            var curFormats = line.formats();\n            var prevFormats = this.quill.getFormat(range.index - 1, 1);\n            formats = Delta[\"AttributeMap\"].diff(curFormats, prevFormats) || {};\n\n            if (Object.keys(formats).length > 0) {\n              // line.length() - 1 targets \\n in line, another -1 for newline being deleted\n              var formatDelta = new Delta_default.a().retain(range.index + line.length() - 2).retain(1, formats);\n              delta = delta.compose(formatDelta);\n            }\n          }\n        }\n      }\n\n      this.quill.updateContents(delta, core_quill[\"a\" /* default */].sources.USER);\n      this.quill.focus();\n    }\n  }, {\n    key: \"handleDelete\",\n    value: function handleDelete(range, context) {\n      // Check for astral symbols\n      var length = /^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/.test(context.suffix) ? 2 : 1;\n      if (range.index >= this.quill.getLength() - length) return;\n      var formats = {};\n\n      var _this$quill$getLine5 = this.quill.getLine(range.index),\n          _this$quill$getLine6 = _slicedToArray(_this$quill$getLine5, 1),\n          line = _this$quill$getLine6[0];\n\n      var delta = new Delta_default.a().retain(range.index).delete(length);\n\n      if (context.offset >= line.length() - 1) {\n        var _this$quill$getLine7 = this.quill.getLine(range.index + 1),\n            _this$quill$getLine8 = _slicedToArray(_this$quill$getLine7, 1),\n            next = _this$quill$getLine8[0];\n\n        if (next) {\n          var curFormats = line.formats();\n          var nextFormats = this.quill.getFormat(range.index, 1);\n          formats = Delta[\"AttributeMap\"].diff(curFormats, nextFormats) || {};\n\n          if (Object.keys(formats).length > 0) {\n            delta = delta.retain(next.length() - 1).retain(1, formats);\n          }\n        }\n      }\n\n      this.quill.updateContents(delta, core_quill[\"a\" /* default */].sources.USER);\n      this.quill.focus();\n    }\n  }, {\n    key: \"handleDeleteRange\",\n    value: function handleDeleteRange(range, context) {\n      this.raiseOnKeydownCallback(context.event);\n      deleteRange({\n        range: range,\n        quill: this.quill\n      });\n      this.quill.focus();\n    }\n  }, {\n    key: \"handleEnter\",\n    value: function handleEnter(range, context) {\n      var _this5 = this;\n\n      var lineFormats = Object.keys(context.format).reduce(function (formats, format) {\n        if (_this5.quill.scroll.query(format, parchment[\"Scope\"].BLOCK) && !Array.isArray(context.format[format])) {\n          formats[format] = context.format[format];\n        }\n\n        return formats;\n      }, {});\n      var delta = new Delta_default.a().retain(range.index).delete(range.length).insert('\\n', lineFormats);\n      this.quill.updateContents(delta, core_quill[\"a\" /* default */].sources.USER);\n      this.quill.setSelection(range.index + 1, core_quill[\"a\" /* default */].sources.SILENT);\n      this.quill.focus();\n\n      var _this$quill$getLine9 = this.quill.getLine(range.index + 1),\n          _this$quill$getLine10 = _slicedToArray(_this$quill$getLine9, 1),\n          line = _this$quill$getLine10[0];\n\n      var scrollConfig = getScrollIntoViewConfig(line.domNode);\n\n      if (scrollConfig !== null) {\n        line.domNode.scrollIntoView(scrollConfig);\n      }\n\n      Object.keys(context.format).forEach(function (name) {\n        if (lineFormats[name] != null) return;\n        if (Array.isArray(context.format[name])) return;\n        if (name === 'code' || name === 'link') return;\n\n        _this5.raiseOnKeydownCallback(context.event);\n\n        _this5.quill.format(name, context.format[name], core_quill[\"a\" /* default */].sources.USER);\n      });\n    }\n  }], [{\n    key: \"match\",\n    value: function match(evt, binding) {\n      if (['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].some(function (key) {\n        return !!binding[key] !== evt[key] && binding[key] !== null;\n      })) {\n        return false;\n      }\n\n      return binding.key === Keyboard.normalizeKeyName(evt) || binding.key === evt.which;\n    }\n  }, {\n    key: \"normalizeKeyName\",\n    value: function normalizeKeyName(_ref3) {\n      var key = _ref3.key,\n          which = _ref3.which;\n      var isKeySupported = !!key;\n      var normalizedKey = isKeySupported ? key : which;\n\n      if (normalizedKey) {\n        if (isKeySupported) {\n          normalizedKey = KEY_NAMES[normalizedKey.toLowerCase()] || normalizedKey;\n        } else {\n          normalizedKey = KEY_CODES[normalizedKey] || String.fromCharCode(normalizedKey);\n        }\n      }\n\n      return normalizedKey;\n    }\n  }]);\n\n  return Keyboard;\n}(core_module[\"a\" /* default */]);\n\nkeyboard_Keyboard.DEFAULTS = {\n  bindings: {\n    bold: makeFormatHandler('bold', 66),\n    italic: makeFormatHandler('italic', 73),\n    underline: makeFormatHandler('underline', 85),\n    indent: {\n      // highlight tab or tab at beginning of list, indent or blockquote\n      key: 'tab',\n      format: ['blockquote', 'indent', 'list'],\n      handler: function handler(range, context) {\n        if (context.collapsed && context.offset !== 0) return true;\n        this.quill.format('indent', '+1', core_quill[\"a\" /* default */].sources.USER);\n        return false;\n      }\n    },\n    outdent: {\n      key: 'tab',\n      shiftKey: true,\n      format: ['blockquote', 'indent', 'list'],\n      // highlight tab or tab at beginning of list, indent or blockquote\n      handler: function handler(range, context) {\n        if (context.collapsed && context.offset !== 0) return true;\n        this.quill.format('indent', '-1', core_quill[\"a\" /* default */].sources.USER);\n        return false;\n      }\n    },\n    'outdent backspace': {\n      key: 'backspace',\n      collapsed: true,\n      shiftKey: null,\n      metaKey: null,\n      ctrlKey: null,\n      altKey: null,\n      format: ['indent', 'list'],\n      offset: 0,\n      handler: function handler(range, context) {\n        if (context.format.indent != null) {\n          this.quill.format('indent', '-1', core_quill[\"a\" /* default */].sources.USER);\n        } else if (context.format.list != null) {\n          this.quill.format('list', false, core_quill[\"a\" /* default */].sources.USER);\n        }\n      }\n    },\n    'indent code-block': makeCodeBlockHandler(true),\n    'outdent code-block': makeCodeBlockHandler(false),\n    'remove tab': {\n      key: 'tab',\n      shiftKey: true,\n      collapsed: true,\n      prefix: /\\t$/,\n      handler: function handler(range) {\n        this.quill.deleteText(range.index - 1, 1, core_quill[\"a\" /* default */].sources.USER);\n      }\n    },\n    tab: {\n      key: 'tab',\n      handler: function handler(range, context) {\n        if (context.format.table) return true;\n        this.quill.history.cutoff();\n        var delta = new Delta_default.a().retain(range.index).delete(range.length).insert('\\t');\n        this.quill.updateContents(delta, core_quill[\"a\" /* default */].sources.USER);\n        this.quill.history.cutoff();\n        this.quill.setSelection(range.index + 1, core_quill[\"a\" /* default */].sources.SILENT);\n        return false;\n      }\n    },\n    'blockquote empty enter': {\n      key: 'enter',\n      collapsed: true,\n      format: ['blockquote'],\n      empty: true,\n      handler: function handler() {\n        this.quill.format('blockquote', false, core_quill[\"a\" /* default */].sources.USER);\n      }\n    },\n    'list empty enter': {\n      key: 'enter',\n      collapsed: true,\n      format: ['list'],\n      empty: true,\n      handler: function handler(range, context) {\n        var formats = {\n          list: false\n        };\n\n        if (context.format.indent) {\n          formats.indent = false;\n        }\n\n        this.quill.formatLine(range.index, range.length, formats, core_quill[\"a\" /* default */].sources.USER);\n      }\n    },\n    'checklist enter': {\n      key: 'enter',\n      collapsed: true,\n      format: {\n        list: 'checked'\n      },\n      handler: function handler(range) {\n        var _this$quill$getLine11 = this.quill.getLine(range.index),\n            _this$quill$getLine12 = _slicedToArray(_this$quill$getLine11, 2),\n            line = _this$quill$getLine12[0],\n            offset = _this$quill$getLine12[1];\n\n        var formats = _objectSpread(_objectSpread({}, line.formats()), {}, {\n          list: 'checked'\n        });\n\n        var delta = new Delta_default.a().retain(range.index).insert('\\n', formats).retain(line.length() - offset - 1).retain(1, {\n          list: 'unchecked'\n        });\n        this.quill.updateContents(delta, core_quill[\"a\" /* default */].sources.USER);\n        this.quill.setSelection(range.index + 1, core_quill[\"a\" /* default */].sources.SILENT);\n        this.quill.scrollIntoView();\n      }\n    },\n    'header enter': {\n      key: 'enter',\n      collapsed: true,\n      format: ['header'],\n      suffix: /^$/,\n      handler: function handler(range, context) {\n        var _this$quill$getLine13 = this.quill.getLine(range.index),\n            _this$quill$getLine14 = _slicedToArray(_this$quill$getLine13, 2),\n            line = _this$quill$getLine14[0],\n            offset = _this$quill$getLine14[1];\n\n        var delta = new Delta_default.a().retain(range.index).insert('\\n', context.format).retain(line.length() - offset - 1).retain(1, {\n          header: null\n        });\n        this.quill.updateContents(delta, core_quill[\"a\" /* default */].sources.USER);\n        this.quill.setSelection(range.index + 1, core_quill[\"a\" /* default */].sources.SILENT);\n        this.quill.scrollIntoView();\n      }\n    },\n    'list autofill': {\n      key: 'space',\n      shiftKey: null,\n      collapsed: true,\n      format: {\n        'code-block': false,\n        blockquote: false,\n        table: false\n      },\n      prefix: /^\\s*?(\\d+\\.|-|\\*|\\[ ?\\]|\\[x\\])$/,\n      handler: function handler(range, context) {\n        if (this.quill.scroll.query('list') == null) return true;\n        var length = context.prefix.length;\n\n        var _this$quill$getLine15 = this.quill.getLine(range.index),\n            _this$quill$getLine16 = _slicedToArray(_this$quill$getLine15, 2),\n            line = _this$quill$getLine16[0],\n            offset = _this$quill$getLine16[1];\n\n        if (offset > length) return true;\n        var value;\n\n        switch (context.prefix.trim()) {\n          case '[]':\n          case '[ ]':\n            value = 'unchecked';\n            break;\n\n          case '[x]':\n            value = 'checked';\n            break;\n\n          case '-':\n          case '*':\n            value = 'bullet';\n            break;\n\n          default:\n            value = 'ordered';\n        }\n\n        this.quill.insertText(range.index, ' ', core_quill[\"a\" /* default */].sources.USER);\n        this.quill.history.cutoff();\n        var delta = new Delta_default.a().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, {\n          list: value\n        });\n        this.raiseOnKeydownCallback(context.event);\n        this.quill.updateContents(delta, core_quill[\"a\" /* default */].sources.USER);\n        this.quill.history.cutoff();\n        this.quill.setSelection(range.index - length, core_quill[\"a\" /* default */].sources.SILENT);\n        return false;\n      }\n    },\n    'code exit': {\n      key: 'enter',\n      collapsed: true,\n      format: ['code-block'],\n      prefix: /^$/,\n      suffix: /^\\s*$/,\n      handler: function handler(range) {\n        var _this$quill$getLine17 = this.quill.getLine(range.index),\n            _this$quill$getLine18 = _slicedToArray(_this$quill$getLine17, 2),\n            line = _this$quill$getLine18[0],\n            offset = _this$quill$getLine18[1];\n\n        var numLines = 2;\n        var cur = line;\n\n        while (cur != null && cur.length() <= 1 && cur.formats()['code-block']) {\n          cur = cur.prev;\n          numLines -= 1; // Requisite prev lines are empty\n\n          if (numLines <= 0) {\n            var delta = new Delta_default.a().retain(range.index + line.length() - offset - 2).retain(1, {\n              'code-block': null\n            }).delete(1);\n            this.quill.updateContents(delta, core_quill[\"a\" /* default */].sources.USER);\n            this.quill.setSelection(range.index - 1, core_quill[\"a\" /* default */].sources.SILENT);\n            return false;\n          }\n        }\n\n        return true;\n      }\n    },\n    'embed left': makeEmbedArrowHandler('leftArrow', false),\n    'embed left shift': makeEmbedArrowHandler('leftArrow', true),\n    'embed right': makeEmbedArrowHandler('rightArrow', false),\n    'embed right shift': makeEmbedArrowHandler('rightArrow', true)\n  }\n};\n\nfunction makeCodeBlockHandler(indent) {\n  return {\n    key: 'tab',\n    shiftKey: !indent,\n    format: {\n      'code-block': true\n    },\n    handler: function handler(range) {\n      var CodeBlock = this.quill.scroll.query('code-block');\n      var lines = range.length === 0 ? this.quill.getLines(range.index, 1) : this.quill.getLines(range);\n      var index = range.index,\n          length = range.length;\n      lines.forEach(function (line, i) {\n        if (indent) {\n          line.insertAt(0, CodeBlock.TAB);\n\n          if (i === 0) {\n            index += CodeBlock.TAB.length;\n          } else {\n            length += CodeBlock.TAB.length;\n          }\n        } else if (line.domNode.textContent.indexOf(CodeBlock.TAB) === 0) {\n          line.deleteAt(0, CodeBlock.TAB.length);\n\n          if (i === 0) {\n            index -= CodeBlock.TAB.length;\n          } else {\n            length -= CodeBlock.TAB.length;\n          }\n        }\n      });\n      this.quill.update(core_quill[\"a\" /* default */].sources.USER);\n      this.quill.setSelection(index, length, core_quill[\"a\" /* default */].sources.SILENT);\n    }\n  };\n}\n\nfunction makeEmbedArrowHandler(key, shiftKey) {\n  var _ref4;\n\n  var where = key === 'leftArrow' ? 'prefix' : 'suffix';\n  return _ref4 = {\n    key: key,\n    shiftKey: shiftKey,\n    altKey: null\n  }, _defineProperty(_ref4, where, /^$/), _defineProperty(_ref4, \"handler\", function handler(range) {\n    var index = range.index;\n\n    if (key === 'rightArrow') {\n      index += range.length + 1;\n    }\n\n    var _this$quill$getLeaf = this.quill.getLeaf(index),\n        _this$quill$getLeaf2 = _slicedToArray(_this$quill$getLeaf, 1),\n        leaf = _this$quill$getLeaf2[0];\n\n    if (!(leaf instanceof parchment[\"EmbedBlot\"])) return true;\n\n    if (key === 'leftArrow') {\n      if (shiftKey) {\n        this.quill.setSelection(range.index - 1, range.length + 1, core_quill[\"a\" /* default */].sources.USER);\n      } else {\n        this.quill.setSelection(range.index - 1, core_quill[\"a\" /* default */].sources.USER);\n      }\n    } else if (shiftKey) {\n      this.quill.setSelection(range.index, range.length + 1, core_quill[\"a\" /* default */].sources.USER);\n    } else {\n      this.quill.setSelection(range.index + range.length + 1, core_quill[\"a\" /* default */].sources.USER);\n    }\n\n    return false;\n  }), _ref4;\n}\n\nfunction makeFormatHandler(format, which) {\n  return {\n    key: format[0],\n    which: which,\n    shortKey: true,\n    handler: function handler(range, context) {\n      this.quill.format(format, !context.format[format], core_quill[\"a\" /* default */].sources.USER);\n      return {\n        preventAfterAllMatches: true\n      };\n    }\n  };\n}\n\nfunction normalize(binding) {\n  if (typeof binding === 'string' || typeof binding === 'number') {\n    binding = {\n      key: binding\n    };\n  } else if (_typeof(binding) === 'object') {\n    binding = lodash_clonedeep_default()(binding);\n  } else {\n    return null;\n  }\n\n  if (binding.shortKey) {\n    binding[SHORTKEY] = binding.shortKey;\n    delete binding.shortKey;\n  }\n\n  return binding;\n}\n\nfunction deleteRange(_ref5) {\n  var quill = _ref5.quill,\n      range = _ref5.range;\n  var lines = quill.getLines(range);\n  var formats = {};\n\n  if (lines.length > 1) {\n    var firstFormats = lines[0].formats();\n    var lastFormats = lines[lines.length - 1].formats();\n    formats = Delta[\"AttributeMap\"].diff(lastFormats, firstFormats) || {};\n  }\n\n  quill.deleteText(range, core_quill[\"a\" /* default */].sources.USER);\n\n  if (Object.keys(formats).length > 0) {\n    quill.formatLine(range.index, 1, formats, core_quill[\"a\" /* default */].sources.USER);\n  }\n\n  quill.setSelection(range.index, core_quill[\"a\" /* default */].sources.SILENT);\n}\n\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar shared = __webpack_require__(92);\nvar hasOwn = __webpack_require__(33);\nvar uid = __webpack_require__(93);\nvar NATIVE_SYMBOL = __webpack_require__(94);\nvar USE_SYMBOL_AS_UID = __webpack_require__(95);\n\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar symbolFor = Symbol && Symbol['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return Clipboard; });\n/* unused harmony export matchAttributor */\n/* unused harmony export matchBlot */\n/* unused harmony export matchNewline */\n/* unused harmony export matchText */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return traverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return applyFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return deltaEndsWith; });\n/* harmony import */ var quill_delta__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var quill_delta__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(quill_delta__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);\n/* harmony import */ var _blots_block__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);\n/* harmony import */ var _core_quill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);\n/* harmony import */ var _core_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23);\n/* harmony import */ var _core_module__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(14);\n/* harmony import */ var _formats_align__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(35);\n/* harmony import */ var _formats_background__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(42);\n/* harmony import */ var _formats_code__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(19);\n/* harmony import */ var _formats_color__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(31);\n/* harmony import */ var _formats_direction__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(32);\n/* harmony import */ var _formats_font__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(43);\n/* harmony import */ var _formats_size__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(44);\n/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(26);\n/* harmony import */ var _utils_capitalize__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(30);\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar debug = Object(_core_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])('quill:clipboard');\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar CLIPBOARD_CONFIG = [[TEXT_NODE, matchText], [TEXT_NODE, matchNewline], ['br', matchBreak], [ELEMENT_NODE, matchNewline], [ELEMENT_NODE, matchBlot], [ELEMENT_NODE, matchAttributor], [ELEMENT_NODE, matchStyles], ['li', matchIndent], ['ol, ul', matchList], ['pre', matchCodeBlock], ['b', matchAlias.bind(matchAlias, 'bold')], ['i', matchAlias.bind(matchAlias, 'italic')], ['strike', matchAlias.bind(matchAlias, 'strike')], ['style', matchIgnore]];\nvar HTML_TEXT_MATCHERS = [matchText, matchNewline];\nvar ATTRIBUTE_ATTRIBUTORS = [_formats_align__WEBPACK_IMPORTED_MODULE_6__[/* AlignAttribute */ \"a\"], _formats_direction__WEBPACK_IMPORTED_MODULE_10__[/* DirectionAttribute */ \"a\"]].reduce(function (memo, attr) {\n  memo[attr.keyName] = attr;\n  return memo;\n}, {});\nvar STYLE_ATTRIBUTORS = [_formats_align__WEBPACK_IMPORTED_MODULE_6__[/* AlignStyle */ \"c\"], _formats_background__WEBPACK_IMPORTED_MODULE_7__[/* BackgroundStyle */ \"b\"], _formats_color__WEBPACK_IMPORTED_MODULE_9__[/* ColorStyle */ \"c\"], _formats_direction__WEBPACK_IMPORTED_MODULE_10__[/* DirectionStyle */ \"c\"], _formats_font__WEBPACK_IMPORTED_MODULE_11__[/* FontStyle */ \"b\"], _formats_size__WEBPACK_IMPORTED_MODULE_12__[/* SizeStyle */ \"b\"]].reduce(function (memo, attr) {\n  memo[attr.keyName] = attr;\n  return memo;\n}, {});\n\nvar Clipboard = /*#__PURE__*/function (_Module) {\n  _inherits(Clipboard, _Module);\n\n  var _super = _createSuper(Clipboard);\n\n  function Clipboard(quill, options) {\n    var _options$tableBlots;\n\n    var _this;\n\n    _classCallCheck(this, Clipboard);\n\n    _this = _super.call(this, quill, options);\n\n    _this.quill.root.addEventListener('copy', function (e) {\n      return _this.onCaptureCopy(e, false);\n    });\n\n    _this.quill.root.addEventListener('cut', function (e) {\n      return _this.onCaptureCopy(e, true);\n    });\n\n    _this.quill.root.addEventListener('paste', _this.onCapturePaste.bind(_assertThisInitialized(_this)));\n\n    _this.matchers = [];\n    _this.tableBlots = (_options$tableBlots = options.tableBlots) !== null && _options$tableBlots !== void 0 ? _options$tableBlots : [];\n    CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          selector = _ref2[0],\n          matcher = _ref2[1];\n\n      _this.addMatcher(selector, matcher);\n    });\n    return _this;\n  }\n\n  _createClass(Clipboard, [{\n    key: \"addMatcher\",\n    value: function addMatcher(selector, matcher) {\n      this.matchers.push([selector, matcher]);\n    }\n  }, {\n    key: \"addTableBlot\",\n    value: function addTableBlot(blotName) {\n      this.tableBlots.push(blotName);\n    }\n  }, {\n    key: \"convert\",\n    value: function convert(_ref3) {\n      var html = _ref3.html,\n          text = _ref3.text;\n      var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (formats[_formats_code__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"c\"].blotName]) {\n        return new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a().insert(text, _defineProperty({}, _formats_code__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"c\"].blotName, formats[_formats_code__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"c\"].blotName]));\n      }\n\n      return html ? this.applyMatchers(html, formats) : this.applyTextMatchers(text);\n    }\n  }, {\n    key: \"applyTextMatchers\",\n    value: function applyTextMatchers() {\n      var _this2 = this;\n\n      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      if (text.length === 0) {\n        return new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a();\n      }\n\n      var matchers = this.prepareTextMatching();\n      var element = this.quill.root.ownerDocument.createElement('div');\n      element.textContent = text;\n      var node = element.childNodes[0];\n      return matchers.reduce(function (delta, matcher) {\n        return matcher(node, delta, _this2.quill.scroll);\n      }, new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a());\n    }\n  }, {\n    key: \"applyMatchers\",\n    value: function applyMatchers(html) {\n      var _this3 = this;\n\n      var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var doc = new DOMParser().parseFromString(html, 'text/html');\n      var container = doc.body;\n      var nodeMatches = new WeakMap();\n\n      var _this$prepareMatching = this.prepareMatching(container, nodeMatches),\n          _this$prepareMatching2 = _slicedToArray(_this$prepareMatching, 2),\n          elementMatchers = _this$prepareMatching2[0],\n          textMatchers = _this$prepareMatching2[1];\n\n      var delta = traverse(this.quill.scroll, container, elementMatchers, textMatchers, nodeMatches); // Remove trailing newline\n\n      if (deltaEndsWith(delta, '\\n') && (delta.ops[delta.ops.length - 1].attributes == null || Object.values(formats).some(function (blotName) {\n        return _this3.tableBlots.includes(blotName);\n      }))) {\n        return delta.compose(new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a().retain(delta.length() - 1).delete(1));\n      }\n\n      return delta;\n    }\n  }, {\n    key: \"dangerouslyPasteHTML\",\n    value: function dangerouslyPasteHTML(index, html) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _core_quill__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.API;\n\n      if (typeof index === 'string') {\n        var delta = this.convert({\n          html: index,\n          text: ''\n        });\n        this.quill.setContents(delta, html);\n        this.quill.setSelection(0, _core_quill__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.SILENT);\n      } else {\n        var paste = this.convert({\n          html: html,\n          text: ''\n        });\n        this.quill.updateContents(new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a().retain(index).concat(paste), source);\n        this.quill.setSelection(index + paste.length(), _core_quill__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.SILENT);\n      }\n    }\n  }, {\n    key: \"onCaptureCopy\",\n    value: function onCaptureCopy(e) {\n      var isCut = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (e.defaultPrevented) return;\n\n      if (e.clipboardData) {\n        e.preventDefault();\n      } else {\n        return;\n      }\n\n      var _this$quill$selection = this.quill.selection.getRange(),\n          _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1),\n          range = _this$quill$selection2[0];\n\n      if (range == null) return;\n\n      var _this$onCopy = this.onCopy(range, isCut),\n          html = _this$onCopy.html,\n          text = _this$onCopy.text;\n\n      e.clipboardData.setData('text/plain', text);\n      e.clipboardData.setData('text/html', html);\n\n      if (isCut) {\n        this.raiseCallback('onCut', e);\n        Object(_keyboard__WEBPACK_IMPORTED_MODULE_13__[/* deleteRange */ \"c\"])({\n          range: range,\n          quill: this.quill\n        });\n      }\n    }\n  }, {\n    key: \"onCapturePaste\",\n    value: function onCapturePaste(e) {\n      if (e.defaultPrevented || !this.quill.isEnabled()) {\n        return;\n      }\n\n      this.raiseCallback('onPaste', e);\n\n      if (e.clipboardData) {\n        e.preventDefault();\n      } else {\n        return;\n      }\n\n      var range = this.quill.getSelection(true);\n\n      if (range == null) {\n        return;\n      }\n\n      var html = e.clipboardData.getData('text/html');\n      var files = Array.from(e.clipboardData.files || []);\n\n      if (!html && files.length > 0) {\n        this.quill.uploader.upload(range, files);\n        return;\n      }\n\n      if (html && files.length > 0) {\n        var _DOMParser$parseFromS = new DOMParser().parseFromString(html, 'text/html'),\n            body = _DOMParser$parseFromS.body;\n\n        var documentContainsImage = body.childElementCount === 1 && body.firstElementChild.tagName === 'IMG';\n\n        if (documentContainsImage) {\n          this.quill.uploader.upload(range, files);\n          return;\n        }\n      }\n\n      var text = e.clipboardData.getData('text/plain');\n      this.onPaste(range, {\n        html: html,\n        text: text\n      });\n    }\n  }, {\n    key: \"raiseCallback\",\n    value: function raiseCallback(name, event) {\n      var callback = this.options[name];\n\n      if (callback && typeof callback === 'function') {\n        callback(event);\n      }\n    }\n  }, {\n    key: \"onCopy\",\n    value: function onCopy(range) {\n      var text = this.quill.getText(range);\n      var html = this.quill.getSemanticHTML(range);\n      return {\n        html: html,\n        text: text\n      };\n    }\n  }, {\n    key: \"onPaste\",\n    value: function onPaste(range, _ref4) {\n      var text = _ref4.text,\n          html = _ref4.html;\n      var formats = this.quill.getFormat(range.index);\n      var pastedDelta = this.convert({\n        text: text,\n        html: html\n      }, formats);\n      debug.log('onPaste', pastedDelta, {\n        text: text,\n        html: html\n      });\n      var delta = new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a().retain(range.index).delete(range.length).concat(pastedDelta);\n      this.quill.updateContents(delta, _core_quill__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.USER); // range.length contributes to delta.length()\n\n      this.quill.setSelection(delta.length() - range.length, _core_quill__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.SILENT);\n      this.quill.scrollIntoView();\n    }\n  }, {\n    key: \"prepareMatching\",\n    value: function prepareMatching(container, nodeMatches) {\n      var elementMatchers = [];\n      var textMatchers = [];\n      this.matchers.forEach(function (pair) {\n        var _pair = _slicedToArray(pair, 2),\n            selector = _pair[0],\n            matcher = _pair[1];\n\n        switch (selector) {\n          case TEXT_NODE:\n            textMatchers.push(matcher);\n            break;\n\n          case ELEMENT_NODE:\n            elementMatchers.push(matcher);\n            break;\n\n          default:\n            Array.from(container.querySelectorAll(selector)).forEach(function (node) {\n              if (nodeMatches.has(node)) {\n                var matches = nodeMatches.get(node);\n                matches.push(matcher);\n              } else {\n                nodeMatches.set(node, [matcher]);\n              }\n            });\n            break;\n        }\n      });\n      return [elementMatchers, textMatchers];\n    }\n  }, {\n    key: \"prepareTextMatching\",\n    value: function prepareTextMatching() {\n      var textMatchers = [matchPlainText];\n      this.matchers.forEach(function (pair) {\n        var _pair2 = _slicedToArray(pair, 2),\n            selector = _pair2[0],\n            matcher = _pair2[1];\n\n        if (HTML_TEXT_MATCHERS.indexOf(matcher) === -1 && selector === TEXT_NODE) {\n          textMatchers.push(matcher);\n        }\n      });\n      return textMatchers;\n    }\n  }]);\n\n  return Clipboard;\n}(_core_module__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"]);\n\nClipboard.DEFAULTS = {\n  matchers: []\n};\n\nfunction applyFormat(delta, format, value) {\n  if (_typeof(format) === 'object') {\n    return Object.keys(format).reduce(function (newDelta, key) {\n      return applyFormat(newDelta, key, format[key]);\n    }, delta);\n  }\n\n  return delta.reduce(function (newDelta, op) {\n    if (op.attributes && op.attributes[format]) {\n      return newDelta.push(op);\n    }\n\n    var formats = value ? _defineProperty({}, format, value) : {};\n    return newDelta.insert(op.insert, _objectSpread(_objectSpread({}, formats), op.attributes));\n  }, new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a());\n}\n\nfunction deltaEndsWith(delta, text) {\n  var endText = '';\n\n  for (var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i // eslint-disable-line no-plusplus\n  ) {\n    var op = delta.ops[i];\n    if (typeof op.insert !== 'string') break;\n    endText = op.insert + endText;\n  }\n\n  return endText.slice(-1 * text.length) === text;\n}\n\nfunction isLine(node) {\n  if (node.childNodes.length === 0) return false; // Exclude embed blocks\n\n  return ['address', 'article', 'blockquote', 'canvas', 'dd', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'iframe', 'li', 'main', 'nav', 'ol', 'output', 'p', 'pre', 'section', 'table', 'td', 'tr', 'ul', 'video'].indexOf(node.tagName.toLowerCase()) !== -1;\n}\n\nvar preNodes = new WeakMap();\n\nfunction isPre(node) {\n  if (node == null) return false;\n\n  if (!preNodes.has(node)) {\n    if (node.tagName === 'PRE') {\n      preNodes.set(node, true);\n    } else {\n      preNodes.set(node, isPre(node.parentNode));\n    }\n  }\n\n  return preNodes.get(node);\n}\n\nfunction traverse(scroll, node, elementMatchers, textMatchers, nodeMatches) {\n  // Post-order\n  if (node.nodeType === node.TEXT_NODE) {\n    return textMatchers.reduce(function (delta, matcher) {\n      return matcher(node, delta, scroll);\n    }, new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a());\n  }\n\n  if (node.nodeType === node.ELEMENT_NODE) {\n    return Array.from(node.childNodes || []).reduce(function (delta, childNode) {\n      var childrenDelta = traverse(scroll, childNode, elementMatchers, textMatchers, nodeMatches);\n\n      if (childNode.nodeType === node.ELEMENT_NODE) {\n        childrenDelta = elementMatchers.reduce(function (reducedDelta, matcher) {\n          return matcher(childNode, reducedDelta, scroll);\n        }, childrenDelta);\n        childrenDelta = (nodeMatches.get(childNode) || []).reduce(function (reducedDelta, matcher) {\n          return matcher(childNode, reducedDelta, scroll);\n        }, childrenDelta);\n      }\n\n      return delta.concat(childrenDelta);\n    }, new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a());\n  }\n\n  return new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a();\n}\n\nfunction matchAlias(format, node, delta) {\n  return applyFormat(delta, format, true);\n}\n\nfunction matchAttributor(node, delta, scroll) {\n  if (['TD', 'TH', 'TABLE'].indexOf(node.tagName) === -1) {\n    var attributes = parchment__WEBPACK_IMPORTED_MODULE_1__[\"Attributor\"].keys(node);\n    var classes = parchment__WEBPACK_IMPORTED_MODULE_1__[\"ClassAttributor\"].keys(node);\n    var styles = parchment__WEBPACK_IMPORTED_MODULE_1__[\"StyleAttributor\"].keys(node);\n    var formats = {};\n    attributes.concat(classes).concat(styles).forEach(function (name) {\n      var attr = scroll.query(name, parchment__WEBPACK_IMPORTED_MODULE_1__[\"Scope\"].ATTRIBUTE);\n\n      if (attr != null) {\n        formats[attr.attrName] = attr.value(node);\n        if (formats[attr.attrName]) return;\n      }\n\n      attr = ATTRIBUTE_ATTRIBUTORS[name];\n\n      if (attr != null && (attr.attrName === name || attr.keyName === name)) {\n        formats[attr.attrName] = attr.value(node) || undefined;\n      }\n\n      attr = STYLE_ATTRIBUTORS[name];\n\n      if (attr != null && (attr.attrName === name || attr.keyName === name)) {\n        attr = STYLE_ATTRIBUTORS[name];\n        formats[attr.attrName] = attr.value(node) || undefined;\n      }\n    });\n\n    if (Object.keys(formats).length > 0) {\n      return applyFormat(delta, formats);\n    }\n  }\n\n  return delta;\n}\n\nfunction matchBlot(node, delta, scroll) {\n  var match = scroll.query(node);\n  if (match == null) return delta;\n\n  if (match.prototype instanceof parchment__WEBPACK_IMPORTED_MODULE_1__[\"EmbedBlot\"]) {\n    var embed = {};\n    var value = match.value(node);\n\n    if (value != null) {\n      embed[match.blotName] = value;\n      return new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a().insert(embed, match.formats(node, scroll));\n    }\n  } else {\n    if (match.prototype instanceof parchment__WEBPACK_IMPORTED_MODULE_1__[\"BlockBlot\"] && !deltaEndsWith(delta, '\\n')) {\n      delta.insert('\\n');\n    }\n\n    if (typeof match.formats === 'function') {\n      return applyFormat(delta, match.blotName, match.formats(node, scroll));\n    }\n  }\n\n  return delta;\n}\n\nfunction matchBreak(node, delta) {\n  if (!deltaEndsWith(delta, '\\n')) {\n    delta.insert('\\n');\n  }\n\n  return delta;\n}\n\nfunction matchCodeBlock(node, delta, scroll) {\n  var match = scroll.query('code-block');\n  var language = match ? match.formats(node, scroll) : true;\n  return applyFormat(delta, 'code-block', language);\n}\n\nfunction matchIgnore() {\n  return new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a();\n}\n\nfunction matchIndent(node, delta, scroll) {\n  var match = scroll.query(node);\n\n  if (match == null || match.blotName !== 'list' || !deltaEndsWith(delta, '\\n')) {\n    return delta;\n  }\n\n  var indent = -1;\n  var parent = node.parentNode;\n\n  while (parent != null) {\n    if (['OL', 'UL'].indexOf(parent.tagName) !== -1) {\n      indent += 1;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  if (indent <= 0) return delta;\n  return delta.reduce(function (composed, op) {\n    if (op.attributes && typeof op.attributes.indent === 'number') {\n      return composed.push(op);\n    }\n\n    return composed.insert(op.insert, _objectSpread({\n      indent: indent\n    }, op.attributes || {}));\n  }, new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a());\n}\n\nfunction matchList(node, delta) {\n  var list = node.tagName === 'OL' ? 'ordered' : 'bullet';\n  return applyFormat(delta, 'list', list);\n}\n\nfunction matchNewline(node, delta, scroll) {\n  if (!deltaEndsWith(delta, '\\n')) {\n    if (isLine(node)) {\n      return delta.insert('\\n');\n    }\n\n    if (delta.length() > 0 && node.nextSibling) {\n      var nextSibling = node.nextSibling;\n\n      while (nextSibling != null) {\n        if (isLine(nextSibling)) {\n          return delta.insert('\\n');\n        }\n\n        var match = scroll.query(nextSibling);\n\n        if ((match === null || match === void 0 ? void 0 : match.prototype) instanceof _blots_block__WEBPACK_IMPORTED_MODULE_2__[/* BlockEmbed */ \"a\"]) {\n          return delta.insert('\\n');\n        }\n\n        nextSibling = nextSibling.firstChild;\n      }\n    }\n  }\n\n  return delta;\n}\n\nfunction matchStyles(node, delta) {\n  var formats = {};\n  var style = node.style || {};\n  ['height', 'width'].forEach(function (dimension) {\n    var isCell = ['TD', 'TH'].indexOf(node.tagName) !== -1;\n    var isTable = node.tagName === 'TABLE';\n\n    if ((isCell || isTable) && style[dimension]) {\n      var name = \"\".concat(isTable ? 'table' : 'cell').concat(Object(_utils_capitalize__WEBPACK_IMPORTED_MODULE_14__[/* default */ \"a\"])(dimension));\n      formats[name] = style[dimension];\n    }\n  });\n\n  if (style.fontStyle === 'italic') {\n    formats.italic = true;\n  }\n\n  if (style.textDecoration.indexOf('underline') !== -1) {\n    formats.underline = true;\n  }\n\n  if (style.textDecoration.indexOf('line-through') !== -1) {\n    formats.strike = true;\n  }\n\n  if (style.fontWeight.indexOf('bold') === 0 || parseInt(style.fontWeight, 10) >= 700) {\n    formats.bold = true;\n  }\n\n  if (Object.keys(formats).length > 0) {\n    delta = applyFormat(delta, formats);\n  }\n\n  if (parseFloat(style.textIndent || 0) > 0) {\n    // Could be 0.5in\n    return new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a().insert('\\t').concat(delta);\n  }\n\n  return delta;\n}\n\nfunction matchPlainText(node, delta) {\n  var text = node.data || '';\n  text = text.replace(/\\r\\n/g, '\\n');\n  return delta.insert(text);\n}\n\nfunction matchText(node, delta) {\n  var text = node.data; // Word represents empty line with <o:p>&nbsp;</o:p>\n\n  if (node.parentNode.tagName === 'O:P') {\n    return delta.insert(text.trim());\n  }\n\n  if (text.trim().length === 0 && text.indexOf('\\n') !== -1) {\n    return delta;\n  }\n\n  if (!isPre(node)) {\n    var replacer = function replacer(collapse, match) {\n      var replaced = match.replace(/[^\\u00a0]/g, ''); // \\u00a0 is nbsp;\n\n      return replaced.length < 1 && collapse ? ' ' : replaced;\n    };\n\n    text = text.replace(/\\r\\n/g, ' ').replace(/\\n/g, ' ');\n    text = text.replace(/\\s\\s+/g, replacer.bind(replacer, true)); // collapse whitespace\n\n    if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {\n      text = text.replace(/^\\s+/, replacer.bind(replacer, false));\n    }\n\n    if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {\n      text = text.replace(/\\s+$/, replacer.bind(replacer, false));\n    }\n  }\n\n  return delta.insert(text);\n}\n\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(54), __webpack_require__(61)(module)))\n\n/***/ }),\n/* 30 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return capitalize; });\nfunction capitalize(text) {\n  return text ? text.substring(0, 1).toUpperCase() + text.substring(1) : '';\n}\n\n/***/ }),\n/* 31 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ColorAttributor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return ColorClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return ColorStyle; });\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar ColorAttributor = /*#__PURE__*/function (_StyleAttributor) {\n  _inherits(ColorAttributor, _StyleAttributor);\n\n  var _super = _createSuper(ColorAttributor);\n\n  function ColorAttributor() {\n    _classCallCheck(this, ColorAttributor);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ColorAttributor, [{\n    key: \"value\",\n    value: function value(domNode) {\n      var value = _get(_getPrototypeOf(ColorAttributor.prototype), \"value\", this).call(this, domNode);\n\n      if (value.indexOf('rgb(') !== 0) return value;\n      value = value.replace(/^[^\\d]+/, '').replace(/[^\\d]+$/, '');\n      var hex = value.split(',').map(function (component) {\n        return \"00\".concat(parseInt(component, 10).toString(16)).slice(-2);\n      }).join('');\n      return \"#\".concat(hex);\n    }\n  }]);\n\n  return ColorAttributor;\n}(parchment__WEBPACK_IMPORTED_MODULE_0__[\"StyleAttributor\"]);\n\nvar ColorClass = new parchment__WEBPACK_IMPORTED_MODULE_0__[\"ClassAttributor\"]('color', 'ql-color', {\n  scope: parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].INLINE\n});\nvar ColorStyle = new ColorAttributor('color', 'color', {\n  scope: parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].INLINE\n});\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return DirectionAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return DirectionClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return DirectionStyle; });\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n\nvar config = {\n  scope: parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].BLOCK,\n  whitelist: ['rtl']\n};\nvar DirectionAttribute = new parchment__WEBPACK_IMPORTED_MODULE_0__[\"Attributor\"]('direction', 'dir', config);\nvar DirectionClass = new parchment__WEBPACK_IMPORTED_MODULE_0__[\"ClassAttributor\"]('direction', 'ql-direction', config);\nvar DirectionStyle = new parchment__WEBPACK_IMPORTED_MODULE_0__[\"StyleAttributor\"]('direction', 'direction', config);\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar uncurryThis = __webpack_require__(21);\nvar toObject = __webpack_require__(64);\n\nvar hasOwnProperty = uncurryThis({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject(it), key);\n};\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeMax = Math.max,\n    nativeNow = Date.now;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = merge;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(54), __webpack_require__(61)(module)))\n\n/***/ }),\n/* 35 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return AlignAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return AlignClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return AlignStyle; });\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n\nvar config = {\n  scope: parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].BLOCK,\n  whitelist: ['right', 'center', 'justify']\n};\nvar AlignAttribute = new parchment__WEBPACK_IMPORTED_MODULE_0__[\"Attributor\"]('align', 'align', config);\nvar AlignClass = new parchment__WEBPACK_IMPORTED_MODULE_0__[\"ClassAttributor\"]('align', 'ql-align', config);\nvar AlignStyle = new parchment__WEBPACK_IMPORTED_MODULE_0__[\"StyleAttributor\"]('align', 'text-align', config);\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar isObject = __webpack_require__(48);\n\nvar String = global.String;\nvar TypeError = global.TypeError;\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw TypeError(String(argument) + ' is not an object');\n};\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(36);\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\nvar call = Function.prototype.call;\n\nmodule.exports = call.bind ? call.bind(call) : function () {\n  return call.apply(call, arguments);\n};\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Link; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return _sanitize; });\n/* harmony import */ var _blots_inline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar Link = /*#__PURE__*/function (_Inline) {\n  _inherits(Link, _Inline);\n\n  var _super = _createSuper(Link);\n\n  function Link() {\n    _classCallCheck(this, Link);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Link, [{\n    key: \"format\",\n    value: function format(name, value) {\n      if (name !== this.statics.blotName || !value) {\n        _get(_getPrototypeOf(Link.prototype), \"format\", this).call(this, name, value);\n      } else {\n        this.domNode.setAttribute('href', this.constructor.sanitize(value));\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var node = _get(_getPrototypeOf(Link), \"create\", this).call(this, value);\n\n      node.setAttribute('href', this.sanitize(value));\n      node.setAttribute('rel', 'noopener noreferrer');\n      node.setAttribute('target', '_blank');\n      return node;\n    }\n  }, {\n    key: \"formats\",\n    value: function formats(domNode) {\n      return domNode.getAttribute('href');\n    }\n  }, {\n    key: \"sanitize\",\n    value: function sanitize(url) {\n      return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;\n    }\n  }]);\n\n  return Link;\n}(_blots_inline__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"]);\n\nLink.blotName = 'link';\nLink.tagName = 'A';\nLink.SANITIZED_URL = 'about:blank';\nLink.PROTOCOL_WHITELIST = ['http', 'https', 'mailto', 'tel'];\n\nfunction _sanitize(url, protocols) {\n  var anchor = document.createElement('a');\n  anchor.href = url;\n  var protocol = anchor.href.slice(0, anchor.href.indexOf(':'));\n  return protocols.indexOf(protocol) > -1;\n}\n\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = (new WeakMap());\n\n/***/ }),\n/* 42 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return BackgroundClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return BackgroundStyle; });\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);\n\n\nvar BackgroundClass = new parchment__WEBPACK_IMPORTED_MODULE_0__[\"ClassAttributor\"]('background', 'ql-bg', {\n  scope: parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].INLINE\n});\nvar BackgroundStyle = new _color__WEBPACK_IMPORTED_MODULE_1__[/* ColorAttributor */ \"a\"]('background', 'background-color', {\n  scope: parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].INLINE\n});\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return FontStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return FontClass; });\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\nvar config = {\n  scope: parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].INLINE,\n  whitelist: ['serif', 'monospace']\n};\nvar FontClass = new parchment__WEBPACK_IMPORTED_MODULE_0__[\"ClassAttributor\"]('font', 'ql-font', config);\n\nvar FontStyleAttributor = /*#__PURE__*/function (_StyleAttributor) {\n  _inherits(FontStyleAttributor, _StyleAttributor);\n\n  var _super = _createSuper(FontStyleAttributor);\n\n  function FontStyleAttributor() {\n    _classCallCheck(this, FontStyleAttributor);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(FontStyleAttributor, [{\n    key: \"value\",\n    value: function value(node) {\n      return _get(_getPrototypeOf(FontStyleAttributor.prototype), \"value\", this).call(this, node).replace(/[\"']/g, '');\n    }\n  }]);\n\n  return FontStyleAttributor;\n}(parchment__WEBPACK_IMPORTED_MODULE_0__[\"StyleAttributor\"]);\n\nvar FontStyle = new FontStyleAttributor('font', 'font-family', config);\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SizeClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return SizeStyle; });\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n\nvar SizeClass = new parchment__WEBPACK_IMPORTED_MODULE_0__[\"ClassAttributor\"]('size', 'ql-size', {\n  scope: parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].INLINE,\n  whitelist: ['small', 'large', 'huge']\n});\nvar SizeStyle = new parchment__WEBPACK_IMPORTED_MODULE_0__[\"StyleAttributor\"]('size', 'font-size', {\n  scope: parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].INLINE,\n  whitelist: ['10px', '18px', '32px']\n});\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return toggleAttribute; });\nfunction toggleAttribute(domNode, attrName, value) {\n  if (value) {\n    domNode.setAttribute(attrName, value);\n  } else {\n    domNode.removeAttribute(attrName);\n  }\n}\n\n/***/ }),\n/* 46 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _blots_inline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar Bold = /*#__PURE__*/function (_Inline) {\n  _inherits(Bold, _Inline);\n\n  var _super = _createSuper(Bold);\n\n  function Bold() {\n    _classCallCheck(this, Bold);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Bold, [{\n    key: \"optimize\",\n    value: function optimize(context) {\n      _get(_getPrototypeOf(Bold.prototype), \"optimize\", this).call(this, context);\n\n      if (this.domNode.tagName !== this.statics.tagName[0]) {\n        this.replaceWith(this.statics.blotName);\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      return _get(_getPrototypeOf(Bold), \"create\", this).call(this);\n    }\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      return true;\n    }\n  }]);\n\n  return Bold;\n}(_blots_inline__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"]);\n\nBold.blotName = 'bold';\nBold.tagName = ['STRONG', 'B'];\n/* harmony default export */ __webpack_exports__[\"a\"] = (Bold);\n\n/***/ }),\n/* 47 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return History; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return getLastChangeIndex; });\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _core_quill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);\n/* harmony import */ var _core_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);\n/* harmony import */ var _utils_has_window__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\nvar History = /*#__PURE__*/function (_Module) {\n  _inherits(History, _Module);\n\n  var _super = _createSuper(History);\n\n  function History(quill, options) {\n    var _this;\n\n    _classCallCheck(this, History);\n\n    _this = _super.call(this, quill, options);\n    _this.lastRecorded = 0;\n    _this.ignoreChange = false;\n\n    _this.clear();\n\n    _this.quill.on(_core_quill__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].events.EDITOR_CHANGE, function (eventName, delta, oldDelta, source) {\n      if (eventName !== _core_quill__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].events.TEXT_CHANGE || _this.ignoreChange) return;\n\n      if (!_this.options.userOnly || source === _core_quill__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].sources.USER) {\n        _this.record(delta, oldDelta);\n      } else {\n        _this.transform(delta);\n      }\n    });\n\n    _this.quill.keyboard.addBinding({\n      key: 'z',\n      shortKey: true\n    }, _this.undo.bind(_assertThisInitialized(_this)));\n\n    _this.quill.keyboard.addBinding({\n      key: 'z',\n      shortKey: true,\n      shiftKey: true\n    }, _this.redo.bind(_assertThisInitialized(_this)));\n\n    if (Object(_utils_has_window__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])() && /Win/i.test(navigator.platform)) {\n      _this.quill.keyboard.addBinding({\n        key: 'y',\n        shortKey: true\n      }, _this.redo.bind(_assertThisInitialized(_this)));\n    }\n\n    _this.quill.root.addEventListener('beforeinput', function (event) {\n      if (event.inputType === 'historyUndo') {\n        _this.undo();\n\n        event.preventDefault();\n      } else if (event.inputType === 'historyRedo') {\n        _this.redo();\n\n        event.preventDefault();\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(History, [{\n    key: \"change\",\n    value: function change(source, dest) {\n      if (this.stack[source].length === 0) return;\n      var delta = this.stack[source].pop();\n      var base = this.quill.getContents();\n      var inverseDelta = delta.invert(base);\n      this.stack[dest].push(inverseDelta);\n      this.lastRecorded = 0;\n      this.ignoreChange = true;\n      this.quill.updateContents(delta, _core_quill__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].sources.USER);\n      this.ignoreChange = false;\n      var index = getLastChangeIndex(this.quill.scroll, delta);\n      this.quill.setSelection(index);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.stack = {\n        undo: [],\n        redo: []\n      };\n    }\n  }, {\n    key: \"cutoff\",\n    value: function cutoff() {\n      this.lastRecorded = 0;\n    }\n  }, {\n    key: \"record\",\n    value: function record(changeDelta, oldDelta) {\n      if (changeDelta.ops.length === 0) return;\n      this.stack.redo = [];\n      var undoDelta = changeDelta.invert(oldDelta);\n      var timestamp = Date.now();\n\n      if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {\n        var delta = this.stack.undo.pop();\n        undoDelta = undoDelta.compose(delta);\n      } else {\n        this.lastRecorded = timestamp;\n      }\n\n      if (undoDelta.length() === 0) return;\n      this.stack.undo.push(undoDelta);\n\n      if (this.stack.undo.length > this.options.maxStack) {\n        this.stack.undo.shift();\n      }\n    }\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      this.change('redo', 'undo');\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(delta) {\n      transformStack(this.stack.undo, delta);\n      transformStack(this.stack.redo, delta);\n    }\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      this.change('undo', 'redo');\n    }\n  }]);\n\n  return History;\n}(_core_module__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]);\n\nHistory.DEFAULTS = {\n  delay: 1000,\n  maxStack: 100,\n  userOnly: false\n};\n\nfunction transformStack(stack, delta) {\n  var remoteDelta = delta;\n\n  for (var i = stack.length - 1; i >= 0; i -= 1) {\n    var oldDelta = stack[i];\n    stack[i] = remoteDelta.transform(oldDelta, true);\n    remoteDelta = oldDelta.transform(remoteDelta);\n\n    if (stack[i].length() === 0) {\n      stack.splice(i, 1);\n    }\n  }\n}\n\nfunction endsWithNewlineChange(scroll, delta) {\n  var lastOp = delta.ops[delta.ops.length - 1];\n  if (lastOp == null) return false;\n\n  if (lastOp.insert != null) {\n    return typeof lastOp.insert === 'string' && lastOp.insert.endsWith('\\n');\n  }\n\n  if (lastOp.attributes != null) {\n    return Object.keys(lastOp.attributes).some(function (attr) {\n      return scroll.query(attr, parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].BLOCK) != null;\n    });\n  }\n\n  return false;\n}\n\nfunction getLastChangeIndex(scroll, delta) {\n  var deleteLength = delta.reduce(function (length, op) {\n    return length + (op.delete || 0);\n  }, 0);\n  var changeIndex = delta.length() - deleteLength;\n\n  if (endsWithNewlineChange(scroll, delta)) {\n    changeIndex -= 1;\n  }\n\n  return changeIndex;\n}\n\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isCallable = __webpack_require__(22);\n\nmodule.exports = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it);\n};\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar DESCRIPTORS = __webpack_require__(38);\nvar IE8_DOM_DEFINE = __webpack_require__(97);\nvar anObject = __webpack_require__(37);\nvar toPropertyKey = __webpack_require__(80);\n\nvar TypeError = global.TypeError;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return prepareAttributor; });\n/* harmony import */ var _attributors_element_attributor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69);\n/* harmony import */ var _utils_capitalize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);\nvar _excluded = [\"name\"];\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nfunction prepareAttributor(_ref, attrName) {\n  var name = _ref.name,\n      elementConfig = _objectWithoutProperties(_ref, _excluded);\n\n  return new _attributors_element_attributor__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"](\"\".concat(name).concat(Object(_utils_capitalize__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(attrName)), attrName, elementConfig);\n}\n\n/***/ }),\n/* 51 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return makeTableArrowHandler; });\n/* harmony import */ var _core_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n\nfunction makeTableArrowHandler(up, formats) {\n  return {\n    key: up ? 'upArrow' : 'downArrow',\n    collapsed: true,\n    format: formats,\n    handler: function handler(range, context) {\n      var key = up ? 'prev' : 'next';\n      var line = context.line;\n      var cell = line.statics.blotName.indexOf('Line') > -1 ? line.parent : line;\n      var targetTablePart = cell.parent.parent[key];\n      var targetRow = cell.parent[key] || (targetTablePart === null || targetTablePart === void 0 ? void 0 : targetTablePart.children.head);\n\n      if (targetRow != null) {\n        if (targetRow.statics.blotName === 'tableRow' || targetRow.statics.blotName === 'tableHeaderRow') {\n          var targetCell = targetRow.children.head;\n          var cur = cell;\n\n          while (cur.prev != null) {\n            cur = cur.prev;\n            targetCell = targetCell.next;\n          }\n\n          var index = targetCell.offset(this.quill.scroll) + Math.min(context.offset, targetCell.length() - 1);\n          this.quill.setSelection(index, 0, _core_quill__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].sources.USER);\n        }\n      } else {\n        var targetLine = cell.table()[key];\n\n        if (targetLine != null) {\n          if (up) {\n            this.quill.setSelection(targetLine.offset(this.quill.scroll) + targetLine.length() - 1, 0, _core_quill__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].sources.USER);\n          } else {\n            this.quill.setSelection(targetLine.offset(this.quill.scroll), 0, _core_quill__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].sources.USER);\n          }\n        }\n      }\n\n      return false;\n    }\n  };\n}\n\n/***/ }),\n/* 52 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return prepareAttributeMatcher; });\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _attributors_element_attributor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69);\n/* harmony import */ var _attributors_element_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);\n/* harmony import */ var _formats_table_attributors_cell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);\n/* harmony import */ var _formats_table_attributors_table__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);\n/* harmony import */ var _clipboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(28);\n\n\n\n\n\n\nvar ATTRIBUTORS = {\n  table: _formats_table_attributors_table__WEBPACK_IMPORTED_MODULE_4__[/* TABLE_ATTRIBUTORS */ \"a\"],\n  cell: _formats_table_attributors_cell__WEBPACK_IMPORTED_MODULE_3__[/* CELL_ATTRIBUTORS */ \"a\"]\n};\nfunction prepareAttributeMatcher(type) {\n  var attributors = ATTRIBUTORS[type];\n  return function (node, delta, scroll) {\n    var attributes = _attributors_element_attributor__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].keys(node);\n    var styles = _attributors_element_style__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"].keys(node);\n    var formats = {};\n    attributes.concat(styles).forEach(function (name) {\n      var attr = scroll.query(name, parchment__WEBPACK_IMPORTED_MODULE_0__[\"Scope\"].ATTRIBUTE);\n\n      if (attr != null) {\n        formats[attr.attrName] = attr.value(node);\n        if (formats[attr.attrName]) return;\n      }\n\n      attr = attributors[name];\n\n      if (attr != null && (attr.attrName === name || attr.keyName === name)) {\n        attr = attributors[name];\n        formats[attr.attrName] = attr.value(node) || undefined;\n      }\n    });\n\n    if (Object.keys(formats).length > 0) {\n      return Object(_clipboard__WEBPACK_IMPORTED_MODULE_5__[/* applyFormat */ \"a\"])(delta, formats);\n    }\n\n    return delta;\n  };\n}\n\n/***/ }),\n/* 53 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Theme = /*#__PURE__*/function () {\n  function Theme(quill, options) {\n    _classCallCheck(this, Theme);\n\n    this.quill = quill;\n    this.options = options;\n    this.modules = {};\n  }\n\n  _createClass(Theme, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      Object.keys(this.options.modules).forEach(function (name) {\n        if (_this.modules[name] == null) {\n          _this.addModule(name);\n        }\n      });\n    }\n  }, {\n    key: \"addModule\",\n    value: function addModule(name) {\n      var ModuleClass = this.quill.constructor.import(\"modules/\".concat(name));\n      this.modules[name] = new ModuleClass(this.quill, this.options.modules[name] || {});\n      return this.modules[name];\n    }\n  }]);\n\n  return Theme;\n}();\n\nTheme.DEFAULTS = {\n  modules: {}\n};\nTheme.themes = {\n  default: Theme\n};\n/* harmony default export */ __webpack_exports__[\"a\"] = (Theme);\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var quill_delta__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var quill_delta__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(quill_delta__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var _core_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);\n/* harmony import */ var _utils_has_window__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\nvar Uploader = /*#__PURE__*/function (_Module) {\n  _inherits(Uploader, _Module);\n\n  var _super = _createSuper(Uploader);\n\n  function Uploader(quill, options) {\n    var _this;\n\n    _classCallCheck(this, Uploader);\n\n    _this = _super.call(this, quill, options);\n\n    _this.preventImageUploading(false);\n\n    _this.addDragOverHandler();\n\n    _this.addDropHandler();\n\n    return _this;\n  }\n\n  _createClass(Uploader, [{\n    key: \"addDragOverHandler\",\n    value: function addDragOverHandler() {\n      if (Object(_utils_has_window__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])()) {\n        var ua = window.navigator.userAgent.toLowerCase();\n        var isMsIe = ua.indexOf('msie ') !== -1 || ua.indexOf('trident/') !== -1 || ua.indexOf('edge/') !== -1;\n\n        if (isMsIe) {\n          this.quill.root.addEventListener('dragover', function (e) {\n            e.preventDefault();\n          });\n        }\n      }\n    }\n  }, {\n    key: \"addDropHandler\",\n    value: function addDropHandler() {\n      var _this2 = this;\n\n      this.quill.root.addEventListener('drop', function (e) {\n        var noFiles = e.dataTransfer.files.length === 0;\n        var onDrop = _this2.options.onDrop;\n\n        if (onDrop && typeof onDrop === 'function') {\n          onDrop(e);\n        }\n\n        if (noFiles || _this2.preventImageUpload) {\n          return;\n        }\n\n        e.preventDefault();\n        var native;\n\n        if (document.caretRangeFromPoint) {\n          native = document.caretRangeFromPoint(e.clientX, e.clientY);\n        } else if (document.caretPositionFromPoint) {\n          var position = document.caretPositionFromPoint(e.clientX, e.clientY);\n          native = document.createRange();\n          native.setStart(position.offsetNode, position.offset);\n          native.setEnd(position.offsetNode, position.offset);\n        } else {\n          return;\n        }\n\n        var normalized = _this2.quill.selection.normalizeNative(native);\n\n        var range = _this2.quill.selection.normalizedToRange(normalized);\n\n        _this2.upload(range, e.dataTransfer.files);\n      });\n    }\n  }, {\n    key: \"preventImageUploading\",\n    value: function preventImageUploading(value) {\n      if (typeof value !== 'undefined') {\n        this.preventImageUpload = value;\n      }\n\n      return this.preventImageUpload;\n    }\n  }, {\n    key: \"upload\",\n    value: function upload(range, files, force) {\n      var _this3 = this;\n\n      if (this.preventImageUpload && !force) {\n        return;\n      }\n\n      var uploads = [];\n      Array.from(files).forEach(function (file) {\n        if (file && _this3.options.mimetypes.indexOf(file.type) !== -1) {\n          uploads.push(file);\n        }\n      });\n\n      if (uploads.length > 0) {\n        this.options.handler.call(this, range, uploads, this.options.imageBlot);\n      }\n    }\n  }]);\n\n  return Uploader;\n}(_core_module__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]);\n\nUploader.DEFAULTS = {\n  mimetypes: ['image/png', 'image/jpeg', 'image/pjpeg', 'image/gif', 'image/webp', 'image/bmp', 'image/svg+xml', 'image/vnd.microsoft.icon'],\n  imageBlot: 'image',\n  handler: function handler(range, files, blotName) {\n    var _this4 = this;\n\n    var promises = files.map(function (file) {\n      return new Promise(function (resolve) {\n        var reader = new FileReader();\n\n        reader.onload = function (e) {\n          resolve(e.target.result);\n        };\n\n        reader.readAsDataURL(file);\n      });\n    });\n    Promise.all(promises).then(function (images) {\n      var update = images.reduce(function (delta, image) {\n        return delta.insert(_defineProperty({}, blotName, image));\n      }, new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a().retain(range.index).delete(range.length));\n\n      _this4.quill.updateContents(update, _core_emitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].sources.USER);\n\n      _this4.quill.setSelection(range.index + images.length, _core_emitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].sources.SILENT);\n    });\n  }\n};\n/* harmony default export */ __webpack_exports__[\"a\"] = (Uploader);\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar isCallable = __webpack_require__(22);\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar getOwnPropertyDescriptor = __webpack_require__(85).f;\nvar createNonEnumerableProperty = __webpack_require__(66);\nvar redefine = __webpack_require__(86);\nvar setGlobal = __webpack_require__(77);\nvar copyConstructorProperties = __webpack_require__(131);\nvar isForced = __webpack_require__(136);\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n  options.name        - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(130);\nvar requireObjectCoercible = __webpack_require__(65);\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n\n\n/***/ }),\n/* 59 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar GUARD_TEXT = \"\\uFEFF\";\n\nvar Embed = /*#__PURE__*/function (_EmbedBlot) {\n  _inherits(Embed, _EmbedBlot);\n\n  var _super = _createSuper(Embed);\n\n  function Embed(scroll, node) {\n    var _this;\n\n    _classCallCheck(this, Embed);\n\n    _this = _super.call(this, scroll, node);\n    _this.contentNode = document.createElement('span');\n\n    _this.contentNode.setAttribute('contenteditable', false);\n\n    Array.from(_this.domNode.childNodes).forEach(function (childNode) {\n      _this.contentNode.appendChild(childNode);\n    });\n    _this.leftGuard = document.createTextNode(GUARD_TEXT);\n    _this.rightGuard = document.createTextNode(GUARD_TEXT);\n\n    _this.domNode.appendChild(_this.leftGuard);\n\n    _this.domNode.appendChild(_this.contentNode);\n\n    _this.domNode.appendChild(_this.rightGuard);\n\n    return _this;\n  }\n\n  _createClass(Embed, [{\n    key: \"index\",\n    value: function index(node, offset) {\n      if (node === this.leftGuard) return 0;\n      if (node === this.rightGuard) return 1;\n      return _get(_getPrototypeOf(Embed.prototype), \"index\", this).call(this, node, offset);\n    }\n  }, {\n    key: \"restore\",\n    value: function restore(node) {\n      var range;\n      var textNode;\n      var text = node.data.split(GUARD_TEXT).join('');\n\n      if (node === this.leftGuard) {\n        if (this.prev instanceof _text__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]) {\n          var prevLength = this.prev.length();\n          this.prev.insertAt(prevLength, text);\n          range = {\n            startNode: this.prev.domNode,\n            startOffset: prevLength + text.length\n          };\n        } else {\n          textNode = document.createTextNode(text);\n          this.parent.insertBefore(this.scroll.create(textNode), this);\n          range = {\n            startNode: textNode,\n            startOffset: text.length\n          };\n        }\n      } else if (node === this.rightGuard) {\n        if (this.next instanceof _text__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]) {\n          this.next.insertAt(0, text);\n          range = {\n            startNode: this.next.domNode,\n            startOffset: text.length\n          };\n        } else {\n          textNode = document.createTextNode(text);\n          this.parent.insertBefore(this.scroll.create(textNode), this.next);\n          range = {\n            startNode: textNode,\n            startOffset: text.length\n          };\n        }\n      }\n\n      node.data = GUARD_TEXT;\n      return range;\n    }\n  }, {\n    key: \"update\",\n    value: function update(mutations, context) {\n      var _this2 = this;\n\n      mutations.forEach(function (mutation) {\n        if (mutation.type === 'characterData' && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {\n          var range = _this2.restore(mutation.target);\n\n          if (range) context.range = range;\n        }\n      });\n    }\n  }]);\n\n  return Embed;\n}(parchment__WEBPACK_IMPORTED_MODULE_0__[\"EmbedBlot\"]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Embed);\n\n/***/ }),\n/* 60 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return getId; });\nfunction getId() {\n  return Math.random().toString(36).slice(2, 6);\n}\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n/***/ }),\n/* 62 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXTERNAL MODULE: ./node_modules/quill-delta/dist/Delta.js\nvar Delta = __webpack_require__(1);\nvar Delta_default = /*#__PURE__*/__webpack_require__.n(Delta);\n\n// EXTERNAL MODULE: ./node_modules/parchment/src/parchment.ts + 17 modules\nvar parchment = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./core/quill.js\nvar quill = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./core/module.js\nvar core_module = __webpack_require__(14);\n\n// EXTERNAL MODULE: ./blots/block.js\nvar block = __webpack_require__(6);\n\n// EXTERNAL MODULE: ./blots/break.js\nvar blots_break = __webpack_require__(12);\n\n// EXTERNAL MODULE: ./blots/container.js\nvar container = __webpack_require__(15);\n\n// EXTERNAL MODULE: ./utils/is_defined.js\nvar is_defined = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./formats/table/attributors/cell.js\nvar attributors_cell = __webpack_require__(9);\n\n// EXTERNAL MODULE: ./formats/table/attributors/table.js\nvar attributors_table = __webpack_require__(8);\n\n// EXTERNAL MODULE: ./formats/table/get_id.js\nvar get_id = __webpack_require__(60);\n\n// EXTERNAL MODULE: ./formats/table/toggle_attribute.js\nvar toggle_attribute = __webpack_require__(45);\n\n// CONCATENATED MODULE: ./formats/table/index.js\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\nvar CELL_IDENTITY_KEYS = ['row', 'cell'];\nvar TABLE_TAGS = ['TD', 'TH', 'TR', 'TBODY', 'THEAD', 'TABLE'];\nvar DATA_PREFIX = 'data-table-';\n\nvar table_CellLine = /*#__PURE__*/function (_Block) {\n  _inherits(CellLine, _Block);\n\n  var _super = _createSuper(CellLine);\n\n  function CellLine() {\n    _classCallCheck(this, CellLine);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(CellLine, [{\n    key: \"optimize\",\n    value: function optimize() {\n      var _get2;\n\n      var rowId = this.domNode.getAttribute(\"\".concat(DATA_PREFIX, \"row\"));\n\n      if (this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer)) {\n        var domNode = this.domNode;\n        var formats = {\n          row: rowId\n        };\n        Object.keys(attributors_cell[\"b\" /* CELL_FORMATS */]).forEach(function (format) {\n          var value = domNode.dataset[format.toLowerCase()];\n\n          if (value) {\n            formats[format] = value;\n          }\n        });\n        this.wrap(this.statics.requiredContainer.blotName, formats);\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      (_get2 = _get(_getPrototypeOf(CellLine.prototype), \"optimize\", this)).call.apply(_get2, [this].concat(args));\n    }\n  }, {\n    key: \"format\",\n    value: function format(name, value) {\n      var isCell = CELL_IDENTITY_KEYS.indexOf(name) > -1;\n\n      if (isCell || attributors_table[\"b\" /* TABLE_FORMATS */][name] || attributors_cell[\"b\" /* CELL_FORMATS */][name]) {\n        var attrName = \"data-\".concat(isCell ? 'table-' : '').concat(name.toLowerCase());\n        Object(toggle_attribute[\"a\" /* default */])(this.domNode, attrName, value);\n\n        if (attributors_cell[\"b\" /* CELL_FORMATS */][name]) {\n          var _this$cell;\n\n          (_this$cell = this.cell()) === null || _this$cell === void 0 ? void 0 : _this$cell.format(name, value);\n        }\n\n        if (attributors_table[\"b\" /* TABLE_FORMATS */][name]) {\n          var _this$cell2, _this$cell2$table;\n\n          (_this$cell2 = this.cell()) === null || _this$cell2 === void 0 ? void 0 : (_this$cell2$table = _this$cell2.table()) === null || _this$cell2$table === void 0 ? void 0 : _this$cell2$table.format(name, value);\n        }\n      } else {\n        _get(_getPrototypeOf(CellLine.prototype), \"format\", this).call(this, name, value);\n      }\n    }\n  }, {\n    key: \"cell\",\n    value: function cell() {\n      return 'row' in this.parent ? this.parent : null;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var node = _get(_getPrototypeOf(CellLine), \"create\", this).call(this, value);\n\n      CELL_IDENTITY_KEYS.forEach(function (key) {\n        var _value$key;\n\n        var identityMarker = key === 'row' ? tableId : table_cellId;\n        node.setAttribute(\"\".concat(DATA_PREFIX).concat(key), (_value$key = value[key]) !== null && _value$key !== void 0 ? _value$key : identityMarker());\n      });\n      return node;\n    }\n  }, {\n    key: \"formats\",\n    value: function formats(domNode) {\n      return CELL_IDENTITY_KEYS.reduce(function (formats, attribute) {\n        var attrName = \"\".concat(DATA_PREFIX).concat(attribute);\n\n        if (domNode.hasAttribute(attrName)) {\n          formats[attribute] = domNode.getAttribute(attrName) || undefined;\n        }\n\n        return formats;\n      }, {});\n    }\n  }]);\n\n  return CellLine;\n}(block[\"d\" /* default */]);\n\ntable_CellLine.blotName = 'tableCellLine';\ntable_CellLine.className = 'ql-table-cell-line';\ntable_CellLine.tagName = 'P';\n\nvar HeaderCellLine = /*#__PURE__*/function (_CellLine) {\n  _inherits(HeaderCellLine, _CellLine);\n\n  var _super2 = _createSuper(HeaderCellLine);\n\n  function HeaderCellLine() {\n    _classCallCheck(this, HeaderCellLine);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return HeaderCellLine;\n}(table_CellLine);\n\nHeaderCellLine.blotName = 'tableHeaderCellLine';\nHeaderCellLine.className = 'ql-table-header-cell-line';\n\nvar table_BaseCell = /*#__PURE__*/function (_Container) {\n  _inherits(BaseCell, _Container);\n\n  var _super3 = _createSuper(BaseCell);\n\n  function BaseCell() {\n    _classCallCheck(this, BaseCell);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(BaseCell, [{\n    key: \"format\",\n    value: function format(name, value) {\n      var _CELL_FORMATS$name;\n\n      (_CELL_FORMATS$name = attributors_cell[\"b\" /* CELL_FORMATS */][name]) === null || _CELL_FORMATS$name === void 0 ? void 0 : _CELL_FORMATS$name.add(this.domNode, value);\n    }\n  }, {\n    key: \"checkMerge\",\n    value: function checkMerge() {\n      if (_get(_getPrototypeOf(BaseCell.prototype), \"checkMerge\", this).call(this) && this.next.children.head != null) {\n        var thisHead = this.children.head.formats()[this.children.head.statics.blotName];\n        var thisTail = this.children.tail.formats()[this.children.tail.statics.blotName];\n        var nextHead = this.next.children.head.formats()[this.next.children.head.statics.blotName];\n        var nextTail = this.next.children.tail.formats()[this.next.children.tail.statics.blotName];\n        return thisHead.cell === thisTail.cell && thisHead.cell === nextHead.cell && thisHead.cell === nextTail.cell;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      return BaseCell.cellFormats(this.domNode);\n    }\n  }, {\n    key: \"cellOffset\",\n    value: function cellOffset() {\n      if (this.parent) {\n        return this.parent.children.indexOf(this);\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"row\",\n    value: function row() {\n      return 'table' in this.parent ? this.parent : null;\n    }\n  }, {\n    key: \"rowOffset\",\n    value: function rowOffset() {\n      if (this.row()) {\n        return this.row().rowOffset();\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"table\",\n    value: function table() {\n      var _this$row;\n\n      return (_this$row = this.row()) === null || _this$row === void 0 ? void 0 : _this$row.table();\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize() {\n      var _this$domNode$getAttr, _get3;\n\n      var rowId = (_this$domNode$getAttr = this.domNode.getAttribute(\"\".concat(DATA_PREFIX, \"row\"))) !== null && _this$domNode$getAttr !== void 0 ? _this$domNode$getAttr : this.domNode.getAttribute(\"\".concat(DATA_PREFIX, \"header-row\"));\n\n      if (this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer)) {\n        this.wrap(this.statics.requiredContainer.blotName, {\n          row: rowId\n        });\n      }\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      (_get3 = _get(_getPrototypeOf(BaseCell.prototype), \"optimize\", this)).call.apply(_get3, [this].concat(args));\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var node = _get(_getPrototypeOf(BaseCell), \"create\", this).call(this, value);\n\n      if (value) {\n        Object.keys(value).forEach(function (format) {\n          var _CELL_FORMATS$format;\n\n          (_CELL_FORMATS$format = attributors_cell[\"b\" /* CELL_FORMATS */][format]) === null || _CELL_FORMATS$format === void 0 ? void 0 : _CELL_FORMATS$format.add(node, value[format]);\n        });\n      }\n\n      return node;\n    }\n  }, {\n    key: \"cellFormats\",\n    value: function cellFormats(domNode) {\n      var formats = {};\n\n      if (domNode.hasAttribute(\"\".concat(DATA_PREFIX, \"row\")) || domNode.hasAttribute(\"\".concat(DATA_PREFIX, \"header-row\"))) {\n        var _domNode$getAttribute;\n\n        formats.row = (_domNode$getAttribute = domNode.getAttribute(\"\".concat(DATA_PREFIX, \"row\"))) !== null && _domNode$getAttribute !== void 0 ? _domNode$getAttribute : domNode.getAttribute(\"\".concat(DATA_PREFIX, \"header-row\"));\n      }\n\n      Object.keys(attributors_cell[\"b\" /* CELL_FORMATS */]).forEach(function (format) {\n        var _domNode$firstElement;\n\n        var value = (_domNode$firstElement = domNode.firstElementChild) === null || _domNode$firstElement === void 0 ? void 0 : _domNode$firstElement.dataset[format.toLowerCase()];\n\n        if (value) {\n          formats[format] = value;\n        }\n      });\n      return formats;\n    }\n  }]);\n\n  return BaseCell;\n}(container[\"a\" /* default */]);\n\ntable_BaseCell.tagName = ['TD', 'TH'];\n\nvar TableCell = /*#__PURE__*/function (_BaseCell) {\n  _inherits(TableCell, _BaseCell);\n\n  var _super4 = _createSuper(TableCell);\n\n  function TableCell() {\n    _classCallCheck(this, TableCell);\n\n    return _super4.apply(this, arguments);\n  }\n\n  _createClass(TableCell, [{\n    key: \"format\",\n    value: function format(name, value) {\n      if (name === 'row') {\n        this.domNode.setAttribute(\"\".concat(DATA_PREFIX).concat(name), value);\n        this.children.forEach(function (child) {\n          child.format(name, value);\n        });\n      } else {\n        _get(_getPrototypeOf(TableCell.prototype), \"format\", this).call(this, name, value);\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var node = _get(_getPrototypeOf(TableCell), \"create\", this).call(this, value);\n\n      var attrName = \"\".concat(DATA_PREFIX, \"row\");\n\n      if (value !== null && value !== void 0 && value.row) {\n        node.setAttribute(attrName, value.row);\n      }\n\n      return node;\n    }\n  }]);\n\n  return TableCell;\n}(table_BaseCell);\n\nTableCell.blotName = 'tableCell';\nTableCell.className = 'ql-table-data-cell';\nTableCell.dataAttribute = \"\".concat(DATA_PREFIX, \"row\");\n\nvar TableHeaderCell = /*#__PURE__*/function (_BaseCell2) {\n  _inherits(TableHeaderCell, _BaseCell2);\n\n  var _super5 = _createSuper(TableHeaderCell);\n\n  function TableHeaderCell() {\n    _classCallCheck(this, TableHeaderCell);\n\n    return _super5.apply(this, arguments);\n  }\n\n  _createClass(TableHeaderCell, [{\n    key: \"format\",\n    value: function format(name, value) {\n      if (name === 'row') {\n        this.domNode.setAttribute(\"\".concat(DATA_PREFIX).concat(name), value);\n        this.children.forEach(function (child) {\n          child.format(name, value);\n        });\n      } else {\n        _get(_getPrototypeOf(TableHeaderCell.prototype), \"format\", this).call(this, name, value);\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var node = _get(_getPrototypeOf(TableHeaderCell), \"create\", this).call(this, value);\n\n      var attrName = \"\".concat(DATA_PREFIX, \"header-row\");\n\n      if (value && value.row) {\n        node.setAttribute(attrName, value.row);\n      }\n\n      return node;\n    }\n  }]);\n\n  return TableHeaderCell;\n}(table_BaseCell);\n\nTableHeaderCell.tagName = ['TH', 'TD'];\nTableHeaderCell.className = 'ql-table-header-cell';\nTableHeaderCell.blotName = 'tableHeaderCell';\nTableHeaderCell.dataAttribute = \"\".concat(DATA_PREFIX, \"header-row\");\n\nvar table_BaseRow = /*#__PURE__*/function (_Container2) {\n  _inherits(BaseRow, _Container2);\n\n  var _super6 = _createSuper(BaseRow);\n\n  function BaseRow() {\n    _classCallCheck(this, BaseRow);\n\n    return _super6.apply(this, arguments);\n  }\n\n  _createClass(BaseRow, [{\n    key: \"checkMerge\",\n    value: function checkMerge() {\n      if (_get(_getPrototypeOf(BaseRow.prototype), \"checkMerge\", this).call(this) && Object(is_defined[\"a\" /* default */])(this.next.children.head)) {\n        var formatName = 'row';\n        var thisHead = this.children.head.formats();\n        var thisTail = this.children.tail.formats();\n        var nextHead = this.next.children.head.formats();\n        var nextTail = this.next.children.tail.formats();\n        return thisHead[formatName] === thisTail[formatName] && thisHead[formatName] === nextHead[formatName] && thisHead[formatName] === nextTail[formatName];\n      }\n\n      return false;\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize() {\n      var _get4,\n          _this = this;\n\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      (_get4 = _get(_getPrototypeOf(BaseRow.prototype), \"optimize\", this)).call.apply(_get4, [this].concat(args));\n\n      var formatName = this.childFormatName;\n      this.children.forEach(function (child) {\n        if (!Object(is_defined[\"a\" /* default */])(child.next)) {\n          return;\n        }\n\n        var childFormats = child.formats();\n        var nextFormats = child.next.formats();\n\n        if (childFormats[formatName] !== nextFormats[formatName]) {\n          var next = _this.splitAfter(child);\n\n          if (next) {\n            next.optimize();\n          }\n\n          if (_this.prev) {\n            _this.prev.optimize();\n          }\n        }\n      });\n    }\n  }, {\n    key: \"rowOffset\",\n    value: function rowOffset() {\n      if (this.parent) {\n        return this.parent.children.indexOf(this);\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"table\",\n    value: function table() {\n      var _this$parent;\n\n      return (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.parent;\n    }\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      var formats = {};\n      var attrName = \"\".concat(DATA_PREFIX, \"row\");\n\n      if (this.domNode.hasAttribute(attrName)) {\n        formats[attrName] = this.domNode.getAttribute(attrName);\n      }\n\n      return formats;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var node = _get(_getPrototypeOf(BaseRow), \"create\", this).call(this, value);\n\n      if (value !== null && value !== void 0 && value.row) {\n        node.setAttribute(\"\".concat(DATA_PREFIX, \"row\"), value.row);\n      }\n\n      return node;\n    }\n  }]);\n\n  return BaseRow;\n}(container[\"a\" /* default */]);\n\ntable_BaseRow.tagName = 'TR';\n\nvar TableRow = /*#__PURE__*/function (_BaseRow) {\n  _inherits(TableRow, _BaseRow);\n\n  var _super7 = _createSuper(TableRow);\n\n  function TableRow(scroll, domNode) {\n    var _this2;\n\n    _classCallCheck(this, TableRow);\n\n    _this2 = _super7.call(this, scroll, domNode);\n    _this2.childFormatName = 'table';\n    return _this2;\n  }\n\n  return TableRow;\n}(table_BaseRow);\n\nTableRow.blotName = 'tableRow';\n\nvar TableHeaderRow = /*#__PURE__*/function (_BaseRow2) {\n  _inherits(TableHeaderRow, _BaseRow2);\n\n  var _super8 = _createSuper(TableHeaderRow);\n\n  function TableHeaderRow(scroll, domNode) {\n    var _this3;\n\n    _classCallCheck(this, TableHeaderRow);\n\n    _this3 = _super8.call(this, scroll, domNode);\n    _this3.childFormatName = 'tableHeaderCell';\n    return _this3;\n  }\n\n  return TableHeaderRow;\n}(table_BaseRow);\n\nTableHeaderRow.blotName = 'tableHeaderRow';\n\nvar table_RowContainer = /*#__PURE__*/function (_Container3) {\n  _inherits(RowContainer, _Container3);\n\n  var _super9 = _createSuper(RowContainer);\n\n  function RowContainer() {\n    _classCallCheck(this, RowContainer);\n\n    return _super9.apply(this, arguments);\n  }\n\n  _createClass(RowContainer, [{\n    key: \"optimize\",\n    value: function optimize() {\n      var _get5;\n\n      if (this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer)) {\n        var domNode = this.children.head.children.head.children.head.domNode;\n        var formats = {};\n        Object.keys(attributors_table[\"b\" /* TABLE_FORMATS */]).forEach(function (format) {\n          var value = domNode.dataset[format.toLowerCase()];\n\n          if (value) {\n            formats[format] = value;\n          }\n        });\n        this.wrap(this.statics.requiredContainer.blotName, formats);\n      }\n\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      (_get5 = _get(_getPrototypeOf(RowContainer.prototype), \"optimize\", this)).call.apply(_get5, [this].concat(args));\n    }\n  }]);\n\n  return RowContainer;\n}(container[\"a\" /* default */]);\n\nvar TableBody = /*#__PURE__*/function (_RowContainer) {\n  _inherits(TableBody, _RowContainer);\n\n  var _super10 = _createSuper(TableBody);\n\n  function TableBody() {\n    _classCallCheck(this, TableBody);\n\n    return _super10.apply(this, arguments);\n  }\n\n  return TableBody;\n}(table_RowContainer);\n\nTableBody.blotName = 'tableBody';\nTableBody.tagName = 'TBODY';\n\nvar TableHeader = /*#__PURE__*/function (_RowContainer2) {\n  _inherits(TableHeader, _RowContainer2);\n\n  var _super11 = _createSuper(TableHeader);\n\n  function TableHeader() {\n    _classCallCheck(this, TableHeader);\n\n    return _super11.apply(this, arguments);\n  }\n\n  return TableHeader;\n}(table_RowContainer);\n\nTableHeader.blotName = 'tableHeader';\nTableHeader.tagName = 'THEAD';\n\nvar table_TableContainer = /*#__PURE__*/function (_Container4) {\n  _inherits(TableContainer, _Container4);\n\n  var _super12 = _createSuper(TableContainer);\n\n  function TableContainer() {\n    _classCallCheck(this, TableContainer);\n\n    return _super12.apply(this, arguments);\n  }\n\n  _createClass(TableContainer, [{\n    key: \"balanceCells\",\n    value: function balanceCells() {\n      var headerRows = this.descendants(TableHeaderRow);\n      var bodyRows = this.descendants(TableRow);\n      var maxColCount = this.getMaxTableColCount(headerRows, bodyRows);\n      this.balanceRows(maxColCount, headerRows, TableHeaderCell);\n      this.balanceRows(maxColCount, bodyRows, TableCell);\n    }\n  }, {\n    key: \"getMaxTableColCount\",\n    value: function getMaxTableColCount(headerRows, bodyRows) {\n      return Math.max(this.getMaxRowColCount(headerRows), this.getMaxRowColCount(bodyRows));\n    }\n  }, {\n    key: \"getMaxRowColCount\",\n    value: function getMaxRowColCount(rows) {\n      return Math.max.apply(Math, _toConsumableArray(rows.map(function (row) {\n        return row.children.length;\n      })));\n    }\n  }, {\n    key: \"balanceRows\",\n    value: function balanceRows(maxColCount, rows, CellClass) {\n      var _this4 = this;\n\n      rows.forEach(function (row) {\n        new Array(maxColCount - row.children.length).fill(0).forEach(function () {\n          var value;\n\n          if (Object(is_defined[\"a\" /* default */])(row.children.head)) {\n            value = CellClass.cellFormats(row.children.head.domNode);\n          }\n\n          var blot = _this4.scroll.create(CellClass.blotName, value);\n\n          var cellLine = _this4.scroll.create(CellClass.allowedChildren[0].blotName, value);\n\n          blot.appendChild(cellLine);\n          row.appendChild(blot);\n          blot.optimize(); // Add break blot\n        });\n      });\n    }\n  }, {\n    key: \"cells\",\n    value: function cells(column) {\n      return this.rows().map(function (row) {\n        return row.children.at(column);\n      });\n    }\n  }, {\n    key: \"deleteColumn\",\n    value: function deleteColumn(index) {\n      var _this5 = this;\n\n      [TableHeader, TableBody].forEach(function (blot) {\n        var _this5$descendants = _this5.descendants(blot),\n            _this5$descendants2 = _slicedToArray(_this5$descendants, 1),\n            tablePart = _this5$descendants2[0];\n\n        if (!Object(is_defined[\"a\" /* default */])(tablePart) || !Object(is_defined[\"a\" /* default */])(tablePart.children.head)) {\n          return;\n        }\n\n        tablePart.children.forEach(function (row) {\n          var cell = row.children.at(index);\n\n          if (Object(is_defined[\"a\" /* default */])(cell)) {\n            cell.remove();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"insertColumn\",\n    value: function insertColumn(index) {\n      var _this6 = this;\n\n      [TableHeader, TableBody].forEach(function (blot) {\n        var _this6$descendants = _this6.descendants(blot),\n            _this6$descendants2 = _slicedToArray(_this6$descendants, 1),\n            tablePart = _this6$descendants2[0];\n\n        if (!Object(is_defined[\"a\" /* default */])(tablePart) || !Object(is_defined[\"a\" /* default */])(tablePart.children.head)) {\n          return;\n        }\n\n        var CellBlot = blot === TableHeader ? TableHeaderCell : TableCell;\n        var CellLineBlot = blot === TableHeader ? HeaderCellLine : table_CellLine;\n        tablePart.children.forEach(function (row) {\n          var ref = row.children.at(index);\n          var value = CellLineBlot.formats(row.children.head.children.head.domNode);\n\n          var cell = _this6.scroll.create(CellBlot.blotName, {\n            row: value.row\n          });\n\n          var cellLine = _this6.scroll.create(CellLineBlot.blotName, {\n            row: value.row\n          });\n\n          var emptyLine = _this6.scroll.create(blots_break[\"a\" /* default */].blotName);\n\n          cellLine.appendChild(emptyLine);\n          cell.appendChild(cellLine);\n          row.insertBefore(cell, ref);\n        });\n      });\n    }\n  }, {\n    key: \"insertRow\",\n    value: function insertRow(index) {\n      var _this7 = this;\n\n      var _this$descendants = this.descendants(TableBody),\n          _this$descendants2 = _slicedToArray(_this$descendants, 1),\n          body = _this$descendants2[0];\n\n      if (!Object(is_defined[\"a\" /* default */])(body) || !Object(is_defined[\"a\" /* default */])(body.children.head)) {\n        return;\n      }\n\n      var id = tableId();\n      var row = this.scroll.create(TableRow.blotName, {\n        row: id\n      });\n      body.children.head.children.forEach(function () {\n        var cell = _this7.scroll.create(TableCell.blotName, {\n          row: id\n        });\n\n        var cellLine = _this7.scroll.create(table_CellLine.blotName, {\n          row: id\n        });\n\n        var emptyLine = _this7.scroll.create(blots_break[\"a\" /* default */].blotName);\n\n        cellLine.appendChild(emptyLine);\n        cell.appendChild(cellLine);\n        row.appendChild(cell);\n      });\n      var ref = body.children.at(index);\n      body.insertBefore(row, ref);\n    }\n  }, {\n    key: \"insertHeaderRow\",\n    value: function insertHeaderRow() {\n      var _this8 = this;\n\n      var _this$descendants3 = this.descendants(TableHeader),\n          _this$descendants4 = _slicedToArray(_this$descendants3, 1),\n          header = _this$descendants4[0];\n\n      var _this$descendants5 = this.descendants(TableBody),\n          _this$descendants6 = _slicedToArray(_this$descendants5, 1),\n          body = _this$descendants6[0];\n\n      if (Object(is_defined[\"a\" /* default */])(header) || !Object(is_defined[\"a\" /* default */])(body) || !Object(is_defined[\"a\" /* default */])(body.children.head)) {\n        return;\n      }\n\n      var id = tableId();\n      var newHeader = this.scroll.create(TableHeader.blotName);\n      var row = this.scroll.create(TableHeaderRow.blotName);\n      var ref = this.children.at(0);\n      newHeader.appendChild(row);\n      body.children.head.children.forEach(function () {\n        var cell = _this8.scroll.create(TableHeaderCell.blotName, {\n          row: id\n        });\n\n        var cellLine = _this8.scroll.create(HeaderCellLine.blotName, {\n          row: id\n        });\n\n        var emptyLine = _this8.scroll.create(blots_break[\"a\" /* default */].blotName);\n\n        cellLine.appendChild(emptyLine);\n        cell.appendChild(cellLine);\n        row.appendChild(cell);\n        cell.optimize();\n      });\n      this.insertBefore(newHeader, ref);\n    }\n  }, {\n    key: \"rows\",\n    value: function rows() {\n      var body = this.children.head;\n      return Object(is_defined[\"a\" /* default */])(body) ? body.children.map(function (row) {\n        return row;\n      }) : [];\n    }\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      var formats = {};\n      var childElem = this.cells()[0].domNode.firstElementChild;\n      Object.keys(attributors_table[\"b\" /* TABLE_FORMATS */]).forEach(function (format) {\n        var value = childElem.dataset[format.toLowerCase()];\n\n        if (value) {\n          formats[format] = value;\n        }\n      });\n      return formats;\n    }\n  }, {\n    key: \"format\",\n    value: function format(name, value) {\n      var tableFormat = attributors_table[\"b\" /* TABLE_FORMATS */][name];\n\n      if (tableFormat) {\n        var attrName = \"data-\".concat(name.toLowerCase());\n        this.cells().forEach(function (cell) {\n          Object(toggle_attribute[\"a\" /* default */])(cell.children.head.domNode, attrName, value);\n        });\n        tableFormat.add(this.domNode, value);\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var node = _get(_getPrototypeOf(TableContainer), \"create\", this).call(this, value);\n\n      if (value) {\n        Object.keys(value).forEach(function (format) {\n          var _TABLE_FORMATS$format;\n\n          (_TABLE_FORMATS$format = attributors_table[\"b\" /* TABLE_FORMATS */][format]) === null || _TABLE_FORMATS$format === void 0 ? void 0 : _TABLE_FORMATS$format.add(node, value[format]);\n        });\n      }\n\n      return node;\n    }\n  }]);\n\n  return TableContainer;\n}(container[\"a\" /* default */]);\n\ntable_TableContainer.blotName = 'tableContainer';\ntable_TableContainer.tagName = 'TABLE';\ntable_TableContainer.allowedChildren = [TableHeader, TableBody];\nTableBody.requiredContainer = table_TableContainer;\nTableHeader.requiredContainer = table_TableContainer;\nTableBody.allowedChildren = [TableRow];\nTableRow.requiredContainer = TableBody;\nTableRow.allowedChildren = [TableCell];\nTableCell.requiredContainer = TableRow;\ntable_CellLine.requiredContainer = TableCell;\nTableCell.allowedChildren = [table_CellLine];\nTableHeader.allowedChildren = [TableHeaderRow];\nTableHeaderRow.requiredContainer = TableHeader;\nHeaderCellLine.requiredContainer = TableHeaderCell;\nTableHeaderCell.allowedChildren = [HeaderCellLine];\nTableHeaderRow.allowedChildren = [TableHeaderCell];\nTableHeaderCell.requiredContainer = TableHeaderRow;\n\nfunction tableId() {\n  return \"row-\".concat(Object(get_id[\"a\" /* default */])());\n}\n\nfunction table_cellId() {\n  return \"cell-\".concat(Object(get_id[\"a\" /* default */])());\n}\n\n\n// EXTERNAL MODULE: ./modules/clipboard.js\nvar clipboard = __webpack_require__(28);\n\n// EXTERNAL MODULE: ./modules/table/utils/make_table_arrow_handler.js\nvar make_table_arrow_handler = __webpack_require__(51);\n\n// EXTERNAL MODULE: ./modules/table/utils/prepare_attr_matcher.js\nvar prepare_attr_matcher = __webpack_require__(52);\n\n// CONCATENATED MODULE: ./modules/table/index.js\nfunction table_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { table_typeof = function _typeof(obj) { return typeof obj; }; } else { table_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return table_typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction table_slicedToArray(arr, i) { return table_arrayWithHoles(arr) || table_iterableToArrayLimit(arr, i) || table_unsupportedIterableToArray(arr, i) || table_nonIterableRest(); }\n\nfunction table_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction table_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return table_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return table_arrayLikeToArray(o, minLen); }\n\nfunction table_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction table_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction table_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction table_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction table_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction table_createClass(Constructor, protoProps, staticProps) { if (protoProps) table_defineProperties(Constructor.prototype, protoProps); if (staticProps) table_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction table_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) table_setPrototypeOf(subClass, superClass); }\n\nfunction table_setPrototypeOf(o, p) { table_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return table_setPrototypeOf(o, p); }\n\nfunction table_createSuper(Derived) { var hasNativeReflectConstruct = table_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = table_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = table_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return table_possibleConstructorReturn(this, result); }; }\n\nfunction table_possibleConstructorReturn(self, call) { if (call && (table_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return table_assertThisInitialized(self); }\n\nfunction table_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction table_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction table_getPrototypeOf(o) { table_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return table_getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\n\n\n\nvar EMPTY_RESULT = [null, null, null, -1];\n\nvar table_Table = /*#__PURE__*/function (_Module) {\n  table_inherits(Table, _Module);\n\n  var _super = table_createSuper(Table);\n\n  function Table() {\n    var _this;\n\n    table_classCallCheck(this, Table);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.tableBlots = [table_CellLine.blotName, HeaderCellLine.blotName];\n\n    _this.tableBlots.forEach(function (blotName) {\n      _this.quill.editor.addImmediateFormat(blotName);\n    });\n\n    _this.integrateClipboard();\n\n    _this.addKeyboardHandlers();\n\n    _this.listenBalanceCells();\n\n    return _this;\n  }\n\n  table_createClass(Table, [{\n    key: \"integrateClipboard\",\n    value: function integrateClipboard() {\n      var _this2 = this;\n\n      this.tableBlots.forEach(function (blotName) {\n        _this2.quill.clipboard.addTableBlot(blotName);\n      });\n      this.quill.clipboard.addMatcher('td, th', matchCell);\n      this.quill.clipboard.addMatcher('table', Object(prepare_attr_matcher[\"a\" /* default */])('table'));\n      this.quill.clipboard.addMatcher('td, th', Object(prepare_attr_matcher[\"a\" /* default */])('cell'));\n    }\n  }, {\n    key: \"addKeyboardHandlers\",\n    value: function addKeyboardHandlers() {\n      var _this3 = this;\n\n      var bindings = Table.keyboardBindings;\n      Object.keys(bindings).forEach(function (name) {\n        if (bindings[name]) {\n          _this3.quill.keyboard.addBinding(bindings[name]);\n        }\n      });\n    }\n  }, {\n    key: \"balanceTables\",\n    value: function balanceTables() {\n      this.quill.scroll.descendants(table_TableContainer).forEach(function (table) {\n        table.balanceCells();\n      });\n    }\n  }, {\n    key: \"deleteColumn\",\n    value: function deleteColumn() {\n      var _this$getTable = this.getTable(),\n          _this$getTable2 = table_slicedToArray(_this$getTable, 3),\n          table = _this$getTable2[0],\n          cell = _this$getTable2[2];\n\n      if (!Object(is_defined[\"a\" /* default */])(cell)) {\n        return;\n      }\n\n      table.deleteColumn(cell.cellOffset());\n      this.quill.update(quill[\"a\" /* default */].sources.USER);\n    }\n  }, {\n    key: \"deleteRow\",\n    value: function deleteRow() {\n      var _this$getTable3 = this.getTable(),\n          _this$getTable4 = table_slicedToArray(_this$getTable3, 2),\n          row = _this$getTable4[1];\n\n      if (!Object(is_defined[\"a\" /* default */])(row)) {\n        return;\n      }\n\n      row.remove();\n      this.quill.update(quill[\"a\" /* default */].sources.USER);\n    }\n  }, {\n    key: \"deleteTable\",\n    value: function deleteTable() {\n      var _this$getTable5 = this.getTable(),\n          _this$getTable6 = table_slicedToArray(_this$getTable5, 1),\n          table = _this$getTable6[0];\n\n      if (!Object(is_defined[\"a\" /* default */])(table)) {\n        return;\n      }\n\n      var offset = table.offset();\n      table.remove();\n      this.quill.update(quill[\"a\" /* default */].sources.USER);\n      this.quill.setSelection(offset, quill[\"a\" /* default */].sources.SILENT);\n    }\n  }, {\n    key: \"getTable\",\n    value: function getTable() {\n      var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.quill.getSelection();\n\n      if (!Object(is_defined[\"a\" /* default */])(range)) {\n        return EMPTY_RESULT;\n      }\n\n      var _this$quill$getLine = this.quill.getLine(range.index),\n          _this$quill$getLine2 = table_slicedToArray(_this$quill$getLine, 2),\n          cellLine = _this$quill$getLine2[0],\n          offset = _this$quill$getLine2[1];\n\n      if (!Object(is_defined[\"a\" /* default */])(cellLine) || this.tableBlots.indexOf(cellLine.statics.blotName) === -1) {\n        return EMPTY_RESULT;\n      }\n\n      var cell = cellLine.parent;\n      var row = cell.parent;\n      var table = row.parent.parent;\n      return [table, row, cell, offset];\n    }\n  }, {\n    key: \"insertColumn\",\n    value: function insertColumn(offset) {\n      var range = this.quill.getSelection();\n\n      var _this$getTable7 = this.getTable(range),\n          _this$getTable8 = table_slicedToArray(_this$getTable7, 3),\n          table = _this$getTable8[0],\n          row = _this$getTable8[1],\n          cell = _this$getTable8[2];\n\n      if (!Object(is_defined[\"a\" /* default */])(cell)) {\n        return;\n      }\n\n      var column = cell.cellOffset();\n      table.insertColumn(column + offset);\n      this.quill.update(quill[\"a\" /* default */].sources.USER);\n      var shift = row.rowOffset();\n\n      if (offset === 0) {\n        shift += 1;\n      }\n\n      this.quill.setSelection(range.index + shift, range.length, quill[\"a\" /* default */].sources.SILENT);\n    }\n  }, {\n    key: \"insertColumnLeft\",\n    value: function insertColumnLeft() {\n      this.insertColumn(0);\n    }\n  }, {\n    key: \"insertColumnRight\",\n    value: function insertColumnRight() {\n      this.insertColumn(1);\n    }\n  }, {\n    key: \"insertRow\",\n    value: function insertRow(offset) {\n      var range = this.quill.getSelection();\n\n      var _this$getTable9 = this.getTable(range),\n          _this$getTable10 = table_slicedToArray(_this$getTable9, 3),\n          table = _this$getTable10[0],\n          row = _this$getTable10[1],\n          cell = _this$getTable10[2];\n\n      if (!Object(is_defined[\"a\" /* default */])(cell)) {\n        return;\n      }\n\n      var index = row.rowOffset();\n      table.insertRow(index + offset);\n      this.quill.update(quill[\"a\" /* default */].sources.USER);\n\n      if (offset > 0) {\n        this.quill.setSelection(range, quill[\"a\" /* default */].sources.SILENT);\n      } else {\n        this.quill.setSelection(range.index + row.children.length, range.length, quill[\"a\" /* default */].sources.SILENT);\n      }\n    }\n  }, {\n    key: \"insertRowAbove\",\n    value: function insertRowAbove() {\n      this.insertRow(0);\n    }\n  }, {\n    key: \"insertRowBelow\",\n    value: function insertRowBelow() {\n      this.insertRow(1);\n    }\n  }, {\n    key: \"insertHeaderRow\",\n    value: function insertHeaderRow() {\n      var range = this.quill.getSelection();\n\n      var _this$getTable11 = this.getTable(range),\n          _this$getTable12 = table_slicedToArray(_this$getTable11, 3),\n          table = _this$getTable12[0],\n          cell = _this$getTable12[2];\n\n      if (!Object(is_defined[\"a\" /* default */])(cell)) {\n        return;\n      }\n\n      table.insertHeaderRow();\n      this.quill.update(quill[\"a\" /* default */].sources.USER);\n    }\n  }, {\n    key: \"insertTable\",\n    value: function insertTable(rows, columns) {\n      var range = this.quill.getSelection();\n\n      if (!Object(is_defined[\"a\" /* default */])(range)) {\n        return;\n      }\n\n      var delta = new Array(rows).fill(0).reduce(function (memo) {\n        var rowId = tableId();\n        new Array(columns).fill('\\n').forEach(function (text) {\n          memo.insert(text, {\n            tableCellLine: {\n              row: rowId,\n              cell: tableId()\n            }\n          });\n        });\n        return memo;\n      }, new Delta_default.a().retain(range.index));\n      this.quill.updateContents(delta, quill[\"a\" /* default */].sources.USER);\n      this.quill.setSelection(range.index, quill[\"a\" /* default */].sources.SILENT);\n      this.balanceTables();\n    }\n  }, {\n    key: \"tableFormats\",\n    value: function tableFormats() {\n      return this.tableBlots;\n    }\n  }, {\n    key: \"listenBalanceCells\",\n    value: function listenBalanceCells() {\n      var _this4 = this;\n\n      this.quill.on(quill[\"a\" /* default */].events.SCROLL_OPTIMIZE, function (mutations) {\n        mutations.some(function (mutation) {\n          if (['TD', 'TH', 'TR', 'TBODY', 'THEAD', 'TABLE'].indexOf(mutation.target.tagName) !== -1) {\n            _this4.quill.once(quill[\"a\" /* default */].events.TEXT_CHANGE, function (delta, old, source) {\n              if (source !== quill[\"a\" /* default */].sources.USER) return;\n\n              _this4.balanceTables();\n            });\n\n            return true;\n          }\n\n          return false;\n        });\n      });\n      this.quill.on(quill[\"a\" /* default */].events.CONTENT_SETTED, function () {\n        _this4.quill.once(quill[\"a\" /* default */].events.TEXT_CHANGE, function () {\n          _this4.balanceTables();\n        });\n      });\n    }\n  }], [{\n    key: \"register\",\n    value: function register() {\n      quill[\"a\" /* default */].register(table_CellLine, true);\n      quill[\"a\" /* default */].register(HeaderCellLine, true);\n      quill[\"a\" /* default */].register(TableHeaderCell, true);\n      quill[\"a\" /* default */].register(TableCell, true);\n      quill[\"a\" /* default */].register(TableHeaderRow, true);\n      quill[\"a\" /* default */].register(TableRow, true);\n      quill[\"a\" /* default */].register(TableBody, true);\n      quill[\"a\" /* default */].register(TableHeader, true);\n      quill[\"a\" /* default */].register(table_TableContainer, true);\n      [attributors_table[\"b\" /* TABLE_FORMATS */], attributors_cell[\"b\" /* CELL_FORMATS */]].forEach(function (formats) {\n        Object.keys(formats).forEach(function (name) {\n          quill[\"a\" /* default */].register(_defineProperty({}, \"formats/\".concat(name), formats[name]), true);\n        });\n      });\n    }\n  }]);\n\n  return Table;\n}(core_module[\"a\" /* default */]);\n\ntable_Table.keyboardBindings = {\n  'table backspace': {\n    key: 'backspace',\n    format: ['tableCellLine', 'tableHeaderCellLine'],\n    collapsed: true,\n    offset: 0,\n    handler: function handler(range) {\n      var _this$quill$getLine3 = this.quill.getLine(range.index),\n          _this$quill$getLine4 = table_slicedToArray(_this$quill$getLine3, 1),\n          line = _this$quill$getLine4[0];\n\n      if (!line.prev || ['tableCellLine', 'tableHeaderCellLine'].indexOf(line.prev.statics.blotName) === -1) {\n        return false;\n      }\n\n      return true;\n    }\n  },\n  'table delete': {\n    key: 'del',\n    format: ['tableCellLine', 'tableHeaderCellLine'],\n    collapsed: true,\n    suffix: /^$/,\n    handler: function handler() {}\n  },\n  'table cell enter': {\n    key: 'enter',\n    shiftKey: null,\n    format: ['tableCellLine', 'tableHeaderCellLine'],\n    handler: function handler(range, context) {\n      var _this$quill$selection,\n          _this5 = this;\n\n      if ((_this$quill$selection = this.quill.selection) !== null && _this$quill$selection !== void 0 && _this$quill$selection.composing) return;\n\n      if (range.length > 0) {\n        this.quill.scroll.deleteAt(range.index, range.length);\n      }\n\n      var lineFormats = Object.keys(context.format).reduce(function (formats, format) {\n        if (_this5.quill.scroll.query(format, parchment[\"Scope\"].BLOCK) && !Array.isArray(context.format[format])) {\n          formats[format] = context.format[format];\n        }\n\n        return formats;\n      }, {});\n      this.quill.insertText(range.index, '\\n', lineFormats.tableCellLine, quill[\"a\" /* default */].sources.USER);\n      this.quill.setSelection(range.index + 1, quill[\"a\" /* default */].sources.SILENT);\n      this.quill.focus();\n      Object.keys(context.format).forEach(function (name) {\n        if (lineFormats[name] != null) return;\n        if (Array.isArray(context.format[name])) return;\n        if (name === 'link') return;\n\n        _this5.quill.format(name, context.format[name], quill[\"a\" /* default */].sources.USER);\n      });\n    }\n  },\n  'table tab': {\n    key: 'tab',\n    shiftKey: null,\n    format: ['tableCellLine', 'tableHeaderCellLine'],\n    handler: function handler(range, context) {\n      var event = context.event,\n          cell = context.line;\n      var offset = cell.offset(this.quill.scroll);\n\n      if (event.shiftKey) {\n        this.quill.setSelection(offset - 1, quill[\"a\" /* default */].sources.USER);\n      } else {\n        this.quill.setSelection(offset + cell.length(), quill[\"a\" /* default */].sources.USER);\n      }\n    }\n  },\n  'table down': Object(make_table_arrow_handler[\"a\" /* default */])(false, ['tableCellLine', 'tableHeaderCellLine']),\n  'table up': Object(make_table_arrow_handler[\"a\" /* default */])(true, ['tableCellLine', 'tableHeaderCellLine'])\n};\n\nfunction matchCell(node, delta) {\n  var row = node.parentNode;\n  var table = row.parentNode.tagName === 'TABLE' ? row.parentNode : row.parentNode.parentNode;\n  var isHeaderRow = row.parentNode.tagName === 'THEAD' ? true : null;\n  var rows = Array.from(table.querySelectorAll('tr'));\n  var cells = Array.from(row.querySelectorAll('th,td'));\n  var rowId = rows.indexOf(row) + 1;\n  var cellId = cells.indexOf(node) + 1;\n  var cellLineBlotName = isHeaderRow ? 'tableHeaderCellLine' : 'tableCellLine';\n\n  if (delta.length() === 0) {\n    delta = new Delta_default.a().insert('\\n', _defineProperty({}, cellLineBlotName, {\n      row: rowId,\n      cell: cellId\n    }));\n    return delta;\n  }\n\n  if (!Object(clipboard[\"c\" /* deltaEndsWith */])(delta, '\\n')) {\n    delta.insert('\\n');\n  }\n\n  return Object(clipboard[\"a\" /* applyFormat */])(delta, cellLineBlotName, {\n    row: rowId,\n    cell: cellId\n  });\n}\n\n/* harmony default export */ var modules_table = __webpack_exports__[\"a\"] = (table_Table);\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports) {\n\nmodule.exports = false;\n\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar requireObjectCoercible = __webpack_require__(65);\n\nvar Object = global.Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\n\nvar TypeError = global.TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(38);\nvar definePropertyModule = __webpack_require__(49);\nvar createPropertyDescriptor = __webpack_require__(67);\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n/* 69 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar ElementAttributor = /*#__PURE__*/function (_Attributor) {\n  _inherits(ElementAttributor, _Attributor);\n\n  var _super = _createSuper(ElementAttributor);\n\n  function ElementAttributor(attrName, keyName) {\n    var _options$allowedTags;\n\n    var _this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      allowedTags: []\n    };\n\n    _classCallCheck(this, ElementAttributor);\n\n    _this = _super.call(this, attrName, keyName, options);\n    _this.allowedTags = (_options$allowedTags = options.allowedTags) !== null && _options$allowedTags !== void 0 ? _options$allowedTags : [];\n    return _this;\n  }\n\n  _createClass(ElementAttributor, [{\n    key: \"canAdd\",\n    value: function canAdd(node, value) {\n      var isNodeAllowed = this.allowedTags.indexOf(node.tagName) > -1;\n      return isNodeAllowed && _get(_getPrototypeOf(ElementAttributor.prototype), \"canAdd\", this).call(this, node, value);\n    }\n  }]);\n\n  return ElementAttributor;\n}(parchment__WEBPACK_IMPORTED_MODULE_0__[\"Attributor\"]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ElementAttributor);\n\n/***/ }),\n/* 70 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar ElementStyleAttributor = /*#__PURE__*/function (_StyleAttributor) {\n  _inherits(ElementStyleAttributor, _StyleAttributor);\n\n  var _super = _createSuper(ElementStyleAttributor);\n\n  function ElementStyleAttributor(attrName, keyName) {\n    var _options$allowedTags;\n\n    var _this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      allowedTags: []\n    };\n\n    _classCallCheck(this, ElementStyleAttributor);\n\n    _this = _super.call(this, attrName, keyName, options);\n    _this.allowedTags = (_options$allowedTags = options.allowedTags) !== null && _options$allowedTags !== void 0 ? _options$allowedTags : [];\n    return _this;\n  }\n\n  _createClass(ElementStyleAttributor, [{\n    key: \"canAdd\",\n    value: function canAdd(node, value) {\n      var isNodeAllowed = this.allowedTags.indexOf(node.tagName) > -1;\n      return isNodeAllowed && _get(_getPrototypeOf(ElementStyleAttributor.prototype), \"canAdd\", this).call(this, node, value);\n    }\n  }]);\n\n  return ElementStyleAttributor;\n}(parchment__WEBPACK_IMPORTED_MODULE_0__[\"StyleAttributor\"]);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ElementStyleAttributor);\n\n/***/ }),\n/* 71 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXTERNAL MODULE: ./node_modules/quill-delta/dist/Delta.js\nvar Delta = __webpack_require__(1);\nvar Delta_default = /*#__PURE__*/__webpack_require__.n(Delta);\n\n// EXTERNAL MODULE: ./core/quill.js\nvar core_quill = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./core/module.js\nvar core_module = __webpack_require__(14);\n\n// EXTERNAL MODULE: ./blots/block.js\nvar block = __webpack_require__(6);\n\n// EXTERNAL MODULE: ./blots/container.js\nvar container = __webpack_require__(15);\n\n// EXTERNAL MODULE: ./utils/is_defined.js\nvar is_defined = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./formats/table/attributors/table.js\nvar attributors_table = __webpack_require__(8);\n\n// EXTERNAL MODULE: ./formats/table/get_id.js\nvar get_id = __webpack_require__(60);\n\n// EXTERNAL MODULE: ./formats/table/toggle_attribute.js\nvar toggle_attribute = __webpack_require__(45);\n\n// CONCATENATED MODULE: ./formats/table/lite.js\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\nvar TABLE_TAGS = ['TD', 'TH', 'TR', 'TBODY', 'THEAD', 'TABLE'];\nvar DATA_PREFIX = 'data-tablelite-';\n\nvar lite_BaseCell = /*#__PURE__*/function (_Block) {\n  _inherits(BaseCell, _Block);\n\n  var _super = _createSuper(BaseCell);\n\n  function BaseCell() {\n    _classCallCheck(this, BaseCell);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(BaseCell, [{\n    key: \"format\",\n    value: function format(name, value) {\n      if (attributors_table[\"b\" /* TABLE_FORMATS */][name]) {\n        var _this$row, _this$row$table;\n\n        var attrName = \"data-\".concat(name.toLowerCase());\n        Object(toggle_attribute[\"a\" /* default */])(this.domNode, attrName, value);\n        (_this$row = this.row()) === null || _this$row === void 0 ? void 0 : (_this$row$table = _this$row.table()) === null || _this$row$table === void 0 ? void 0 : _this$row$table.format(name, value);\n      } else {\n        _get(_getPrototypeOf(BaseCell.prototype), \"format\", this).call(this, name, value);\n      }\n    }\n  }, {\n    key: \"cellOffset\",\n    value: function cellOffset() {\n      if (this.parent) {\n        return this.parent.children.indexOf(this);\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"row\",\n    value: function row() {\n      return 'table' in this.parent ? this.parent : null;\n    }\n  }, {\n    key: \"rowOffset\",\n    value: function rowOffset() {\n      if (this.row()) {\n        return this.row().rowOffset();\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"table\",\n    value: function table() {\n      var _this$row2;\n\n      return (_this$row2 = this.row()) === null || _this$row2 === void 0 ? void 0 : _this$row2.table();\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var node = _get(_getPrototypeOf(BaseCell), \"create\", this).call(this);\n\n      var attrName = this.dataAttribute;\n      Object(toggle_attribute[\"a\" /* default */])(node, attrName, value !== null && value !== void 0 ? value : tableId());\n      return node;\n    }\n  }, {\n    key: \"formats\",\n    value: function formats(domNode) {\n      var attrName = this.dataAttribute;\n\n      if (domNode.hasAttribute(attrName)) {\n        return domNode.getAttribute(attrName);\n      }\n\n      return undefined;\n    }\n  }]);\n\n  return BaseCell;\n}(block[\"d\" /* default */]);\n\nlite_BaseCell.tagName = ['TD', 'TH'];\n\nvar TableCell = /*#__PURE__*/function (_BaseCell) {\n  _inherits(TableCell, _BaseCell);\n\n  var _super2 = _createSuper(TableCell);\n\n  function TableCell() {\n    _classCallCheck(this, TableCell);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(TableCell, [{\n    key: \"format\",\n    value: function format(name, value) {\n      if (name === TableCell.blotName && value) {\n        this.domNode.setAttribute(TableCell.dataAttribute, value);\n      } else {\n        _get(_getPrototypeOf(TableCell.prototype), \"format\", this).call(this, name, value);\n      }\n    }\n  }]);\n\n  return TableCell;\n}(lite_BaseCell);\n\nTableCell.blotName = 'table';\nTableCell.dataAttribute = \"\".concat(DATA_PREFIX, \"row\");\n\nvar TableHeaderCell = /*#__PURE__*/function (_BaseCell2) {\n  _inherits(TableHeaderCell, _BaseCell2);\n\n  var _super3 = _createSuper(TableHeaderCell);\n\n  function TableHeaderCell() {\n    _classCallCheck(this, TableHeaderCell);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(TableHeaderCell, [{\n    key: \"format\",\n    value: function format(name, value) {\n      if (name === TableHeaderCell.blotName && value) {\n        this.domNode.setAttribute(TableHeaderCell.dataAttribute, value);\n      } else {\n        _get(_getPrototypeOf(TableHeaderCell.prototype), \"format\", this).call(this, name, value);\n      }\n    }\n  }]);\n\n  return TableHeaderCell;\n}(lite_BaseCell);\n\nTableHeaderCell.tagName = ['TH', 'TD'];\nTableHeaderCell.blotName = 'tableHeaderCell';\nTableHeaderCell.dataAttribute = \"\".concat(DATA_PREFIX, \"header-row\");\n\nvar lite_BaseRow = /*#__PURE__*/function (_Container) {\n  _inherits(BaseRow, _Container);\n\n  var _super4 = _createSuper(BaseRow);\n\n  function BaseRow() {\n    _classCallCheck(this, BaseRow);\n\n    return _super4.apply(this, arguments);\n  }\n\n  _createClass(BaseRow, [{\n    key: \"checkMerge\",\n    value: function checkMerge() {\n      if (_get(_getPrototypeOf(BaseRow.prototype), \"checkMerge\", this).call(this) && Object(is_defined[\"a\" /* default */])(this.next.children.head)) {\n        var formatName = this.childFormatName;\n        var thisHead = this.children.head.formats();\n        var thisTail = this.children.tail.formats();\n        var nextHead = this.next.children.head.formats();\n        var nextTail = this.next.children.tail.formats();\n        return thisHead[formatName] === thisTail[formatName] && thisHead[formatName] === nextHead[formatName] && thisHead[formatName] === nextTail[formatName];\n      }\n\n      return false;\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize() {\n      var _get2,\n          _this = this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      (_get2 = _get(_getPrototypeOf(BaseRow.prototype), \"optimize\", this)).call.apply(_get2, [this].concat(args));\n\n      var formatName = this.childFormatName;\n      this.children.forEach(function (child) {\n        if (!Object(is_defined[\"a\" /* default */])(child.next)) {\n          return;\n        }\n\n        var childFormats = child.formats();\n        var nextFormats = child.next.formats();\n\n        if (childFormats[formatName] !== nextFormats[formatName]) {\n          var next = _this.splitAfter(child);\n\n          if (next) {\n            next.optimize();\n          } // We might be able to merge with prev now\n\n\n          if (_this.prev) {\n            _this.prev.optimize();\n          }\n        }\n      });\n    }\n  }, {\n    key: \"rowOffset\",\n    value: function rowOffset() {\n      if (this.parent) {\n        return this.parent.children.indexOf(this);\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"table\",\n    value: function table() {\n      var _this$parent;\n\n      return (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.parent;\n    }\n  }]);\n\n  return BaseRow;\n}(container[\"a\" /* default */]);\n\nlite_BaseRow.tagName = 'TR';\n\nvar TableRow = /*#__PURE__*/function (_BaseRow) {\n  _inherits(TableRow, _BaseRow);\n\n  var _super5 = _createSuper(TableRow);\n\n  function TableRow(scroll, domNode) {\n    var _this2;\n\n    _classCallCheck(this, TableRow);\n\n    _this2 = _super5.call(this, scroll, domNode);\n    _this2.childFormatName = 'table';\n    return _this2;\n  }\n\n  return TableRow;\n}(lite_BaseRow);\n\nTableRow.blotName = 'tableRow';\n\nvar TableHeaderRow = /*#__PURE__*/function (_BaseRow2) {\n  _inherits(TableHeaderRow, _BaseRow2);\n\n  var _super6 = _createSuper(TableHeaderRow);\n\n  function TableHeaderRow(scroll, domNode) {\n    var _this3;\n\n    _classCallCheck(this, TableHeaderRow);\n\n    _this3 = _super6.call(this, scroll, domNode);\n    _this3.childFormatName = 'tableHeaderCell';\n    return _this3;\n  }\n\n  return TableHeaderRow;\n}(lite_BaseRow);\n\nTableHeaderRow.blotName = 'tableHeaderRow';\n\nvar lite_RowContainer = /*#__PURE__*/function (_Container2) {\n  _inherits(RowContainer, _Container2);\n\n  var _super7 = _createSuper(RowContainer);\n\n  function RowContainer() {\n    _classCallCheck(this, RowContainer);\n\n    return _super7.apply(this, arguments);\n  }\n\n  _createClass(RowContainer, [{\n    key: \"optimize\",\n    value: function optimize() {\n      var _get3;\n\n      if (this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer)) {\n        var domNode = this.children.head.children.head.domNode;\n        var formats = {};\n        Object.keys(attributors_table[\"b\" /* TABLE_FORMATS */]).forEach(function (format) {\n          var value = domNode.dataset[format.toLowerCase()];\n\n          if (value) {\n            formats[format] = value;\n          }\n        });\n        this.wrap(this.statics.requiredContainer.blotName, formats);\n      }\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      (_get3 = _get(_getPrototypeOf(RowContainer.prototype), \"optimize\", this)).call.apply(_get3, [this].concat(args));\n    }\n  }]);\n\n  return RowContainer;\n}(container[\"a\" /* default */]);\n\nvar TableBody = /*#__PURE__*/function (_RowContainer) {\n  _inherits(TableBody, _RowContainer);\n\n  var _super8 = _createSuper(TableBody);\n\n  function TableBody() {\n    _classCallCheck(this, TableBody);\n\n    return _super8.apply(this, arguments);\n  }\n\n  return TableBody;\n}(lite_RowContainer);\n\nTableBody.blotName = 'tableBody';\nTableBody.tagName = ['TBODY'];\n\nvar TableHeader = /*#__PURE__*/function (_RowContainer2) {\n  _inherits(TableHeader, _RowContainer2);\n\n  var _super9 = _createSuper(TableHeader);\n\n  function TableHeader() {\n    _classCallCheck(this, TableHeader);\n\n    return _super9.apply(this, arguments);\n  }\n\n  return TableHeader;\n}(lite_RowContainer);\n\nTableHeader.blotName = 'tableHeader';\nTableHeader.tagName = ['THEAD'];\n\nvar lite_TableContainer = /*#__PURE__*/function (_Container3) {\n  _inherits(TableContainer, _Container3);\n\n  var _super10 = _createSuper(TableContainer);\n\n  function TableContainer() {\n    _classCallCheck(this, TableContainer);\n\n    return _super10.apply(this, arguments);\n  }\n\n  _createClass(TableContainer, [{\n    key: \"balanceCells\",\n    value: function balanceCells() {\n      var headerRows = this.descendants(TableHeaderRow);\n      var bodyRows = this.descendants(TableRow);\n      var maxColCount = this.getMaxTableColCount(headerRows, bodyRows);\n      this.balanceRows(maxColCount, headerRows, TableHeaderCell);\n      this.balanceRows(maxColCount, bodyRows, TableCell);\n    }\n  }, {\n    key: \"getMaxTableColCount\",\n    value: function getMaxTableColCount(headerRows, bodyRows) {\n      return Math.max(this.getMaxRowColCount(headerRows), this.getMaxRowColCount(bodyRows));\n    }\n  }, {\n    key: \"getMaxRowColCount\",\n    value: function getMaxRowColCount(rows) {\n      return Math.max.apply(Math, _toConsumableArray(rows.map(function (row) {\n        return row.children.length;\n      })));\n    }\n  }, {\n    key: \"balanceRows\",\n    value: function balanceRows(maxColCount, rows, CellClass) {\n      var _this4 = this;\n\n      rows.forEach(function (row) {\n        new Array(maxColCount - row.children.length).fill(0).forEach(function () {\n          var value;\n\n          if (Object(is_defined[\"a\" /* default */])(row.children.head)) {\n            value = CellClass.formats(row.children.head.domNode);\n          }\n\n          var blot = _this4.scroll.create(CellClass.blotName, value);\n\n          row.appendChild(blot);\n          blot.optimize(); // Add break blot\n        });\n      });\n    }\n  }, {\n    key: \"cells\",\n    value: function cells(column) {\n      return this.rows().map(function (row) {\n        return row.children.at(column);\n      });\n    }\n  }, {\n    key: \"deleteColumn\",\n    value: function deleteColumn(index) {\n      var _this5 = this;\n\n      [TableHeader, TableBody].forEach(function (blot) {\n        var _this5$descendants = _this5.descendants(blot),\n            _this5$descendants2 = _slicedToArray(_this5$descendants, 1),\n            tablePart = _this5$descendants2[0];\n\n        if (!Object(is_defined[\"a\" /* default */])(tablePart) || !Object(is_defined[\"a\" /* default */])(tablePart.children.head)) {\n          return;\n        }\n\n        tablePart.children.forEach(function (row) {\n          var cell = row.children.at(index);\n\n          if (Object(is_defined[\"a\" /* default */])(cell)) {\n            cell.remove();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"insertColumn\",\n    value: function insertColumn(index) {\n      var _this6 = this;\n\n      [TableHeader, TableBody].forEach(function (blot) {\n        var _this6$descendants = _this6.descendants(blot),\n            _this6$descendants2 = _slicedToArray(_this6$descendants, 1),\n            tablePart = _this6$descendants2[0];\n\n        if (!Object(is_defined[\"a\" /* default */])(tablePart) || !Object(is_defined[\"a\" /* default */])(tablePart.children.head)) {\n          return;\n        }\n\n        var CellBlot = blot === TableHeader ? TableHeaderCell : TableCell;\n        tablePart.children.forEach(function (row) {\n          var ref = row.children.at(index);\n          var value = CellBlot.formats(row.children.head.domNode);\n\n          var cell = _this6.scroll.create(CellBlot.blotName, value);\n\n          row.insertBefore(cell, ref);\n        });\n      });\n    }\n  }, {\n    key: \"insertRow\",\n    value: function insertRow(index) {\n      var _this7 = this;\n\n      var _this$descendants = this.descendants(TableBody),\n          _this$descendants2 = _slicedToArray(_this$descendants, 1),\n          body = _this$descendants2[0];\n\n      if (!Object(is_defined[\"a\" /* default */])(body) || !Object(is_defined[\"a\" /* default */])(body.children.head)) {\n        return;\n      }\n\n      var id = tableId();\n      var row = this.scroll.create(TableRow.blotName);\n      body.children.head.children.forEach(function () {\n        var cell = _this7.scroll.create(TableCell.blotName, id);\n\n        row.appendChild(cell);\n      });\n      var ref = body.children.at(index);\n      body.insertBefore(row, ref);\n    }\n  }, {\n    key: \"insertHeaderRow\",\n    value: function insertHeaderRow() {\n      var _this8 = this;\n\n      var _this$descendants3 = this.descendants(TableHeader),\n          _this$descendants4 = _slicedToArray(_this$descendants3, 1),\n          header = _this$descendants4[0];\n\n      var _this$descendants5 = this.descendants(TableBody),\n          _this$descendants6 = _slicedToArray(_this$descendants5, 1),\n          body = _this$descendants6[0];\n\n      if (Object(is_defined[\"a\" /* default */])(header) || !Object(is_defined[\"a\" /* default */])(body) || !Object(is_defined[\"a\" /* default */])(body.children.head)) {\n        return;\n      }\n\n      var id = tableId();\n      var newHeader = this.scroll.create(TableHeader.blotName);\n      var row = this.scroll.create(TableHeaderRow.blotName);\n      var ref = this.children.at(0);\n      newHeader.appendChild(row);\n      body.children.head.children.forEach(function () {\n        var cell = _this8.scroll.create(TableHeaderCell.blotName, id);\n\n        row.appendChild(cell);\n        cell.optimize();\n      });\n      this.insertBefore(newHeader, ref);\n    }\n  }, {\n    key: \"rows\",\n    value: function rows() {\n      var body = this.children.head;\n      return Object(is_defined[\"a\" /* default */])(body) ? body.children.map(function (row) {\n        return row;\n      }) : [];\n    }\n  }, {\n    key: \"formats\",\n    value: function formats() {\n      var formats = {};\n      var childElem = this.cells()[0].domNode;\n      Object.keys(attributors_table[\"b\" /* TABLE_FORMATS */]).forEach(function (format) {\n        var value = childElem.dataset[format.toLowerCase()];\n\n        if (value) {\n          formats[format] = value;\n        }\n      });\n      return formats;\n    }\n  }, {\n    key: \"format\",\n    value: function format(name, value) {\n      var tableFormat = attributors_table[\"b\" /* TABLE_FORMATS */][name];\n\n      if (tableFormat) {\n        var attrName = \"data-\".concat(name.toLowerCase());\n        this.cells().forEach(function (cell) {\n          Object(toggle_attribute[\"a\" /* default */])(cell.domNode, attrName, value);\n        });\n        tableFormat.add(this.domNode, value);\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var node = _get(_getPrototypeOf(TableContainer), \"create\", this).call(this, value);\n\n      if (value) {\n        Object.keys(value).forEach(function (format) {\n          var _TABLE_FORMATS$format;\n\n          (_TABLE_FORMATS$format = attributors_table[\"b\" /* TABLE_FORMATS */][format]) === null || _TABLE_FORMATS$format === void 0 ? void 0 : _TABLE_FORMATS$format.add(node, value[format]);\n        });\n      }\n\n      return node;\n    }\n  }]);\n\n  return TableContainer;\n}(container[\"a\" /* default */]);\n\nlite_TableContainer.blotName = 'tableContainer';\nlite_TableContainer.tagName = 'TABLE';\nlite_TableContainer.allowedChildren = [TableHeader, TableBody];\nTableBody.requiredContainer = lite_TableContainer;\nTableHeader.requiredContainer = lite_TableContainer;\nTableBody.allowedChildren = [TableRow];\nTableRow.requiredContainer = TableBody;\nTableRow.allowedChildren = [TableCell];\nTableCell.requiredContainer = TableRow;\nTableHeader.allowedChildren = [TableHeaderRow];\nTableHeaderRow.requiredContainer = TableHeader;\nTableHeaderRow.allowedChildren = [TableHeaderCell];\nTableHeaderCell.requiredContainer = TableHeaderRow;\n\nfunction tableId() {\n  return \"row-\".concat(Object(get_id[\"a\" /* default */])());\n}\n\n\n// EXTERNAL MODULE: ./modules/clipboard.js\nvar clipboard = __webpack_require__(28);\n\n// EXTERNAL MODULE: ./modules/table/utils/make_table_arrow_handler.js\nvar make_table_arrow_handler = __webpack_require__(51);\n\n// CONCATENATED MODULE: ./modules/table/utils/insert_pr_below.js\n\n\nfunction insertParagraphAbove(_ref) {\n  var quill = _ref.quill,\n      index = _ref.index,\n      range = _ref.range;\n  var insertIndex = index - 1;\n  var delta = new Delta_default.a().retain(insertIndex).insert('\\n');\n  quill.updateContents(delta, core_quill[\"a\" /* default */].sources.USER);\n  quill.setSelection(range.index + 1, range.length, core_quill[\"a\" /* default */].sources.SILENT);\n}\n// CONCATENATED MODULE: ./modules/table/utils/insert_pr_above.js\n\n\nfunction insertParagraphBelow(_ref) {\n  var quill = _ref.quill,\n      index = _ref.index,\n      table = _ref.table;\n  var insertIndex = index + table.length();\n  var delta = new Delta_default.a().retain(insertIndex).insert('\\n');\n  quill.updateContents(delta, core_quill[\"a\" /* default */].sources.USER);\n  quill.setSelection(insertIndex, core_quill[\"a\" /* default */].sources.USER);\n}\n// CONCATENATED MODULE: ./modules/table/utils/table_side.js\nfunction tableSide(row, cell, offset) {\n  if (row.prev == null && row.next == null) {\n    if (cell.prev == null && cell.next == null) {\n      return offset === 0 ? -1 : 1;\n    }\n\n    return cell.prev == null ? -1 : 1;\n  }\n\n  if (row.prev == null) {\n    return -1;\n  }\n\n  if (row.next == null) {\n    return 1;\n  }\n\n  return null;\n}\n// EXTERNAL MODULE: ./modules/table/utils/prepare_attr_matcher.js\nvar prepare_attr_matcher = __webpack_require__(52);\n\n// EXTERNAL MODULE: ./formats/table/attributors/cell.js\nvar attributors_cell = __webpack_require__(9);\n\n// CONCATENATED MODULE: ./modules/table/lite.js\nfunction lite_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { lite_typeof = function _typeof(obj) { return typeof obj; }; } else { lite_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return lite_typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction lite_slicedToArray(arr, i) { return lite_arrayWithHoles(arr) || lite_iterableToArrayLimit(arr, i) || lite_unsupportedIterableToArray(arr, i) || lite_nonIterableRest(); }\n\nfunction lite_nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction lite_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return lite_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return lite_arrayLikeToArray(o, minLen); }\n\nfunction lite_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction lite_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction lite_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction lite_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction lite_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction lite_createClass(Constructor, protoProps, staticProps) { if (protoProps) lite_defineProperties(Constructor.prototype, protoProps); if (staticProps) lite_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction lite_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) lite_setPrototypeOf(subClass, superClass); }\n\nfunction lite_setPrototypeOf(o, p) { lite_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return lite_setPrototypeOf(o, p); }\n\nfunction lite_createSuper(Derived) { var hasNativeReflectConstruct = lite_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = lite_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = lite_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return lite_possibleConstructorReturn(this, result); }; }\n\nfunction lite_possibleConstructorReturn(self, call) { if (call && (lite_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return lite_assertThisInitialized(self); }\n\nfunction lite_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction lite_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction lite_getPrototypeOf(o) { lite_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return lite_getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar EMPTY_RESULT = [null, null, null, -1];\n\nvar lite_TableLite = /*#__PURE__*/function (_Module) {\n  lite_inherits(TableLite, _Module);\n\n  var _super = lite_createSuper(TableLite);\n\n  function TableLite() {\n    var _this;\n\n    lite_classCallCheck(this, TableLite);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.tableBlots = [TableCell.blotName, TableHeaderCell.blotName];\n\n    _this.tableBlots.forEach(function (blotName) {\n      _this.quill.editor.addImmediateFormat(blotName);\n    });\n\n    _this.integrateClipboard();\n\n    _this.addKeyboardHandlers();\n\n    _this.listenBalanceCells();\n\n    return _this;\n  }\n\n  lite_createClass(TableLite, [{\n    key: \"integrateClipboard\",\n    value: function integrateClipboard() {\n      var _this2 = this;\n\n      this.tableBlots.forEach(function (blotName) {\n        return _this2.quill.clipboard.addTableBlot(blotName);\n      });\n      this.quill.clipboard.addMatcher('tr', matchTable);\n      this.quill.clipboard.addMatcher('table', Object(prepare_attr_matcher[\"a\" /* default */])('table'));\n      this.quill.clipboard.addMatcher('td, th', Object(prepare_attr_matcher[\"a\" /* default */])('cell'));\n    }\n  }, {\n    key: \"addKeyboardHandlers\",\n    value: function addKeyboardHandlers() {\n      var _this3 = this;\n\n      var bindings = TableLite.keyboardBindings;\n      Object.keys(bindings).forEach(function (name) {\n        if (bindings[name]) {\n          _this3.quill.keyboard.addBinding(bindings[name]);\n        }\n      });\n    }\n  }, {\n    key: \"balanceTables\",\n    value: function balanceTables() {\n      this.quill.scroll.descendants(lite_TableContainer).forEach(function (table) {\n        table.balanceCells();\n      });\n    }\n  }, {\n    key: \"deleteColumn\",\n    value: function deleteColumn() {\n      var _this$getTable = this.getTable(),\n          _this$getTable2 = lite_slicedToArray(_this$getTable, 3),\n          table = _this$getTable2[0],\n          cell = _this$getTable2[2];\n\n      if (!Object(is_defined[\"a\" /* default */])(cell)) {\n        return;\n      }\n\n      table.deleteColumn(cell.cellOffset());\n      this.quill.update(core_quill[\"a\" /* default */].sources.USER);\n    }\n  }, {\n    key: \"deleteRow\",\n    value: function deleteRow() {\n      var _this$getTable3 = this.getTable(),\n          _this$getTable4 = lite_slicedToArray(_this$getTable3, 2),\n          row = _this$getTable4[1];\n\n      if (!Object(is_defined[\"a\" /* default */])(row)) {\n        return;\n      }\n\n      row.remove();\n      this.quill.update(core_quill[\"a\" /* default */].sources.USER);\n    }\n  }, {\n    key: \"deleteTable\",\n    value: function deleteTable() {\n      var _this$getTable5 = this.getTable(),\n          _this$getTable6 = lite_slicedToArray(_this$getTable5, 1),\n          table = _this$getTable6[0];\n\n      if (!Object(is_defined[\"a\" /* default */])(table)) {\n        return;\n      }\n\n      var offset = table.offset();\n      table.remove();\n      this.quill.update(core_quill[\"a\" /* default */].sources.USER);\n      this.quill.setSelection(offset, core_quill[\"a\" /* default */].sources.SILENT);\n    }\n  }, {\n    key: \"getTable\",\n    value: function getTable() {\n      var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.quill.getSelection();\n\n      if (!Object(is_defined[\"a\" /* default */])(range)) {\n        return EMPTY_RESULT;\n      }\n\n      var _this$quill$getLine = this.quill.getLine(range.index),\n          _this$quill$getLine2 = lite_slicedToArray(_this$quill$getLine, 2),\n          cell = _this$quill$getLine2[0],\n          offset = _this$quill$getLine2[1];\n\n      if (!Object(is_defined[\"a\" /* default */])(cell) || this.tableBlots.indexOf(cell.statics.blotName) === -1) {\n        return EMPTY_RESULT;\n      }\n\n      var row = cell.parent;\n      var table = row.parent.parent;\n      return [table, row, cell, offset];\n    }\n  }, {\n    key: \"insertColumn\",\n    value: function insertColumn(offset) {\n      var range = this.quill.getSelection();\n\n      var _this$getTable7 = this.getTable(range),\n          _this$getTable8 = lite_slicedToArray(_this$getTable7, 3),\n          table = _this$getTable8[0],\n          row = _this$getTable8[1],\n          cell = _this$getTable8[2];\n\n      if (!Object(is_defined[\"a\" /* default */])(cell)) {\n        return;\n      }\n\n      var column = cell.cellOffset();\n      table.insertColumn(column + offset);\n      this.quill.update(core_quill[\"a\" /* default */].sources.USER);\n      var shift = row.rowOffset();\n\n      if (offset === 0) {\n        shift += 1;\n      }\n\n      this.quill.setSelection(range.index + shift, range.length, core_quill[\"a\" /* default */].sources.SILENT);\n    }\n  }, {\n    key: \"insertColumnLeft\",\n    value: function insertColumnLeft() {\n      this.insertColumn(0);\n    }\n  }, {\n    key: \"insertColumnRight\",\n    value: function insertColumnRight() {\n      this.insertColumn(1);\n    }\n  }, {\n    key: \"insertRow\",\n    value: function insertRow(offset) {\n      var range = this.quill.getSelection();\n\n      var _this$getTable9 = this.getTable(range),\n          _this$getTable10 = lite_slicedToArray(_this$getTable9, 3),\n          table = _this$getTable10[0],\n          row = _this$getTable10[1],\n          cell = _this$getTable10[2];\n\n      if (!Object(is_defined[\"a\" /* default */])(cell)) {\n        return;\n      }\n\n      var index = row.rowOffset();\n      table.insertRow(index + offset);\n      this.quill.update(core_quill[\"a\" /* default */].sources.USER);\n\n      if (offset > 0) {\n        this.quill.setSelection(range, core_quill[\"a\" /* default */].sources.SILENT);\n      } else {\n        this.quill.setSelection(range.index + row.children.length, range.length, core_quill[\"a\" /* default */].sources.SILENT);\n      }\n    }\n  }, {\n    key: \"insertRowAbove\",\n    value: function insertRowAbove() {\n      this.insertRow(0);\n    }\n  }, {\n    key: \"insertRowBelow\",\n    value: function insertRowBelow() {\n      this.insertRow(1);\n    }\n  }, {\n    key: \"insertHeaderRow\",\n    value: function insertHeaderRow() {\n      var range = this.quill.getSelection();\n\n      var _this$getTable11 = this.getTable(range),\n          _this$getTable12 = lite_slicedToArray(_this$getTable11, 3),\n          table = _this$getTable12[0],\n          cell = _this$getTable12[2];\n\n      if (!Object(is_defined[\"a\" /* default */])(cell)) {\n        return;\n      }\n\n      table.insertHeaderRow();\n      this.quill.update(core_quill[\"a\" /* default */].sources.USER);\n    }\n  }, {\n    key: \"insertTable\",\n    value: function insertTable(rows, columns) {\n      var range = this.quill.getSelection();\n\n      if (!Object(is_defined[\"a\" /* default */])(range)) {\n        return;\n      }\n\n      var delta = new Array(rows).fill(0).reduce(function (memo) {\n        var text = new Array(columns).fill('\\n').join('');\n        return memo.insert(text, {\n          table: tableId()\n        });\n      }, new Delta_default.a().retain(range.index));\n      this.quill.updateContents(delta, core_quill[\"a\" /* default */].sources.USER);\n      this.quill.setSelection(range.index, core_quill[\"a\" /* default */].sources.SILENT);\n      this.balanceTables();\n    }\n  }, {\n    key: \"tableFormats\",\n    value: function tableFormats() {\n      return this.tableBlots;\n    }\n  }, {\n    key: \"listenBalanceCells\",\n    value: function listenBalanceCells() {\n      var _this4 = this;\n\n      this.quill.on(core_quill[\"a\" /* default */].events.SCROLL_OPTIMIZE, function (mutations) {\n        mutations.some(function (mutation) {\n          if (['TD', 'TH', 'TR', 'TBODY', 'THEAD', 'TABLE'].indexOf(mutation.target.tagName) !== -1) {\n            _this4.quill.once(core_quill[\"a\" /* default */].events.TEXT_CHANGE, function (delta, old, source) {\n              if (source !== core_quill[\"a\" /* default */].sources.USER) return;\n\n              _this4.balanceTables();\n            });\n\n            return true;\n          }\n\n          return false;\n        });\n      });\n      this.quill.on(core_quill[\"a\" /* default */].events.CONTENT_SETTED, function () {\n        _this4.quill.once(core_quill[\"a\" /* default */].events.TEXT_CHANGE, function () {\n          _this4.balanceTables();\n        });\n      });\n    }\n  }], [{\n    key: \"register\",\n    value: function register() {\n      core_quill[\"a\" /* default */].register(TableHeaderCell, true);\n      core_quill[\"a\" /* default */].register(TableCell, true);\n      core_quill[\"a\" /* default */].register(TableHeaderRow, true);\n      core_quill[\"a\" /* default */].register(TableRow, true);\n      core_quill[\"a\" /* default */].register(TableBody, true);\n      core_quill[\"a\" /* default */].register(TableHeader, true);\n      core_quill[\"a\" /* default */].register(lite_TableContainer, true);\n      [attributors_table[\"b\" /* TABLE_FORMATS */], attributors_cell[\"b\" /* CELL_FORMATS */]].forEach(function (formats) {\n        Object.keys(formats).forEach(function (name) {\n          core_quill[\"a\" /* default */].register(_defineProperty({}, \"formats/\".concat(name), formats[name]), true);\n        });\n      });\n    }\n  }]);\n\n  return TableLite;\n}(core_module[\"a\" /* default */]);\n\nlite_TableLite.keyboardBindings = {\n  'table backspace': {\n    key: 'backspace',\n    format: ['table', 'tableHeaderCell'],\n    collapsed: true,\n    offset: 0,\n    handler: function handler() {}\n  },\n  'table delete': {\n    key: 'del',\n    format: ['table', 'tableHeaderCell'],\n    collapsed: true,\n    suffix: /^$/,\n    handler: function handler() {}\n  },\n  'table enter': {\n    key: 'enter',\n    shiftKey: null,\n    format: ['table'],\n    handler: function handler(range) {\n      var module = this.quill.getModule('table');\n\n      if (module) {\n        var quill = this.quill;\n\n        var _module$getTable = module.getTable(range),\n            _module$getTable2 = lite_slicedToArray(_module$getTable, 4),\n            table = _module$getTable2[0],\n            row = _module$getTable2[1],\n            cell = _module$getTable2[2],\n            offset = _module$getTable2[3];\n\n        var shift = tableSide(row, cell, offset);\n        var hasHead = table.children.length > 1 && table.children.head;\n\n        if (shift == null || shift < 0 && hasHead) {\n          return;\n        }\n\n        var index = table.offset();\n\n        if (shift < 0) {\n          insertParagraphAbove({\n            quill: quill,\n            index: index,\n            range: range\n          });\n        } else {\n          insertParagraphBelow({\n            quill: quill,\n            index: index,\n            table: table\n          });\n        }\n      }\n    }\n  },\n  'table header enter': {\n    key: 'enter',\n    shiftKey: null,\n    format: ['tableHeaderCell'],\n    handler: function handler(range) {\n      var module = this.quill.getModule('table');\n\n      if (module) {\n        var quill = this.quill;\n\n        var _module$getTable3 = module.getTable(range),\n            _module$getTable4 = lite_slicedToArray(_module$getTable3, 4),\n            table = _module$getTable4[0],\n            row = _module$getTable4[1],\n            cell = _module$getTable4[2],\n            offset = _module$getTable4[3];\n\n        var shift = tableSide(row, cell, offset);\n\n        if (shift == null) {\n          return;\n        }\n\n        var index = table.offset();\n        var hasBody = table.children.length > 1 && table.children.tail;\n\n        if (shift < 0 || shift > 0 && hasBody) {\n          insertParagraphAbove({\n            quill: quill,\n            index: index,\n            range: range\n          });\n        } else {\n          insertParagraphBelow({\n            quill: quill,\n            index: index,\n            table: table\n          });\n        }\n      }\n    }\n  },\n  'table tab': {\n    key: 'tab',\n    shiftKey: null,\n    format: ['table', 'tableHeaderCell'],\n    handler: function handler(range, context) {\n      var event = context.event,\n          cell = context.line;\n      var offset = cell.offset(this.quill.scroll);\n\n      if (event.shiftKey) {\n        this.quill.setSelection(offset - 1, core_quill[\"a\" /* default */].sources.USER);\n      } else {\n        this.quill.setSelection(offset + cell.length(), core_quill[\"a\" /* default */].sources.USER);\n      }\n    }\n  },\n  'table down': Object(make_table_arrow_handler[\"a\" /* default */])(false, ['table', 'tableHeaderCell']),\n  'table up': Object(make_table_arrow_handler[\"a\" /* default */])(true, ['table', 'tableHeaderCell'])\n};\n\nfunction matchTable(node, delta) {\n  var table = node.parentNode.tagName === 'TABLE' ? node.parentNode : node.parentNode.parentNode;\n  var isHeaderRow = node.parentNode.tagName === 'THEAD' ? true : null;\n  var rows = Array.from(table.querySelectorAll('tr'));\n  var row = rows.indexOf(node) + 1;\n  return Object(clipboard[\"a\" /* applyFormat */])(delta, isHeaderRow ? 'tableHeaderCell' : 'table', row);\n}\n\n/* harmony default export */ var lite = __webpack_exports__[\"a\"] = (lite_TableLite);\n\n/***/ }),\n/* 72 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SyntaxCodeBlock; });\n/* unused harmony export CodeToken */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return Syntax; });\n/* harmony import */ var quill_delta__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var quill_delta__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(quill_delta__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var parchment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);\n/* harmony import */ var _blots_inline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);\n/* harmony import */ var _core_quill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);\n/* harmony import */ var _core_module__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14);\n/* harmony import */ var _blots_block__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6);\n/* harmony import */ var _blots_break__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);\n/* harmony import */ var _blots_cursor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(24);\n/* harmony import */ var _blots_text__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(11);\n/* harmony import */ var _formats_code__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(19);\n/* harmony import */ var _clipboard__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(28);\n/* harmony import */ var _utils_has_window__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(17);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TokenAttributor = new parchment__WEBPACK_IMPORTED_MODULE_1__[\"ClassAttributor\"]('code-token', 'hljs', {\n  scope: parchment__WEBPACK_IMPORTED_MODULE_1__[\"Scope\"].INLINE\n});\n\nvar CodeToken = /*#__PURE__*/function (_Inline) {\n  _inherits(CodeToken, _Inline);\n\n  var _super = _createSuper(CodeToken);\n\n  function CodeToken(scroll, domNode, value) {\n    var _this;\n\n    _classCallCheck(this, CodeToken);\n\n    _this = _super.call(this, scroll, domNode, value);\n    TokenAttributor.add(_this.domNode, value);\n    return _this;\n  }\n\n  _createClass(CodeToken, [{\n    key: \"format\",\n    value: function format(_format, value) {\n      if (_format !== CodeToken.blotName) {\n        _get(_getPrototypeOf(CodeToken.prototype), \"format\", this).call(this, _format, value);\n      } else if (value) {\n        TokenAttributor.add(this.domNode, value);\n      } else {\n        TokenAttributor.remove(this.domNode);\n        this.domNode.classList.remove(this.statics.className);\n      }\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize() {\n      var _get2;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      (_get2 = _get(_getPrototypeOf(CodeToken.prototype), \"optimize\", this)).call.apply(_get2, [this].concat(args));\n\n      if (!TokenAttributor.value(this.domNode)) {\n        this.unwrap();\n      }\n    }\n  }], [{\n    key: \"formats\",\n    value: function formats(node, scroll) {\n      while (node != null && node !== scroll.domNode) {\n        if (node.classList && node.classList.contains(_formats_code__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"c\"].className)) {\n          return _get(_getPrototypeOf(CodeToken), \"formats\", this).call(this, node, scroll);\n        }\n\n        node = node.parentNode;\n      }\n\n      return undefined;\n    }\n  }]);\n\n  return CodeToken;\n}(_blots_inline__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]);\n\nCodeToken.blotName = 'code-token';\nCodeToken.className = 'ql-token';\n\nvar SyntaxCodeBlock = /*#__PURE__*/function (_CodeBlock) {\n  _inherits(SyntaxCodeBlock, _CodeBlock);\n\n  var _super2 = _createSuper(SyntaxCodeBlock);\n\n  function SyntaxCodeBlock() {\n    _classCallCheck(this, SyntaxCodeBlock);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(SyntaxCodeBlock, [{\n    key: \"format\",\n    value: // Syntax module will register\n    function format(name, value) {\n      if (name === this.statics.blotName && value) {\n        this.domNode.setAttribute('data-language', value);\n      } else {\n        _get(_getPrototypeOf(SyntaxCodeBlock.prototype), \"format\", this).call(this, name, value);\n      }\n    }\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(name, value) {\n      this.formatAt(0, this.length(), CodeToken.blotName, false);\n      return _get(_getPrototypeOf(SyntaxCodeBlock.prototype), \"replaceWith\", this).call(this, name, value);\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var domNode = _get(_getPrototypeOf(SyntaxCodeBlock), \"create\", this).call(this, value);\n\n      if (typeof value === 'string') {\n        domNode.setAttribute('data-language', value);\n      }\n\n      return domNode;\n    }\n  }, {\n    key: \"formats\",\n    value: function formats(domNode) {\n      return domNode.getAttribute('data-language') || 'plain';\n    }\n  }, {\n    key: \"register\",\n    value: function register() {}\n  }]);\n\n  return SyntaxCodeBlock;\n}(_formats_code__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"c\"]);\n\nvar SyntaxCodeBlockContainer = /*#__PURE__*/function (_CodeBlockContainer) {\n  _inherits(SyntaxCodeBlockContainer, _CodeBlockContainer);\n\n  var _super3 = _createSuper(SyntaxCodeBlockContainer);\n\n  function SyntaxCodeBlockContainer() {\n    _classCallCheck(this, SyntaxCodeBlockContainer);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(SyntaxCodeBlockContainer, [{\n    key: \"attach\",\n    value: function attach() {\n      _get(_getPrototypeOf(SyntaxCodeBlockContainer.prototype), \"attach\", this).call(this);\n\n      this.forceNext = false;\n      this.scroll.emitMount(this);\n    }\n  }, {\n    key: \"format\",\n    value: function format(name, value) {\n      if (name === SyntaxCodeBlock.blotName) {\n        this.forceNext = true;\n        this.children.forEach(function (child) {\n          child.format(name, value);\n        });\n      }\n    }\n  }, {\n    key: \"formatAt\",\n    value: function formatAt(index, length, name, value) {\n      if (name === SyntaxCodeBlock.blotName) {\n        this.forceNext = true;\n      }\n\n      _get(_getPrototypeOf(SyntaxCodeBlockContainer.prototype), \"formatAt\", this).call(this, index, length, name, value);\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight(_highlight) {\n      var _this2 = this;\n\n      var forced = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.children.head == null) return;\n      var nodes = Array.from(this.domNode.childNodes).filter(function (node) {\n        return node !== _this2.uiNode;\n      });\n      var text = \"\".concat(nodes.map(function (node) {\n        return node.textContent;\n      }).join('\\n'), \"\\n\");\n      var language = SyntaxCodeBlock.formats(this.children.head.domNode);\n\n      if (forced || this.forceNext || this.cachedText !== text) {\n        if (text.trim().length > 0 || this.cachedText == null) {\n          var oldDelta = this.children.reduce(function (delta, child) {\n            return delta.concat(Object(_blots_block__WEBPACK_IMPORTED_MODULE_5__[/* blockDelta */ \"b\"])(child, false));\n          }, new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a());\n\n          var delta = _highlight(text, language);\n\n          oldDelta.diff(delta).reduce(function (index, _ref) {\n            var retain = _ref.retain,\n                attributes = _ref.attributes;\n            // Should be all retains\n            if (!retain) return index;\n\n            if (attributes) {\n              Object.keys(attributes).forEach(function (format) {\n                if ([SyntaxCodeBlock.blotName, CodeToken.blotName].indexOf(format) !== -1) {\n                  _this2.formatAt(index, retain, format, attributes[format]);\n                }\n              });\n            }\n\n            return index + retain;\n          }, 0);\n        }\n\n        this.cachedText = text;\n        this.forceNext = false;\n      }\n    }\n  }, {\n    key: \"html\",\n    value: function html(index, length) {\n      var _this$children$find = this.children.find(index),\n          _this$children$find2 = _slicedToArray(_this$children$find, 1),\n          codeBlock = _this$children$find2[0];\n\n      var language = codeBlock ? SyntaxCodeBlock.formats(codeBlock.domNode) : 'plain';\n      return \"<pre data-language=\\\"\".concat(language, \"\\\">\\n\").concat(this.code(index, length), \"\\n</pre>\");\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize(context) {\n      _get(_getPrototypeOf(SyntaxCodeBlockContainer.prototype), \"optimize\", this).call(this, context);\n\n      if (this.parent != null && this.children.head != null && this.uiNode != null) {\n        var language = SyntaxCodeBlock.formats(this.children.head.domNode);\n\n        if (language !== this.uiNode.value) {\n          this.uiNode.value = language;\n        }\n      }\n    }\n  }]);\n\n  return SyntaxCodeBlockContainer;\n}(_formats_code__WEBPACK_IMPORTED_MODULE_9__[/* CodeBlockContainer */ \"b\"]);\n\nSyntaxCodeBlockContainer.allowedChildren = [SyntaxCodeBlock];\nSyntaxCodeBlock.requiredContainer = SyntaxCodeBlockContainer;\nSyntaxCodeBlock.allowedChildren = [CodeToken, _blots_cursor__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"], _blots_text__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"], _blots_break__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"]];\n\nvar Syntax = /*#__PURE__*/function (_Module) {\n  _inherits(Syntax, _Module);\n\n  var _super4 = _createSuper(Syntax);\n\n  function Syntax(quill, options) {\n    var _this3;\n\n    _classCallCheck(this, Syntax);\n\n    _this3 = _super4.call(this, quill, options);\n\n    if (_this3.options.hljs == null) {\n      throw new Error('Syntax module requires highlight.js. Please include the library on the page before Quill.');\n    }\n\n    _this3.languages = _this3.options.languages.reduce(function (memo, _ref2) {\n      var key = _ref2.key;\n      memo[key] = true;\n      return memo;\n    }, {});\n    _this3.highlightBlot = _this3.highlightBlot.bind(_assertThisInitialized(_this3));\n\n    _this3.initListener();\n\n    _this3.initTimer();\n\n    return _this3;\n  }\n\n  _createClass(Syntax, [{\n    key: \"initListener\",\n    value: function initListener() {\n      var _this4 = this;\n\n      this.quill.on(_core_quill__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].events.SCROLL_BLOT_MOUNT, function (blot) {\n        if (!(blot instanceof SyntaxCodeBlockContainer)) return;\n\n        var select = _this4.quill.root.ownerDocument.createElement('select');\n\n        _this4.options.languages.forEach(function (_ref3) {\n          var key = _ref3.key,\n              label = _ref3.label;\n          var option = select.ownerDocument.createElement('option');\n          option.textContent = label;\n          option.setAttribute('value', key);\n          select.appendChild(option);\n        });\n\n        select.addEventListener('change', function () {\n          blot.format(SyntaxCodeBlock.blotName, select.value);\n\n          _this4.quill.root.focus(); // Prevent scrolling\n\n\n          _this4.highlight(blot, true);\n        });\n\n        if (blot.uiNode == null) {\n          blot.attachUI(select);\n\n          if (blot.children.head) {\n            select.value = SyntaxCodeBlock.formats(blot.children.head.domNode);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"initTimer\",\n    value: function initTimer() {\n      var _this5 = this;\n\n      var timer = null;\n      this.quill.on(_core_quill__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].events.SCROLL_OPTIMIZE, function () {\n        clearTimeout(timer);\n        timer = setTimeout(function () {\n          _this5.highlight();\n\n          timer = null;\n        }, _this5.options.interval);\n      });\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight() {\n      var _this6 = this;\n\n      var blot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.quill.selection.composing) return;\n      this.quill.update(_core_quill__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.USER);\n      var range = this.quill.getSelection();\n      var blots = blot == null ? this.quill.scroll.descendants(SyntaxCodeBlockContainer) : [blot];\n      blots.forEach(function (container) {\n        container.highlight(_this6.highlightBlot, force);\n      });\n      this.quill.update(_core_quill__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.SILENT);\n\n      if (range != null) {\n        this.quill.setSelection(range, _core_quill__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].sources.SILENT);\n      }\n    }\n  }, {\n    key: \"highlightBlot\",\n    value: function highlightBlot(text) {\n      var language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'plain';\n      language = this.languages[language] ? language : 'plain';\n\n      if (language === 'plain') {\n        return Object(_blots_text__WEBPACK_IMPORTED_MODULE_8__[/* escapeText */ \"b\"])(text).split('\\n').reduce(function (delta, line, i) {\n          if (i !== 0) {\n            delta.insert('\\n', _defineProperty({}, _formats_code__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"c\"].blotName, language));\n          }\n\n          return delta.insert(line);\n        }, new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a());\n      }\n\n      var container = this.quill.root.ownerDocument.createElement('div');\n      container.classList.add(_formats_code__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"c\"].className);\n      container.innerHTML = this.options.hljs.highlight(language, text).value;\n      return Object(_clipboard__WEBPACK_IMPORTED_MODULE_10__[/* traverse */ \"d\"])(this.quill.scroll, container, [function (node, delta) {\n        var value = TokenAttributor.value(node);\n\n        if (value) {\n          return delta.compose(new quill_delta__WEBPACK_IMPORTED_MODULE_0___default.a().retain(delta.length(), _defineProperty({}, CodeToken.blotName, value)));\n        }\n\n        return delta;\n      }], [function (node, delta) {\n        return node.data.split('\\n').reduce(function (memo, nodeText, i) {\n          if (i !== 0) memo.insert('\\n', _defineProperty({}, _formats_code__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"c\"].blotName, language));\n          return memo.insert(nodeText);\n        }, delta);\n      }], new WeakMap());\n    }\n  }], [{\n    key: \"register\",\n    value: function register() {\n      _core_quill__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].register(CodeToken, true);\n      _core_quill__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].register(SyntaxCodeBlock, true);\n      _core_quill__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].register(SyntaxCodeBlockContainer, true);\n    }\n  }]);\n\n  return Syntax;\n}(_core_module__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"]);\n\nSyntax.DEFAULTS = {\n  hljs: function () {\n    if (Object(_utils_has_window__WEBPACK_IMPORTED_MODULE_11__[/* default */ \"a\"])()) {\n      return window.hljs;\n    }\n\n    return null;\n  }(),\n  interval: 1000,\n  languages: [{\n    key: 'plain',\n    label: 'Plain'\n  }, {\n    key: 'bash',\n    label: 'Bash'\n  }, {\n    key: 'cpp',\n    label: 'C++'\n  }, {\n    key: 'cs',\n    label: 'C#'\n  }, {\n    key: 'css',\n    label: 'CSS'\n  }, {\n    key: 'diff',\n    label: 'Diff'\n  }, {\n    key: 'xml',\n    label: 'HTML/XML'\n  }, {\n    key: 'java',\n    label: 'Java'\n  }, {\n    key: 'javascript',\n    label: 'Javascript'\n  }, {\n    key: 'markdown',\n    label: 'Markdown'\n  }, {\n    key: 'php',\n    label: 'PHP'\n  }, {\n    key: 'python',\n    label: 'Python'\n  }, {\n    key: 'ruby',\n    label: 'Ruby'\n  }, {\n    key: 'sql',\n    label: 'SQL'\n  }]\n};\n\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports) {\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nmodule.exports = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- safe\n  return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);\n};\n\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar classof = __webpack_require__(75);\n\nvar String = global.String;\n\nmodule.exports = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return String(argument);\n};\n\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar TO_STRING_TAG_SUPPORT = __webpack_require__(122);\nvar isCallable = __webpack_require__(22);\nvar classofRaw = __webpack_require__(78);\nvar wellKnownSymbol = __webpack_require__(27);\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar Object = global.Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar setGlobal = __webpack_require__(77);\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\nmodule.exports = store;\n\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nmodule.exports = function (key, value) {\n  try {\n    defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar uncurryThis = __webpack_require__(21);\n\nvar toString = uncurryThis({}.toString);\nvar stringSlice = uncurryThis(''.slice);\n\nmodule.exports = function (it) {\n  return stringSlice(toString(it), 8, -1);\n};\n\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar uncurryThis = __webpack_require__(21);\nvar isCallable = __webpack_require__(22);\nvar store = __webpack_require__(76);\n\nvar functionToString = uncurryThis(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toPrimitive = __webpack_require__(126);\nvar isSymbol = __webpack_require__(99);\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar aCallable = __webpack_require__(82);\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable(func);\n};\n\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar isCallable = __webpack_require__(22);\nvar tryToString = __webpack_require__(100);\n\nvar TypeError = global.TypeError;\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw TypeError(tryToString(argument) + ' is not a function');\n};\n\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(92);\nvar uid = __webpack_require__(93);\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(38);\nvar call = __webpack_require__(39);\nvar propertyIsEnumerableModule = __webpack_require__(101);\nvar createPropertyDescriptor = __webpack_require__(67);\nvar toIndexedObject = __webpack_require__(58);\nvar toPropertyKey = __webpack_require__(80);\nvar hasOwn = __webpack_require__(33);\nvar IE8_DOM_DEFINE = __webpack_require__(97);\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar isCallable = __webpack_require__(22);\nvar hasOwn = __webpack_require__(33);\nvar createNonEnumerableProperty = __webpack_require__(66);\nvar setGlobal = __webpack_require__(77);\nvar inspectSource = __webpack_require__(79);\nvar InternalStateModule = __webpack_require__(96);\nvar CONFIGURABLE_FUNCTION_NAME = __webpack_require__(102).CONFIGURABLE;\n\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(String).split('String');\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  var name = options && options.name !== undefined ? options.name : key;\n  var state;\n  if (isCallable(value)) {\n    if (String(name).slice(0, 7) === 'Symbol(') {\n      name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n    }\n    if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n      createNonEnumerableProperty(value, 'name', name);\n    }\n    state = enforceInternalState(value);\n    if (!state.source) {\n      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n    }\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else createNonEnumerableProperty(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, 'toString', function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n});\n\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toLength = __webpack_require__(105);\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nmodule.exports = function (obj) {\n  return toLength(obj.length);\n};\n\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports) {\n\n// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* global ActiveXObject -- old IE, WSH */\nvar anObject = __webpack_require__(37);\nvar defineProperties = __webpack_require__(138);\nvar enumBugKeys = __webpack_require__(88);\nvar hiddenKeys = __webpack_require__(84);\nvar html = __webpack_require__(139);\nvar documentCreateElement = __webpack_require__(98);\nvar sharedKey = __webpack_require__(83);\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : defineProperties(result, Properties);\n};\n\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Iterator_1 = __importDefault(__webpack_require__(116));\nvar Op;\n(function (Op) {\n    function iterator(ops) {\n        return new Iterator_1.default(ops);\n    }\n    Op.iterator = iterator;\n    function length(op) {\n        if (typeof op.delete === 'number') {\n            return op.delete;\n        }\n        else if (typeof op.retain === 'number') {\n            return op.retain;\n        }\n        else {\n            return typeof op.insert === 'string' ? op.insert.length : 1;\n        }\n    }\n    Op.length = length;\n})(Op || (Op = {}));\nexports.default = Op;\n\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar IS_PURE = __webpack_require__(63);\nvar store = __webpack_require__(76);\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.19.1',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'\n});\n\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar uncurryThis = __webpack_require__(21);\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString = uncurryThis(1.0.toString);\n\nmodule.exports = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n};\n\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = __webpack_require__(123);\nvar fails = __webpack_require__(36);\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = __webpack_require__(94);\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar NATIVE_WEAK_MAP = __webpack_require__(125);\nvar global = __webpack_require__(10);\nvar uncurryThis = __webpack_require__(21);\nvar isObject = __webpack_require__(48);\nvar createNonEnumerableProperty = __webpack_require__(66);\nvar hasOwn = __webpack_require__(33);\nvar shared = __webpack_require__(76);\nvar sharedKey = __webpack_require__(83);\nvar hiddenKeys = __webpack_require__(84);\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError = global.TypeError;\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = uncurryThis(store.get);\n  var wmhas = uncurryThis(store.has);\n  var wmset = uncurryThis(store.set);\n  set = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(38);\nvar fails = __webpack_require__(36);\nvar createElement = __webpack_require__(98);\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar isObject = __webpack_require__(48);\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar getBuiltIn = __webpack_require__(56);\nvar isCallable = __webpack_require__(22);\nvar isPrototypeOf = __webpack_require__(127);\nvar USE_SYMBOL_AS_UID = __webpack_require__(95);\n\nvar Object = global.Object;\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn('Symbol');\n  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object(it));\n};\n\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\n\nvar String = global.String;\n\nmodule.exports = function (argument) {\n  try {\n    return String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(38);\nvar hasOwn = __webpack_require__(33);\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar uncurryThis = __webpack_require__(21);\nvar hasOwn = __webpack_require__(33);\nvar toIndexedObject = __webpack_require__(58);\nvar indexOf = __webpack_require__(134).indexOf;\nvar hiddenKeys = __webpack_require__(84);\n\nvar push = uncurryThis([].push);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toIntegerOrInfinity = __webpack_require__(73);\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toIntegerOrInfinity(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toIntegerOrInfinity = __webpack_require__(73);\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar fails = __webpack_require__(36);\nvar isCallable = __webpack_require__(22);\nvar create = __webpack_require__(89);\nvar getPrototypeOf = __webpack_require__(108);\nvar redefine = __webpack_require__(86);\nvar wellKnownSymbol = __webpack_require__(27);\nvar IS_PURE = __webpack_require__(63);\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar BUGGY_SAFARI_ITERATORS = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype[ITERATOR].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\nelse if (IS_PURE) IteratorPrototype = create(IteratorPrototype);\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable(IteratorPrototype[ITERATOR])) {\n  redefine(IteratorPrototype, ITERATOR, function () {\n    return this;\n  });\n}\n\nmodule.exports = {\n  IteratorPrototype: IteratorPrototype,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\n\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar internalObjectKeys = __webpack_require__(103);\nvar enumBugKeys = __webpack_require__(88);\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es/no-object-keys -- safe\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar hasOwn = __webpack_require__(33);\nvar isCallable = __webpack_require__(22);\nvar toObject = __webpack_require__(64);\nvar sharedKey = __webpack_require__(83);\nvar CORRECT_PROTOTYPE_GETTER = __webpack_require__(140);\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar Object = global.Object;\nvar ObjectPrototype = Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {\n  var object = toObject(O);\n  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof Object ? ObjectPrototype : null;\n};\n\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar defineProperty = __webpack_require__(49).f;\nvar hasOwn = __webpack_require__(33);\nvar wellKnownSymbol = __webpack_require__(27);\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\nmodule.exports = function (it, TAG, STATIC) {\n  if (it && !hasOwn(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });\n  }\n};\n\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof = __webpack_require__(75);\nvar getMethod = __webpack_require__(81);\nvar Iterators = __webpack_require__(68);\nvar wellKnownSymbol = __webpack_require__(27);\n\nvar ITERATOR = wellKnownSymbol('iterator');\n\nmodule.exports = function (it) {\n  if (it != undefined) return getMethod(it, ITERATOR)\n    || getMethod(it, '@@iterator')\n    || Iterators[classof(it)];\n};\n\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\n\nmodule.exports = global;\n\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar uncurryThis = __webpack_require__(21);\n\nmodule.exports = function (CONSTRUCTOR, METHOD) {\n  return uncurryThis(global[CONSTRUCTOR].prototype[METHOD]);\n};\n\n\n/***/ }),\n/* 113 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/core-js/features/array/from.js\nvar from = __webpack_require__(117);\n\n// EXTERNAL MODULE: ./node_modules/core-js/features/array/fill.js\nvar fill = __webpack_require__(153);\n\n// EXTERNAL MODULE: ./node_modules/core-js/features/object/values.js\nvar values = __webpack_require__(159);\n\n// EXTERNAL MODULE: ./node_modules/core-js/features/string/ends-with.js\nvar ends_with = __webpack_require__(164);\n\n// CONCATENATED MODULE: ./polyfills.js\n// IE11 support\r\n\r\n\r\n\r\n\r\n\n// EXTERNAL MODULE: ./core.js\nvar core = __webpack_require__(25);\n\n// EXTERNAL MODULE: ./formats/align.js\nvar align = __webpack_require__(35);\n\n// EXTERNAL MODULE: ./formats/direction.js\nvar direction = __webpack_require__(32);\n\n// EXTERNAL MODULE: ./node_modules/parchment/src/parchment.ts + 17 modules\nvar parchment = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./formats/indent.js\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar IndentAttributor = /*#__PURE__*/function (_ClassAttributor) {\n  _inherits(IndentAttributor, _ClassAttributor);\n\n  var _super = _createSuper(IndentAttributor);\n\n  function IndentAttributor() {\n    _classCallCheck(this, IndentAttributor);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(IndentAttributor, [{\n    key: \"add\",\n    value: function add(node, value) {\n      if (value === '+1' || value === '-1') {\n        var indent = this.value(node) || 0;\n        value = value === '+1' ? indent + 1 : indent - 1;\n      }\n\n      if (value === 0) {\n        this.remove(node);\n        return true;\n      }\n\n      return _get(_getPrototypeOf(IndentAttributor.prototype), \"add\", this).call(this, node, value);\n    }\n  }, {\n    key: \"canAdd\",\n    value: function canAdd(node, value) {\n      return _get(_getPrototypeOf(IndentAttributor.prototype), \"canAdd\", this).call(this, node, value) || _get(_getPrototypeOf(IndentAttributor.prototype), \"canAdd\", this).call(this, node, parseInt(value, 10));\n    }\n  }, {\n    key: \"value\",\n    value: function value(node) {\n      return parseInt(_get(_getPrototypeOf(IndentAttributor.prototype), \"value\", this).call(this, node), 10) || undefined; // Don't return NaN\n    }\n  }]);\n\n  return IndentAttributor;\n}(parchment[\"ClassAttributor\"]);\n\nvar IndentClass = new IndentAttributor('indent', 'ql-indent', {\n  scope: parchment[\"Scope\"].BLOCK,\n  whitelist: [1, 2, 3, 4, 5, 6, 7, 8]\n});\n/* harmony default export */ var indent = (IndentClass);\n// EXTERNAL MODULE: ./blots/block.js\nvar block = __webpack_require__(6);\n\n// CONCATENATED MODULE: ./formats/blockquote.js\nfunction blockquote_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { blockquote_typeof = function _typeof(obj) { return typeof obj; }; } else { blockquote_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return blockquote_typeof(obj); }\n\nfunction blockquote_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction blockquote_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) blockquote_setPrototypeOf(subClass, superClass); }\n\nfunction blockquote_setPrototypeOf(o, p) { blockquote_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return blockquote_setPrototypeOf(o, p); }\n\nfunction blockquote_createSuper(Derived) { var hasNativeReflectConstruct = blockquote_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = blockquote_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = blockquote_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return blockquote_possibleConstructorReturn(this, result); }; }\n\nfunction blockquote_possibleConstructorReturn(self, call) { if (call && (blockquote_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return blockquote_assertThisInitialized(self); }\n\nfunction blockquote_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction blockquote_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction blockquote_getPrototypeOf(o) { blockquote_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return blockquote_getPrototypeOf(o); }\n\n\n\nvar Blockquote = /*#__PURE__*/function (_Block) {\n  blockquote_inherits(Blockquote, _Block);\n\n  var _super = blockquote_createSuper(Blockquote);\n\n  function Blockquote() {\n    blockquote_classCallCheck(this, Blockquote);\n\n    return _super.apply(this, arguments);\n  }\n\n  return Blockquote;\n}(block[\"d\" /* default */]);\n\nBlockquote.blotName = 'blockquote';\nBlockquote.tagName = 'blockquote';\n/* harmony default export */ var blockquote = (Blockquote);\n// CONCATENATED MODULE: ./formats/header.js\nfunction header_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { header_typeof = function _typeof(obj) { return typeof obj; }; } else { header_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return header_typeof(obj); }\n\nfunction header_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction header_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction header_createClass(Constructor, protoProps, staticProps) { if (protoProps) header_defineProperties(Constructor.prototype, protoProps); if (staticProps) header_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction header_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) header_setPrototypeOf(subClass, superClass); }\n\nfunction header_setPrototypeOf(o, p) { header_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return header_setPrototypeOf(o, p); }\n\nfunction header_createSuper(Derived) { var hasNativeReflectConstruct = header_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = header_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = header_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return header_possibleConstructorReturn(this, result); }; }\n\nfunction header_possibleConstructorReturn(self, call) { if (call && (header_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return header_assertThisInitialized(self); }\n\nfunction header_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction header_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction header_getPrototypeOf(o) { header_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return header_getPrototypeOf(o); }\n\n\n\nvar Header = /*#__PURE__*/function (_Block) {\n  header_inherits(Header, _Block);\n\n  var _super = header_createSuper(Header);\n\n  function Header() {\n    header_classCallCheck(this, Header);\n\n    return _super.apply(this, arguments);\n  }\n\n  header_createClass(Header, null, [{\n    key: \"formats\",\n    value: function formats(domNode) {\n      return this.tagName.indexOf(domNode.tagName) + 1;\n    }\n  }]);\n\n  return Header;\n}(block[\"d\" /* default */]);\n\nHeader.blotName = 'header';\nHeader.tagName = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];\n/* harmony default export */ var header = (Header);\n// EXTERNAL MODULE: ./blots/container.js\nvar container = __webpack_require__(15);\n\n// EXTERNAL MODULE: ./core/quill.js\nvar core_quill = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./formats/list.js\nfunction list_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { list_typeof = function _typeof(obj) { return typeof obj; }; } else { list_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return list_typeof(obj); }\n\nfunction list_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction list_createClass(Constructor, protoProps, staticProps) { if (protoProps) list_defineProperties(Constructor.prototype, protoProps); if (staticProps) list_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction list_get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { list_get = Reflect.get; } else { list_get = function _get(target, property, receiver) { var base = list_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return list_get(target, property, receiver || target); }\n\nfunction list_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = list_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction list_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction list_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) list_setPrototypeOf(subClass, superClass); }\n\nfunction list_setPrototypeOf(o, p) { list_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return list_setPrototypeOf(o, p); }\n\nfunction list_createSuper(Derived) { var hasNativeReflectConstruct = list_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = list_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = list_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return list_possibleConstructorReturn(this, result); }; }\n\nfunction list_possibleConstructorReturn(self, call) { if (call && (list_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return list_assertThisInitialized(self); }\n\nfunction list_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction list_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction list_getPrototypeOf(o) { list_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return list_getPrototypeOf(o); }\n\n\n\n\n\nvar ListContainer = /*#__PURE__*/function (_Container) {\n  list_inherits(ListContainer, _Container);\n\n  var _super = list_createSuper(ListContainer);\n\n  function ListContainer() {\n    list_classCallCheck(this, ListContainer);\n\n    return _super.apply(this, arguments);\n  }\n\n  return ListContainer;\n}(container[\"a\" /* default */]);\n\nListContainer.blotName = 'list-container';\nListContainer.tagName = 'OL';\n\nvar list_ListItem = /*#__PURE__*/function (_Block) {\n  list_inherits(ListItem, _Block);\n\n  var _super2 = list_createSuper(ListItem);\n\n  function ListItem(scroll, domNode) {\n    var _this;\n\n    list_classCallCheck(this, ListItem);\n\n    _this = _super2.call(this, scroll, domNode);\n    var ui = domNode.ownerDocument.createElement('span');\n\n    var listEventHandler = function listEventHandler(e) {\n      if (!scroll.isEnabled()) return;\n\n      var format = _this.statics.formats(domNode, scroll);\n\n      if (format === 'checked') {\n        _this.format('list', 'unchecked');\n\n        e.preventDefault();\n      } else if (format === 'unchecked') {\n        _this.format('list', 'checked');\n\n        e.preventDefault();\n      }\n    };\n\n    ui.addEventListener('mousedown', listEventHandler);\n    ui.addEventListener('touchstart', listEventHandler);\n\n    _this.attachUI(ui);\n\n    return _this;\n  }\n\n  list_createClass(ListItem, [{\n    key: \"format\",\n    value: function format(name, value) {\n      if (name === this.statics.blotName && value) {\n        this.domNode.setAttribute('data-list', value);\n      } else {\n        list_get(list_getPrototypeOf(ListItem.prototype), \"format\", this).call(this, name, value);\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var node = list_get(list_getPrototypeOf(ListItem), \"create\", this).call(this);\n\n      node.setAttribute('data-list', value);\n      return node;\n    }\n  }, {\n    key: \"formats\",\n    value: function formats(domNode) {\n      return domNode.getAttribute('data-list') || undefined;\n    }\n  }, {\n    key: \"register\",\n    value: function register() {\n      core_quill[\"a\" /* default */].register(ListContainer);\n    }\n  }]);\n\n  return ListItem;\n}(block[\"d\" /* default */]);\n\nlist_ListItem.blotName = 'list';\nlist_ListItem.tagName = 'LI';\nListContainer.allowedChildren = [list_ListItem];\nlist_ListItem.requiredContainer = ListContainer;\n\n// EXTERNAL MODULE: ./formats/background.js\nvar background = __webpack_require__(42);\n\n// EXTERNAL MODULE: ./formats/color.js\nvar color = __webpack_require__(31);\n\n// EXTERNAL MODULE: ./formats/font.js\nvar font = __webpack_require__(43);\n\n// EXTERNAL MODULE: ./formats/size.js\nvar size = __webpack_require__(44);\n\n// EXTERNAL MODULE: ./formats/bold.js\nvar bold = __webpack_require__(46);\n\n// CONCATENATED MODULE: ./formats/italic.js\nfunction italic_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { italic_typeof = function _typeof(obj) { return typeof obj; }; } else { italic_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return italic_typeof(obj); }\n\nfunction italic_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction italic_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) italic_setPrototypeOf(subClass, superClass); }\n\nfunction italic_setPrototypeOf(o, p) { italic_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return italic_setPrototypeOf(o, p); }\n\nfunction italic_createSuper(Derived) { var hasNativeReflectConstruct = italic_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = italic_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = italic_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return italic_possibleConstructorReturn(this, result); }; }\n\nfunction italic_possibleConstructorReturn(self, call) { if (call && (italic_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return italic_assertThisInitialized(self); }\n\nfunction italic_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction italic_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction italic_getPrototypeOf(o) { italic_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return italic_getPrototypeOf(o); }\n\n\n\nvar Italic = /*#__PURE__*/function (_Bold) {\n  italic_inherits(Italic, _Bold);\n\n  var _super = italic_createSuper(Italic);\n\n  function Italic() {\n    italic_classCallCheck(this, Italic);\n\n    return _super.apply(this, arguments);\n  }\n\n  return Italic;\n}(bold[\"a\" /* default */]);\n\nItalic.blotName = 'italic';\nItalic.tagName = ['EM', 'I'];\n/* harmony default export */ var italic = (Italic);\n// EXTERNAL MODULE: ./formats/link.js\nvar formats_link = __webpack_require__(40);\n\n// EXTERNAL MODULE: ./blots/inline.js\nvar inline = __webpack_require__(16);\n\n// CONCATENATED MODULE: ./formats/script.js\nfunction script_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { script_typeof = function _typeof(obj) { return typeof obj; }; } else { script_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return script_typeof(obj); }\n\nfunction script_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction script_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction script_createClass(Constructor, protoProps, staticProps) { if (protoProps) script_defineProperties(Constructor.prototype, protoProps); if (staticProps) script_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction script_get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { script_get = Reflect.get; } else { script_get = function _get(target, property, receiver) { var base = script_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return script_get(target, property, receiver || target); }\n\nfunction script_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = script_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction script_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) script_setPrototypeOf(subClass, superClass); }\n\nfunction script_setPrototypeOf(o, p) { script_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return script_setPrototypeOf(o, p); }\n\nfunction script_createSuper(Derived) { var hasNativeReflectConstruct = script_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = script_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = script_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return script_possibleConstructorReturn(this, result); }; }\n\nfunction script_possibleConstructorReturn(self, call) { if (call && (script_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return script_assertThisInitialized(self); }\n\nfunction script_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction script_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction script_getPrototypeOf(o) { script_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return script_getPrototypeOf(o); }\n\n\n\nvar Script = /*#__PURE__*/function (_Inline) {\n  script_inherits(Script, _Inline);\n\n  var _super = script_createSuper(Script);\n\n  function Script() {\n    script_classCallCheck(this, Script);\n\n    return _super.apply(this, arguments);\n  }\n\n  script_createClass(Script, null, [{\n    key: \"create\",\n    value: function create(value) {\n      if (value === 'super') {\n        return document.createElement('sup');\n      }\n\n      if (value === 'sub') {\n        return document.createElement('sub');\n      }\n\n      return script_get(script_getPrototypeOf(Script), \"create\", this).call(this, value);\n    }\n  }, {\n    key: \"formats\",\n    value: function formats(domNode) {\n      if (domNode.tagName === 'SUB') return 'sub';\n      if (domNode.tagName === 'SUP') return 'super';\n      return undefined;\n    }\n  }]);\n\n  return Script;\n}(inline[\"a\" /* default */]);\n\nScript.blotName = 'script';\nScript.tagName = ['SUB', 'SUP'];\n/* harmony default export */ var script = (Script);\n// CONCATENATED MODULE: ./formats/strike.js\nfunction strike_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { strike_typeof = function _typeof(obj) { return typeof obj; }; } else { strike_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return strike_typeof(obj); }\n\nfunction strike_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction strike_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) strike_setPrototypeOf(subClass, superClass); }\n\nfunction strike_setPrototypeOf(o, p) { strike_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return strike_setPrototypeOf(o, p); }\n\nfunction strike_createSuper(Derived) { var hasNativeReflectConstruct = strike_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = strike_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = strike_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return strike_possibleConstructorReturn(this, result); }; }\n\nfunction strike_possibleConstructorReturn(self, call) { if (call && (strike_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return strike_assertThisInitialized(self); }\n\nfunction strike_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction strike_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction strike_getPrototypeOf(o) { strike_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return strike_getPrototypeOf(o); }\n\n\n\nvar Strike = /*#__PURE__*/function (_Bold) {\n  strike_inherits(Strike, _Bold);\n\n  var _super = strike_createSuper(Strike);\n\n  function Strike() {\n    strike_classCallCheck(this, Strike);\n\n    return _super.apply(this, arguments);\n  }\n\n  return Strike;\n}(bold[\"a\" /* default */]);\n\nStrike.blotName = 'strike';\nStrike.tagName = ['S', 'STRIKE'];\n/* harmony default export */ var strike = (Strike);\n// CONCATENATED MODULE: ./formats/underline.js\nfunction underline_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { underline_typeof = function _typeof(obj) { return typeof obj; }; } else { underline_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return underline_typeof(obj); }\n\nfunction underline_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction underline_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) underline_setPrototypeOf(subClass, superClass); }\n\nfunction underline_setPrototypeOf(o, p) { underline_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return underline_setPrototypeOf(o, p); }\n\nfunction underline_createSuper(Derived) { var hasNativeReflectConstruct = underline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = underline_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = underline_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return underline_possibleConstructorReturn(this, result); }; }\n\nfunction underline_possibleConstructorReturn(self, call) { if (call && (underline_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return underline_assertThisInitialized(self); }\n\nfunction underline_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction underline_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction underline_getPrototypeOf(o) { underline_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return underline_getPrototypeOf(o); }\n\n\n\nvar Underline = /*#__PURE__*/function (_Inline) {\n  underline_inherits(Underline, _Inline);\n\n  var _super = underline_createSuper(Underline);\n\n  function Underline() {\n    underline_classCallCheck(this, Underline);\n\n    return _super.apply(this, arguments);\n  }\n\n  return Underline;\n}(inline[\"a\" /* default */]);\n\nUnderline.blotName = 'underline';\nUnderline.tagName = 'U';\n/* harmony default export */ var underline = (Underline);\n// EXTERNAL MODULE: ./blots/embed.js\nvar blots_embed = __webpack_require__(59);\n\n// EXTERNAL MODULE: ./utils/has_window.js\nvar has_window = __webpack_require__(17);\n\n// CONCATENATED MODULE: ./formats/formula.js\nfunction formula_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { formula_typeof = function _typeof(obj) { return typeof obj; }; } else { formula_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return formula_typeof(obj); }\n\nfunction formula_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction formula_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction formula_createClass(Constructor, protoProps, staticProps) { if (protoProps) formula_defineProperties(Constructor.prototype, protoProps); if (staticProps) formula_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction formula_get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { formula_get = Reflect.get; } else { formula_get = function _get(target, property, receiver) { var base = formula_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return formula_get(target, property, receiver || target); }\n\nfunction formula_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = formula_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction formula_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) formula_setPrototypeOf(subClass, superClass); }\n\nfunction formula_setPrototypeOf(o, p) { formula_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return formula_setPrototypeOf(o, p); }\n\nfunction formula_createSuper(Derived) { var hasNativeReflectConstruct = formula_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = formula_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = formula_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return formula_possibleConstructorReturn(this, result); }; }\n\nfunction formula_possibleConstructorReturn(self, call) { if (call && (formula_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return formula_assertThisInitialized(self); }\n\nfunction formula_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction formula_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction formula_getPrototypeOf(o) { formula_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return formula_getPrototypeOf(o); }\n\n\n\n\nvar formula_Formula = /*#__PURE__*/function (_Embed) {\n  formula_inherits(Formula, _Embed);\n\n  var _super = formula_createSuper(Formula);\n\n  function Formula() {\n    formula_classCallCheck(this, Formula);\n\n    return _super.apply(this, arguments);\n  }\n\n  formula_createClass(Formula, [{\n    key: \"html\",\n    value: function html() {\n      var _this$value = this.value(),\n          formula = _this$value.formula;\n\n      return \"<span>\".concat(formula, \"</span>\");\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var katex = null;\n\n      if (Object(has_window[\"a\" /* default */])()) {\n        katex = window.katex;\n      }\n\n      if (katex == null) {\n        throw new Error('Formula module requires KaTeX.');\n      }\n\n      var node = formula_get(formula_getPrototypeOf(Formula), \"create\", this).call(this, value);\n\n      if (typeof value === 'string') {\n        katex.render(value, node, {\n          throwOnError: false,\n          errorColor: '#f00'\n        });\n        node.setAttribute('data-value', value);\n      }\n\n      return node;\n    }\n  }, {\n    key: \"value\",\n    value: function value(domNode) {\n      return domNode.getAttribute('data-value');\n    }\n  }]);\n\n  return Formula;\n}(blots_embed[\"a\" /* default */]);\n\nformula_Formula.blotName = 'formula';\nformula_Formula.className = 'ql-formula';\nformula_Formula.tagName = 'SPAN';\n/* harmony default export */ var formula = (formula_Formula);\n// CONCATENATED MODULE: ./formats/image.js\nfunction image_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { image_typeof = function _typeof(obj) { return typeof obj; }; } else { image_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return image_typeof(obj); }\n\nfunction image_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction image_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction image_createClass(Constructor, protoProps, staticProps) { if (protoProps) image_defineProperties(Constructor.prototype, protoProps); if (staticProps) image_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction image_get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { image_get = Reflect.get; } else { image_get = function _get(target, property, receiver) { var base = image_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return image_get(target, property, receiver || target); }\n\nfunction image_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = image_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction image_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) image_setPrototypeOf(subClass, superClass); }\n\nfunction image_setPrototypeOf(o, p) { image_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return image_setPrototypeOf(o, p); }\n\nfunction image_createSuper(Derived) { var hasNativeReflectConstruct = image_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = image_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = image_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return image_possibleConstructorReturn(this, result); }; }\n\nfunction image_possibleConstructorReturn(self, call) { if (call && (image_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return image_assertThisInitialized(self); }\n\nfunction image_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction image_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction image_getPrototypeOf(o) { image_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return image_getPrototypeOf(o); }\n\n\n\n\nvar ATTRIBUTES = ['alt', 'height', 'width'];\n\nvar image_Image = /*#__PURE__*/function (_EmbedBlot) {\n  image_inherits(Image, _EmbedBlot);\n\n  var _super = image_createSuper(Image);\n\n  function Image() {\n    image_classCallCheck(this, Image);\n\n    return _super.apply(this, arguments);\n  }\n\n  image_createClass(Image, [{\n    key: \"format\",\n    value: function format(name, value) {\n      if (ATTRIBUTES.indexOf(name) > -1) {\n        if (value) {\n          this.domNode.setAttribute(name, value);\n        } else {\n          this.domNode.removeAttribute(name);\n        }\n      } else {\n        image_get(image_getPrototypeOf(Image.prototype), \"format\", this).call(this, name, value);\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var node = image_get(image_getPrototypeOf(Image), \"create\", this).call(this, value);\n\n      if (typeof value === 'string') {\n        node.setAttribute('src', this.sanitize(value));\n      }\n\n      return node;\n    }\n  }, {\n    key: \"formats\",\n    value: function formats(domNode) {\n      return ATTRIBUTES.reduce(function (formats, attribute) {\n        if (domNode.hasAttribute(attribute)) {\n          formats[attribute] = domNode.getAttribute(attribute);\n        }\n\n        return formats;\n      }, {});\n    }\n  }, {\n    key: \"match\",\n    value: function match(url) {\n      return /\\.(jpe?g|gif|png)$/.test(url) || /^data:image\\/.+;base64/.test(url);\n    }\n  }, {\n    key: \"register\",\n    value: function register() {\n      if (Object(has_window[\"a\" /* default */])() && /Firefox/i.test(navigator.userAgent)) {\n        setTimeout(function () {\n          // Disable image resizing in Firefox\n          document.execCommand('enableObjectResizing', false, false);\n        }, 1);\n      }\n    }\n  }, {\n    key: \"sanitize\",\n    value: function sanitize(url) {\n      return Object(formats_link[\"b\" /* sanitize */])(url, ['http', 'https', 'data']) ? url : '//:0';\n    }\n  }, {\n    key: \"value\",\n    value: function value(domNode) {\n      return domNode.getAttribute('src');\n    }\n  }]);\n\n  return Image;\n}(parchment[\"EmbedBlot\"]);\n\nimage_Image.blotName = 'image';\nimage_Image.tagName = 'IMG';\n/* harmony default export */ var formats_image = (image_Image);\n// CONCATENATED MODULE: ./formats/video.js\nfunction video_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { video_typeof = function _typeof(obj) { return typeof obj; }; } else { video_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return video_typeof(obj); }\n\nfunction video_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction video_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction video_createClass(Constructor, protoProps, staticProps) { if (protoProps) video_defineProperties(Constructor.prototype, protoProps); if (staticProps) video_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction video_get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { video_get = Reflect.get; } else { video_get = function _get(target, property, receiver) { var base = video_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return video_get(target, property, receiver || target); }\n\nfunction video_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = video_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction video_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) video_setPrototypeOf(subClass, superClass); }\n\nfunction video_setPrototypeOf(o, p) { video_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return video_setPrototypeOf(o, p); }\n\nfunction video_createSuper(Derived) { var hasNativeReflectConstruct = video_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = video_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = video_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return video_possibleConstructorReturn(this, result); }; }\n\nfunction video_possibleConstructorReturn(self, call) { if (call && (video_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return video_assertThisInitialized(self); }\n\nfunction video_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction video_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction video_getPrototypeOf(o) { video_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return video_getPrototypeOf(o); }\n\n\n\nvar video_ATTRIBUTES = ['height', 'width'];\n\nvar video_Video = /*#__PURE__*/function (_BlockEmbed) {\n  video_inherits(Video, _BlockEmbed);\n\n  var _super = video_createSuper(Video);\n\n  function Video() {\n    video_classCallCheck(this, Video);\n\n    return _super.apply(this, arguments);\n  }\n\n  video_createClass(Video, [{\n    key: \"format\",\n    value: function format(name, value) {\n      if (video_ATTRIBUTES.indexOf(name) > -1) {\n        if (value) {\n          this.domNode.setAttribute(name, value);\n        } else {\n          this.domNode.removeAttribute(name);\n        }\n      } else {\n        video_get(video_getPrototypeOf(Video.prototype), \"format\", this).call(this, name, value);\n      }\n    }\n  }, {\n    key: \"html\",\n    value: function html() {\n      var _this$value = this.value(),\n          video = _this$value.video;\n\n      return \"<a href=\\\"\".concat(video, \"\\\">\").concat(video, \"</a>\");\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      var node = video_get(video_getPrototypeOf(Video), \"create\", this).call(this, value);\n\n      node.setAttribute('frameborder', '0');\n      node.setAttribute('allowfullscreen', true);\n      node.setAttribute('src', this.sanitize(value));\n      return node;\n    }\n  }, {\n    key: \"formats\",\n    value: function formats(domNode) {\n      return video_ATTRIBUTES.reduce(function (formats, attribute) {\n        if (domNode.hasAttribute(attribute)) {\n          formats[attribute] = domNode.getAttribute(attribute);\n        }\n\n        return formats;\n      }, {});\n    }\n  }, {\n    key: \"sanitize\",\n    value: function sanitize(url) {\n      return formats_link[\"a\" /* default */].sanitize(url); // eslint-disable-line import/no-named-as-default-member\n    }\n  }, {\n    key: \"value\",\n    value: function value(domNode) {\n      return domNode.getAttribute('src');\n    }\n  }]);\n\n  return Video;\n}(block[\"a\" /* BlockEmbed */]);\n\nvideo_Video.blotName = 'video';\nvideo_Video.className = 'ql-video';\nvideo_Video.tagName = 'IFRAME';\n/* harmony default export */ var video = (video_Video);\n// EXTERNAL MODULE: ./formats/code.js\nvar code = __webpack_require__(19);\n\n// EXTERNAL MODULE: ./modules/syntax.js\nvar syntax = __webpack_require__(72);\n\n// EXTERNAL MODULE: ./modules/table/index.js + 1 modules\nvar table = __webpack_require__(62);\n\n// EXTERNAL MODULE: ./node_modules/quill-delta/dist/Delta.js\nvar Delta = __webpack_require__(1);\nvar Delta_default = /*#__PURE__*/__webpack_require__.n(Delta);\n\n// CONCATENATED MODULE: ./blots/multiline_break.js\nfunction multiline_break_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { multiline_break_typeof = function _typeof(obj) { return typeof obj; }; } else { multiline_break_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return multiline_break_typeof(obj); }\n\nfunction multiline_break_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction multiline_break_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction multiline_break_createClass(Constructor, protoProps, staticProps) { if (protoProps) multiline_break_defineProperties(Constructor.prototype, protoProps); if (staticProps) multiline_break_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction multiline_break_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) multiline_break_setPrototypeOf(subClass, superClass); }\n\nfunction multiline_break_setPrototypeOf(o, p) { multiline_break_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return multiline_break_setPrototypeOf(o, p); }\n\nfunction multiline_break_createSuper(Derived) { var hasNativeReflectConstruct = multiline_break_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = multiline_break_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = multiline_break_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return multiline_break_possibleConstructorReturn(this, result); }; }\n\nfunction multiline_break_possibleConstructorReturn(self, call) { if (call && (multiline_break_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return multiline_break_assertThisInitialized(self); }\n\nfunction multiline_break_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction multiline_break_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction multiline_break_getPrototypeOf(o) { multiline_break_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return multiline_break_getPrototypeOf(o); }\n\n\n\nvar MultilineBreak = /*#__PURE__*/function (_EmbedBlot) {\n  multiline_break_inherits(MultilineBreak, _EmbedBlot);\n\n  var _super = multiline_break_createSuper(MultilineBreak);\n\n  function MultilineBreak() {\n    multiline_break_classCallCheck(this, MultilineBreak);\n\n    return _super.apply(this, arguments);\n  }\n\n  multiline_break_createClass(MultilineBreak, [{\n    key: \"length\",\n    value: function length() {\n      return 1;\n    }\n  }, {\n    key: \"value\",\n    value: function value() {\n      return '\\n';\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize() {\n      if (!this.prev && !this.next) {\n        this.remove();\n      }\n    }\n  }], [{\n    key: \"value\",\n    value: function value() {\n      return '\\n';\n    }\n  }]);\n\n  return MultilineBreak;\n}(parchment[\"EmbedBlot\"]);\n\nMultilineBreak.blotName = 'multilineBreak';\nMultilineBreak.tagName = 'BR';\n/* harmony default export */ var multiline_break = (MultilineBreak);\n// EXTERNAL MODULE: ./core/module.js\nvar core_module = __webpack_require__(14);\n\n// CONCATENATED MODULE: ./modules/multiline.js\nfunction multiline_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { multiline_typeof = function _typeof(obj) { return typeof obj; }; } else { multiline_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return multiline_typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction multiline_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction multiline_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction multiline_createClass(Constructor, protoProps, staticProps) { if (protoProps) multiline_defineProperties(Constructor.prototype, protoProps); if (staticProps) multiline_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction multiline_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) multiline_setPrototypeOf(subClass, superClass); }\n\nfunction multiline_setPrototypeOf(o, p) { multiline_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return multiline_setPrototypeOf(o, p); }\n\nfunction multiline_createSuper(Derived) { var hasNativeReflectConstruct = multiline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = multiline_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = multiline_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return multiline_possibleConstructorReturn(this, result); }; }\n\nfunction multiline_possibleConstructorReturn(self, call) { if (call && (multiline_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return multiline_assertThisInitialized(self); }\n\nfunction multiline_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction multiline_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction multiline_getPrototypeOf(o) { multiline_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return multiline_getPrototypeOf(o); }\n\n\n\n\n\n\nfunction breakMatcher(node) {\n  if (!node.nextSibling && !node.previousSibling) {\n    return new Delta_default.a().insert('\\n');\n  }\n\n  return new Delta_default.a().insert({\n    multilineBreak: ''\n  });\n}\n\nvar multiline_Multiline = /*#__PURE__*/function (_Module) {\n  multiline_inherits(Multiline, _Module);\n\n  var _super = multiline_createSuper(Multiline);\n\n  function Multiline(quill, options) {\n    var _this;\n\n    multiline_classCallCheck(this, Multiline);\n\n    var path = 'blots/multilineBreak';\n    _this = _super.call(this, quill, options);\n    core_quill[\"a\" /* default */].register(_defineProperty({}, path, multiline_break), true);\n    quill.keyboard.addBinding({\n      key: 'enter',\n      shiftKey: true\n    }, _this.enterHandler.bind(multiline_assertThisInitialized(_this)));\n    quill.keyboard.bindings.enter.unshift(quill.keyboard.bindings.enter.pop());\n    quill.clipboard.addMatcher('BR', breakMatcher);\n    return _this;\n  }\n\n  multiline_createClass(Multiline, [{\n    key: \"enterHandler\",\n    value: function enterHandler(range) {\n      var currentLeaf = this.quill.getLeaf(range.index)[0];\n      var nextLeaf = this.quill.getLeaf(range.index + 1)[0];\n      this.quill.insertEmbed(range.index, 'multilineBreak', true, 'user');\n\n      if (nextLeaf === null || currentLeaf.parent !== nextLeaf.parent) {\n        this.quill.insertEmbed(range.index, 'multilineBreak', true, 'user');\n      }\n\n      this.quill.setSelection(range.index + 1, core_quill[\"a\" /* default */].sources.SILENT);\n    }\n  }]);\n\n  return Multiline;\n}(core_module[\"a\" /* default */]);\n\n/* harmony default export */ var multiline = (multiline_Multiline);\n// EXTERNAL MODULE: ./modules/table/lite.js + 4 modules\nvar lite = __webpack_require__(71);\n\n// EXTERNAL MODULE: ./formats/table/attributors/cell.js\nvar cell = __webpack_require__(9);\n\n// EXTERNAL MODULE: ./formats/table/attributors/table.js\nvar attributors_table = __webpack_require__(8);\n\n// CONCATENATED MODULE: ./quill.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncore[\"default\"].register({\n  'attributors/attribute/direction': direction[\"a\" /* DirectionAttribute */],\n  'attributors/attribute/tableWidth': attributors_table[\"k\" /* TableWidthAttribute */],\n  'attributors/attribute/tableHeight': attributors_table[\"h\" /* TableHeightAttribute */],\n  'attributors/attribute/cellWidth': cell[\"q\" /* CellWidthAttribute */],\n  'attributors/attribute/cellHeight': cell[\"h\" /* CellHeightAttribute */],\n  'attributors/class/align': align[\"b\" /* AlignClass */],\n  'attributors/class/background': background[\"a\" /* BackgroundClass */],\n  'attributors/class/color': color[\"b\" /* ColorClass */],\n  'attributors/class/direction': direction[\"b\" /* DirectionClass */],\n  'attributors/class/font': font[\"a\" /* FontClass */],\n  'attributors/class/size': size[\"a\" /* SizeClass */],\n  'attributors/style/align': align[\"c\" /* AlignStyle */],\n  'attributors/style/background': background[\"b\" /* BackgroundStyle */],\n  'attributors/style/color': color[\"c\" /* ColorStyle */],\n  'attributors/style/direction': direction[\"c\" /* DirectionStyle */],\n  'attributors/style/font': font[\"b\" /* FontStyle */],\n  'attributors/style/size': size[\"b\" /* SizeStyle */],\n  'attributors/style/tableTextAlign': attributors_table[\"j\" /* TableTextAlignStyle */],\n  'attributors/style/tableBackgroundColor': attributors_table[\"c\" /* TableBackgroundColorStyle */],\n  'attributors/style/tableBorder': attributors_table[\"e\" /* TableBorderStyle */],\n  'attributors/style/tableBorderStyle': attributors_table[\"f\" /* TableBorderStyleStyle */],\n  'attributors/style/tableBorderColor': attributors_table[\"d\" /* TableBorderColorStyle */],\n  'attributors/style/tableBorderWidth': attributors_table[\"g\" /* TableBorderWidthStyle */],\n  'attributors/style/tableWidth': attributors_table[\"l\" /* TableWidthStyle */],\n  'attributors/style/tableHeight': attributors_table[\"i\" /* TableHeightStyle */],\n  'attributors/style/cellBackground': cell[\"c\" /* CellBackgroundColorStyle */],\n  'attributors/style/cellBorder': cell[\"e\" /* CellBorderStyle */],\n  'attributors/style/cellBorderStyle': cell[\"f\" /* CellBorderStyleStyle */],\n  'attributors/style/cellBorderWidth': cell[\"g\" /* CellBorderWidthStyle */],\n  'attributors/style/cellBorderColor': cell[\"d\" /* CellBorderColorStyle */],\n  'attributors/style/cellPadding': cell[\"m\" /* CellPaddingStyle */],\n  'attributors/style/cellPaddingTop': cell[\"n\" /* CellPaddingTopStyle */],\n  'attributors/style/cellPaddingBottom': cell[\"j\" /* CellPaddingBottomStyle */],\n  'attributors/style/cellPaddingLeft': cell[\"k\" /* CellPaddingLeftStyle */],\n  'attributors/style/cellPaddingRight': cell[\"l\" /* CellPaddingRightStyle */],\n  'attributors/style/cellVerticalAlign': cell[\"p\" /* CellVerticalAlignStyle */],\n  'attributors/style/cellTextAlign': cell[\"o\" /* CellTextAlignStyle */],\n  'attributors/style/cellWidth': cell[\"r\" /* CellWidthStyle */],\n  'attributors/style/cellHeight': cell[\"i\" /* CellHeightStyle */]\n}, true);\ncore[\"default\"].register({\n  'formats/align': align[\"b\" /* AlignClass */],\n  'formats/direction': direction[\"b\" /* DirectionClass */],\n  'formats/indent': indent,\n  'formats/background': background[\"b\" /* BackgroundStyle */],\n  'formats/color': color[\"c\" /* ColorStyle */],\n  'formats/font': font[\"a\" /* FontClass */],\n  'formats/size': size[\"a\" /* SizeClass */],\n  'formats/blockquote': blockquote,\n  'formats/code-block': code[\"c\" /* default */],\n  'formats/header': header,\n  'formats/list': list_ListItem,\n  'formats/bold': bold[\"a\" /* default */],\n  'formats/code': code[\"a\" /* Code */],\n  'formats/italic': italic,\n  'formats/link': formats_link[\"a\" /* default */],\n  'formats/script': script,\n  'formats/strike': strike,\n  'formats/underline': underline,\n  'formats/formula': formula,\n  'formats/image': formats_image,\n  'formats/video': video,\n  'tableModules/lite': lite[\"a\" /* default */],\n  'tableModules/main': table[\"a\" /* default */],\n  'modules/syntax': syntax[\"b\" /* default */],\n  'modules/multiline': multiline,\n  'modules/table': table[\"a\" /* default */]\n}, true);\n/* harmony default export */ var quill_0 = __webpack_exports__[\"default\"] = (core[\"default\"]);\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports) {\n\n/**\n * This library modifies the diff-patch-match library by Neil Fraser\n * by removing the patch and match functionality and certain advanced\n * options in the diff function. The original license is as follows:\n *\n * ===\n *\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {Int|Object} [cursor_pos] Edit position in text1 or object with more info\n * @return {Array} Array of diff tuples.\n */\nfunction diff_main(text1, text2, cursor_pos, _fix_unicode) {\n  // Check for equality\n  if (text1 === text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (cursor_pos != null) {\n    var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);\n    if (editdiff) {\n      return editdiff;\n    }\n  }\n\n  // Trim off common prefix (speedup).\n  var commonlength = diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = diff_compute_(text1, text2);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  diff_cleanupMerge(diffs, _fix_unicode);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_compute_(text1, text2) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i !== -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [\n      [DIFF_INSERT, longtext.substring(0, i)],\n      [DIFF_EQUAL, shorttext],\n      [DIFF_INSERT, longtext.substring(i + shorttext.length)]\n    ];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length === 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = diff_main(text1_a, text2_a);\n    var diffs_b = diff_main(text1_b, text2_b);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  return diff_bisect_(text1, text2);\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n * @private\n */\nfunction diff_bisect_(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 !== 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 === -d || (k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (\n        x1 < text1_length && y1 < text2_length &&\n        text1.charAt(x1) === text2.charAt(y1)\n      ) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 === -d || (k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (\n        x2 < text1_length && y2 < text2_length &&\n        text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)\n      ) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_bisectSplit_(text1, text2, x, y) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = diff_main(text1a, text2a);\n  var diffsb = diff_main(text1b, text2b);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\nfunction diff_commonPrefix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(pointerstart, pointermid) ==\n      text2.substring(pointerstart, pointermid)\n    ) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {\n    pointermid--;\n  }\n\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\nfunction diff_commonSuffix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n      text2.substring(text2.length - pointermid, text2.length - pointerend)\n    ) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {\n    pointermid--;\n  }\n\n  return pointermid;\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n */\nfunction diff_halfMatch_(text1, text2) {\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {\n      var prefixLength = diff_commonPrefix(\n        longtext.substring(i), shorttext.substring(j));\n      var suffixLength = diff_commonSuffix(\n        longtext.substring(0, i), shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(\n          j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [\n        best_longtext_a, best_longtext_b,\n        best_shorttext_a, best_shorttext_b, best_common\n      ];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {Array} diffs Array of diff tuples.\n * @param {boolean} fix_unicode Whether to normalize to a unicode-correct diff\n */\nfunction diff_cleanupMerge(diffs, fix_unicode) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    if (pointer < diffs.length - 1 && !diffs[pointer][1]) {\n      diffs.splice(pointer, 1);\n      continue;\n    }\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        var previous_equality = pointer - count_insert - count_delete - 1;\n        if (fix_unicode) {\n          // prevent splitting of unicode surrogate pairs.  when fix_unicode is true,\n          // we assume that the old and new text in the diff are complete and correct\n          // unicode-encoded JS strings, but the tuple boundaries may fall between\n          // surrogate pairs.  we fix this by shaving off stray surrogates from the end\n          // of the previous equality and the beginning of this equality.  this may create\n          // empty equalities or a common prefix or suffix.  for example, if AB and AC are\n          // emojis, `[[0, 'A'], [-1, 'BA'], [0, 'C']]` would turn into deleting 'ABAC' and\n          // inserting 'AC', and then the common suffix 'AC' will be eliminated.  in this\n          // particular case, both equalities go away, we absorb any previous inequalities,\n          // and we keep scanning for the next equality before rewriting the tuples.\n          if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {\n            var stray = diffs[previous_equality][1].slice(-1);\n            diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);\n            text_delete = stray + text_delete;\n            text_insert = stray + text_insert;\n            if (!diffs[previous_equality][1]) {\n              // emptied out previous equality, so delete it and include previous delete/insert\n              diffs.splice(previous_equality, 1);\n              pointer--;\n              var k = previous_equality - 1;\n              if (diffs[k] && diffs[k][0] === DIFF_INSERT) {\n                count_insert++;\n                text_insert = diffs[k][1] + text_insert;\n                k--;\n              }\n              if (diffs[k] && diffs[k][0] === DIFF_DELETE) {\n                count_delete++;\n                text_delete = diffs[k][1] + text_delete;\n                k--;\n              }\n              previous_equality = k;\n            }\n          }\n          if (starts_with_pair_end(diffs[pointer][1])) {\n            var stray = diffs[pointer][1].charAt(0);\n            diffs[pointer][1] = diffs[pointer][1].slice(1);\n            text_delete += stray;\n            text_insert += stray;\n          }\n        }\n        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {\n          // for empty equality not at end, wait for next equality\n          diffs.splice(pointer, 1);\n          break;\n        }\n        if (text_delete.length > 0 || text_insert.length > 0) {\n          // note that diff_commonPrefix and diff_commonSuffix are unicode-aware\n          if (text_delete.length > 0 && text_insert.length > 0) {\n            // Factor out any common prefixes.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if (previous_equality >= 0) {\n                diffs[previous_equality][1] += text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixes.\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] =\n                text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length - commonlength);\n              text_delete = text_delete.substring(0, text_delete.length - commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          var n = count_insert + count_delete;\n          if (text_delete.length === 0 && text_insert.length === 0) {\n            diffs.splice(pointer - n, n);\n            pointer = pointer - n;\n          } else if (text_delete.length === 0) {\n            diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);\n            pointer = pointer - n + 1;\n          } else if (text_insert.length === 0) {\n            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);\n            pointer = pointer - n + 1;\n          } else {\n            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);\n            pointer = pointer - n + 2;\n          }\n        }\n        if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL &&\n      diffs[pointer + 1][0] === DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n        diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n          diffs[pointer][1].substring(0, diffs[pointer][1].length -\n            diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n        diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n          diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    diff_cleanupMerge(diffs, fix_unicode);\n  }\n};\n\nfunction is_surrogate_pair_start(charCode) {\n  return charCode >= 0xD800 && charCode <= 0xDBFF;\n}\n\nfunction is_surrogate_pair_end(charCode) {\n  return charCode >= 0xDC00 && charCode <= 0xDFFF;\n}\n\nfunction starts_with_pair_end(str) {\n  return is_surrogate_pair_end(str.charCodeAt(0));\n}\n\nfunction ends_with_pair_start(str) {\n  return is_surrogate_pair_start(str.charCodeAt(str.length - 1));\n}\n\nfunction remove_empty_tuples(tuples) {\n  var ret = [];\n  for (var i = 0; i < tuples.length; i++) {\n    if (tuples[i][1].length > 0) {\n      ret.push(tuples[i]);\n    }\n  }\n  return ret;\n}\n\nfunction make_edit_splice(before, oldMiddle, newMiddle, after) {\n  if (ends_with_pair_start(before) || starts_with_pair_end(after)) {\n    return null;\n  }\n  return remove_empty_tuples([\n    [DIFF_EQUAL, before],\n    [DIFF_DELETE, oldMiddle],\n    [DIFF_INSERT, newMiddle],\n    [DIFF_EQUAL, after]\n  ]);\n}\n\nfunction find_cursor_edit_diff(oldText, newText, cursor_pos) {\n  // note: this runs after equality check has ruled out exact equality\n  var oldRange = typeof cursor_pos === 'number' ?\n    { index: cursor_pos, length: 0 } : cursor_pos.oldRange;\n  var newRange = typeof cursor_pos === 'number' ?\n    null : cursor_pos.newRange;\n  // take into account the old and new selection to generate the best diff\n  // possible for a text edit.  for example, a text change from \"xxx\" to \"xx\"\n  // could be a delete or forwards-delete of any one of the x's, or the\n  // result of selecting two of the x's and typing \"x\".\n  var oldLength = oldText.length;\n  var newLength = newText.length;\n  if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {\n    // see if we have an insert or delete before or after cursor\n    var oldCursor = oldRange.index;\n    var oldBefore = oldText.slice(0, oldCursor);\n    var oldAfter = oldText.slice(oldCursor);\n    var maybeNewCursor = newRange ? newRange.index : null;\n    editBefore: {\n      // is this an insert or delete right before oldCursor?\n      var newCursor = oldCursor + newLength - oldLength;\n      if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {\n        break editBefore;\n      }\n      if (newCursor < 0 || newCursor > newLength) {\n        break editBefore;\n      }\n      var newBefore = newText.slice(0, newCursor);\n      var newAfter = newText.slice(newCursor);\n      if (newAfter !== oldAfter) {\n        break editBefore;\n      }\n      var prefixLength = Math.min(oldCursor, newCursor);\n      var oldPrefix = oldBefore.slice(0, prefixLength);\n      var newPrefix = newBefore.slice(0, prefixLength);\n      if (oldPrefix !== newPrefix) {\n        break editBefore;\n      }\n      var oldMiddle = oldBefore.slice(prefixLength);\n      var newMiddle = newBefore.slice(prefixLength);\n      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);\n    }\n    editAfter: {\n      // is this an insert or delete right after oldCursor?\n      if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {\n        break editAfter;\n      }\n      var cursor = oldCursor;\n      var newBefore = newText.slice(0, cursor);\n      var newAfter = newText.slice(cursor);\n      if (newBefore !== oldBefore) {\n        break editAfter;\n      }\n      var suffixLength = Math.min(oldLength - cursor, newLength - cursor);\n      var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);\n      var newSuffix = newAfter.slice(newAfter.length - suffixLength);\n      if (oldSuffix !== newSuffix) {\n        break editAfter;\n      }\n      var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);\n      var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);\n      return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);\n    }\n  }\n  if (oldRange.length > 0 && newRange && newRange.length === 0) {\n    replaceRange: {\n      // see if diff could be a splice of the old selection range\n      var oldPrefix = oldText.slice(0, oldRange.index);\n      var oldSuffix = oldText.slice(oldRange.index + oldRange.length);\n      var prefixLength = oldPrefix.length;\n      var suffixLength = oldSuffix.length;\n      if (newLength < prefixLength + suffixLength) {\n        break replaceRange;\n      }\n      var newPrefix = newText.slice(0, prefixLength);\n      var newSuffix = newText.slice(newLength - suffixLength);\n      if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {\n        break replaceRange;\n      }\n      var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);\n      var newMiddle = newText.slice(prefixLength, newLength - suffixLength);\n      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);\n    }\n  }\n\n  return null;\n}\n\nfunction diff(text1, text2, cursor_pos) {\n  // only pass fix_unicode=true at the top level, not when diff_main is\n  // recursively invoked\n  return diff_main(text1, text2, cursor_pos, true);\n}\n\ndiff.INSERT = DIFF_INSERT;\ndiff.DELETE = DIFF_DELETE;\ndiff.EQUAL = DIFF_EQUAL;\n\nmodule.exports = diff;\n\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar lodash_clonedeep_1 = __importDefault(__webpack_require__(18));\nvar lodash_isequal_1 = __importDefault(__webpack_require__(29));\nvar AttributeMap;\n(function (AttributeMap) {\n    function compose(a, b, keepNull) {\n        if (a === void 0) { a = {}; }\n        if (b === void 0) { b = {}; }\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        var attributes = lodash_clonedeep_1.default(b);\n        if (!keepNull) {\n            attributes = Object.keys(attributes).reduce(function (copy, key) {\n                if (attributes[key] != null) {\n                    copy[key] = attributes[key];\n                }\n                return copy;\n            }, {});\n        }\n        for (var key in a) {\n            if (a[key] !== undefined && b[key] === undefined) {\n                attributes[key] = a[key];\n            }\n        }\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.compose = compose;\n    function diff(a, b) {\n        if (a === void 0) { a = {}; }\n        if (b === void 0) { b = {}; }\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        var attributes = Object.keys(a)\n            .concat(Object.keys(b))\n            .reduce(function (attrs, key) {\n            if (!lodash_isequal_1.default(a[key], b[key])) {\n                attrs[key] = b[key] === undefined ? null : b[key];\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.diff = diff;\n    function invert(attr, base) {\n        if (attr === void 0) { attr = {}; }\n        if (base === void 0) { base = {}; }\n        attr = attr || {};\n        var baseInverted = Object.keys(base).reduce(function (memo, key) {\n            if (base[key] !== attr[key] && attr[key] !== undefined) {\n                memo[key] = base[key];\n            }\n            return memo;\n        }, {});\n        return Object.keys(attr).reduce(function (memo, key) {\n            if (attr[key] !== base[key] && base[key] === undefined) {\n                memo[key] = null;\n            }\n            return memo;\n        }, baseInverted);\n    }\n    AttributeMap.invert = invert;\n    function transform(a, b, priority) {\n        if (priority === void 0) { priority = false; }\n        if (typeof a !== 'object') {\n            return b;\n        }\n        if (typeof b !== 'object') {\n            return undefined;\n        }\n        if (!priority) {\n            return b; // b simply overwrites us without priority\n        }\n        var attributes = Object.keys(b).reduce(function (attrs, key) {\n            if (a[key] === undefined) {\n                attrs[key] = b[key]; // null is a valid value\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.transform = transform;\n})(AttributeMap || (AttributeMap = {}));\nexports.default = AttributeMap;\n\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Op_1 = __importDefault(__webpack_require__(90));\nvar Iterator = /** @class */ (function () {\n    function Iterator(ops) {\n        this.ops = ops;\n        this.index = 0;\n        this.offset = 0;\n    }\n    Iterator.prototype.hasNext = function () {\n        return this.peekLength() < Infinity;\n    };\n    Iterator.prototype.next = function (length) {\n        if (!length) {\n            length = Infinity;\n        }\n        var nextOp = this.ops[this.index];\n        if (nextOp) {\n            var offset = this.offset;\n            var opLength = Op_1.default.length(nextOp);\n            if (length >= opLength - offset) {\n                length = opLength - offset;\n                this.index += 1;\n                this.offset = 0;\n            }\n            else {\n                this.offset += length;\n            }\n            if (typeof nextOp.delete === 'number') {\n                return { delete: length };\n            }\n            else {\n                var retOp = {};\n                if (nextOp.attributes) {\n                    retOp.attributes = nextOp.attributes;\n                }\n                if (typeof nextOp.retain === 'number') {\n                    retOp.retain = length;\n                }\n                else if (typeof nextOp.insert === 'string') {\n                    retOp.insert = nextOp.insert.substr(offset, length);\n                }\n                else {\n                    // offset should === 0, length should === 1\n                    retOp.insert = nextOp.insert;\n                }\n                return retOp;\n            }\n        }\n        else {\n            return { retain: Infinity };\n        }\n    };\n    Iterator.prototype.peek = function () {\n        return this.ops[this.index];\n    };\n    Iterator.prototype.peekLength = function () {\n        if (this.ops[this.index]) {\n            // Should never return 0 if our index is being managed correctly\n            return Op_1.default.length(this.ops[this.index]) - this.offset;\n        }\n        else {\n            return Infinity;\n        }\n    };\n    Iterator.prototype.peekType = function () {\n        if (this.ops[this.index]) {\n            if (typeof this.ops[this.index].delete === 'number') {\n                return 'delete';\n            }\n            else if (typeof this.ops[this.index].retain === 'number') {\n                return 'retain';\n            }\n            else {\n                return 'insert';\n            }\n        }\n        return 'retain';\n    };\n    Iterator.prototype.rest = function () {\n        if (!this.hasNext()) {\n            return [];\n        }\n        else if (this.offset === 0) {\n            return this.ops.slice(this.index);\n        }\n        else {\n            var offset = this.offset;\n            var index = this.index;\n            var next = this.next();\n            var rest = this.ops.slice(this.index);\n            this.offset = offset;\n            this.index = index;\n            return [next].concat(rest);\n        }\n    };\n    return Iterator;\n}());\nexports.default = Iterator;\n\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar parent = __webpack_require__(118);\n\nmodule.exports = parent;\n\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar parent = __webpack_require__(119);\n\nmodule.exports = parent;\n\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(120);\n__webpack_require__(143);\nvar path = __webpack_require__(111);\n\nmodule.exports = path.Array.from;\n\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar charAt = __webpack_require__(121).charAt;\nvar toString = __webpack_require__(74);\nvar InternalStateModule = __webpack_require__(96);\nvar defineIterator = __webpack_require__(129);\n\nvar STRING_ITERATOR = 'String Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\n\n// `String.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\ndefineIterator(String, 'String', function (iterated) {\n  setInternalState(this, {\n    type: STRING_ITERATOR,\n    string: toString(iterated),\n    index: 0\n  });\n// `%StringIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return { value: undefined, done: true };\n  point = charAt(string, index);\n  state.index += point.length;\n  return { value: point, done: false };\n});\n\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar uncurryThis = __webpack_require__(21);\nvar toIntegerOrInfinity = __webpack_require__(73);\nvar toString = __webpack_require__(74);\nvar requireObjectCoercible = __webpack_require__(65);\n\nvar charAt = uncurryThis(''.charAt);\nvar charCodeAt = uncurryThis(''.charCodeAt);\nvar stringSlice = uncurryThis(''.slice);\n\nvar createMethod = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = toString(requireObjectCoercible($this));\n    var position = toIntegerOrInfinity(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = charCodeAt(S, position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING\n          ? charAt(S, position)\n          : first\n        : CONVERT_TO_STRING\n          ? stringSlice(S, position, position + 2)\n          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod(true)\n};\n\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(27);\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar userAgent = __webpack_require__(124);\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nmodule.exports = version;\n\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getBuiltIn = __webpack_require__(56);\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar isCallable = __webpack_require__(22);\nvar inspectSource = __webpack_require__(79);\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));\n\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar call = __webpack_require__(39);\nvar isObject = __webpack_require__(48);\nvar isSymbol = __webpack_require__(99);\nvar getMethod = __webpack_require__(81);\nvar ordinaryToPrimitive = __webpack_require__(128);\nvar wellKnownSymbol = __webpack_require__(27);\n\nvar TypeError = global.TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call(exoticToPrim, input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw TypeError(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar uncurryThis = __webpack_require__(21);\n\nmodule.exports = uncurryThis({}.isPrototypeOf);\n\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar call = __webpack_require__(39);\nvar isCallable = __webpack_require__(22);\nvar isObject = __webpack_require__(48);\n\nvar TypeError = global.TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(57);\nvar call = __webpack_require__(39);\nvar IS_PURE = __webpack_require__(63);\nvar FunctionName = __webpack_require__(102);\nvar isCallable = __webpack_require__(22);\nvar createIteratorConstructor = __webpack_require__(137);\nvar getPrototypeOf = __webpack_require__(108);\nvar setPrototypeOf = __webpack_require__(141);\nvar setToStringTag = __webpack_require__(109);\nvar createNonEnumerableProperty = __webpack_require__(66);\nvar redefine = __webpack_require__(86);\nvar wellKnownSymbol = __webpack_require__(27);\nvar Iterators = __webpack_require__(68);\nvar IteratorsCore = __webpack_require__(106);\n\nvar PROPER_FUNCTION_NAME = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR = wellKnownSymbol('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf) {\n          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {\n          redefine(CurrentIteratorPrototype, ITERATOR, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {\n      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        redefine(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n    redefine(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });\n  }\n  Iterators[NAME] = defaultIterator;\n\n  return methods;\n};\n\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar uncurryThis = __webpack_require__(21);\nvar fails = __webpack_require__(36);\nvar classof = __webpack_require__(78);\n\nvar Object = global.Object;\nvar split = uncurryThis(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split(it, '') : Object(it);\n} : Object;\n\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hasOwn = __webpack_require__(33);\nvar ownKeys = __webpack_require__(132);\nvar getOwnPropertyDescriptorModule = __webpack_require__(85);\nvar definePropertyModule = __webpack_require__(49);\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getBuiltIn = __webpack_require__(56);\nvar uncurryThis = __webpack_require__(21);\nvar getOwnPropertyNamesModule = __webpack_require__(133);\nvar getOwnPropertySymbolsModule = __webpack_require__(135);\nvar anObject = __webpack_require__(37);\n\nvar concat = uncurryThis([].concat);\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n\n\n/***/ }),\n/* 133 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar internalObjectKeys = __webpack_require__(103);\nvar enumBugKeys = __webpack_require__(88);\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\n\n/***/ }),\n/* 134 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toIndexedObject = __webpack_require__(58);\nvar toAbsoluteIndex = __webpack_require__(104);\nvar lengthOfArrayLike = __webpack_require__(87);\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = lengthOfArrayLike(O);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\n\n/***/ }),\n/* 135 */\n/***/ (function(module, exports) {\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n\n\n/***/ }),\n/* 136 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(36);\nvar isCallable = __webpack_require__(22);\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n\n\n/***/ }),\n/* 137 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar IteratorPrototype = __webpack_require__(106).IteratorPrototype;\nvar create = __webpack_require__(89);\nvar createPropertyDescriptor = __webpack_require__(67);\nvar setToStringTag = __webpack_require__(109);\nvar Iterators = __webpack_require__(68);\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (IteratorConstructor, NAME, next) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });\n  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n  Iterators[TO_STRING_TAG] = returnThis;\n  return IteratorConstructor;\n};\n\n\n/***/ }),\n/* 138 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(38);\nvar definePropertyModule = __webpack_require__(49);\nvar anObject = __webpack_require__(37);\nvar toIndexedObject = __webpack_require__(58);\nvar objectKeys = __webpack_require__(107);\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var props = toIndexedObject(Properties);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\n\n/***/ }),\n/* 139 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getBuiltIn = __webpack_require__(56);\n\nmodule.exports = getBuiltIn('document', 'documentElement');\n\n\n/***/ }),\n/* 140 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(36);\n\nmodule.exports = !fails(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\n\n/***/ }),\n/* 141 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* eslint-disable no-proto -- safe */\nvar uncurryThis = __webpack_require__(21);\nvar anObject = __webpack_require__(37);\nvar aPossiblePrototype = __webpack_require__(142);\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es/no-object-setprototypeof -- safe\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\n\n/***/ }),\n/* 142 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar isCallable = __webpack_require__(22);\n\nvar String = global.String;\nvar TypeError = global.TypeError;\n\nmodule.exports = function (argument) {\n  if (typeof argument == 'object' || isCallable(argument)) return argument;\n  throw TypeError(\"Can't set \" + String(argument) + ' as a prototype');\n};\n\n\n/***/ }),\n/* 143 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(57);\nvar from = __webpack_require__(144);\nvar checkCorrectnessOfIteration = __webpack_require__(152);\n\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n  // eslint-disable-next-line es/no-array-from -- required for testing\n  Array.from(iterable);\n});\n\n// `Array.from` method\n// https://tc39.es/ecma262/#sec-array.from\n$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {\n  from: from\n});\n\n\n/***/ }),\n/* 144 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar global = __webpack_require__(10);\nvar bind = __webpack_require__(145);\nvar call = __webpack_require__(39);\nvar toObject = __webpack_require__(64);\nvar callWithSafeIterationClosing = __webpack_require__(146);\nvar isArrayIteratorMethod = __webpack_require__(148);\nvar isConstructor = __webpack_require__(149);\nvar lengthOfArrayLike = __webpack_require__(87);\nvar createProperty = __webpack_require__(150);\nvar getIterator = __webpack_require__(151);\nvar getIteratorMethod = __webpack_require__(110);\n\nvar Array = global.Array;\n\n// `Array.from` method implementation\n// https://tc39.es/ecma262/#sec-array.from\nmodule.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n  var O = toObject(arrayLike);\n  var IS_CONSTRUCTOR = isConstructor(this);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);\n  var iteratorMethod = getIteratorMethod(O);\n  var index = 0;\n  var length, result, step, iterator, next, value;\n  // if the target is not iterable or it's an array with the default iterator - use a simple case\n  if (iteratorMethod && !(this == Array && isArrayIteratorMethod(iteratorMethod))) {\n    iterator = getIterator(O, iteratorMethod);\n    next = iterator.next;\n    result = IS_CONSTRUCTOR ? new this() : [];\n    for (;!(step = call(next, iterator)).done; index++) {\n      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n      createProperty(result, index, value);\n    }\n  } else {\n    length = lengthOfArrayLike(O);\n    result = IS_CONSTRUCTOR ? new this(length) : Array(length);\n    for (;length > index; index++) {\n      value = mapping ? mapfn(O[index], index) : O[index];\n      createProperty(result, index, value);\n    }\n  }\n  result.length = index;\n  return result;\n};\n\n\n/***/ }),\n/* 145 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar uncurryThis = __webpack_require__(21);\nvar aCallable = __webpack_require__(82);\n\nvar bind = uncurryThis(uncurryThis.bind);\n\n// optional / simple context binding\nmodule.exports = function (fn, that) {\n  aCallable(fn);\n  return that === undefined ? fn : bind ? bind(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/***/ }),\n/* 146 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(37);\nvar iteratorClose = __webpack_require__(147);\n\n// call something on iterator step with safe closing on error\nmodule.exports = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n  } catch (error) {\n    iteratorClose(iterator, 'throw', error);\n  }\n};\n\n\n/***/ }),\n/* 147 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar call = __webpack_require__(39);\nvar anObject = __webpack_require__(37);\nvar getMethod = __webpack_require__(81);\n\nmodule.exports = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject(iterator);\n  try {\n    innerResult = getMethod(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject(innerResult);\n  return value;\n};\n\n\n/***/ }),\n/* 148 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(27);\nvar Iterators = __webpack_require__(68);\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n};\n\n\n/***/ }),\n/* 149 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar uncurryThis = __webpack_require__(21);\nvar fails = __webpack_require__(36);\nvar isCallable = __webpack_require__(22);\nvar classof = __webpack_require__(75);\nvar getBuiltIn = __webpack_require__(56);\nvar inspectSource = __webpack_require__(79);\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct = getBuiltIn('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = uncurryThis(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\nvar isConstructorModern = function (argument) {\n  if (!isCallable(argument)) return false;\n  try {\n    construct(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function (argument) {\n  if (!isCallable(argument)) return false;\n  switch (classof(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n    // we can't check .prototype since constructors produced by .bind haven't it\n  } return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));\n};\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nmodule.exports = !construct || fails(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\n\n/***/ }),\n/* 150 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar toPropertyKey = __webpack_require__(80);\nvar definePropertyModule = __webpack_require__(49);\nvar createPropertyDescriptor = __webpack_require__(67);\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n\n\n/***/ }),\n/* 151 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar call = __webpack_require__(39);\nvar aCallable = __webpack_require__(82);\nvar anObject = __webpack_require__(37);\nvar tryToString = __webpack_require__(100);\nvar getIteratorMethod = __webpack_require__(110);\n\nvar TypeError = global.TypeError;\n\nmodule.exports = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;\n  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));\n  throw TypeError(tryToString(argument) + ' is not iterable');\n};\n\n\n/***/ }),\n/* 152 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(27);\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nmodule.exports = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\n\n/***/ }),\n/* 153 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar parent = __webpack_require__(154);\n\nmodule.exports = parent;\n\n\n/***/ }),\n/* 154 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar parent = __webpack_require__(155);\n\nmodule.exports = parent;\n\n\n/***/ }),\n/* 155 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(156);\nvar entryUnbind = __webpack_require__(112);\n\nmodule.exports = entryUnbind('Array', 'fill');\n\n\n/***/ }),\n/* 156 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(57);\nvar fill = __webpack_require__(157);\nvar addToUnscopables = __webpack_require__(158);\n\n// `Array.prototype.fill` method\n// https://tc39.es/ecma262/#sec-array.prototype.fill\n$({ target: 'Array', proto: true }, {\n  fill: fill\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('fill');\n\n\n/***/ }),\n/* 157 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar toObject = __webpack_require__(64);\nvar toAbsoluteIndex = __webpack_require__(104);\nvar lengthOfArrayLike = __webpack_require__(87);\n\n// `Array.prototype.fill` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.fill\nmodule.exports = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject(this);\n  var length = lengthOfArrayLike(O);\n  var argumentsLength = arguments.length;\n  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);\n  var end = argumentsLength > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n\n\n/***/ }),\n/* 158 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(27);\nvar create = __webpack_require__(89);\nvar definePropertyModule = __webpack_require__(49);\n\nvar UNSCOPABLES = wellKnownSymbol('unscopables');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: create(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nmodule.exports = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\n\n/***/ }),\n/* 159 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar parent = __webpack_require__(160);\n\nmodule.exports = parent;\n\n\n/***/ }),\n/* 160 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar parent = __webpack_require__(161);\n\nmodule.exports = parent;\n\n\n/***/ }),\n/* 161 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(162);\nvar path = __webpack_require__(111);\n\nmodule.exports = path.Object.values;\n\n\n/***/ }),\n/* 162 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(57);\nvar $values = __webpack_require__(163).values;\n\n// `Object.values` method\n// https://tc39.es/ecma262/#sec-object.values\n$({ target: 'Object', stat: true }, {\n  values: function values(O) {\n    return $values(O);\n  }\n});\n\n\n/***/ }),\n/* 163 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(38);\nvar uncurryThis = __webpack_require__(21);\nvar objectKeys = __webpack_require__(107);\nvar toIndexedObject = __webpack_require__(58);\nvar $propertyIsEnumerable = __webpack_require__(101).f;\n\nvar propertyIsEnumerable = uncurryThis($propertyIsEnumerable);\nvar push = uncurryThis([].push);\n\n// `Object.{ entries, values }` methods implementation\nvar createMethod = function (TO_ENTRIES) {\n  return function (it) {\n    var O = toIndexedObject(it);\n    var keys = objectKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) {\n      key = keys[i++];\n      if (!DESCRIPTORS || propertyIsEnumerable(O, key)) {\n        push(result, TO_ENTRIES ? [key, O[key]] : O[key]);\n      }\n    }\n    return result;\n  };\n};\n\nmodule.exports = {\n  // `Object.entries` method\n  // https://tc39.es/ecma262/#sec-object.entries\n  entries: createMethod(true),\n  // `Object.values` method\n  // https://tc39.es/ecma262/#sec-object.values\n  values: createMethod(false)\n};\n\n\n/***/ }),\n/* 164 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar parent = __webpack_require__(165);\n\nmodule.exports = parent;\n\n\n/***/ }),\n/* 165 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar parent = __webpack_require__(166);\n\nmodule.exports = parent;\n\n\n/***/ }),\n/* 166 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(167);\nvar entryUnbind = __webpack_require__(112);\n\nmodule.exports = entryUnbind('String', 'endsWith');\n\n\n/***/ }),\n/* 167 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(57);\nvar uncurryThis = __webpack_require__(21);\nvar getOwnPropertyDescriptor = __webpack_require__(85).f;\nvar toLength = __webpack_require__(105);\nvar toString = __webpack_require__(74);\nvar notARegExp = __webpack_require__(168);\nvar requireObjectCoercible = __webpack_require__(65);\nvar correctIsRegExpLogic = __webpack_require__(170);\nvar IS_PURE = __webpack_require__(63);\n\n// eslint-disable-next-line es/no-string-prototype-endswith -- safe\nvar un$EndsWith = uncurryThis(''.endsWith);\nvar slice = uncurryThis(''.slice);\nvar min = Math.min;\n\nvar CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('endsWith');\n// https://github.com/zloirock/core-js/pull/702\nvar MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {\n  var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');\n  return descriptor && !descriptor.writable;\n}();\n\n// `String.prototype.endsWith` method\n// https://tc39.es/ecma262/#sec-string.prototype.endswith\n$({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {\n  endsWith: function endsWith(searchString /* , endPosition = @length */) {\n    var that = toString(requireObjectCoercible(this));\n    notARegExp(searchString);\n    var endPosition = arguments.length > 1 ? arguments[1] : undefined;\n    var len = that.length;\n    var end = endPosition === undefined ? len : min(toLength(endPosition), len);\n    var search = toString(searchString);\n    return un$EndsWith\n      ? un$EndsWith(that, search, end)\n      : slice(that, end - search.length, end) === search;\n  }\n});\n\n\n/***/ }),\n/* 168 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(10);\nvar isRegExp = __webpack_require__(169);\n\nvar TypeError = global.TypeError;\n\nmodule.exports = function (it) {\n  if (isRegExp(it)) {\n    throw TypeError(\"The method doesn't accept regular expressions\");\n  } return it;\n};\n\n\n/***/ }),\n/* 169 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(48);\nvar classof = __webpack_require__(78);\nvar wellKnownSymbol = __webpack_require__(27);\n\nvar MATCH = wellKnownSymbol('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');\n};\n\n\n/***/ }),\n/* 170 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(27);\n\nvar MATCH = wellKnownSymbol('match');\n\nmodule.exports = function (METHOD_NAME) {\n  var regexp = /./;\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (error2) { /* empty */ }\n  } return false;\n};\n\n\n/***/ }),\n/* 171 */,\n/* 172 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(113);\n\n\n/***/ })\n/******/ ])[\"default\"];\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS1xdWlsbC9kaXN0L2R4LXF1aWxsLmpzPzMxMTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLbUY7QUFDekYsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkZBQTJGLHVCQUF1QixFQUFFO0FBQ3BILDJGQUEyRixxQkFBcUIsRUFBRTtBQUNsSCwyRkFBMkYsaUJBQWlCLEVBQUU7QUFDOUcsMkZBQTJGLGNBQWMsRUFBRTtBQUMz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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7O0FBRWxCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7OztBQUd4QywwREFBMEQ7OztBQUcxRCxzREFBc0Q7OztBQUd0RDs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGOztBQUVqRix5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRyxJQUFJLEVBQUU7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUU7QUFDckU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QiwwQkFBMEI7QUFDMUIsS0FBSztBQUNMLDRCQUE0Qjs7QUFFNUIsMEJBQTBCO0FBQzFCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFELEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVILDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUU7QUFDakU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQU9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7QUFNRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7OztBQVNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQU9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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O0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUhBQXlIO0FBQ3pIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsOEVBQThFOztBQUU5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTREO0FBQzVELEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThD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QTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELHNNQUFzTTs7QUFFdE07QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsS0FBSTs7QUFFdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLFFBQVE7QUFDbkIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU8sV0FBVztBQUM3QixXQUFXLFNBQVM7QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPLFdBQVc7QUFDN0IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUyxHQUFHLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQixFQUFFO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0EsR0FB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RUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxjQUFjO0FBQ3RGO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0QscUJBQXFCO0FBQ3pFO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FB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LENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUdBQXVHO0FBQ3ZHOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFHQUFxRzs7QUFFckc7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpSEFBaUg7O0FBRWpIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1QyxvRUFBb0U7QUFDcEUsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DLHdDQUF3QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLHFCQUFxQjtBQUMxQixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcs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QTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLDRFQUE0RSxlQUFlO0FBQzNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEVBQTRFLGVBQWU7QUFDM0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLDRFQUE0RSxlQUFlO0FBQzNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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UDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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QUFDQTs7QUFFQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSw0RUFBNEUsZUFBZTtBQUMzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLDJCQUEyQiwyRUFBMkUsc0NBQXNDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxzQ0FBc0MsOEhBQThILEdBQUcsRUFBRSx5QkFBeUI7O0FBRXhZLDJDQUEyQyxrQkFBa0Isa0NBQWtDLHFFQUFxRSxFQUFFLEVBQUUsT0FBTyxrQkFBa0IsRUFBRSxZQUFZOztBQUUvTSxxQ0FBcUMsMklBQTJJOztBQUVoTCxpQ0FBaUMsa0tBQWtLOztBQUVuTSxxREFBcUQsZ0JBQWdCLG9FQUFvRSx3REFBd0QsNkRBQTZELHNEQUFzRCxzSEFBc0g7O0FBRTFhLDBDQUEwQyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxrQkFBa0IsRUFBRSxhQUFhOztBQUV6TCw0Q0FBNEMsMEdBQTBHLHdCQUF3QixlQUFlLGVBQWUsZ0JBQWdCLFlBQVksTUFBTSx3QkFBd0IsK0JBQStCLGFBQWEscUJBQXFCLG1DQUFtQyxFQUFFLEVBQUUsY0FBYyxXQUFXLFVBQVUsRUFBRSxVQUFVLE1BQU0saURBQWlELEVBQUUsVUFBVSxrQkFBa0IsRUFBRSxFQUFFLGFBQWE7O0FBRW5nQixtQ0FBbUMsb0NBQW9DOztBQUV2RSxxREFBcUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUUzSiwrQ0FBK0MsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFL1QsaUVBQWlFLDBFQUEwRSxrRUFBa0Usb0JBQW9COztBQUVqTyw4Q0FBOEMsK0RBQStELDJFQUEyRSxFQUFFLHlFQUF5RSxlQUFlLHNEQUFzRCxFQUFFLEVBQUUsMkRBQTJEOztBQUV2WSxvQ0FBb0MsZ0ZBQWdGLGlCQUFpQixVQUFVLEdBQUcsa0NBQWtDOztBQUVwTCxvQ0FBb0MsaUVBQWlFLHlDQUF5QyxrREFBa0QsaUNBQWlDLHVEQUF1RCx5REFBeUQsRUFBRSxPQUFPLHVDQUF1QyxFQUFFLHFEQUFxRCxHQUFHOztBQUUzYixxREFBcUQsOEVBQThFLGFBQWEsRUFBRSw0QkFBNEIsaUZBQWlGLEVBQUUseUNBQXlDOztBQUUxUywyQ0FBMkMsdUJBQXVCLHVGQUF1RixFQUFFLGFBQWE7O0FBRXhLLDBDQUEwQyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDZFQUE2RSxHQUFHLGFBQWEsRUFBRSxZQUFZLGNBQWMsRUFBRTs7QUFFM1UsaUNBQWlDLG9HQUFvRyxnREFBZ0QsR0FBRywrQkFBK0I7Ozs7Ozs7Ozs7Ozs7OztBQWV2Tjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FB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QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBLG9DQUFvQzs7O0FBR3BDO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlJQUFpSTtBQUNqSTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNB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R0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsV0FBVztBQUN0QixZQUFZLE1BQU07QUFDbEI7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsVUFBVTtBQUNWLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0I7OztBQUcvQixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVB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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLEdBQUcsMkRBQTJEO0FBQzlEO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvQ0FBb0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGVBQWUsRUFBRTtBQUMxRDtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTLEVBQUU7QUFDekQsQ0FBQyxnQkFBZ0I7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGdCQUFnQjtBQUNuQjtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRywrQkFBK0I7QUFDbEM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLCtCQUErQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsR0FBRyx1RkFBdUY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlCQUFpQjtBQUN0QixHQUFHO0FBQ0g7OztBQUdBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS1xdWlsbC9kaXN0L2R4LXF1aWxsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBEZXZFeHRyZW1lLVF1aWxsIEVkaXRvciB2LjEuNS4xNlxuICogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9cbiAqIENvcHlyaWdodCAoYykgMjAyMCwgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLlxuICogQ29weXJpZ2h0IChjKSAyMDE3LCBTbGFiXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEphc29uIENoZW5cbiAqIENvcHlyaWdodCAoYykgMjAxMywgc2FsZXNmb3JjZS5jb21cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUXVpbGxcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiRGV2RXhwcmVzc1wiXSA9IHJvb3RbXCJEZXZFeHByZXNzXCJdIHx8IHt9LCByb290W1wiRGV2RXhwcmVzc1wiXVtcIlF1aWxsXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNzIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2xvYmFsUmVnaXN0cnk7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBleHBhbmRDb25maWc7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvdmVybG9hZDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFF1aWxsOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9jbG9uZWRlZXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9jbG9uZWRlZXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsb2Rhc2hfY2xvbmVkZWVwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9tZXJnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX21lcmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX21lcmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZWRpdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2R1bGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zZWxlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2luc3RhbmNlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RoZW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGRlYnVnID0gT2JqZWN0KF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoJ3F1aWxsJyk7XG52YXIgZ2xvYmFsUmVnaXN0cnkgPSBuZXcgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJSZWdpc3RyeVwiXSgpO1xucGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJQYXJlbnRCbG90XCJdLnVpQ2xhc3MgPSAncWwtdWknO1xuXG52YXIgUXVpbGwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBRdWlsbChjb250YWluZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1aWxsKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IGV4cGFuZENvbmZpZyhjb250YWluZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcblxuICAgIGlmICh0aGlzLmNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGVidWcuZXJyb3IoJ0ludmFsaWQgUXVpbGwgY29udGFpbmVyJywgY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICBRdWlsbC5kZWJ1Zyh0aGlzLm9wdGlvbnMuZGVidWcpO1xuICAgIH1cblxuICAgIHZhciBodG1sID0gdGhpcy5jb250YWluZXIuaW5uZXJIVE1MLnRyaW0oKTtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdxbC1jb250YWluZXInKTtcbiAgICB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICBfaW5zdGFuY2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2V0KHRoaXMuY29udGFpbmVyLCB0aGlzKTtcbiAgICB0aGlzLnJvb3QgPSB0aGlzLmFkZENvbnRhaW5lcigncWwtZWRpdG9yJyk7XG4gICAgdGhpcy5yb290LmNsYXNzTGlzdC5hZGQoJ3FsLWJsYW5rJyk7XG4gICAgdGhpcy5zY3JvbGxpbmdDb250YWluZXIgPSB0aGlzLm9wdGlvbnMuc2Nyb2xsaW5nQ29udGFpbmVyIHx8IHRoaXMucm9vdDtcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgpO1xuICAgIHZhciBTY3JvbGxCbG90ID0gdGhpcy5vcHRpb25zLnJlZ2lzdHJ5LnF1ZXJ5KHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiU2Nyb2xsQmxvdFwiXS5ibG90TmFtZSk7XG4gICAgdGhpcy5zY3JvbGwgPSBuZXcgU2Nyb2xsQmxvdCh0aGlzLm9wdGlvbnMucmVnaXN0cnksIHRoaXMucm9vdCwge1xuICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgdG9nZ2xlQmxhbmtDbGFzczogdGhpcy50b2dnbGVCbGFua0NsYXNzLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvciA9IG5ldyBfZWRpdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0odGhpcy5zY3JvbGwpO1xuICAgIHRoaXMuc2VsZWN0aW9uID0gbmV3IF9zZWxlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYlwiXSh0aGlzLnNjcm9sbCwgdGhpcy5lbWl0dGVyKTtcbiAgICB0aGlzLnRoZW1lID0gbmV3IHRoaXMub3B0aW9ucy50aGVtZSh0aGlzLCB0aGlzLm9wdGlvbnMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcblxuICAgIHRoaXMua2V5Ym9hcmQgPSB0aGlzLnRoZW1lLmFkZE1vZHVsZSgna2V5Ym9hcmQnKTtcbiAgICB0aGlzLmNsaXBib2FyZCA9IHRoaXMudGhlbWUuYWRkTW9kdWxlKCdjbGlwYm9hcmQnKTtcbiAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLnRoZW1lLmFkZE1vZHVsZSgnaGlzdG9yeScpO1xuICAgIHRoaXMudXBsb2FkZXIgPSB0aGlzLnRoZW1lLmFkZE1vZHVsZSgndXBsb2FkZXInKTtcbiAgICB0aGlzLnRoZW1lLmluaXQoKTtcbiAgICB0aGlzLmVtaXR0ZXIub24oX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ldmVudHMuRURJVE9SX0NIQU5HRSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmV2ZW50cy5URVhUX0NIQU5HRSkge1xuICAgICAgICBfdGhpcy50b2dnbGVCbGFua0NsYXNzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0dGVyLm9uKF9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZXZlbnRzLlNDUk9MTF9VUERBVEUsIGZ1bmN0aW9uIChzb3VyY2UsIG11dGF0aW9ucykge1xuICAgICAgdmFyIG9sZFJhbmdlID0gX3RoaXMuc2VsZWN0aW9uLmxhc3RSYW5nZTtcblxuICAgICAgdmFyIF90aGlzJHNlbGVjdGlvbiRnZXRSYSA9IF90aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpLFxuICAgICAgICAgIF90aGlzJHNlbGVjdGlvbiRnZXRSYTIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRzZWxlY3Rpb24kZ2V0UmEsIDEpLFxuICAgICAgICAgIG5ld1JhbmdlID0gX3RoaXMkc2VsZWN0aW9uJGdldFJhMlswXTtcblxuICAgICAgdmFyIHNlbGVjdGlvbkluZm8gPSBvbGRSYW5nZSAmJiBuZXdSYW5nZSA/IHtcbiAgICAgICAgb2xkUmFuZ2U6IG9sZFJhbmdlLFxuICAgICAgICBuZXdSYW5nZTogbmV3UmFuZ2VcbiAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgICBtb2RpZnkuY2FsbChfdGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuZWRpdG9yLnVwZGF0ZShudWxsLCBtdXRhdGlvbnMsIHNlbGVjdGlvbkluZm8pO1xuICAgICAgfSwgc291cmNlKTtcbiAgICB9KTtcbiAgICB0aGlzLnNldENvbnRlbnRzKHRoaXMuZ2V0SW5pdGlhbENvbnRlbnQoaHRtbCkpO1xuICAgIHRoaXMuaGlzdG9yeS5jbGVhcigpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcikge1xuICAgICAgdGhpcy5yb290LnNldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZWhvbGRlcicsIHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZWFkT25seSkge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5hbGxvd1JlYWRPbmx5RWRpdHMgPSBmYWxzZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhRdWlsbCwgW3tcbiAgICBrZXk6IFwiZ2V0SW5pdGlhbENvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbENvbnRlbnQoaHRtbCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xpcGJvYXJkLmNvbnZlcnQoe1xuICAgICAgICBodG1sOiBcIlwiLmNvbmNhdChodG1sLCBcIjxwPjxicj48L3A+XCIpLFxuICAgICAgICB0ZXh0OiAnXFxuJ1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZUJsYW5rQ2xhc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlQmxhbmtDbGFzcygpIHtcbiAgICAgIHZhciBpc0NvbXBvc2luZyA9IHRoaXMuc2VsZWN0aW9uLmNvbXBvc2luZztcbiAgICAgIHRoaXMucm9vdC5jbGFzc0xpc3QudG9nZ2xlKCdxbC1ibGFuaycsIHRoaXMuZWRpdG9yLmlzQmxhbmsoaXNDb21wb3NpbmcpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQ29udGFpbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgIHZhciByZWZOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbnRhaW5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNvbnRhaW5lcjtcbiAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIHJlZk5vZGUpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmx1clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBibHVyKCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0UmFuZ2UobnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlVGV4dChpbmRleCwgbGVuZ3RoLCBzb3VyY2UpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgX292ZXJsb2FkID0gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCwgc291cmNlKTtcblxuICAgICAgdmFyIF9vdmVybG9hZDIgPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQsIDQpO1xuXG4gICAgICBpbmRleCA9IF9vdmVybG9hZDJbMF07XG4gICAgICBsZW5ndGggPSBfb3ZlcmxvYWQyWzFdO1xuICAgICAgc291cmNlID0gX292ZXJsb2FkMlszXTtcbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuZWRpdG9yLmRlbGV0ZVRleHQoaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4LCAtMSAqIGxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIHRoaXMuZW5hYmxlKGZhbHNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWRpdFJlYWRPbmx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRSZWFkT25seShtb2RpZmllcikge1xuICAgICAgdGhpcy5hbGxvd1JlYWRPbmx5RWRpdHMgPSB0cnVlO1xuICAgICAgdmFyIHZhbHVlID0gbW9kaWZpZXIoKTtcbiAgICAgIHRoaXMuYWxsb3dSZWFkT25seUVkaXRzID0gZmFsc2U7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB2YXIgZW5hYmxlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHRoaXMuc2Nyb2xsLmVuYWJsZShlbmFibGVkKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC50b2dnbGUoJ3FsLWRpc2FibGVkJywgIWVuYWJsZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLnNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3A7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5mb2N1cygpO1xuICAgICAgdGhpcy5zY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zb3VyY2VzLkFQSTtcbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IF90aGlzMy5nZXRTZWxlY3Rpb24odHJ1ZSk7XG5cbiAgICAgICAgdmFyIGNoYW5nZSA9IG5ldyBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSgpO1xuICAgICAgICBpZiAocmFuZ2UgPT0gbnVsbCkgcmV0dXJuIGNoYW5nZTtcblxuICAgICAgICBpZiAoX3RoaXMzLnNjcm9sbC5xdWVyeShuYW1lLCBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIlNjb3BlXCJdLkJMT0NLKSkge1xuICAgICAgICAgIGNoYW5nZSA9IF90aGlzMy5lZGl0b3IuZm9ybWF0TGluZShyYW5nZS5pbmRleCwgcmFuZ2UubGVuZ3RoLCBfZGVmaW5lUHJvcGVydHkoe30sIG5hbWUsIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgX3RoaXMzLnNlbGVjdGlvbi5mb3JtYXQobmFtZSwgdmFsdWUpO1xuXG4gICAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFuZ2UgPSBfdGhpczMuZWRpdG9yLmZvcm1hdFRleHQocmFuZ2UuaW5kZXgsIHJhbmdlLmxlbmd0aCwgX2RlZmluZVByb3BlcnR5KHt9LCBuYW1lLCB2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMzLnNldFNlbGVjdGlvbihyYW5nZSwgX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zb3VyY2VzLlNJTEVOVCk7XG5cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICAgIH0sIHNvdXJjZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdExpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0TGluZShpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSwgc291cmNlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdHM7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcblxuICAgICAgdmFyIF9vdmVybG9hZDMgPSBvdmVybG9hZChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSwgc291cmNlKTtcblxuICAgICAgdmFyIF9vdmVybG9hZDQgPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQzLCA0KTtcblxuICAgICAgaW5kZXggPSBfb3ZlcmxvYWQ0WzBdO1xuICAgICAgbGVuZ3RoID0gX292ZXJsb2FkNFsxXTtcbiAgICAgIGZvcm1hdHMgPSBfb3ZlcmxvYWQ0WzJdO1xuICAgICAgc291cmNlID0gX292ZXJsb2FkNFszXTtcbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuZWRpdG9yLmZvcm1hdExpbmUoaW5kZXgsIGxlbmd0aCwgZm9ybWF0cyk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4LCAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRUZXh0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlLCBzb3VyY2UpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgZm9ybWF0czsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuXG4gICAgICB2YXIgX292ZXJsb2FkNSA9IG92ZXJsb2FkKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlLCBzb3VyY2UpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkNiA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZDUsIDQpO1xuXG4gICAgICBpbmRleCA9IF9vdmVybG9hZDZbMF07XG4gICAgICBsZW5ndGggPSBfb3ZlcmxvYWQ2WzFdO1xuICAgICAgZm9ybWF0cyA9IF9vdmVybG9hZDZbMl07XG4gICAgICBzb3VyY2UgPSBfb3ZlcmxvYWQ2WzNdO1xuICAgICAgcmV0dXJuIG1vZGlmeS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNS5lZGl0b3IuZm9ybWF0VGV4dChpbmRleCwgbGVuZ3RoLCBmb3JtYXRzKTtcbiAgICAgIH0sIHNvdXJjZSwgaW5kZXgsIDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb3VuZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRzKGluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgdmFyIGJvdW5kcztcblxuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYm91bmRzID0gdGhpcy5zZWxlY3Rpb24uZ2V0Qm91bmRzKGluZGV4LCBsZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm91bmRzID0gdGhpcy5zZWxlY3Rpb24uZ2V0Qm91bmRzKGluZGV4LmluZGV4LCBpbmRleC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGFpbmVyQm91bmRzID0gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBib3R0b206IGJvdW5kcy5ib3R0b20gLSBjb250YWluZXJCb3VuZHMudG9wLFxuICAgICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQsXG4gICAgICAgIGxlZnQ6IGJvdW5kcy5sZWZ0IC0gY29udGFpbmVyQm91bmRzLmxlZnQsXG4gICAgICAgIHJpZ2h0OiBib3VuZHMucmlnaHQgLSBjb250YWluZXJCb3VuZHMubGVmdCxcbiAgICAgICAgdG9wOiBib3VuZHMudG9wIC0gY29udGFpbmVyQm91bmRzLnRvcCxcbiAgICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29udGVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGVudHMoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmdldExlbmd0aCgpIC0gaW5kZXg7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQ3ID0gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQ4ID0gX3NsaWNlZFRvQXJyYXkoX292ZXJsb2FkNywgMik7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkOFswXTtcbiAgICAgIGxlbmd0aCA9IF9vdmVybG9hZDhbMV07XG4gICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0Q29udGVudHMoaW5kZXgsIGxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtYXQoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuZ2V0U2VsZWN0aW9uKHRydWUpO1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldEZvcm1hdChpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldEZvcm1hdChpbmRleC5pbmRleCwgaW5kZXgubGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXgoYmxvdCkge1xuICAgICAgcmV0dXJuIGJsb3Qub2Zmc2V0KHRoaXMuc2Nyb2xsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExlbmd0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbC5sZW5ndGgoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGVhZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZWFmKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGwubGVhZihpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGluZShpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsLmxpbmUoaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMaW5lc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMaW5lcygpIHtcbiAgICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbC5saW5lcyhpbmRleC5pbmRleCwgaW5kZXgubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsLmxpbmVzKGluZGV4LCBsZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNb2R1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW9kdWxlKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW1lLm1vZHVsZXNbbmFtZV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3Rpb24oKSB7XG4gICAgICB2YXIgZm9jdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgaWYgKGZvY3VzKSB0aGlzLmZvY3VzKCk7XG4gICAgICB0aGlzLnVwZGF0ZSgpOyAvLyBNYWtlIHN1cmUgd2UgYWNjZXNzIGdldFJhbmdlIHdpdGggZWRpdG9yIGluIGNvbnNpc3RlbnQgc3RhdGVcblxuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmdldFJhbmdlKClbMF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNlbWFudGljSFRNTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZW1hbnRpY0hUTUwoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmdldExlbmd0aCgpIC0gaW5kZXg7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQ5ID0gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQxMCA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZDksIDIpO1xuXG4gICAgICBpbmRleCA9IF9vdmVybG9hZDEwWzBdO1xuICAgICAgbGVuZ3RoID0gX292ZXJsb2FkMTBbMV07XG4gICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0SFRNTChpbmRleCwgbGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0KCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5nZXRMZW5ndGgoKSAtIGluZGV4O1xuXG4gICAgICB2YXIgX292ZXJsb2FkMTEgPSBvdmVybG9hZChpbmRleCwgbGVuZ3RoKTtcblxuICAgICAgdmFyIF9vdmVybG9hZDEyID0gX3NsaWNlZFRvQXJyYXkoX292ZXJsb2FkMTEsIDIpO1xuXG4gICAgICBpbmRleCA9IF9vdmVybG9hZDEyWzBdO1xuICAgICAgbGVuZ3RoID0gX292ZXJsb2FkMTJbMV07XG4gICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0VGV4dChpbmRleCwgbGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzRm9jdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzRm9jdXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uaGFzRm9jdXMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0RW1iZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0RW1iZWQoaW5kZXgsIGVtYmVkLCB2YWx1ZSkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFF1aWxsLnNvdXJjZXMuQVBJO1xuICAgICAgcmV0dXJuIG1vZGlmeS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNi5lZGl0b3IuaW5zZXJ0RW1iZWQoaW5kZXgsIGVtYmVkLCB2YWx1ZSk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRUZXh0KGluZGV4LCB0ZXh0LCBuYW1lLCB2YWx1ZSwgc291cmNlKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdHM7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcblxuICAgICAgdmFyIF9vdmVybG9hZDEzID0gb3ZlcmxvYWQoaW5kZXgsIDAsIG5hbWUsIHZhbHVlLCBzb3VyY2UpO1xuXG4gICAgICB2YXIgX292ZXJsb2FkMTQgPSBfc2xpY2VkVG9BcnJheShfb3ZlcmxvYWQxMywgNCk7XG5cbiAgICAgIGluZGV4ID0gX292ZXJsb2FkMTRbMF07XG4gICAgICBmb3JtYXRzID0gX292ZXJsb2FkMTRbMl07XG4gICAgICBzb3VyY2UgPSBfb3ZlcmxvYWQxNFszXTtcbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczcuZWRpdG9yLmluc2VydFRleHQoaW5kZXgsIHRleHQsIGZvcm1hdHMpO1xuICAgICAgfSwgc291cmNlLCBpbmRleCwgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0VuYWJsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsLmlzRW5hYmxlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKCkge1xuICAgICAgdmFyIF90aGlzJGVtaXR0ZXI7XG5cbiAgICAgIHJldHVybiAoX3RoaXMkZW1pdHRlciA9IHRoaXMuZW1pdHRlcikub2ZmLmFwcGx5KF90aGlzJGVtaXR0ZXIsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKCkge1xuICAgICAgdmFyIF90aGlzJGVtaXR0ZXIyO1xuXG4gICAgICByZXR1cm4gKF90aGlzJGVtaXR0ZXIyID0gdGhpcy5lbWl0dGVyKS5vbi5hcHBseShfdGhpcyRlbWl0dGVyMiwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKCkge1xuICAgICAgdmFyIF90aGlzJGVtaXR0ZXIzO1xuXG4gICAgICByZXR1cm4gKF90aGlzJGVtaXR0ZXIzID0gdGhpcy5lbWl0dGVyKS5vbmNlLmFwcGx5KF90aGlzJGVtaXR0ZXIzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVGb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRm9ybWF0KGluZGV4LCBsZW5ndGgsIHNvdXJjZSkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQxNSA9IG92ZXJsb2FkKGluZGV4LCBsZW5ndGgsIHNvdXJjZSk7XG5cbiAgICAgIHZhciBfb3ZlcmxvYWQxNiA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZDE1LCA0KTtcblxuICAgICAgaW5kZXggPSBfb3ZlcmxvYWQxNlswXTtcbiAgICAgIGxlbmd0aCA9IF9vdmVybG9hZDE2WzFdO1xuICAgICAgc291cmNlID0gX292ZXJsb2FkMTZbM107XG4gICAgICByZXR1cm4gbW9kaWZ5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM4LmVkaXRvci5yZW1vdmVGb3JtYXQoaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9LCBzb3VyY2UsIGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2Nyb2xsSW50b1ZpZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5zY3JvbGxJbnRvVmlldyh0aGlzLnNjcm9sbGluZ0NvbnRhaW5lcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldENvbnRlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbnRlbnRzKGRlbHRhKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zb3VyY2VzLkFQSTtcbiAgICAgIHJldHVybiBtb2RpZnkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlbHRhID0gbmV3IHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKGRlbHRhKTtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gX3RoaXM5LmdldExlbmd0aCgpOyAvLyBRdWlsbCB3aWxsIHNldCBlbXB0eSBlZGl0b3IgdG8gXFxuXG5cblxuICAgICAgICB2YXIgZGVsZXRlMSA9IF90aGlzOS5lZGl0b3IuZGVsZXRlVGV4dCgwLCBsZW5ndGgpOyAvLyBkZWx0YSBhbHdheXMgYXBwbGllZCBiZWZvcmUgZXhpc3RpbmcgY29udGVudFxuXG5cbiAgICAgICAgdmFyIGFwcGxpZWQgPSBfdGhpczkuZWRpdG9yLmFwcGx5RGVsdGEoZGVsdGEpOyAvLyBSZW1vdmUgZXh0cmEgXFxuIGZyb20gZW1wdHkgZWRpdG9yIGluaXRpYWxpemF0aW9uXG5cblxuICAgICAgICB2YXIgZGVsZXRlMiA9IF90aGlzOS5lZGl0b3IuZGVsZXRlVGV4dChfdGhpczkuZ2V0TGVuZ3RoKCkgLSAxLCAxKTtcblxuICAgICAgICBfdGhpczkuZW1pdHRlci5lbWl0KFF1aWxsLmV2ZW50cy5DT05URU5UX1NFVFRFRCk7XG5cbiAgICAgICAgcmV0dXJuIGRlbGV0ZTEuY29tcG9zZShhcHBsaWVkKS5jb21wb3NlKGRlbGV0ZTIpO1xuICAgICAgfSwgc291cmNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbmRleCwgbGVuZ3RoLCBzb3VyY2UpIHtcbiAgICAgIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFJhbmdlKG51bGwsIGxlbmd0aCB8fCBRdWlsbC5zb3VyY2VzLkFQSSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX292ZXJsb2FkMTcgPSBvdmVybG9hZChpbmRleCwgbGVuZ3RoLCBzb3VyY2UpO1xuXG4gICAgICAgIHZhciBfb3ZlcmxvYWQxOCA9IF9zbGljZWRUb0FycmF5KF9vdmVybG9hZDE3LCA0KTtcblxuICAgICAgICBpbmRleCA9IF9vdmVybG9hZDE4WzBdO1xuICAgICAgICBsZW5ndGggPSBfb3ZlcmxvYWQxOFsxXTtcbiAgICAgICAgc291cmNlID0gX292ZXJsb2FkMThbM107XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFJhbmdlKG5ldyBfc2VsZWN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogUmFuZ2UgKi8gXCJhXCJdKE1hdGgubWF4KDAsIGluZGV4KSwgbGVuZ3RoKSwgc291cmNlKTtcblxuICAgICAgICBpZiAoc291cmNlICE9PSBfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNvdXJjZXMuU0lMRU5UKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcodGhpcy5zY3JvbGxpbmdDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGV4dCh0ZXh0KSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNvdXJjZXMuQVBJO1xuICAgICAgdmFyIGRlbHRhID0gbmV3IHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKCkuaW5zZXJ0KHRleHQpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q29udGVudHMoZGVsdGEsIHNvdXJjZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNvdXJjZXMuVVNFUjtcbiAgICAgIHZhciBjaGFuZ2UgPSB0aGlzLnNjcm9sbC51cGRhdGUoc291cmNlKTsgLy8gV2lsbCB1cGRhdGUgc2VsZWN0aW9uIGJlZm9yZSBzZWxlY3Rpb24udXBkYXRlKCkgZG9lcyBpZiB0ZXh0IGNoYW5nZXNcblxuICAgICAgdGhpcy5zZWxlY3Rpb24udXBkYXRlKHNvdXJjZSk7IC8vIFRPRE8gdGhpcyBpcyB1c3VhbGx5IHVuZGVmaW5lZFxuXG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVDb250ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDb250ZW50cyhkZWx0YSkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNvdXJjZXMuQVBJO1xuICAgICAgcmV0dXJuIG1vZGlmeS5jYWxsKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsdGEgPSBuZXcgcXVpbGxfZGVsdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEoZGVsdGEpO1xuICAgICAgICByZXR1cm4gX3RoaXMxMC5lZGl0b3IuYXBwbHlEZWx0YShkZWx0YSwgc291cmNlKTtcbiAgICAgIH0sIHNvdXJjZSwgdHJ1ZSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZGVidWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVidWcobGltaXQpIHtcbiAgICAgIGlmIChsaW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICBsaW1pdCA9ICdsb2cnO1xuICAgICAgfVxuXG4gICAgICBfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubGV2ZWwobGltaXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmQobm9kZSkge1xuICAgICAgcmV0dXJuIF9pbnN0YW5jZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXQobm9kZSkgfHwgZ2xvYmFsUmVnaXN0cnkuZmluZChub2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW1wb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbXBvcnQobmFtZSkge1xuICAgICAgaWYgKHRoaXMuaW1wb3J0c1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGRlYnVnLmVycm9yKFwiQ2Fubm90IGltcG9ydCBcIi5jb25jYXQobmFtZSwgXCIuIEFyZSB5b3Ugc3VyZSBpdCB3YXMgcmVnaXN0ZXJlZD9cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5pbXBvcnRzW25hbWVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWdpc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcihwYXRoLCB0YXJnZXQpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcblxuICAgICAgdmFyIG92ZXJ3cml0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXRoLmF0dHJOYW1lIHx8IHBhdGguYmxvdE5hbWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHJlZ2lzdGVyKEJsb3QgfCBBdHRyaWJ1dG9yLCBvdmVyd3JpdGUpXG4gICAgICAgICAgdGhpcy5yZWdpc3RlcihcImZvcm1hdHMvXCIuY29uY2F0KG5hbWUpLCBwYXRoLCB0YXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHBhdGgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgX3RoaXMxMS5yZWdpc3RlcihrZXksIHBhdGhba2V5XSwgdGFyZ2V0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaW1wb3J0c1twYXRoXSAhPSBudWxsICYmICFvdmVyd3JpdGUpIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFwiT3ZlcndyaXRpbmcgXCIuY29uY2F0KHBhdGgsIFwiIHdpdGhcIiksIHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmltcG9ydHNbcGF0aF0gPSB0YXJnZXQ7XG5cbiAgICAgICAgaWYgKChwYXRoLmluZGV4T2YoJ2Jsb3RzLycpID09PSAwIHx8IHBhdGguaW5kZXhPZignZm9ybWF0cy8nKSA9PT0gMCkgJiYgdGFyZ2V0LmJsb3ROYW1lICE9PSAnYWJzdHJhY3QnKSB7XG4gICAgICAgICAgZ2xvYmFsUmVnaXN0cnkucmVnaXN0ZXIodGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0LnJlZ2lzdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlZ2lzdGVyKGdsb2JhbFJlZ2lzdHJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRdWlsbDtcbn0oKTtcblxuUXVpbGwuREVGQVVMVFMgPSB7XG4gIGJvdW5kczogbnVsbCxcbiAgbW9kdWxlczoge30sXG4gIHBsYWNlaG9sZGVyOiAnJyxcbiAgcmVhZE9ubHk6IGZhbHNlLFxuICByZWdpc3RyeTogZ2xvYmFsUmVnaXN0cnksXG4gIHNjcm9sbGluZ0NvbnRhaW5lcjogbnVsbCxcbiAgdGhlbWU6ICdkZWZhdWx0J1xufTtcblF1aWxsLmV2ZW50cyA9IF9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZXZlbnRzO1xuUXVpbGwuc291cmNlcyA9IF9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc291cmNlczsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cblF1aWxsLnZlcnNpb24gPSAgZmFsc2UgPyB1bmRlZmluZWQgOiBcIjEuNS4xNlwiO1xuUXVpbGwuaW1wb3J0cyA9IHtcbiAgZGVsdGE6IHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLFxuICBwYXJjaG1lbnQ6IHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLFxuICAnY29yZS9tb2R1bGUnOiBfbW9kdWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0sXG4gICdjb3JlL3RoZW1lJzogX3RoZW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdXG59O1xuXG5mdW5jdGlvbiBleHBhbmRDb25maWcoY29udGFpbmVyLCB1c2VyQ29uZmlnKSB7XG4gIHVzZXJDb25maWcgPSBsb2Rhc2hfbWVyZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0KCkoe1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIG1vZHVsZXM6IHtcbiAgICAgIGNsaXBib2FyZDogdHJ1ZSxcbiAgICAgIGtleWJvYXJkOiB0cnVlLFxuICAgICAgaGlzdG9yeTogdHJ1ZSxcbiAgICAgIHVwbG9hZGVyOiB0cnVlXG4gICAgfVxuICB9LCB1c2VyQ29uZmlnKTtcblxuICBpZiAoIXVzZXJDb25maWcudGhlbWUgfHwgdXNlckNvbmZpZy50aGVtZSA9PT0gUXVpbGwuREVGQVVMVFMudGhlbWUpIHtcbiAgICB1c2VyQ29uZmlnLnRoZW1lID0gX3RoZW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdO1xuICB9IGVsc2Uge1xuICAgIHVzZXJDb25maWcudGhlbWUgPSBRdWlsbC5pbXBvcnQoXCJ0aGVtZXMvXCIuY29uY2F0KHVzZXJDb25maWcudGhlbWUpKTtcblxuICAgIGlmICh1c2VyQ29uZmlnLnRoZW1lID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGhlbWUgXCIuY29uY2F0KHVzZXJDb25maWcudGhlbWUsIFwiLiBEaWQgeW91IHJlZ2lzdGVyIGl0P1wiKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRoZW1lQ29uZmlnID0gbG9kYXNoX2Nsb25lZGVlcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQoKSh1c2VyQ29uZmlnLnRoZW1lLkRFRkFVTFRTKTtcbiAgW3RoZW1lQ29uZmlnLCB1c2VyQ29uZmlnXS5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICBjb25maWcubW9kdWxlcyA9IGNvbmZpZy5tb2R1bGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGNvbmZpZy5tb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgIGlmIChjb25maWcubW9kdWxlc1ttb2R1bGVdID09PSB0cnVlKSB7XG4gICAgICAgIGNvbmZpZy5tb2R1bGVzW21vZHVsZV0gPSB7fTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHZhciBtb2R1bGVOYW1lcyA9IE9iamVjdC5rZXlzKHRoZW1lQ29uZmlnLm1vZHVsZXMpLmNvbmNhdChPYmplY3Qua2V5cyh1c2VyQ29uZmlnLm1vZHVsZXMpKTtcbiAgdmFyIG1vZHVsZUNvbmZpZyA9IG1vZHVsZU5hbWVzLnJlZHVjZShmdW5jdGlvbiAoY29uZmlnLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZUNsYXNzID0gUXVpbGwuaW1wb3J0KFwibW9kdWxlcy9cIi5jb25jYXQobmFtZSkpO1xuXG4gICAgaWYgKG1vZHVsZUNsYXNzID09IG51bGwpIHtcbiAgICAgIGRlYnVnLmVycm9yKFwiQ2Fubm90IGxvYWQgXCIuY29uY2F0KG5hbWUsIFwiIG1vZHVsZS4gQXJlIHlvdSBzdXJlIHlvdSByZWdpc3RlcmVkIGl0P1wiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZ1tuYW1lXSA9IG1vZHVsZUNsYXNzLkRFRkFVTFRTIHx8IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBjb25maWc7XG4gIH0sIHt9KTsgLy8gU3BlY2lhbCBjYXNlIHRvb2xiYXIgc2hvcnRoYW5kXG5cbiAgaWYgKHVzZXJDb25maWcubW9kdWxlcyAhPSBudWxsICYmIHVzZXJDb25maWcubW9kdWxlcy50b29sYmFyICYmIHVzZXJDb25maWcubW9kdWxlcy50b29sYmFyLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICB1c2VyQ29uZmlnLm1vZHVsZXMudG9vbGJhciA9IHtcbiAgICAgIGNvbnRhaW5lcjogdXNlckNvbmZpZy5tb2R1bGVzLnRvb2xiYXJcbiAgICB9O1xuICB9XG5cbiAgdXNlckNvbmZpZyA9IGxvZGFzaF9tZXJnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQoKSh7fSwgUXVpbGwuREVGQVVMVFMsIHtcbiAgICBtb2R1bGVzOiBtb2R1bGVDb25maWdcbiAgfSwgdGhlbWVDb25maWcsIHVzZXJDb25maWcpO1xuICBbJ2JvdW5kcycsICdjb250YWluZXInLCAnc2Nyb2xsaW5nQ29udGFpbmVyJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiB1c2VyQ29uZmlnW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB1c2VyQ29uZmlnW2tleV0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHVzZXJDb25maWdba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgdXNlckNvbmZpZy5tb2R1bGVzID0gT2JqZWN0LmtleXModXNlckNvbmZpZy5tb2R1bGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGNvbmZpZywgbmFtZSkge1xuICAgIGlmICh1c2VyQ29uZmlnLm1vZHVsZXNbbmFtZV0pIHtcbiAgICAgIGNvbmZpZ1tuYW1lXSA9IHVzZXJDb25maWcubW9kdWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnO1xuICB9LCB7fSk7XG4gIHJldHVybiB1c2VyQ29uZmlnO1xufSAvLyBIYW5kbGUgc2VsZWN0aW9uIHByZXNlcnZhdGlvbiBhbmQgVEVYVF9DSEFOR0UgZW1pc3Npb25cbi8vIGNvbW1vbiB0byBtb2RpZmljYXRpb24gQVBJc1xuXG5cbmZ1bmN0aW9uIG1vZGlmeShtb2RpZmllciwgc291cmNlLCBpbmRleCwgc2hpZnQpIHtcbiAgaWYgKCF0aGlzLmlzRW5hYmxlZCgpICYmIHNvdXJjZSA9PT0gX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zb3VyY2VzLlVTRVIgJiYgIXRoaXMuYWxsb3dSZWFkT25seUVkaXRzKSB7XG4gICAgcmV0dXJuIG5ldyBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSgpO1xuICB9XG5cbiAgdmFyIHJhbmdlID0gaW5kZXggPT0gbnVsbCA/IG51bGwgOiB0aGlzLmdldFNlbGVjdGlvbigpO1xuICB2YXIgb2xkRGVsdGEgPSB0aGlzLmVkaXRvci5kZWx0YTtcbiAgdmFyIGNoYW5nZSA9IG1vZGlmaWVyKCk7XG5cbiAgaWYgKHJhbmdlICE9IG51bGwpIHtcbiAgICBpZiAoaW5kZXggPT09IHRydWUpIHtcbiAgICAgIGluZGV4ID0gcmFuZ2UuaW5kZXg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICB9XG5cbiAgICBpZiAoc2hpZnQgPT0gbnVsbCkge1xuICAgICAgcmFuZ2UgPSBzaGlmdFJhbmdlKHJhbmdlLCBjaGFuZ2UsIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgcmFuZ2UgPSBzaGlmdFJhbmdlKHJhbmdlLCBpbmRleCwgc2hpZnQsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTZWxlY3Rpb24ocmFuZ2UsIF9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc291cmNlcy5TSUxFTlQpO1xuICB9XG5cbiAgaWYgKGNoYW5nZS5sZW5ndGgoKSA+IDApIHtcbiAgICB2YXIgX3RoaXMkZW1pdHRlcjQ7XG5cbiAgICB2YXIgYXJncyA9IFtfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmV2ZW50cy5URVhUX0NIQU5HRSwgY2hhbmdlLCBvbGREZWx0YSwgc291cmNlXTtcblxuICAgIChfdGhpcyRlbWl0dGVyNCA9IHRoaXMuZW1pdHRlcikuZW1pdC5hcHBseShfdGhpcyRlbWl0dGVyNCwgW19lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZXZlbnRzLkVESVRPUl9DSEFOR0VdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBpZiAoc291cmNlICE9PSBfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNvdXJjZXMuU0lMRU5UKSB7XG4gICAgICB2YXIgX3RoaXMkZW1pdHRlcjU7XG5cbiAgICAgIChfdGhpcyRlbWl0dGVyNSA9IHRoaXMuZW1pdHRlcikuZW1pdC5hcHBseShfdGhpcyRlbWl0dGVyNSwgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoYW5nZTtcbn1cblxuZnVuY3Rpb24gb3ZlcmxvYWQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUsIHNvdXJjZSkge1xuICB2YXIgZm9ybWF0cyA9IHt9O1xuXG4gIGlmICh0eXBlb2YgaW5kZXguaW5kZXggPT09ICdudW1iZXInICYmIHR5cGVvZiBpbmRleC5sZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gQWxsb3cgZm9yIHRocm93YXdheSBlbmQgKHVzZWQgYnkgaW5zZXJ0VGV4dC9pbnNlcnRFbWJlZClcbiAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHNvdXJjZSA9IHZhbHVlO1xuICAgICAgdmFsdWUgPSBuYW1lO1xuICAgICAgbmFtZSA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IGluZGV4Lmxlbmd0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gICAgICBpbmRleCA9IGluZGV4LmluZGV4OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IGluZGV4Lmxlbmd0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gICAgICBpbmRleCA9IGluZGV4LmluZGV4OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgc291cmNlID0gdmFsdWU7XG4gICAgdmFsdWUgPSBuYW1lO1xuICAgIG5hbWUgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gMDtcbiAgfSAvLyBIYW5kbGUgZm9ybWF0IGJlaW5nIG9iamVjdCwgdHdvIGZvcm1hdCBuYW1lL3ZhbHVlIHN0cmluZ3Mgb3IgZXhjbHVkZWRcblxuXG4gIGlmIChfdHlwZW9mKG5hbWUpID09PSAnb2JqZWN0Jykge1xuICAgIGZvcm1hdHMgPSBuYW1lO1xuICAgIHNvdXJjZSA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBmb3JtYXRzW25hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZSA9IG5hbWU7XG4gICAgfVxuICB9IC8vIEhhbmRsZSBvcHRpb25hbCBzb3VyY2VcblxuXG4gIHNvdXJjZSA9IHNvdXJjZSB8fCBfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNvdXJjZXMuQVBJO1xuICByZXR1cm4gW2luZGV4LCBsZW5ndGgsIGZvcm1hdHMsIHNvdXJjZV07XG59XG5cbmZ1bmN0aW9uIHNoaWZ0UmFuZ2UocmFuZ2UsIGluZGV4LCBsZW5ndGgsIHNvdXJjZSkge1xuICBpZiAocmFuZ2UgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHZhciBzdGFydDtcbiAgdmFyIGVuZDtcblxuICBpZiAoaW5kZXggaW5zdGFuY2VvZiBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSkge1xuICAgIHZhciBfbWFwID0gW3JhbmdlLmluZGV4LCByYW5nZS5pbmRleCArIHJhbmdlLmxlbmd0aF0ubWFwKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgIHJldHVybiBpbmRleC50cmFuc2Zvcm1Qb3NpdGlvbihwb3MsIHNvdXJjZSAhPT0gX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zb3VyY2VzLlVTRVIpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9tYXAyID0gX3NsaWNlZFRvQXJyYXkoX21hcCwgMik7XG5cbiAgICBzdGFydCA9IF9tYXAyWzBdO1xuICAgIGVuZCA9IF9tYXAyWzFdO1xuICB9IGVsc2Uge1xuICAgIHZhciBfbWFwMyA9IFtyYW5nZS5pbmRleCwgcmFuZ2UuaW5kZXggKyByYW5nZS5sZW5ndGhdLm1hcChmdW5jdGlvbiAocG9zKSB7XG4gICAgICBpZiAocG9zIDwgaW5kZXggfHwgcG9zID09PSBpbmRleCAmJiBzb3VyY2UgPT09IF9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc291cmNlcy5VU0VSKSByZXR1cm4gcG9zO1xuXG4gICAgICBpZiAobGVuZ3RoID49IDApIHtcbiAgICAgICAgcmV0dXJuIHBvcyArIGxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGgubWF4KGluZGV4LCBwb3MgKyBsZW5ndGgpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9tYXA0ID0gX3NsaWNlZFRvQXJyYXkoX21hcDMsIDIpO1xuXG4gICAgc3RhcnQgPSBfbWFwNFswXTtcbiAgICBlbmQgPSBfbWFwNFsxXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgX3NlbGVjdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIFJhbmdlICovIFwiYVwiXShzdGFydCwgZW5kIC0gc3RhcnQpO1xufVxuXG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgZmFzdF9kaWZmXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxMTQpKTtcbnZhciBsb2Rhc2hfY2xvbmVkZWVwXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOCkpO1xudmFyIGxvZGFzaF9pc2VxdWFsXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyOSkpO1xudmFyIEF0dHJpYnV0ZU1hcF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTE1KSk7XG52YXIgT3BfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKSk7XG52YXIgTlVMTF9DSEFSQUNURVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDApOyAvLyBQbGFjZWhvbGRlciBjaGFyIGZvciBlbWJlZCBpbiBkaWZmKClcbnZhciBEZWx0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWx0YShvcHMpIHtcbiAgICAgICAgLy8gQXNzdW1lIHdlIGFyZSBnaXZlbiBhIHdlbGwgZm9ybWVkIG9wc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wcyA9IG9wcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHMgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KG9wcy5vcHMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wcyA9IG9wcy5vcHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wcyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIERlbHRhLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoYXJnLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBuZXdPcCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgJiYgYXJnLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbmV3T3AuaW5zZXJ0ID0gYXJnO1xuICAgICAgICBpZiAoYXR0cmlidXRlcyAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgYXR0cmlidXRlcyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5ld09wLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2gobmV3T3ApO1xuICAgIH07XG4gICAgRGVsdGEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKHsgZGVsZXRlOiBsZW5ndGggfSk7XG4gICAgfTtcbiAgICBEZWx0YS5wcm90b3R5cGUucmV0YWluID0gZnVuY3Rpb24gKGxlbmd0aCwgYXR0cmlidXRlcykge1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdPcCA9IHsgcmV0YWluOiBsZW5ndGggfTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIGF0dHJpYnV0ZXMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBuZXdPcC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKG5ld09wKTtcbiAgICB9O1xuICAgIERlbHRhLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG5ld09wKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMub3BzLmxlbmd0aDtcbiAgICAgICAgdmFyIGxhc3RPcCA9IHRoaXMub3BzW2luZGV4IC0gMV07XG4gICAgICAgIG5ld09wID0gbG9kYXNoX2Nsb25lZGVlcF8xLmRlZmF1bHQobmV3T3ApO1xuICAgICAgICBpZiAodHlwZW9mIGxhc3RPcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3T3AuZGVsZXRlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBsYXN0T3AuZGVsZXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMub3BzW2luZGV4IC0gMV0gPSB7IGRlbGV0ZTogbGFzdE9wLmRlbGV0ZSArIG5ld09wLmRlbGV0ZSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2luY2UgaXQgZG9lcyBub3QgbWF0dGVyIGlmIHdlIGluc2VydCBiZWZvcmUgb3IgYWZ0ZXIgZGVsZXRpbmcgYXQgdGhlIHNhbWUgaW5kZXgsXG4gICAgICAgICAgICAvLyBhbHdheXMgcHJlZmVyIHRvIGluc2VydCBmaXJzdFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0T3AuZGVsZXRlID09PSAnbnVtYmVyJyAmJiBuZXdPcC5pbnNlcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4IC09IDE7XG4gICAgICAgICAgICAgICAgbGFzdE9wID0gdGhpcy5vcHNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RPcCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHMudW5zaGlmdChuZXdPcCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2Rhc2hfaXNlcXVhbF8xLmRlZmF1bHQobmV3T3AuYXR0cmlidXRlcywgbGFzdE9wLmF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdPcC5pbnNlcnQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBsYXN0T3AuaW5zZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wc1tpbmRleCAtIDFdID0geyBpbnNlcnQ6IGxhc3RPcC5pbnNlcnQgKyBuZXdPcC5pbnNlcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdPcC5hdHRyaWJ1dGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHNbaW5kZXggLSAxXS5hdHRyaWJ1dGVzID0gbmV3T3AuYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5ld09wLnJldGFpbiA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGxhc3RPcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BzW2luZGV4IC0gMV0gPSB7IHJldGFpbjogbGFzdE9wLnJldGFpbiArIG5ld09wLnJldGFpbiB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld09wLmF0dHJpYnV0ZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wc1tpbmRleCAtIDFdLmF0dHJpYnV0ZXMgPSBuZXdPcC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMub3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5vcHMucHVzaChuZXdPcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wcy5zcGxpY2UoaW5kZXgsIDAsIG5ld09wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERlbHRhLnByb3RvdHlwZS5jaG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFzdE9wID0gdGhpcy5vcHNbdGhpcy5vcHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0T3AgJiYgbGFzdE9wLnJldGFpbiAmJiAhbGFzdE9wLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMub3BzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRGVsdGEucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BzLmZpbHRlcihwcmVkaWNhdGUpO1xuICAgIH07XG4gICAgRGVsdGEucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMub3BzLmZvckVhY2gocHJlZGljYXRlKTtcbiAgICB9O1xuICAgIERlbHRhLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wcy5tYXAocHJlZGljYXRlKTtcbiAgICB9O1xuICAgIERlbHRhLnByb3RvdHlwZS5wYXJ0aXRpb24gPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBwYXNzZWQgPSBbXTtcbiAgICAgICAgdmFyIGZhaWxlZCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gcHJlZGljYXRlKG9wKSA/IHBhc3NlZCA6IGZhaWxlZDtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG9wKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbcGFzc2VkLCBmYWlsZWRdO1xuICAgIH07XG4gICAgRGVsdGEucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHMucmVkdWNlKHByZWRpY2F0ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9O1xuICAgIERlbHRhLnByb3RvdHlwZS5jaGFuZ2VMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShmdW5jdGlvbiAobGVuZ3RoLCBlbGVtKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS5pbnNlcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoICsgT3BfMS5kZWZhdWx0Lmxlbmd0aChlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsZW0uZGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCAtIGVsZW0uZGVsZXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfSwgMCk7XG4gICAgfTtcbiAgICBEZWx0YS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoZnVuY3Rpb24gKGxlbmd0aCwgZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCArIE9wXzEuZGVmYXVsdC5sZW5ndGgoZWxlbSk7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgRGVsdGEucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XG4gICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBJbmZpbml0eTsgfVxuICAgICAgICB2YXIgb3BzID0gW107XG4gICAgICAgIHZhciBpdGVyID0gT3BfMS5kZWZhdWx0Lml0ZXJhdG9yKHRoaXMub3BzKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kICYmIGl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgbmV4dE9wID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBuZXh0T3AgPSBpdGVyLm5leHQoc3RhcnQgLSBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0T3AgPSBpdGVyLm5leHQoZW5kIC0gaW5kZXgpO1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKG5leHRPcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCArPSBPcF8xLmRlZmF1bHQubGVuZ3RoKG5leHRPcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEZWx0YShvcHMpO1xuICAgIH07XG4gICAgRGVsdGEucHJvdG90eXBlLmNvbXBvc2UgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIHRoaXNJdGVyID0gT3BfMS5kZWZhdWx0Lml0ZXJhdG9yKHRoaXMub3BzKTtcbiAgICAgICAgdmFyIG90aGVySXRlciA9IE9wXzEuZGVmYXVsdC5pdGVyYXRvcihvdGhlci5vcHMpO1xuICAgICAgICB2YXIgb3BzID0gW107XG4gICAgICAgIHZhciBmaXJzdE90aGVyID0gb3RoZXJJdGVyLnBlZWsoKTtcbiAgICAgICAgaWYgKGZpcnN0T3RoZXIgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIGZpcnN0T3RoZXIucmV0YWluID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgZmlyc3RPdGhlci5hdHRyaWJ1dGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdExlZnQgPSBmaXJzdE90aGVyLnJldGFpbjtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzSXRlci5wZWVrVHlwZSgpID09PSAnaW5zZXJ0JyAmJlxuICAgICAgICAgICAgICAgIHRoaXNJdGVyLnBlZWtMZW5ndGgoKSA8PSBmaXJzdExlZnQpIHtcbiAgICAgICAgICAgICAgICBmaXJzdExlZnQgLT0gdGhpc0l0ZXIucGVla0xlbmd0aCgpO1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKHRoaXNJdGVyLm5leHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RPdGhlci5yZXRhaW4gLSBmaXJzdExlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgb3RoZXJJdGVyLm5leHQoZmlyc3RPdGhlci5yZXRhaW4gLSBmaXJzdExlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWx0YSA9IG5ldyBEZWx0YShvcHMpO1xuICAgICAgICB3aGlsZSAodGhpc0l0ZXIuaGFzTmV4dCgpIHx8IG90aGVySXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGlmIChvdGhlckl0ZXIucGVla1R5cGUoKSA9PT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICBkZWx0YS5wdXNoKG90aGVySXRlci5uZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpc0l0ZXIucGVla1R5cGUoKSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICBkZWx0YS5wdXNoKHRoaXNJdGVyLm5leHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSBNYXRoLm1pbih0aGlzSXRlci5wZWVrTGVuZ3RoKCksIG90aGVySXRlci5wZWVrTGVuZ3RoKCkpO1xuICAgICAgICAgICAgICAgIHZhciB0aGlzT3AgPSB0aGlzSXRlci5uZXh0KGxlbmd0aF8xKTtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJPcCA9IG90aGVySXRlci5uZXh0KGxlbmd0aF8xKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG90aGVyT3AucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3T3AgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzT3AucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3T3AucmV0YWluID0gbGVuZ3RoXzE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPcC5pbnNlcnQgPSB0aGlzT3AuaW5zZXJ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIG51bGwgd2hlbiBjb21wb3Npbmcgd2l0aCBhIHJldGFpbiwgb3RoZXJ3aXNlIHJlbW92ZSBpdCBmb3IgaW5zZXJ0c1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IEF0dHJpYnV0ZU1hcF8xLmRlZmF1bHQuY29tcG9zZSh0aGlzT3AuYXR0cmlidXRlcywgb3RoZXJPcC5hdHRyaWJ1dGVzLCB0eXBlb2YgdGhpc09wLnJldGFpbiA9PT0gJ251bWJlcicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3T3AuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsdGEucHVzaChuZXdPcCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbiBpZiByZXN0IG9mIG90aGVyIGlzIGp1c3QgcmV0YWluXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXJJdGVyLmhhc05leHQoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9kYXNoX2lzZXF1YWxfMS5kZWZhdWx0KGRlbHRhLm9wc1tkZWx0YS5vcHMubGVuZ3RoIC0gMV0sIG5ld09wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3QgPSBuZXcgRGVsdGEodGhpc0l0ZXIucmVzdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWx0YS5jb25jYXQocmVzdCkuY2hvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyIG9wIHNob3VsZCBiZSBkZWxldGUsIHdlIGNvdWxkIGJlIGFuIGluc2VydCBvciByZXRhaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0ICsgZGVsZXRlIGNhbmNlbHMgb3V0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvdGhlck9wLmRlbGV0ZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRoaXNPcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhLnB1c2gob3RoZXJPcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWx0YS5jaG9wKCk7XG4gICAgfTtcbiAgICBEZWx0YS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IG5ldyBEZWx0YSh0aGlzLm9wcy5zbGljZSgpKTtcbiAgICAgICAgaWYgKG90aGVyLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZWx0YS5wdXNoKG90aGVyLm9wc1swXSk7XG4gICAgICAgICAgICBkZWx0YS5vcHMgPSBkZWx0YS5vcHMuY29uY2F0KG90aGVyLm9wcy5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH07XG4gICAgRGVsdGEucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAob3RoZXIsIGN1cnNvcikge1xuICAgICAgICBpZiAodGhpcy5vcHMgPT09IG90aGVyLm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWx0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdzID0gW3RoaXMsIG90aGVyXS5tYXAoZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsdGFcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgICAgIGlmIChvcC5pbnNlcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycgPyBvcC5pbnNlcnQgOiBOVUxMX0NIQVJBQ1RFUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByZXAgPSBkZWx0YSA9PT0gb3RoZXIgPyAnb24nIDogJ3dpdGgnO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlmZigpIGNhbGxlZCAnICsgcHJlcCArICcgbm9uLWRvY3VtZW50Jyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZXREZWx0YSA9IG5ldyBEZWx0YSgpO1xuICAgICAgICB2YXIgZGlmZlJlc3VsdCA9IGZhc3RfZGlmZl8xLmRlZmF1bHQoc3RyaW5nc1swXSwgc3RyaW5nc1sxXSwgY3Vyc29yKTtcbiAgICAgICAgdmFyIHRoaXNJdGVyID0gT3BfMS5kZWZhdWx0Lml0ZXJhdG9yKHRoaXMub3BzKTtcbiAgICAgICAgdmFyIG90aGVySXRlciA9IE9wXzEuZGVmYXVsdC5pdGVyYXRvcihvdGhlci5vcHMpO1xuICAgICAgICBkaWZmUmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGNvbXBvbmVudFsxXS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBvcExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb21wb25lbnRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBmYXN0X2RpZmZfMS5kZWZhdWx0LklOU0VSVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wTGVuZ3RoID0gTWF0aC5taW4ob3RoZXJJdGVyLnBlZWtMZW5ndGgoKSwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldERlbHRhLnB1c2gob3RoZXJJdGVyLm5leHQob3BMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGZhc3RfZGlmZl8xLmRlZmF1bHQuREVMRVRFOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3BMZW5ndGggPSBNYXRoLm1pbihsZW5ndGgsIHRoaXNJdGVyLnBlZWtMZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzSXRlci5uZXh0KG9wTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldERlbHRhLmRlbGV0ZShvcExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBmYXN0X2RpZmZfMS5kZWZhdWx0LkVRVUFMOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3BMZW5ndGggPSBNYXRoLm1pbih0aGlzSXRlci5wZWVrTGVuZ3RoKCksIG90aGVySXRlci5wZWVrTGVuZ3RoKCksIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc09wID0gdGhpc0l0ZXIubmV4dChvcExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJPcCA9IG90aGVySXRlci5uZXh0KG9wTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2Rhc2hfaXNlcXVhbF8xLmRlZmF1bHQodGhpc09wLmluc2VydCwgb3RoZXJPcC5pbnNlcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0RGVsdGEucmV0YWluKG9wTGVuZ3RoLCBBdHRyaWJ1dGVNYXBfMS5kZWZhdWx0LmRpZmYodGhpc09wLmF0dHJpYnV0ZXMsIG90aGVyT3AuYXR0cmlidXRlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0RGVsdGEucHVzaChvdGhlck9wKS5kZWxldGUob3BMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxlbmd0aCAtPSBvcExlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXREZWx0YS5jaG9wKCk7XG4gICAgfTtcbiAgICBEZWx0YS5wcm90b3R5cGUuZWFjaExpbmUgPSBmdW5jdGlvbiAocHJlZGljYXRlLCBuZXdsaW5lKSB7XG4gICAgICAgIGlmIChuZXdsaW5lID09PSB2b2lkIDApIHsgbmV3bGluZSA9ICdcXG4nOyB9XG4gICAgICAgIHZhciBpdGVyID0gT3BfMS5kZWZhdWx0Lml0ZXJhdG9yKHRoaXMub3BzKTtcbiAgICAgICAgdmFyIGxpbmUgPSBuZXcgRGVsdGEoKTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGlmIChpdGVyLnBlZWtUeXBlKCkgIT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRoaXNPcCA9IGl0ZXIucGVlaygpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gT3BfMS5kZWZhdWx0Lmxlbmd0aCh0aGlzT3ApIC0gaXRlci5wZWVrTGVuZ3RoKCk7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0eXBlb2YgdGhpc09wLmluc2VydCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IHRoaXNPcC5pbnNlcnQuaW5kZXhPZihuZXdsaW5lLCBzdGFydCkgLSBzdGFydFxuICAgICAgICAgICAgICAgIDogLTE7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgbGluZS5wdXNoKGl0ZXIubmV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmUucHVzaChpdGVyLm5leHQoaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobGluZSwgaXRlci5uZXh0KDEpLmF0dHJpYnV0ZXMgfHwge30sIGkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbmV3IERlbHRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICBwcmVkaWNhdGUobGluZSwge30sIGkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWx0YS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgdmFyIGludmVydGVkID0gbmV3IERlbHRhKCk7XG4gICAgICAgIHRoaXMucmVkdWNlKGZ1bmN0aW9uIChiYXNlSW5kZXgsIG9wKSB7XG4gICAgICAgICAgICBpZiAob3AuaW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWQuZGVsZXRlKE9wXzEuZGVmYXVsdC5sZW5ndGgob3ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wLnJldGFpbiAmJiBvcC5hdHRyaWJ1dGVzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnZlcnRlZC5yZXRhaW4ob3AucmV0YWluKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZUluZGV4ICsgb3AucmV0YWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3AuZGVsZXRlIHx8IChvcC5yZXRhaW4gJiYgb3AuYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzIgPSAob3AuZGVsZXRlIHx8IG9wLnJldGFpbik7XG4gICAgICAgICAgICAgICAgdmFyIHNsaWNlID0gYmFzZS5zbGljZShiYXNlSW5kZXgsIGJhc2VJbmRleCArIGxlbmd0aF8yKTtcbiAgICAgICAgICAgICAgICBzbGljZS5mb3JFYWNoKGZ1bmN0aW9uIChiYXNlT3ApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wLmRlbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ZWQucHVzaChiYXNlT3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wLnJldGFpbiAmJiBvcC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnRlZC5yZXRhaW4oT3BfMS5kZWZhdWx0Lmxlbmd0aChiYXNlT3ApLCBBdHRyaWJ1dGVNYXBfMS5kZWZhdWx0LmludmVydChvcC5hdHRyaWJ1dGVzLCBiYXNlT3AuYXR0cmlidXRlcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VJbmRleCArIGxlbmd0aF8yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJhc2VJbmRleDtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiBpbnZlcnRlZC5jaG9wKCk7XG4gICAgfTtcbiAgICBEZWx0YS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKGFyZywgcHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHsgcHJpb3JpdHkgPSBmYWxzZTsgfVxuICAgICAgICBwcmlvcml0eSA9ICEhcHJpb3JpdHk7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9zaXRpb24oYXJnLCBwcmlvcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG90aGVyID0gYXJnO1xuICAgICAgICB2YXIgdGhpc0l0ZXIgPSBPcF8xLmRlZmF1bHQuaXRlcmF0b3IodGhpcy5vcHMpO1xuICAgICAgICB2YXIgb3RoZXJJdGVyID0gT3BfMS5kZWZhdWx0Lml0ZXJhdG9yKG90aGVyLm9wcyk7XG4gICAgICAgIHZhciBkZWx0YSA9IG5ldyBEZWx0YSgpO1xuICAgICAgICB3aGlsZSAodGhpc0l0ZXIuaGFzTmV4dCgpIHx8IG90aGVySXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzSXRlci5wZWVrVHlwZSgpID09PSAnaW5zZXJ0JyAmJlxuICAgICAgICAgICAgICAgIChwcmlvcml0eSB8fCBvdGhlckl0ZXIucGVla1R5cGUoKSAhPT0gJ2luc2VydCcpKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEucmV0YWluKE9wXzEuZGVmYXVsdC5sZW5ndGgodGhpc0l0ZXIubmV4dCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdGhlckl0ZXIucGVla1R5cGUoKSA9PT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICBkZWx0YS5wdXNoKG90aGVySXRlci5uZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8zID0gTWF0aC5taW4odGhpc0l0ZXIucGVla0xlbmd0aCgpLCBvdGhlckl0ZXIucGVla0xlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc09wID0gdGhpc0l0ZXIubmV4dChsZW5ndGhfMyk7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyT3AgPSBvdGhlckl0ZXIubmV4dChsZW5ndGhfMyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNPcC5kZWxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3VyIGRlbGV0ZSBlaXRoZXIgbWFrZXMgdGhlaXIgZGVsZXRlIHJlZHVuZGFudCBvciByZW1vdmVzIHRoZWlyIHJldGFpblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3RoZXJPcC5kZWxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEucHVzaChvdGhlck9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHJldGFpbiBlaXRoZXIgdGhlaXIgcmV0YWluIG9yIGluc2VydFxuICAgICAgICAgICAgICAgICAgICBkZWx0YS5yZXRhaW4obGVuZ3RoXzMsIEF0dHJpYnV0ZU1hcF8xLmRlZmF1bHQudHJhbnNmb3JtKHRoaXNPcC5hdHRyaWJ1dGVzLCBvdGhlck9wLmF0dHJpYnV0ZXMsIHByaW9yaXR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWx0YS5jaG9wKCk7XG4gICAgfTtcbiAgICBEZWx0YS5wcm90b3R5cGUudHJhbnNmb3JtUG9zaXRpb24gPSBmdW5jdGlvbiAoaW5kZXgsIHByaW9yaXR5KSB7XG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdm9pZCAwKSB7IHByaW9yaXR5ID0gZmFsc2U7IH1cbiAgICAgICAgcHJpb3JpdHkgPSAhIXByaW9yaXR5O1xuICAgICAgICB2YXIgdGhpc0l0ZXIgPSBPcF8xLmRlZmF1bHQuaXRlcmF0b3IodGhpcy5vcHMpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgd2hpbGUgKHRoaXNJdGVyLmhhc05leHQoKSAmJiBvZmZzZXQgPD0gaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGhfNCA9IHRoaXNJdGVyLnBlZWtMZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBuZXh0VHlwZSA9IHRoaXNJdGVyLnBlZWtUeXBlKCk7XG4gICAgICAgICAgICB0aGlzSXRlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dFR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggLT0gTWF0aC5taW4obGVuZ3RoXzQsIGluZGV4IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHRUeXBlID09PSAnaW5zZXJ0JyAmJiAob2Zmc2V0IDwgaW5kZXggfHwgIXByaW9yaXR5KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IGxlbmd0aF80O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aF80O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIERlbHRhLk9wID0gT3BfMS5kZWZhdWx0O1xuICAgIERlbHRhLkF0dHJpYnV0ZU1hcCA9IEF0dHJpYnV0ZU1hcF8xLmRlZmF1bHQ7XG4gICAgcmV0dXJuIERlbHRhO1xufSgpKTtcbm1vZHVsZS5leHBvcnRzID0gRGVsdGE7XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlBhcmVudEJsb3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBhYnN0cmFjdF9wYXJlbnQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ29udGFpbmVyQmxvdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGNvbnRhaW5lcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJMZWFmQmxvdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGxlYWY7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRW1iZWRCbG90XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gYmxvdF9lbWJlZDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJTY3JvbGxCbG90XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gYmxvdF9zY3JvbGw7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQmxvY2tCbG90XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gYmxvY2s7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiSW5saW5lQmxvdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGlubGluZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUZXh0QmxvdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGJsb3RfdGV4dDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJBdHRyaWJ1dG9yXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gYXR0cmlidXRvcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDbGFzc0F0dHJpYnV0b3JcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBhdHRyaWJ1dG9yX2NsYXNzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlN0eWxlQXR0cmlidXRvclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHN0eWxlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkF0dHJpYnV0b3JTdG9yZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHN0b3JlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlJlZ2lzdHJ5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gcmVnaXN0cnk7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU2NvcGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBzcmNfc2NvcGU7IH0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9wYXJjaG1lbnQvc3JjL3Njb3BlLnRzXG52YXIgU2NvcGU7XG5cbihmdW5jdGlvbiAoU2NvcGUpIHtcbiAgU2NvcGVbU2NvcGVbXCJUWVBFXCJdID0gM10gPSBcIlRZUEVcIjtcbiAgU2NvcGVbU2NvcGVbXCJMRVZFTFwiXSA9IDEyXSA9IFwiTEVWRUxcIjtcbiAgU2NvcGVbU2NvcGVbXCJBVFRSSUJVVEVcIl0gPSAxM10gPSBcIkFUVFJJQlVURVwiO1xuICBTY29wZVtTY29wZVtcIkJMT1RcIl0gPSAxNF0gPSBcIkJMT1RcIjtcbiAgU2NvcGVbU2NvcGVbXCJJTkxJTkVcIl0gPSA3XSA9IFwiSU5MSU5FXCI7XG4gIFNjb3BlW1Njb3BlW1wiQkxPQ0tcIl0gPSAxMV0gPSBcIkJMT0NLXCI7XG4gIFNjb3BlW1Njb3BlW1wiQkxPQ0tfQkxPVFwiXSA9IDEwXSA9IFwiQkxPQ0tfQkxPVFwiO1xuICBTY29wZVtTY29wZVtcIklOTElORV9CTE9UXCJdID0gNl0gPSBcIklOTElORV9CTE9UXCI7XG4gIFNjb3BlW1Njb3BlW1wiQkxPQ0tfQVRUUklCVVRFXCJdID0gOV0gPSBcIkJMT0NLX0FUVFJJQlVURVwiO1xuICBTY29wZVtTY29wZVtcIklOTElORV9BVFRSSUJVVEVcIl0gPSA1XSA9IFwiSU5MSU5FX0FUVFJJQlVURVwiO1xuICBTY29wZVtTY29wZVtcIkFOWVwiXSA9IDE1XSA9IFwiQU5ZXCI7XG59KShTY29wZSB8fCAoU2NvcGUgPSB7fSkpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfc2NvcGUgPSAoU2NvcGUpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvcGFyY2htZW50L3NyYy9jb2xsZWN0aW9uL2xpbmtlZC1saXN0LnRzXG52YXIgTGlua2VkTGlzdCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpbmtlZExpc3QoKSB7XG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIExpbmtlZExpc3QucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBub2Rlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cblxuICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG5vZGVzWzBdLCBudWxsKTtcblxuICAgIGlmIChub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgcmVzdCA9IG5vZGVzLnNsaWNlKDEpO1xuICAgICAgdGhpcy5hcHBlbmQuYXBwbHkodGhpcywgcmVzdCk7XG4gICAgfVxuICB9O1xuXG4gIExpbmtlZExpc3QucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgdmFyIGN1ciA9IG5leHQoKTtcblxuICAgIHdoaWxlIChjdXIgJiYgaW5kZXggPiAwKSB7XG4gICAgICBpbmRleCAtPSAxO1xuICAgICAgY3VyID0gbmV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXI7XG4gIH07XG5cbiAgTGlua2VkTGlzdC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBuZXh0ID0gdGhpcy5pdGVyYXRvcigpO1xuICAgIHZhciBjdXIgPSBuZXh0KCk7XG5cbiAgICB3aGlsZSAoY3VyKSB7XG4gICAgICBpZiAoY3VyID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjdXIgPSBuZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIExpbmtlZExpc3QucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBuZXh0ID0gdGhpcy5pdGVyYXRvcigpO1xuICAgIHZhciBjdXIgPSBuZXh0KCk7XG4gICAgdmFyIGluZGV4ID0gMDtcblxuICAgIHdoaWxlIChjdXIpIHtcbiAgICAgIGlmIChjdXIgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuXG4gICAgICBpbmRleCArPSAxO1xuICAgICAgY3VyID0gbmV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBMaW5rZWRMaXN0LnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAobm9kZSwgcmVmTm9kZSkge1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZShub2RlKTtcbiAgICBub2RlLm5leHQgPSByZWZOb2RlO1xuXG4gICAgaWYgKHJlZk5vZGUgIT0gbnVsbCkge1xuICAgICAgbm9kZS5wcmV2ID0gcmVmTm9kZS5wcmV2O1xuXG4gICAgICBpZiAocmVmTm9kZS5wcmV2ICE9IG51bGwpIHtcbiAgICAgICAgcmVmTm9kZS5wcmV2Lm5leHQgPSBub2RlO1xuICAgICAgfVxuXG4gICAgICByZWZOb2RlLnByZXYgPSBub2RlO1xuXG4gICAgICBpZiAocmVmTm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnRhaWwgIT0gbnVsbCkge1xuICAgICAgdGhpcy50YWlsLm5leHQgPSBub2RlO1xuICAgICAgbm9kZS5wcmV2ID0gdGhpcy50YWlsO1xuICAgICAgdGhpcy50YWlsID0gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5vZGU7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgfTtcblxuICBMaW5rZWRMaXN0LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY3VyID0gdGhpcy5oZWFkO1xuXG4gICAgd2hpbGUgKGN1ciAhPSBudWxsKSB7XG4gICAgICBpZiAoY3VyID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuXG4gICAgICBpbmRleCArPSBjdXIubGVuZ3RoKCk7XG4gICAgICBjdXIgPSBjdXIubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgTGlua2VkTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbnMobm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5wcmV2ICE9IG51bGwpIHtcbiAgICAgIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgIH1cblxuICAgIGlmIChub2RlLm5leHQgIT0gbnVsbCkge1xuICAgICAgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgICAgdGhpcy5oZWFkID0gbm9kZS5uZXh0O1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICAgIHRoaXMudGFpbCA9IG5vZGUucHJldjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCAtPSAxO1xuICB9O1xuXG4gIExpbmtlZExpc3QucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gKGN1ck5vZGUpIHtcbiAgICBpZiAoY3VyTm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjdXJOb2RlID0gdGhpcy5oZWFkO1xuICAgIH0gLy8gVE9ETyB1c2UgeWllbGQgd2hlbiB3ZSBjYW5cblxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXQgPSBjdXJOb2RlO1xuXG4gICAgICBpZiAoY3VyTm9kZSAhPSBudWxsKSB7XG4gICAgICAgIGN1ck5vZGUgPSBjdXJOb2RlLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfTtcblxuICBMaW5rZWRMaXN0LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGluZGV4LCBpbmNsdXNpdmUpIHtcbiAgICBpZiAoaW5jbHVzaXZlID09PSB2b2lkIDApIHtcbiAgICAgIGluY2x1c2l2ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBuZXh0ID0gdGhpcy5pdGVyYXRvcigpO1xuICAgIHZhciBjdXIgPSBuZXh0KCk7XG5cbiAgICB3aGlsZSAoY3VyKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY3VyLmxlbmd0aCgpO1xuXG4gICAgICBpZiAoaW5kZXggPCBsZW5ndGggfHwgaW5jbHVzaXZlICYmIGluZGV4ID09PSBsZW5ndGggJiYgKGN1ci5uZXh0ID09IG51bGwgfHwgY3VyLm5leHQubGVuZ3RoKCkgIT09IDApKSB7XG4gICAgICAgIHJldHVybiBbY3VyLCBpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGluZGV4IC09IGxlbmd0aDtcbiAgICAgIGN1ciA9IG5leHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW251bGwsIDBdO1xuICB9O1xuXG4gIExpbmtlZExpc3QucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICB2YXIgY3VyID0gbmV4dCgpO1xuXG4gICAgd2hpbGUgKGN1cikge1xuICAgICAgY2FsbGJhY2soY3VyKTtcbiAgICAgIGN1ciA9IG5leHQoKTtcbiAgICB9XG4gIH07XG5cbiAgTGlua2VkTGlzdC5wcm90b3R5cGUuZm9yRWFjaEF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9hID0gdGhpcy5maW5kKGluZGV4KSxcbiAgICAgICAgc3RhcnROb2RlID0gX2FbMF0sXG4gICAgICAgIG9mZnNldCA9IF9hWzFdO1xuXG4gICAgdmFyIGN1ckluZGV4ID0gaW5kZXggLSBvZmZzZXQ7XG4gICAgdmFyIG5leHQgPSB0aGlzLml0ZXJhdG9yKHN0YXJ0Tm9kZSk7XG4gICAgdmFyIGN1ciA9IG5leHQoKTtcblxuICAgIHdoaWxlIChjdXIgJiYgY3VySW5kZXggPCBpbmRleCArIGxlbmd0aCkge1xuICAgICAgdmFyIGN1ckxlbmd0aCA9IGN1ci5sZW5ndGgoKTtcblxuICAgICAgaWYgKGluZGV4ID4gY3VySW5kZXgpIHtcbiAgICAgICAgY2FsbGJhY2soY3VyLCBpbmRleCAtIGN1ckluZGV4LCBNYXRoLm1pbihsZW5ndGgsIGN1ckluZGV4ICsgY3VyTGVuZ3RoIC0gaW5kZXgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKGN1ciwgMCwgTWF0aC5taW4oY3VyTGVuZ3RoLCBpbmRleCArIGxlbmd0aCAtIGN1ckluZGV4KSk7XG4gICAgICB9XG5cbiAgICAgIGN1ckluZGV4ICs9IGN1ckxlbmd0aDtcbiAgICAgIGN1ciA9IG5leHQoKTtcbiAgICB9XG4gIH07XG5cbiAgTGlua2VkTGlzdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjdXIpIHtcbiAgICAgIG1lbW8ucHVzaChjYWxsYmFjayhjdXIpKTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIFtdKTtcbiAgfTtcblxuICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG1lbW8pIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICB2YXIgY3VyID0gbmV4dCgpO1xuXG4gICAgd2hpbGUgKGN1cikge1xuICAgICAgbWVtbyA9IGNhbGxiYWNrKG1lbW8sIGN1cik7XG4gICAgICBjdXIgPSBuZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgcmV0dXJuIExpbmtlZExpc3Q7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGxpbmtlZF9saXN0ID0gKExpbmtlZExpc3QpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvcGFyY2htZW50L3NyYy9lcnJvci50c1xudmFyIF9fZXh0ZW5kcyA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzIHx8IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9leHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gZXh0ZW5kU3RhdGljcyhkLCBiKSB7XG4gICAgX2V4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgICAgX19wcm90b19fOiBbXVxuICAgIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZC5fX3Byb3RvX18gPSBiO1xuICAgIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikge1xuICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgfVxuXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xufSgpO1xuXG52YXIgUGFyY2htZW50RXJyb3IgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUGFyY2htZW50RXJyb3IsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gUGFyY2htZW50RXJyb3IobWVzc2FnZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBtZXNzYWdlID0gJ1tQYXJjaG1lbnRdICcgKyBtZXNzYWdlO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICBfdGhpcy5uYW1lID0gX3RoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gUGFyY2htZW50RXJyb3I7XG59KEVycm9yKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZXJyb3IgPSAoUGFyY2htZW50RXJyb3IpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvcGFyY2htZW50L3NyYy9yZWdpc3RyeS50c1xuXG5cblxudmFyIHJlZ2lzdHJ5X1JlZ2lzdHJ5ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVnaXN0cnkoKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5jbGFzc2VzID0ge307XG4gICAgdGhpcy50YWdzID0ge307XG4gICAgdGhpcy50eXBlcyA9IHt9O1xuICB9XG5cbiAgUmVnaXN0cnkuZmluZCA9IGZ1bmN0aW9uIChub2RlLCBidWJibGUpIHtcbiAgICBpZiAoYnViYmxlID09PSB2b2lkIDApIHtcbiAgICAgIGJ1YmJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJsb3RzLmhhcyhub2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuYmxvdHMuZ2V0KG5vZGUpIHx8IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGJ1YmJsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChub2RlLnBhcmVudE5vZGUsIGJ1YmJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgUmVnaXN0cnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzY3JvbGwsIGlucHV0LCB2YWx1ZSkge1xuICAgIHZhciBtYXRjaCA9IHRoaXMucXVlcnkoaW5wdXQpO1xuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgXCIgKyBpbnB1dCArIFwiIGJsb3RcIik7XG4gICAgfVxuXG4gICAgdmFyIGJsb3RDbGFzcyA9IG1hdGNoO1xuICAgIHZhciBub2RlID0gLy8gQHRzLWlnbm9yZVxuICAgIGlucHV0IGluc3RhbmNlb2YgTm9kZSB8fCBpbnB1dC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgPyBpbnB1dCA6IGJsb3RDbGFzcy5jcmVhdGUodmFsdWUpO1xuICAgIHZhciBibG90ID0gbmV3IGJsb3RDbGFzcyhzY3JvbGwsIG5vZGUsIHZhbHVlKTtcbiAgICBSZWdpc3RyeS5ibG90cy5zZXQoYmxvdC5kb21Ob2RlLCBibG90KTtcbiAgICByZXR1cm4gYmxvdDtcbiAgfTtcblxuICBSZWdpc3RyeS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChub2RlLCBidWJibGUpIHtcbiAgICBpZiAoYnViYmxlID09PSB2b2lkIDApIHtcbiAgICAgIGJ1YmJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBSZWdpc3RyeS5maW5kKG5vZGUsIGJ1YmJsZSk7XG4gIH07XG5cbiAgUmVnaXN0cnkucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5LCBzY29wZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoc2NvcGUgPT09IHZvaWQgMCkge1xuICAgICAgc2NvcGUgPSBzcmNfc2NvcGUuQU5ZO1xuICAgIH1cblxuICAgIHZhciBtYXRjaDtcblxuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtYXRjaCA9IHRoaXMudHlwZXNbcXVlcnldIHx8IHRoaXMuYXR0cmlidXRlc1txdWVyeV07IC8vIEB0cy1pZ25vcmVcbiAgICB9IGVsc2UgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgVGV4dCB8fCBxdWVyeS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIG1hdGNoID0gdGhpcy50eXBlcy50ZXh0O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHF1ZXJ5ICYgc3JjX3Njb3BlLkxFVkVMICYgc3JjX3Njb3BlLkJMT0NLKSB7XG4gICAgICAgIG1hdGNoID0gdGhpcy50eXBlcy5ibG9jaztcbiAgICAgIH0gZWxzZSBpZiAocXVlcnkgJiBzcmNfc2NvcGUuTEVWRUwgJiBzcmNfc2NvcGUuSU5MSU5FKSB7XG4gICAgICAgIG1hdGNoID0gdGhpcy50eXBlcy5pbmxpbmU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChxdWVyeSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZXMgPSAocXVlcnkuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKS5zcGxpdCgvXFxzKy8pO1xuICAgICAgbmFtZXMuc29tZShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBtYXRjaCA9IF90aGlzLmNsYXNzZXNbbmFtZV07XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIG1hdGNoID0gbWF0Y2ggfHwgdGhpcy50YWdzW3F1ZXJ5LnRhZ05hbWVdO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIEB0cy1pZ25vcmVcblxuXG4gICAgaWYgKHNjb3BlICYgc3JjX3Njb3BlLkxFVkVMICYgbWF0Y2guc2NvcGUgJiYgc2NvcGUgJiBzcmNfc2NvcGUuVFlQRSAmIG1hdGNoLnNjb3BlKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgUmVnaXN0cnkucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZGVmaW5pdGlvbnMgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBkZWZpbml0aW9uc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cblxuICAgIGlmIChkZWZpbml0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gZGVmaW5pdGlvbnMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5yZWdpc3RlcihkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBkZWZpbml0aW9uID0gZGVmaW5pdGlvbnNbMF07XG5cbiAgICBpZiAodHlwZW9mIGRlZmluaXRpb24uYmxvdE5hbWUgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBkZWZpbml0aW9uLmF0dHJOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IGVycm9yKCdJbnZhbGlkIGRlZmluaXRpb24nKTtcbiAgICB9IGVsc2UgaWYgKGRlZmluaXRpb24uYmxvdE5hbWUgPT09ICdhYnN0cmFjdCcpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcignQ2Fubm90IHJlZ2lzdGVyIGFic3RyYWN0IGNsYXNzJyk7XG4gICAgfVxuXG4gICAgdGhpcy50eXBlc1tkZWZpbml0aW9uLmJsb3ROYW1lIHx8IGRlZmluaXRpb24uYXR0ck5hbWVdID0gZGVmaW5pdGlvbjtcblxuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbi5rZXlOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW2RlZmluaXRpb24ua2V5TmFtZV0gPSBkZWZpbml0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGVmaW5pdGlvbi5jbGFzc05hbWUgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNsYXNzZXNbZGVmaW5pdGlvbi5jbGFzc05hbWVdID0gZGVmaW5pdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluaXRpb24udGFnTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24udGFnTmFtZSkpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLnRhZ05hbWUgPSBkZWZpbml0aW9uLnRhZ05hbWUubWFwKGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmluaXRpb24udGFnTmFtZSA9IGRlZmluaXRpb24udGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRhZ05hbWVzID0gQXJyYXkuaXNBcnJheShkZWZpbml0aW9uLnRhZ05hbWUpID8gZGVmaW5pdGlvbi50YWdOYW1lIDogW2RlZmluaXRpb24udGFnTmFtZV07XG4gICAgICAgIHRhZ05hbWVzLmZvckVhY2goZnVuY3Rpb24gKHRhZykge1xuICAgICAgICAgIGlmIChfdGhpcy50YWdzW3RhZ10gPT0gbnVsbCB8fCBkZWZpbml0aW9uLmNsYXNzTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy50YWdzW3RhZ10gPSBkZWZpbml0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmluaXRpb247XG4gIH07XG5cbiAgUmVnaXN0cnkuYmxvdHMgPSBuZXcgV2Vha01hcCgpO1xuICByZXR1cm4gUmVnaXN0cnk7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5X1JlZ2lzdHJ5KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3BhcmNobWVudC9zcmMvYmxvdC9hYnN0cmFjdC9zaGFkb3cudHNcblxuXG5cblxudmFyIHNoYWRvd19TaGFkb3dCbG90ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hhZG93QmxvdChzY3JvbGwsIGRvbU5vZGUpIHtcbiAgICB0aGlzLnNjcm9sbCA9IHNjcm9sbDtcbiAgICB0aGlzLmRvbU5vZGUgPSBkb21Ob2RlO1xuICAgIHJlZ2lzdHJ5LmJsb3RzLnNldChkb21Ob2RlLCB0aGlzKTtcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gIH1cblxuICBTaGFkb3dCbG90LmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnRhZ05hbWUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IGVycm9yKCdCbG90IGRlZmluaXRpb24gbWlzc2luZyB0YWdOYW1lJyk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKHBhcnNlSW50KHZhbHVlLCAxMCkudG9TdHJpbmcoKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy50YWdOYW1lW3ZhbHVlIC0gMV0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRhZ05hbWUuaW5kZXhPZih2YWx1ZSkgPiAtMSkge1xuICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWVbMF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNsYXNzTmFtZSkge1xuICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hhZG93QmxvdC5wcm90b3R5cGUsIFwic3RhdGljc1wiLCB7XG4gICAgLy8gSGFjayBmb3IgYWNjZXNzaW5nIGluaGVyaXRlZCBzdGF0aWMgbWV0aG9kc1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3I7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG5cbiAgU2hhZG93QmxvdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKCkgey8vIE5vdGhpbmcgdG8gZG9cbiAgfTtcblxuICBTaGFkb3dCbG90LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9tTm9kZSA9IHRoaXMuZG9tTm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLnNjcm9sbC5jcmVhdGUoZG9tTm9kZSk7XG4gIH07XG5cbiAgU2hhZG93QmxvdC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB9XG5cbiAgICByZWdpc3RyeS5ibG90cy5kZWxldGUodGhpcy5kb21Ob2RlKTtcbiAgfTtcblxuICBTaGFkb3dCbG90LnByb3RvdHlwZS5kZWxldGVBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgdmFyIGJsb3QgPSB0aGlzLmlzb2xhdGUoaW5kZXgsIGxlbmd0aCk7XG4gICAgYmxvdC5yZW1vdmUoKTtcbiAgfTtcblxuICBTaGFkb3dCbG90LnByb3RvdHlwZS5mb3JtYXRBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBibG90ID0gdGhpcy5pc29sYXRlKGluZGV4LCBsZW5ndGgpO1xuXG4gICAgaWYgKHRoaXMuc2Nyb2xsLnF1ZXJ5KG5hbWUsIHNyY19zY29wZS5CTE9UKSAhPSBudWxsICYmIHZhbHVlKSB7XG4gICAgICBibG90LndyYXAobmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zY3JvbGwucXVlcnkobmFtZSwgc3JjX3Njb3BlLkFUVFJJQlVURSkgIT0gbnVsbCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuc2Nyb2xsLmNyZWF0ZSh0aGlzLnN0YXRpY3Muc2NvcGUpO1xuICAgICAgYmxvdC53cmFwKHBhcmVudCk7XG4gICAgICBwYXJlbnQuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgU2hhZG93QmxvdC5wcm90b3R5cGUuaW5zZXJ0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICB2YXIgYmxvdCA9IGRlZiA9PSBudWxsID8gdGhpcy5zY3JvbGwuY3JlYXRlKCd0ZXh0JywgdmFsdWUpIDogdGhpcy5zY3JvbGwuY3JlYXRlKHZhbHVlLCBkZWYpO1xuICAgIHZhciByZWYgPSB0aGlzLnNwbGl0KGluZGV4KTtcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYmxvdCwgcmVmIHx8IHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgU2hhZG93QmxvdC5wcm90b3R5cGUuaXNvbGF0ZSA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuc3BsaXQoaW5kZXgpO1xuXG4gICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHQgdG8gaXNvbGF0ZSBhdCBlbmQnKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuc3BsaXQobGVuZ3RoKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIFNoYWRvd0Jsb3QucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMTtcbiAgfTtcblxuICBTaGFkb3dCbG90LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAocm9vdCkge1xuICAgIGlmIChyb290ID09PSB2b2lkIDApIHtcbiAgICAgIHJvb3QgPSB0aGlzLnBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJlbnQgPT0gbnVsbCB8fCB0aGlzID09PSByb290KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGRyZW4ub2Zmc2V0KHRoaXMpICsgdGhpcy5wYXJlbnQub2Zmc2V0KHJvb3QpO1xuICB9O1xuXG4gIFNoYWRvd0Jsb3QucHJvdG90eXBlLm9wdGltaXplID0gZnVuY3Rpb24gKF9jb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuc3RhdGljcy5yZXF1aXJlZENvbnRhaW5lciAmJiAhKHRoaXMucGFyZW50IGluc3RhbmNlb2YgdGhpcy5zdGF0aWNzLnJlcXVpcmVkQ29udGFpbmVyKSkge1xuICAgICAgdGhpcy53cmFwKHRoaXMuc3RhdGljcy5yZXF1aXJlZENvbnRhaW5lci5ibG90TmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIFNoYWRvd0Jsb3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kb21Ob2RlLnBhcmVudE5vZGUgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kb21Ob2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb21Ob2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLmRldGFjaCgpO1xuICB9O1xuXG4gIFNoYWRvd0Jsb3QucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHJlcGxhY2VtZW50ID0gdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnID8gdGhpcy5zY3JvbGwuY3JlYXRlKG5hbWUsIHZhbHVlKSA6IG5hbWU7XG5cbiAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHJlcGxhY2VtZW50LCB0aGlzLm5leHQgfHwgdW5kZWZpbmVkKTtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcGxhY2VtZW50O1xuICB9O1xuXG4gIFNoYWRvd0Jsb3QucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKGluZGV4LCBfZm9yY2UpIHtcbiAgICByZXR1cm4gaW5kZXggPT09IDAgPyB0aGlzIDogdGhpcy5uZXh0O1xuICB9O1xuXG4gIFNoYWRvd0Jsb3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChfbXV0YXRpb25zLCBfY29udGV4dCkgey8vIE5vdGhpbmcgdG8gZG8gYnkgZGVmYXVsdFxuICB9O1xuXG4gIFNoYWRvd0Jsb3QucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgd3JhcHBlciA9IHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyA/IHRoaXMuc2Nyb2xsLmNyZWF0ZShuYW1lLCB2YWx1ZSkgOiBuYW1lO1xuXG4gICAgaWYgKHRoaXMucGFyZW50ICE9IG51bGwpIHtcbiAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh3cmFwcGVyLCB0aGlzLm5leHQgfHwgdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdyYXBwZXIuYXBwZW5kQ2hpbGQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBlcnJvcihcIkNhbm5vdCB3cmFwIFwiICsgbmFtZSk7XG4gICAgfVxuXG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfTtcblxuICBTaGFkb3dCbG90LmJsb3ROYW1lID0gJ2Fic3RyYWN0JztcbiAgcmV0dXJuIFNoYWRvd0Jsb3Q7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNoYWRvdyA9IChzaGFkb3dfU2hhZG93QmxvdCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9wYXJjaG1lbnQvc3JjL2Jsb3QvYWJzdHJhY3QvcGFyZW50LnRzXG52YXIgcGFyZW50X2V4dGVuZHMgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoKSB7XG4gIHZhciBfZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIGV4dGVuZFN0YXRpY3MoZCwgYikge1xuICAgIF9leHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICAgIF9fcHJvdG9fXzogW11cbiAgICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGQuX19wcm90b19fID0gYjtcbiAgICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIHtcbiAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZFN0YXRpY3MoZCwgYik7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgX2V4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgICBmdW5jdGlvbiBfXygpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICAgIH1cblxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cbmZ1bmN0aW9uIG1ha2VBdHRhY2hlZEJsb3Qobm9kZSwgc2Nyb2xsKSB7XG4gIHZhciBibG90ID0gc2Nyb2xsLmZpbmQobm9kZSk7XG5cbiAgaWYgKGJsb3QgPT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICBibG90ID0gc2Nyb2xsLmNyZWF0ZShub2RlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBibG90ID0gc2Nyb2xsLmNyZWF0ZShzcmNfc2NvcGUuSU5MSU5FKTtcbiAgICAgIEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGJsb3QuZG9tTm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJsb3QuZG9tTm9kZSwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGJsb3QuYXR0YWNoKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJsb3Q7XG59XG5cbnZhciBwYXJlbnRfUGFyZW50QmxvdCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIHBhcmVudF9leHRlbmRzKFBhcmVudEJsb3QsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gUGFyZW50QmxvdChzY3JvbGwsIGRvbU5vZGUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzY3JvbGwsIGRvbU5vZGUpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy51aU5vZGUgPSBudWxsO1xuXG4gICAgX3RoaXMuYnVpbGQoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFBhcmVudEJsb3QucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdGhpcy5pbnNlcnRCZWZvcmUob3RoZXIpO1xuICB9O1xuXG4gIFBhcmVudEJsb3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLmF0dGFjaC5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgY2hpbGQuYXR0YWNoKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgUGFyZW50QmxvdC5wcm90b3R5cGUuYXR0YWNoVUkgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICh0aGlzLnVpTm9kZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnVpTm9kZS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnVpTm9kZSA9IG5vZGU7XG5cbiAgICBpZiAoUGFyZW50QmxvdC51aUNsYXNzKSB7XG4gICAgICB0aGlzLnVpTm9kZS5jbGFzc0xpc3QuYWRkKFBhcmVudEJsb3QudWlDbGFzcyk7XG4gICAgfVxuXG4gICAgdGhpcy51aU5vZGUuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAnZmFsc2UnKTtcbiAgICB0aGlzLmRvbU5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMudWlOb2RlLCB0aGlzLmRvbU5vZGUuZmlyc3RDaGlsZCk7XG4gIH07XG5cbiAgUGFyZW50QmxvdC5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgbGlua2VkX2xpc3QoKTsgLy8gTmVlZCB0byBiZSByZXZlcnNlZCBmb3IgaWYgRE9NIG5vZGVzIGFscmVhZHkgaW4gb3JkZXJcblxuICAgIEFycmF5LmZyb20odGhpcy5kb21Ob2RlLmNoaWxkTm9kZXMpLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUgIT09IF90aGlzLnVpTm9kZTtcbiAgICB9KS5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGNoaWxkID0gbWFrZUF0dGFjaGVkQmxvdChub2RlLCBfdGhpcy5zY3JvbGwpO1xuXG4gICAgICAgIF90aGlzLmluc2VydEJlZm9yZShjaGlsZCwgX3RoaXMuY2hpbGRyZW4uaGVhZCB8fCB1bmRlZmluZWQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBlcnJvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBQYXJlbnRCbG90LnByb3RvdHlwZS5kZWxldGVBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgaWYgKGluZGV4ID09PSAwICYmIGxlbmd0aCA9PT0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoQXQoaW5kZXgsIGxlbmd0aCwgZnVuY3Rpb24gKGNoaWxkLCBvZmZzZXQsIGNoaWxkTGVuZ3RoKSB7XG4gICAgICBjaGlsZC5kZWxldGVBdChvZmZzZXQsIGNoaWxkTGVuZ3RoKTtcbiAgICB9KTtcbiAgfTtcblxuICBQYXJlbnRCbG90LnByb3RvdHlwZS5kZXNjZW5kYW50ID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICBpbmRleCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIF9hID0gdGhpcy5jaGlsZHJlbi5maW5kKGluZGV4KSxcbiAgICAgICAgY2hpbGQgPSBfYVswXSxcbiAgICAgICAgb2Zmc2V0ID0gX2FbMV07XG5cbiAgICBpZiAoY3JpdGVyaWEuYmxvdE5hbWUgPT0gbnVsbCAmJiBjcml0ZXJpYShjaGlsZCkgfHwgY3JpdGVyaWEuYmxvdE5hbWUgIT0gbnVsbCAmJiBjaGlsZCBpbnN0YW5jZW9mIGNyaXRlcmlhKSB7XG4gICAgICByZXR1cm4gW2NoaWxkLCBvZmZzZXRdO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBQYXJlbnRCbG90KSB7XG4gICAgICByZXR1cm4gY2hpbGQuZGVzY2VuZGFudChjcml0ZXJpYSwgb2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtudWxsLCAtMV07XG4gICAgfVxuICB9O1xuXG4gIFBhcmVudEJsb3QucHJvdG90eXBlLmRlc2NlbmRhbnRzID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgIGluZGV4ID0gMDtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICAgIGxlbmd0aCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgfVxuXG4gICAgdmFyIGRlc2NlbmRhbnRzID0gW107XG4gICAgdmFyIGxlbmd0aExlZnQgPSBsZW5ndGg7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoQXQoaW5kZXgsIGxlbmd0aCwgZnVuY3Rpb24gKGNoaWxkLCBjaGlsZEluZGV4LCBjaGlsZExlbmd0aCkge1xuICAgICAgaWYgKGNyaXRlcmlhLmJsb3ROYW1lID09IG51bGwgJiYgY3JpdGVyaWEoY2hpbGQpIHx8IGNyaXRlcmlhLmJsb3ROYW1lICE9IG51bGwgJiYgY2hpbGQgaW5zdGFuY2VvZiBjcml0ZXJpYSkge1xuICAgICAgICBkZXNjZW5kYW50cy5wdXNoKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgUGFyZW50QmxvdCkge1xuICAgICAgICBkZXNjZW5kYW50cyA9IGRlc2NlbmRhbnRzLmNvbmNhdChjaGlsZC5kZXNjZW5kYW50cyhjcml0ZXJpYSwgY2hpbGRJbmRleCwgbGVuZ3RoTGVmdCkpO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGhMZWZ0IC09IGNoaWxkTGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiBkZXNjZW5kYW50cztcbiAgfTtcblxuICBQYXJlbnRCbG90LnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgY2hpbGQuZGV0YWNoKCk7XG4gICAgfSk7XG5cbiAgICBfc3VwZXIucHJvdG90eXBlLmRldGFjaC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIFBhcmVudEJsb3QucHJvdG90eXBlLmVuZm9yY2VBbGxvd2VkQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWxsb3dlZCA9IF90aGlzLnN0YXRpY3MuYWxsb3dlZENoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGRlZikge1xuICAgICAgICByZXR1cm4gY2hpbGQgaW5zdGFuY2VvZiBkZWY7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGQuc3RhdGljcy5zY29wZSA9PT0gc3JjX3Njb3BlLkJMT0NLX0JMT1QpIHtcbiAgICAgICAgaWYgKGNoaWxkLm5leHQgIT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzLnNwbGl0QWZ0ZXIoY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkLnByZXYgIT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzLnNwbGl0QWZ0ZXIoY2hpbGQucHJldik7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5wYXJlbnQudW53cmFwKCk7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFBhcmVudEJsb3QpIHtcbiAgICAgICAgY2hpbGQudW53cmFwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBQYXJlbnRCbG90LnByb3RvdHlwZS5mb3JtYXRBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaEF0KGluZGV4LCBsZW5ndGgsIGZ1bmN0aW9uIChjaGlsZCwgb2Zmc2V0LCBjaGlsZExlbmd0aCkge1xuICAgICAgY2hpbGQuZm9ybWF0QXQob2Zmc2V0LCBjaGlsZExlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIFBhcmVudEJsb3QucHJvdG90eXBlLmluc2VydEF0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgdmFyIF9hID0gdGhpcy5jaGlsZHJlbi5maW5kKGluZGV4KSxcbiAgICAgICAgY2hpbGQgPSBfYVswXSxcbiAgICAgICAgb2Zmc2V0ID0gX2FbMV07XG5cbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNoaWxkLmluc2VydEF0KG9mZnNldCwgdmFsdWUsIGRlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBibG90ID0gZGVmID09IG51bGwgPyB0aGlzLnNjcm9sbC5jcmVhdGUoJ3RleHQnLCB2YWx1ZSkgOiB0aGlzLnNjcm9sbC5jcmVhdGUodmFsdWUsIGRlZik7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGJsb3QpO1xuICAgIH1cbiAgfTtcblxuICBQYXJlbnRCbG90LnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAoY2hpbGRCbG90LCByZWZCbG90KSB7XG4gICAgaWYgKGNoaWxkQmxvdC5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgY2hpbGRCbG90LnBhcmVudC5jaGlsZHJlbi5yZW1vdmUoY2hpbGRCbG90KTtcbiAgICB9XG5cbiAgICB2YXIgcmVmRG9tTm9kZSA9IG51bGw7XG4gICAgdGhpcy5jaGlsZHJlbi5pbnNlcnRCZWZvcmUoY2hpbGRCbG90LCByZWZCbG90IHx8IG51bGwpO1xuICAgIGNoaWxkQmxvdC5wYXJlbnQgPSB0aGlzO1xuXG4gICAgaWYgKHJlZkJsb3QgIT0gbnVsbCkge1xuICAgICAgcmVmRG9tTm9kZSA9IHJlZkJsb3QuZG9tTm9kZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kb21Ob2RlLnBhcmVudE5vZGUgIT09IGNoaWxkQmxvdC5kb21Ob2RlIHx8IHRoaXMuZG9tTm9kZS5uZXh0U2libGluZyAhPT0gcmVmRG9tTm9kZSkge1xuICAgICAgdGhpcy5kb21Ob2RlLmluc2VydEJlZm9yZShjaGlsZEJsb3QuZG9tTm9kZSwgcmVmRG9tTm9kZSk7XG4gICAgfVxuXG4gICAgY2hpbGRCbG90LmF0dGFjaCgpO1xuICB9O1xuXG4gIFBhcmVudEJsb3QucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGNoaWxkKSB7XG4gICAgICByZXR1cm4gbWVtbyArIGNoaWxkLmxlbmd0aCgpO1xuICAgIH0sIDApO1xuICB9O1xuXG4gIFBhcmVudEJsb3QucHJvdG90eXBlLm1vdmVDaGlsZHJlbiA9IGZ1bmN0aW9uICh0YXJnZXRQYXJlbnQsIHJlZk5vZGUpIHtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB0YXJnZXRQYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCByZWZOb2RlKTtcbiAgICB9KTtcbiAgfTtcblxuICBQYXJlbnRCbG90LnByb3RvdHlwZS5vcHRpbWl6ZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5vcHRpbWl6ZS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuXG4gICAgdGhpcy5lbmZvcmNlQWxsb3dlZENoaWxkcmVuKCk7XG5cbiAgICBpZiAodGhpcy51aU5vZGUgIT0gbnVsbCAmJiB0aGlzLnVpTm9kZSAhPT0gdGhpcy5kb21Ob2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRoaXMuZG9tTm9kZS5pbnNlcnRCZWZvcmUodGhpcy51aU5vZGUsIHRoaXMuZG9tTm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLnN0YXRpY3MuZGVmYXVsdENoaWxkICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5zY3JvbGwuY3JlYXRlKHRoaXMuc3RhdGljcy5kZWZhdWx0Q2hpbGQuYmxvdE5hbWUpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGNoaWxkKTsgLy8gVE9ETyBkb3VibGUgY2hlY2sgaWYgbmVjZXNzYXJ5XG4gICAgICAgIC8vIGNoaWxkLm9wdGltaXplKGNvbnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgUGFyZW50QmxvdC5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIChpbmRleCwgaW5jbHVzaXZlKSB7XG4gICAgaWYgKGluY2x1c2l2ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpbmNsdXNpdmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSB0aGlzLmNoaWxkcmVuLmZpbmQoaW5kZXgsIGluY2x1c2l2ZSksXG4gICAgICAgIGNoaWxkID0gX2FbMF0sXG4gICAgICAgIG9mZnNldCA9IF9hWzFdO1xuXG4gICAgdmFyIHBvc2l0aW9uID0gW1t0aGlzLCBpbmRleF1dO1xuXG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgUGFyZW50QmxvdCkge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uLmNvbmNhdChjaGlsZC5wYXRoKG9mZnNldCwgaW5jbHVzaXZlKSk7XG4gICAgfSBlbHNlIGlmIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICBwb3NpdGlvbi5wdXNoKFtjaGlsZCwgb2Zmc2V0XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9O1xuXG4gIFBhcmVudEJsb3QucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5yZW1vdmUoY2hpbGQpO1xuICB9O1xuXG4gIFBhcmVudEJsb3QucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHJlcGxhY2VtZW50ID0gdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnID8gdGhpcy5zY3JvbGwuY3JlYXRlKG5hbWUsIHZhbHVlKSA6IG5hbWU7XG5cbiAgICBpZiAocmVwbGFjZW1lbnQgaW5zdGFuY2VvZiBQYXJlbnRCbG90KSB7XG4gICAgICB0aGlzLm1vdmVDaGlsZHJlbihyZXBsYWNlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVwbGFjZVdpdGguY2FsbCh0aGlzLCByZXBsYWNlbWVudCk7XG4gIH07XG5cbiAgUGFyZW50QmxvdC5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoaW5kZXgsIGZvcmNlKSB7XG4gICAgaWYgKGZvcmNlID09PSB2b2lkIDApIHtcbiAgICAgIGZvcmNlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPT09IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWZ0ZXIgPSB0aGlzLmNsb25lKCk7XG5cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShhZnRlciwgdGhpcy5uZXh0IHx8IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoQXQoaW5kZXgsIHRoaXMubGVuZ3RoKCksIGZ1bmN0aW9uIChjaGlsZCwgb2Zmc2V0LCBfbGVuZ3RoKSB7XG4gICAgICB2YXIgc3BsaXQgPSBjaGlsZC5zcGxpdChvZmZzZXQsIGZvcmNlKTtcblxuICAgICAgaWYgKHNwbGl0ICE9IG51bGwpIHtcbiAgICAgICAgYWZ0ZXIuYXBwZW5kQ2hpbGQoc3BsaXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhZnRlcjtcbiAgfTtcblxuICBQYXJlbnRCbG90LnByb3RvdHlwZS5zcGxpdEFmdGVyID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmFyIGFmdGVyID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKGNoaWxkLm5leHQgIT0gbnVsbCkge1xuICAgICAgYWZ0ZXIuYXBwZW5kQ2hpbGQoY2hpbGQubmV4dCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYWZ0ZXIsIHRoaXMubmV4dCB8fCB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBhZnRlcjtcbiAgfTtcblxuICBQYXJlbnRCbG90LnByb3RvdHlwZS51bndyYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLm1vdmVDaGlsZHJlbih0aGlzLnBhcmVudCwgdGhpcy5uZXh0IHx8IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfTtcblxuICBQYXJlbnRCbG90LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobXV0YXRpb25zLCBfY29udGV4dCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgYWRkZWROb2RlcyA9IFtdO1xuICAgIHZhciByZW1vdmVkTm9kZXMgPSBbXTtcbiAgICBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgIGlmIChtdXRhdGlvbi50YXJnZXQgPT09IF90aGlzLmRvbU5vZGUgJiYgbXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgYWRkZWROb2Rlcy5wdXNoLmFwcGx5KGFkZGVkTm9kZXMsIG11dGF0aW9uLmFkZGVkTm9kZXMpO1xuICAgICAgICByZW1vdmVkTm9kZXMucHVzaC5hcHBseShyZW1vdmVkTm9kZXMsIG11dGF0aW9uLnJlbW92ZWROb2Rlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVtb3ZlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIC8vIENoZWNrIG5vZGUgaGFzIGFjdHVhbGx5IGJlZW4gcmVtb3ZlZFxuICAgICAgLy8gT25lIGV4Y2VwdGlvbiBpcyBDaHJvbWUgZG9lcyBub3QgaW1tZWRpYXRlbHkgcmVtb3ZlIElGUkFNRXNcbiAgICAgIC8vIGZyb20gRE9NIGJ1dCBNdXRhdGlvblJlY29yZCBpcyBjb3JyZWN0IGluIGl0cyByZXBvcnRlZCByZW1vdmFsXG4gICAgICBpZiAobm9kZS5wYXJlbnROb2RlICE9IG51bGwgJiYgLy8gQHRzLWlnbm9yZVxuICAgICAgbm9kZS50YWdOYW1lICE9PSAnSUZSQU1FJyAmJiBkb2N1bWVudC5ib2R5LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5vZGUpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmxvdCA9IF90aGlzLnNjcm9sbC5maW5kKG5vZGUpO1xuXG4gICAgICBpZiAoYmxvdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb3QuZG9tTm9kZS5wYXJlbnROb2RlID09IG51bGwgfHwgYmxvdC5kb21Ob2RlLnBhcmVudE5vZGUgPT09IF90aGlzLmRvbU5vZGUpIHtcbiAgICAgICAgYmxvdC5kZXRhY2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhZGRlZE5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSA9PT0gX3RoaXMuZG9tTm9kZSB8fCBub2RlID09PSBfdGhpcy51aU5vZGU7XG4gICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgcmVmQmxvdCA9IG51bGw7XG5cbiAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nICE9IG51bGwpIHtcbiAgICAgICAgcmVmQmxvdCA9IF90aGlzLnNjcm9sbC5maW5kKG5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmxvdCA9IG1ha2VBdHRhY2hlZEJsb3Qobm9kZSwgX3RoaXMuc2Nyb2xsKTtcblxuICAgICAgaWYgKGJsb3QubmV4dCAhPT0gcmVmQmxvdCB8fCBibG90Lm5leHQgPT0gbnVsbCkge1xuICAgICAgICBpZiAoYmxvdC5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGJsb3QucGFyZW50LnJlbW92ZUNoaWxkKF90aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmluc2VydEJlZm9yZShibG90LCByZWZCbG90IHx8IHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbmZvcmNlQWxsb3dlZENoaWxkcmVuKCk7XG4gIH07XG5cbiAgUGFyZW50QmxvdC51aUNsYXNzID0gJyc7XG4gIHJldHVybiBQYXJlbnRCbG90O1xufShzaGFkb3cpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBhYnN0cmFjdF9wYXJlbnQgPSAocGFyZW50X1BhcmVudEJsb3QpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvcGFyY2htZW50L3NyYy9ibG90L2Fic3RyYWN0L2NvbnRhaW5lci50c1xudmFyIGNvbnRhaW5lcl9leHRlbmRzID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2V4dGVuZHMgfHwgZnVuY3Rpb24gKCkge1xuICB2YXIgX2V4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiBleHRlbmRTdGF0aWNzKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgICBfX3Byb3RvX186IFtdXG4gICAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBkLl9fcHJvdG9fXyA9IGI7XG4gICAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSB7XG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgICB9XG5cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG59KCk7XG5cblxuXG5cbnZhciBjb250YWluZXJfQ29udGFpbmVyQmxvdCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIGNvbnRhaW5lcl9leHRlbmRzKENvbnRhaW5lckJsb3QsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQ29udGFpbmVyQmxvdCgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICBDb250YWluZXJCbG90LnByb3RvdHlwZS5jaGVja01lcmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5leHQgIT09IG51bGwgJiYgdGhpcy5uZXh0LnN0YXRpY3MuYmxvdE5hbWUgPT09IHRoaXMuc3RhdGljcy5ibG90TmFtZTtcbiAgfTtcblxuICBDb250YWluZXJCbG90LnByb3RvdHlwZS5kZWxldGVBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5kZWxldGVBdC5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgpO1xuXG4gICAgdGhpcy5lbmZvcmNlQWxsb3dlZENoaWxkcmVuKCk7XG4gIH07XG5cbiAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuZm9ybWF0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLmZvcm1hdEF0LmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuXG4gICAgdGhpcy5lbmZvcmNlQWxsb3dlZENoaWxkcmVuKCk7XG4gIH07XG5cbiAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUuaW5zZXJ0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLmluc2VydEF0LmNhbGwodGhpcywgaW5kZXgsIHZhbHVlLCBkZWYpO1xuXG4gICAgdGhpcy5lbmZvcmNlQWxsb3dlZENoaWxkcmVuKCk7XG4gIH07XG5cbiAgQ29udGFpbmVyQmxvdC5wcm90b3R5cGUub3B0aW1pemUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUub3B0aW1pemUuY2FsbCh0aGlzLCBjb250ZXh0KTtcblxuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgdGhpcy5uZXh0ICE9IG51bGwgJiYgdGhpcy5jaGVja01lcmdlKCkpIHtcbiAgICAgIHRoaXMubmV4dC5tb3ZlQ2hpbGRyZW4odGhpcyk7XG4gICAgICB0aGlzLm5leHQucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuXG4gIENvbnRhaW5lckJsb3QuYmxvdE5hbWUgPSAnY29udGFpbmVyJztcbiAgQ29udGFpbmVyQmxvdC5zY29wZSA9IHNyY19zY29wZS5CTE9DS19CTE9UO1xuICByZXR1cm4gQ29udGFpbmVyQmxvdDtcbn0oYWJzdHJhY3RfcGFyZW50KTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29udGFpbmVyID0gKGNvbnRhaW5lcl9Db250YWluZXJCbG90KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3BhcmNobWVudC9zcmMvYmxvdC9hYnN0cmFjdC9sZWFmLnRzXG52YXIgbGVhZl9leHRlbmRzID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2V4dGVuZHMgfHwgZnVuY3Rpb24gKCkge1xuICB2YXIgX2V4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiBleHRlbmRTdGF0aWNzKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgICBfX3Byb3RvX186IFtdXG4gICAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBkLl9fcHJvdG9fXyA9IGI7XG4gICAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSB7XG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgICB9XG5cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG59KCk7XG5cblxuXG5cbnZhciBsZWFmX0xlYWZCbG90ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgbGVhZl9leHRlbmRzKExlYWZCbG90LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIExlYWZCbG90KCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIExlYWZCbG90LnZhbHVlID0gZnVuY3Rpb24gKF9kb21Ob2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgTGVhZkJsb3QucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24gKG5vZGUsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLmRvbU5vZGUgPT09IG5vZGUgfHwgdGhpcy5kb21Ob2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG5vZGUpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihvZmZzZXQsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBMZWFmQmxvdC5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoaW5kZXgsIF9pbmNsdXNpdmUpIHtcbiAgICB2YXIgY2hpbGROb2RlcyA9IEFycmF5LmZyb20odGhpcy5wYXJlbnQuZG9tTm9kZS5jaGlsZE5vZGVzKTtcbiAgICB2YXIgb2Zmc2V0ID0gY2hpbGROb2Rlcy5pbmRleE9mKHRoaXMuZG9tTm9kZSk7XG5cbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3RoaXMucGFyZW50LmRvbU5vZGUsIG9mZnNldF07XG4gIH07XG5cbiAgTGVhZkJsb3QucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcblxuICAgIHJldHVybiBfYSA9IHt9LCBfYVt0aGlzLnN0YXRpY3MuYmxvdE5hbWVdID0gdGhpcy5zdGF0aWNzLnZhbHVlKHRoaXMuZG9tTm9kZSkgfHwgdHJ1ZSwgX2E7XG4gIH07XG5cbiAgTGVhZkJsb3Quc2NvcGUgPSBzcmNfc2NvcGUuSU5MSU5FX0JMT1Q7XG4gIHJldHVybiBMZWFmQmxvdDtcbn0oc2hhZG93KTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbGVhZiA9IChsZWFmX0xlYWZCbG90KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3BhcmNobWVudC9zcmMvYXR0cmlidXRvci9hdHRyaWJ1dG9yLnRzXG5cblxudmFyIGF0dHJpYnV0b3JfQXR0cmlidXRvciA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0b3IoYXR0ck5hbWUsIGtleU5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5hdHRyTmFtZSA9IGF0dHJOYW1lO1xuICAgIHRoaXMua2V5TmFtZSA9IGtleU5hbWU7XG4gICAgdmFyIGF0dHJpYnV0ZUJpdCA9IHNyY19zY29wZS5UWVBFICYgc3JjX3Njb3BlLkFUVFJJQlVURTtcbiAgICB0aGlzLnNjb3BlID0gb3B0aW9ucy5zY29wZSAhPSBudWxsID8gLy8gSWdub3JlIHR5cGUgYml0cywgZm9yY2UgYXR0cmlidXRlIGJpdFxuICAgIG9wdGlvbnMuc2NvcGUgJiBzcmNfc2NvcGUuTEVWRUwgfCBhdHRyaWJ1dGVCaXQgOiBzcmNfc2NvcGUuQVRUUklCVVRFO1xuXG4gICAgaWYgKG9wdGlvbnMud2hpdGVsaXN0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMud2hpdGVsaXN0ID0gb3B0aW9ucy53aGl0ZWxpc3Q7XG4gICAgfVxuICB9XG5cbiAgQXR0cmlidXRvci5rZXlzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShub2RlLmF0dHJpYnV0ZXMpLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcbiAgICB9KTtcbiAgfTtcblxuICBBdHRyaWJ1dG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKHRoaXMua2V5TmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIEF0dHJpYnV0b3IucHJvdG90eXBlLmNhbkFkZCA9IGZ1bmN0aW9uIChfbm9kZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy53aGl0ZWxpc3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLndoaXRlbGlzdC5pbmRleE9mKHZhbHVlLnJlcGxhY2UoL1tcIiddL2csICcnKSkgPiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMud2hpdGVsaXN0LmluZGV4T2YodmFsdWUpID4gLTE7XG4gICAgfVxuICB9O1xuXG4gIEF0dHJpYnV0b3IucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUodGhpcy5rZXlOYW1lKTtcbiAgfTtcblxuICBBdHRyaWJ1dG9yLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUodGhpcy5rZXlOYW1lKTtcblxuICAgIGlmICh0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkgJiYgdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgcmV0dXJuIEF0dHJpYnV0b3I7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGF0dHJpYnV0b3IgPSAoYXR0cmlidXRvcl9BdHRyaWJ1dG9yKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3BhcmNobWVudC9zcmMvYXR0cmlidXRvci9jbGFzcy50c1xudmFyIGNsYXNzX2V4dGVuZHMgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoKSB7XG4gIHZhciBfZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIGV4dGVuZFN0YXRpY3MoZCwgYikge1xuICAgIF9leHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICAgIF9fcHJvdG9fXzogW11cbiAgICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGQuX19wcm90b19fID0gYjtcbiAgICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIHtcbiAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZFN0YXRpY3MoZCwgYik7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgX2V4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgICBmdW5jdGlvbiBfXygpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICAgIH1cblxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbn0oKTtcblxuXG5cbmZ1bmN0aW9uIGNsYXNzX21hdGNoKG5vZGUsIHByZWZpeCkge1xuICB2YXIgY2xhc3NOYW1lID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gIHJldHVybiBjbGFzc05hbWUuc3BsaXQoL1xccysvKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5pbmRleE9mKHByZWZpeCArIFwiLVwiKSA9PT0gMDtcbiAgfSk7XG59XG5cbnZhciBDbGFzc0F0dHJpYnV0b3IgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBjbGFzc19leHRlbmRzKENsYXNzQXR0cmlidXRvciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBDbGFzc0F0dHJpYnV0b3IoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgQ2xhc3NBdHRyaWJ1dG9yLmtleXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZS5zcGxpdCgnLScpLnNsaWNlKDAsIC0xKS5qb2luKCctJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgQ2xhc3NBdHRyaWJ1dG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlKG5vZGUpO1xuICAgIG5vZGUuY2xhc3NMaXN0LmFkZCh0aGlzLmtleU5hbWUgKyBcIi1cIiArIHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBDbGFzc0F0dHJpYnV0b3IucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBjbGFzc19tYXRjaChub2RlLCB0aGlzLmtleU5hbWUpO1xuICAgIG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgIH0pO1xuXG4gICAgaWYgKG5vZGUuY2xhc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9O1xuXG4gIENsYXNzQXR0cmlidXRvci5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciByZXN1bHQgPSBjbGFzc19tYXRjaChub2RlLCB0aGlzLmtleU5hbWUpWzBdIHx8ICcnO1xuICAgIHZhciB2YWx1ZSA9IHJlc3VsdC5zbGljZSh0aGlzLmtleU5hbWUubGVuZ3RoICsgMSk7IC8vICsxIGZvciBoeXBoZW5cblxuICAgIHJldHVybiB0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkgPyB2YWx1ZSA6ICcnO1xuICB9O1xuXG4gIHJldHVybiBDbGFzc0F0dHJpYnV0b3I7XG59KGF0dHJpYnV0b3IpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBhdHRyaWJ1dG9yX2NsYXNzID0gKENsYXNzQXR0cmlidXRvcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9wYXJjaG1lbnQvc3JjL2F0dHJpYnV0b3Ivc3R5bGUudHNcbnZhciBzdHlsZV9leHRlbmRzID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2V4dGVuZHMgfHwgZnVuY3Rpb24gKCkge1xuICB2YXIgX2V4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiBleHRlbmRTdGF0aWNzKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgICBfX3Byb3RvX186IFtdXG4gICAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBkLl9fcHJvdG9fXyA9IGI7XG4gICAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSB7XG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgICB9XG5cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG59KCk7XG5cblxuXG5mdW5jdGlvbiBjYW1lbGl6ZShuYW1lKSB7XG4gIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy0nKTtcbiAgdmFyIHJlc3QgPSBwYXJ0cy5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gcGFydFswXS50b1VwcGVyQ2FzZSgpICsgcGFydC5zbGljZSgxKTtcbiAgfSkuam9pbignJyk7XG4gIHJldHVybiBwYXJ0c1swXSArIHJlc3Q7XG59XG5cbnZhciBTdHlsZUF0dHJpYnV0b3IgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBzdHlsZV9leHRlbmRzKFN0eWxlQXR0cmlidXRvciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBTdHlsZUF0dHJpYnV0b3IoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgU3R5bGVBdHRyaWJ1dG9yLmtleXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgJycpLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIGFyciA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICByZXR1cm4gYXJyWzBdLnRyaW0oKTtcbiAgICB9KTtcbiAgfTtcblxuICBTdHlsZUF0dHJpYnV0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy5jYW5BZGQobm9kZSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBAdHMtaWdub3JlXG5cblxuICAgIG5vZGUuc3R5bGVbY2FtZWxpemUodGhpcy5rZXlOYW1lKV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBTdHlsZUF0dHJpYnV0b3IucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIG5vZGUuc3R5bGVbY2FtZWxpemUodGhpcy5rZXlOYW1lKV0gPSAnJztcblxuICAgIGlmICghbm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIH1cbiAgfTtcblxuICBTdHlsZUF0dHJpYnV0b3IucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFyIHZhbHVlID0gbm9kZS5zdHlsZVtjYW1lbGl6ZSh0aGlzLmtleU5hbWUpXTtcbiAgICByZXR1cm4gdGhpcy5jYW5BZGQobm9kZSwgdmFsdWUpID8gdmFsdWUgOiAnJztcbiAgfTtcblxuICByZXR1cm4gU3R5bGVBdHRyaWJ1dG9yO1xufShhdHRyaWJ1dG9yKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3R5bGUgPSAoU3R5bGVBdHRyaWJ1dG9yKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3BhcmNobWVudC9zcmMvYXR0cmlidXRvci9zdG9yZS50c1xuXG5cblxuXG5cblxudmFyIHN0b3JlX0F0dHJpYnV0b3JTdG9yZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0b3JTdG9yZShkb21Ob2RlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5kb21Ob2RlID0gZG9tTm9kZTtcbiAgICB0aGlzLmJ1aWxkKCk7XG4gIH1cblxuICBBdHRyaWJ1dG9yU3RvcmUucHJvdG90eXBlLmF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgLy8gdmVyYlxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKGF0dHJpYnV0ZS5hZGQodGhpcy5kb21Ob2RlLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZSh0aGlzLmRvbU5vZGUpICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlLmF0dHJOYW1lXSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZS5hdHRyTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlidXRlLnJlbW92ZSh0aGlzLmRvbU5vZGUpO1xuICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGUuYXR0ck5hbWVdO1xuICAgIH1cbiAgfTtcblxuICBBdHRyaWJ1dG9yU3RvcmUucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB2YXIgYmxvdCA9IHJlZ2lzdHJ5LmZpbmQodGhpcy5kb21Ob2RlKTtcblxuICAgIGlmIChibG90ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IGF0dHJpYnV0b3Iua2V5cyh0aGlzLmRvbU5vZGUpO1xuICAgIHZhciBjbGFzc2VzID0gYXR0cmlidXRvcl9jbGFzcy5rZXlzKHRoaXMuZG9tTm9kZSk7XG4gICAgdmFyIHN0eWxlcyA9IHN0eWxlLmtleXModGhpcy5kb21Ob2RlKTtcbiAgICBhdHRyaWJ1dGVzLmNvbmNhdChjbGFzc2VzKS5jb25jYXQoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgYXR0ciA9IGJsb3Quc2Nyb2xsLnF1ZXJ5KG5hbWUsIHNyY19zY29wZS5BVFRSSUJVVEUpO1xuXG4gICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIGF0dHJpYnV0b3IpIHtcbiAgICAgICAgX3RoaXMuYXR0cmlidXRlc1thdHRyLmF0dHJOYW1lXSA9IGF0dHI7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgQXR0cmlidXRvclN0b3JlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLmF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gX3RoaXMuYXR0cmlidXRlc1trZXldLnZhbHVlKF90aGlzLmRvbU5vZGUpO1xuXG4gICAgICB0YXJnZXQuZm9ybWF0KGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIEF0dHJpYnV0b3JTdG9yZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5jb3B5KHRhcmdldCk7XG4gICAgT2JqZWN0LmtleXModGhpcy5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXNba2V5XS5yZW1vdmUoX3RoaXMuZG9tTm9kZSk7XG4gICAgfSk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gIH07XG5cbiAgQXR0cmlidXRvclN0b3JlLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmF0dHJpYnV0ZXMpLnJlZHVjZShmdW5jdGlvbiAoYXR0cmlidXRlcywgbmFtZSkge1xuICAgICAgYXR0cmlidXRlc1tuYW1lXSA9IF90aGlzLmF0dHJpYnV0ZXNbbmFtZV0udmFsdWUoX3RoaXMuZG9tTm9kZSk7XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LCB7fSk7XG4gIH07XG5cbiAgcmV0dXJuIEF0dHJpYnV0b3JTdG9yZTtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3RvcmUgPSAoc3RvcmVfQXR0cmlidXRvclN0b3JlKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3BhcmNobWVudC9zcmMvYmxvdC9pbmxpbmUudHNcbnZhciBpbmxpbmVfZXh0ZW5kcyA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzIHx8IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9leHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gZXh0ZW5kU3RhdGljcyhkLCBiKSB7XG4gICAgX2V4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgICAgX19wcm90b19fOiBbXVxuICAgIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZC5fX3Byb3RvX18gPSBiO1xuICAgIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikge1xuICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgfVxuXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbiAvLyBTaGFsbG93IG9iamVjdCBjb21wYXJpc29uXG5cbmZ1bmN0aW9uIGlzRXF1YWwob2JqMSwgb2JqMikge1xuICBpZiAoT2JqZWN0LmtleXMob2JqMSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQHRzLWlnbm9yZVxuXG5cbiAgZm9yICh2YXIgcHJvcCBpbiBvYmoxKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChvYmoxW3Byb3BdICE9PSBvYmoyW3Byb3BdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBpbmxpbmVfSW5saW5lQmxvdCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIGlubGluZV9leHRlbmRzKElubGluZUJsb3QsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gSW5saW5lQmxvdChzY3JvbGwsIGRvbU5vZGUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzY3JvbGwsIGRvbU5vZGUpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5hdHRyaWJ1dGVzID0gbmV3IHN0b3JlKF90aGlzLmRvbU5vZGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIElubGluZUJsb3QuZm9ybWF0cyA9IGZ1bmN0aW9uIChkb21Ob2RlLCBzY3JvbGwpIHtcbiAgICB2YXIgbWF0Y2ggPSBzY3JvbGwucXVlcnkoSW5saW5lQmxvdC5ibG90TmFtZSk7XG5cbiAgICBpZiAobWF0Y2ggIT0gbnVsbCAmJiBkb21Ob2RlLnRhZ05hbWUgPT09IG1hdGNoLnRhZ05hbWUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy50YWdOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMudGFnTmFtZSkpIHtcbiAgICAgIHJldHVybiBkb21Ob2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIElubGluZUJsb3QucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAobmFtZSA9PT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lICYmICF2YWx1ZSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIElubGluZUJsb3QpKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC53cmFwKElubGluZUJsb3QuYmxvdE5hbWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuYXR0cmlidXRlcy5jb3B5KGNoaWxkKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy51bndyYXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuc2Nyb2xsLnF1ZXJ5KG5hbWUsIHNyY19zY29wZS5JTkxJTkUpO1xuXG4gICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybWF0IGluc3RhbmNlb2YgYXR0cmlidXRvcikge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuYXR0cmlidXRlKGZvcm1hdCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiAobmFtZSAhPT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lIHx8IHRoaXMuZm9ybWF0cygpW25hbWVdICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlV2l0aChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIElubGluZUJsb3QucHJvdG90eXBlLmZvcm1hdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvcm1hdHMgPSB0aGlzLmF0dHJpYnV0ZXMudmFsdWVzKCk7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuc3RhdGljcy5mb3JtYXRzKHRoaXMuZG9tTm9kZSwgdGhpcy5zY3JvbGwpO1xuXG4gICAgaWYgKGZvcm1hdCAhPSBudWxsKSB7XG4gICAgICBmb3JtYXRzW3RoaXMuc3RhdGljcy5ibG90TmFtZV0gPSBmb3JtYXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdHM7XG4gIH07XG5cbiAgSW5saW5lQmxvdC5wcm90b3R5cGUuZm9ybWF0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5mb3JtYXRzKClbbmFtZV0gIT0gbnVsbCB8fCB0aGlzLnNjcm9sbC5xdWVyeShuYW1lLCBzcmNfc2NvcGUuQVRUUklCVVRFKSkge1xuICAgICAgdmFyIGJsb3QgPSB0aGlzLmlzb2xhdGUoaW5kZXgsIGxlbmd0aCk7XG4gICAgICBibG90LmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9zdXBlci5wcm90b3R5cGUuZm9ybWF0QXQuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIElubGluZUJsb3QucHJvdG90eXBlLm9wdGltaXplID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLm9wdGltaXplLmNhbGwodGhpcywgY29udGV4dCk7XG5cbiAgICB2YXIgZm9ybWF0cyA9IHRoaXMuZm9ybWF0cygpO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKGZvcm1hdHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMudW53cmFwKCk7IC8vIHVuZm9ybWF0dGVkIHNwYW5cbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHRoaXMubmV4dDtcblxuICAgIGlmIChuZXh0IGluc3RhbmNlb2YgSW5saW5lQmxvdCAmJiBuZXh0LnByZXYgPT09IHRoaXMgJiYgaXNFcXVhbChmb3JtYXRzLCBuZXh0LmZvcm1hdHMoKSkpIHtcbiAgICAgIG5leHQubW92ZUNoaWxkcmVuKHRoaXMpO1xuICAgICAgbmV4dC5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG5cbiAgSW5saW5lQmxvdC5wcm90b3R5cGUucmVwbGFjZVdpdGggPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcmVwbGFjZW1lbnQgPSBfc3VwZXIucHJvdG90eXBlLnJlcGxhY2VXaXRoLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzLmNvcHkocmVwbGFjZW1lbnQpO1xuICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgfTtcblxuICBJbmxpbmVCbG90LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgbXV0YXRpb25zLCBjb250ZXh0KTtcblxuICAgIHZhciBhdHRyaWJ1dGVDaGFuZ2VkID0gbXV0YXRpb25zLnNvbWUoZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICByZXR1cm4gbXV0YXRpb24udGFyZ2V0ID09PSBfdGhpcy5kb21Ob2RlICYmIG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJztcbiAgICB9KTtcblxuICAgIGlmIChhdHRyaWJ1dGVDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuYnVpbGQoKTtcbiAgICB9XG4gIH07XG5cbiAgSW5saW5lQmxvdC5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciB3cmFwcGVyID0gX3N1cGVyLnByb3RvdHlwZS53cmFwLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuXG4gICAgaWYgKHdyYXBwZXIgaW5zdGFuY2VvZiBJbmxpbmVCbG90KSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMubW92ZSh3cmFwcGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfTtcblxuICBJbmxpbmVCbG90LmFsbG93ZWRDaGlsZHJlbiA9IFtJbmxpbmVCbG90LCBsZWFmXTtcbiAgSW5saW5lQmxvdC5ibG90TmFtZSA9ICdpbmxpbmUnO1xuICBJbmxpbmVCbG90LnNjb3BlID0gc3JjX3Njb3BlLklOTElORV9CTE9UO1xuICBJbmxpbmVCbG90LnRhZ05hbWUgPSAnU1BBTic7XG4gIHJldHVybiBJbmxpbmVCbG90O1xufShhYnN0cmFjdF9wYXJlbnQpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpbmxpbmUgPSAoaW5saW5lX0lubGluZUJsb3QpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvcGFyY2htZW50L3NyYy9ibG90L2Jsb2NrLnRzXG52YXIgYmxvY2tfZXh0ZW5kcyA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzIHx8IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9leHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gZXh0ZW5kU3RhdGljcyhkLCBiKSB7XG4gICAgX2V4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgICAgX19wcm90b19fOiBbXVxuICAgIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZC5fX3Byb3RvX18gPSBiO1xuICAgIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikge1xuICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgfVxuXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG5cbnZhciBibG9ja19CbG9ja0Jsb3QgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBibG9ja19leHRlbmRzKEJsb2NrQmxvdCwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBCbG9ja0Jsb3Qoc2Nyb2xsLCBkb21Ob2RlKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2Nyb2xsLCBkb21Ob2RlKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuYXR0cmlidXRlcyA9IG5ldyBzdG9yZShfdGhpcy5kb21Ob2RlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBCbG9ja0Jsb3QuZm9ybWF0cyA9IGZ1bmN0aW9uIChkb21Ob2RlLCBzY3JvbGwpIHtcbiAgICB2YXIgbWF0Y2ggPSBzY3JvbGwucXVlcnkoQmxvY2tCbG90LmJsb3ROYW1lKTtcblxuICAgIGlmIChtYXRjaCAhPSBudWxsICYmIGRvbU5vZGUudGFnTmFtZSA9PT0gbWF0Y2gudGFnTmFtZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnRhZ05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy50YWdOYW1lKSkge1xuICAgICAgcmV0dXJuIGRvbU5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfTtcblxuICBCbG9ja0Jsb3QucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLnNjcm9sbC5xdWVyeShuYW1lLCBzcmNfc2NvcGUuQkxPQ0spO1xuXG4gICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgaW5zdGFuY2VvZiBhdHRyaWJ1dG9yKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuYXR0cmlidXRlKGZvcm1hdCwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lICYmICF2YWx1ZSkge1xuICAgICAgdGhpcy5yZXBsYWNlV2l0aChCbG9ja0Jsb3QuYmxvdE5hbWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgKG5hbWUgIT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSB8fCB0aGlzLmZvcm1hdHMoKVtuYW1lXSAhPT0gdmFsdWUpKSB7XG4gICAgICB0aGlzLnJlcGxhY2VXaXRoKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgQmxvY2tCbG90LnByb3RvdHlwZS5mb3JtYXRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb3JtYXRzID0gdGhpcy5hdHRyaWJ1dGVzLnZhbHVlcygpO1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLnN0YXRpY3MuZm9ybWF0cyh0aGlzLmRvbU5vZGUsIHRoaXMuc2Nyb2xsKTtcblxuICAgIGlmIChmb3JtYXQgIT0gbnVsbCkge1xuICAgICAgZm9ybWF0c1t0aGlzLnN0YXRpY3MuYmxvdE5hbWVdID0gZm9ybWF0O1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXRzO1xuICB9O1xuXG4gIEJsb2NrQmxvdC5wcm90b3R5cGUuZm9ybWF0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5zY3JvbGwucXVlcnkobmFtZSwgc3JjX3Njb3BlLkJMT0NLKSAhPSBudWxsKSB7XG4gICAgICB0aGlzLmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9zdXBlci5wcm90b3R5cGUuZm9ybWF0QXQuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIEJsb2NrQmxvdC5wcm90b3R5cGUuaW5zZXJ0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICBpZiAoZGVmID09IG51bGwgfHwgdGhpcy5zY3JvbGwucXVlcnkodmFsdWUsIHNyY19zY29wZS5JTkxJTkUpICE9IG51bGwpIHtcbiAgICAgIC8vIEluc2VydCB0ZXh0IG9yIGlubGluZVxuICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnNlcnRBdC5jYWxsKHRoaXMsIGluZGV4LCB2YWx1ZSwgZGVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFmdGVyID0gdGhpcy5zcGxpdChpbmRleCk7XG5cbiAgICAgIGlmIChhZnRlciAhPSBudWxsKSB7XG4gICAgICAgIHZhciBibG90ID0gdGhpcy5zY3JvbGwuY3JlYXRlKHZhbHVlLCBkZWYpO1xuICAgICAgICBhZnRlci5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJsb3QsIGFmdGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdCB0byBpbnNlcnRBdCBhZnRlciBibG9jayBib3VuZGFyaWVzJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJsb2NrQmxvdC5wcm90b3R5cGUucmVwbGFjZVdpdGggPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcmVwbGFjZW1lbnQgPSBfc3VwZXIucHJvdG90eXBlLnJlcGxhY2VXaXRoLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzLmNvcHkocmVwbGFjZW1lbnQpO1xuICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgfTtcblxuICBCbG9ja0Jsb3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtdXRhdGlvbnMsIGNvbnRleHQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzLCBtdXRhdGlvbnMsIGNvbnRleHQpO1xuXG4gICAgdmFyIGF0dHJpYnV0ZUNoYW5nZWQgPSBtdXRhdGlvbnMuc29tZShmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgIHJldHVybiBtdXRhdGlvbi50YXJnZXQgPT09IF90aGlzLmRvbU5vZGUgJiYgbXV0YXRpb24udHlwZSA9PT0gJ2F0dHJpYnV0ZXMnO1xuICAgIH0pO1xuXG4gICAgaWYgKGF0dHJpYnV0ZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuYXR0cmlidXRlcy5idWlsZCgpO1xuICAgIH1cbiAgfTtcblxuICBCbG9ja0Jsb3QuYmxvdE5hbWUgPSAnYmxvY2snO1xuICBCbG9ja0Jsb3Quc2NvcGUgPSBzcmNfc2NvcGUuQkxPQ0tfQkxPVDtcbiAgQmxvY2tCbG90LnRhZ05hbWUgPSAnUCc7XG4gIEJsb2NrQmxvdC5hbGxvd2VkQ2hpbGRyZW4gPSBbaW5saW5lLCBCbG9ja0Jsb3QsIGxlYWZdO1xuICByZXR1cm4gQmxvY2tCbG90O1xufShhYnN0cmFjdF9wYXJlbnQpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBibG9jayA9IChibG9ja19CbG9ja0Jsb3QpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvcGFyY2htZW50L3NyYy9ibG90L2VtYmVkLnRzXG52YXIgZW1iZWRfZXh0ZW5kcyA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzIHx8IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9leHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gZXh0ZW5kU3RhdGljcyhkLCBiKSB7XG4gICAgX2V4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgICAgX19wcm90b19fOiBbXVxuICAgIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZC5fX3Byb3RvX18gPSBiO1xuICAgIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikge1xuICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgfVxuXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xufSgpO1xuXG5cblxudmFyIEVtYmVkQmxvdCA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIGVtYmVkX2V4dGVuZHMoRW1iZWRCbG90LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEVtYmVkQmxvdCgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICBFbWJlZEJsb3QuZm9ybWF0cyA9IGZ1bmN0aW9uIChfZG9tTm9kZSwgX3Njcm9sbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgRW1iZWRCbG90LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAvLyBzdXBlci5mb3JtYXRBdCB3cmFwcywgd2hpY2ggaXMgd2hhdCB3ZSB3YW50IGluIGdlbmVyYWwsXG4gICAgLy8gYnV0IHRoaXMgYWxsb3dzIHN1YmNsYXNzZXMgdG8gb3ZlcndyaXRlIGZvciBmb3JtYXRzXG4gICAgLy8gdGhhdCBqdXN0IGFwcGx5IHRvIHBhcnRpY3VsYXIgZW1iZWRzXG4gICAgX3N1cGVyLnByb3RvdHlwZS5mb3JtYXRBdC5jYWxsKHRoaXMsIDAsIHRoaXMubGVuZ3RoKCksIG5hbWUsIHZhbHVlKTtcbiAgfTtcblxuICBFbWJlZEJsb3QucHJvdG90eXBlLmZvcm1hdEF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGluZGV4ID09PSAwICYmIGxlbmd0aCA9PT0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgdGhpcy5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfc3VwZXIucHJvdG90eXBlLmZvcm1hdEF0LmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBFbWJlZEJsb3QucHJvdG90eXBlLmZvcm1hdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGljcy5mb3JtYXRzKHRoaXMuZG9tTm9kZSwgdGhpcy5zY3JvbGwpO1xuICB9O1xuXG4gIHJldHVybiBFbWJlZEJsb3Q7XG59KGxlYWYpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBibG90X2VtYmVkID0gKEVtYmVkQmxvdCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9wYXJjaG1lbnQvc3JjL2Jsb3Qvc2Nyb2xsLnRzXG52YXIgc2Nyb2xsX2V4dGVuZHMgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoKSB7XG4gIHZhciBfZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIGV4dGVuZFN0YXRpY3MoZCwgYikge1xuICAgIF9leHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICAgIF9fcHJvdG9fXzogW11cbiAgICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGQuX19wcm90b19fID0gYjtcbiAgICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIHtcbiAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZFN0YXRpY3MoZCwgYik7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgX2V4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgICBmdW5jdGlvbiBfXygpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICAgIH1cblxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cbnZhciBPQlNFUlZFUl9DT05GSUcgPSB7XG4gIGF0dHJpYnV0ZXM6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBzdWJ0cmVlOiB0cnVlXG59O1xudmFyIE1BWF9PUFRJTUlaRV9JVEVSQVRJT05TID0gMTAwO1xuXG52YXIgc2Nyb2xsX1Njcm9sbEJsb3QgPVxuLyoqIEBjbGFzcyAqL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBzY3JvbGxfZXh0ZW5kcyhTY3JvbGxCbG90LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFNjcm9sbEJsb3QocmVnaXN0cnksIG5vZGUpIHtcbiAgICB2YXIgX3RoaXMgPSAvLyBAdHMtaWdub3JlXG4gICAgX3N1cGVyLmNhbGwodGhpcywgbnVsbCwgbm9kZSkgfHwgdGhpcztcblxuICAgIF90aGlzLnJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gICAgX3RoaXMuc2Nyb2xsID0gX3RoaXM7XG5cbiAgICBfdGhpcy5idWlsZCgpO1xuXG4gICAgX3RoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgICBfdGhpcy51cGRhdGUobXV0YXRpb25zKTtcbiAgICB9KTtcblxuICAgIF90aGlzLm9ic2VydmVyLm9ic2VydmUoX3RoaXMuZG9tTm9kZSwgT0JTRVJWRVJfQ09ORklHKTtcblxuICAgIF90aGlzLmF0dGFjaCgpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU2Nyb2xsQmxvdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGlucHV0LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmNyZWF0ZSh0aGlzLCBpbnB1dCwgdmFsdWUpO1xuICB9O1xuXG4gIFNjcm9sbEJsb3QucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAobm9kZSwgYnViYmxlKSB7XG4gICAgaWYgKGJ1YmJsZSA9PT0gdm9pZCAwKSB7XG4gICAgICBidWJibGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5maW5kKG5vZGUsIGJ1YmJsZSk7XG4gIH07XG5cbiAgU2Nyb2xsQmxvdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAocXVlcnksIHNjb3BlKSB7XG4gICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHtcbiAgICAgIHNjb3BlID0gc3JjX3Njb3BlLkFOWTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5xdWVyeShxdWVyeSwgc2NvcGUpO1xuICB9O1xuXG4gIFNjcm9sbEJsb3QucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBkZWZpbml0aW9ucyA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGRlZmluaXRpb25zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChfYSA9IHRoaXMucmVnaXN0cnkpLnJlZ2lzdGVyLmFwcGx5KF9hLCBkZWZpbml0aW9ucyk7XG4gIH07XG5cbiAgU2Nyb2xsQmxvdC5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfc3VwZXIucHJvdG90eXBlLmJ1aWxkLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgU2Nyb2xsQmxvdC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUuZGV0YWNoLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfTtcblxuICBTY3JvbGxCbG90LnByb3RvdHlwZS5kZWxldGVBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIGlmIChpbmRleCA9PT0gMCAmJiBsZW5ndGggPT09IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZWxldGVBdC5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH1cbiAgfTtcblxuICBTY3JvbGxCbG90LnByb3RvdHlwZS5mb3JtYXRBdCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICBfc3VwZXIucHJvdG90eXBlLmZvcm1hdEF0LmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICB9O1xuXG4gIFNjcm9sbEJsb3QucHJvdG90eXBlLmluc2VydEF0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIF9zdXBlci5wcm90b3R5cGUuaW5zZXJ0QXQuY2FsbCh0aGlzLCBpbmRleCwgdmFsdWUsIGRlZik7XG4gIH07XG5cbiAgU2Nyb2xsQmxvdC5wcm90b3R5cGUub3B0aW1pemUgPSBmdW5jdGlvbiAobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChtdXRhdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgbXV0YXRpb25zID0gW107XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgY29udGV4dCA9IHt9O1xuICAgIH1cblxuICAgIF9zdXBlci5wcm90b3R5cGUub3B0aW1pemUuY2FsbCh0aGlzLCBjb250ZXh0KTtcblxuICAgIHZhciBtdXRhdGlvbnNNYXAgPSBjb250ZXh0Lm11dGF0aW9uc01hcCB8fCBuZXcgV2Vha01hcCgpOyAvLyBXZSBtdXN0IG1vZGlmeSBtdXRhdGlvbnMgZGlyZWN0bHksIGNhbm5vdCBtYWtlIGNvcHkgYW5kIHRoZW4gbW9kaWZ5XG5cbiAgICB2YXIgcmVjb3JkcyA9IEFycmF5LmZyb20odGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKTsgLy8gQXJyYXkucHVzaCBjdXJyZW50bHkgc2VlbXMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYSBub24tdGFpbCByZWN1cnNpdmUgZnVuY3Rpb25cbiAgICAvLyBzbyB3ZSBjYW5ub3QganVzdCBtdXRhdGlvbnMucHVzaC5hcHBseShtdXRhdGlvbnMsIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG5cbiAgICB3aGlsZSAocmVjb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICBtdXRhdGlvbnMucHVzaChyZWNvcmRzLnBvcCgpKTtcbiAgICB9XG5cbiAgICB2YXIgbWFyayA9IGZ1bmN0aW9uIG1hcmsoYmxvdCwgbWFya1BhcmVudCkge1xuICAgICAgaWYgKG1hcmtQYXJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgICBtYXJrUGFyZW50ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb3QgPT0gbnVsbCB8fCBibG90ID09PSBfdGhpcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChibG90LmRvbU5vZGUucGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtdXRhdGlvbnNNYXAuaGFzKGJsb3QuZG9tTm9kZSkpIHtcbiAgICAgICAgbXV0YXRpb25zTWFwLnNldChibG90LmRvbU5vZGUsIFtdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcmtQYXJlbnQpIHtcbiAgICAgICAgbWFyayhibG90LnBhcmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvcHRpbWl6ZSA9IGZ1bmN0aW9uIG9wdGltaXplKGJsb3QpIHtcbiAgICAgIC8vIFBvc3Qtb3JkZXIgdHJhdmVyc2FsXG4gICAgICBpZiAoIW11dGF0aW9uc01hcC5oYXMoYmxvdC5kb21Ob2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChibG90IGluc3RhbmNlb2YgYWJzdHJhY3RfcGFyZW50KSB7XG4gICAgICAgIGJsb3QuY2hpbGRyZW4uZm9yRWFjaChvcHRpbWl6ZSk7XG4gICAgICB9XG5cbiAgICAgIG11dGF0aW9uc01hcC5kZWxldGUoYmxvdC5kb21Ob2RlKTtcbiAgICAgIGJsb3Qub3B0aW1pemUoY29udGV4dCk7XG4gICAgfTtcblxuICAgIHZhciByZW1haW5pbmcgPSBtdXRhdGlvbnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgcmVtYWluaW5nLmxlbmd0aCA+IDA7IGkgKz0gMSkge1xuICAgICAgaWYgKGkgPj0gTUFYX09QVElNSVpFX0lURVJBVElPTlMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbUGFyY2htZW50XSBNYXhpbXVtIG9wdGltaXplIGl0ZXJhdGlvbnMgcmVhY2hlZCcpO1xuICAgICAgfVxuXG4gICAgICByZW1haW5pbmcuZm9yRWFjaChmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgdmFyIGJsb3QgPSBfdGhpcy5maW5kKG11dGF0aW9uLnRhcmdldCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGJsb3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChibG90LmRvbU5vZGUgPT09IG11dGF0aW9uLnRhcmdldCkge1xuICAgICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgbWFyayhfdGhpcy5maW5kKG11dGF0aW9uLnByZXZpb3VzU2libGluZywgZmFsc2UpKTtcbiAgICAgICAgICAgIEFycmF5LmZyb20obXV0YXRpb24uYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfdGhpcy5maW5kKG5vZGUsIGZhbHNlKTtcblxuICAgICAgICAgICAgICBtYXJrKGNoaWxkLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgYWJzdHJhY3RfcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoZ3JhbmRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgbWFyayhncmFuZENoaWxkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgICBtYXJrKGJsb3QucHJldik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWFyayhibG90KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKG9wdGltaXplKTtcbiAgICAgIHJlbWFpbmluZyA9IEFycmF5LmZyb20odGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICAgIHJlY29yZHMgPSByZW1haW5pbmcuc2xpY2UoKTtcblxuICAgICAgd2hpbGUgKHJlY29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBtdXRhdGlvbnMucHVzaChyZWNvcmRzLnBvcCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2Nyb2xsQmxvdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250ZXh0ID0ge307XG4gICAgfVxuXG4gICAgbXV0YXRpb25zID0gbXV0YXRpb25zIHx8IHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICB2YXIgbXV0YXRpb25zTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICBtdXRhdGlvbnMubWFwKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgdmFyIGJsb3QgPSByZWdpc3RyeS5maW5kKG11dGF0aW9uLnRhcmdldCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChibG90ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChtdXRhdGlvbnNNYXAuaGFzKGJsb3QuZG9tTm9kZSkpIHtcbiAgICAgICAgbXV0YXRpb25zTWFwLmdldChibG90LmRvbU5vZGUpLnB1c2gobXV0YXRpb24pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11dGF0aW9uc01hcC5zZXQoYmxvdC5kb21Ob2RlLCBbbXV0YXRpb25dKTtcbiAgICAgICAgcmV0dXJuIGJsb3Q7XG4gICAgICB9XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoYmxvdCkge1xuICAgICAgaWYgKGJsb3QgIT0gbnVsbCAmJiBibG90ICE9PSBfdGhpcyAmJiBtdXRhdGlvbnNNYXAuaGFzKGJsb3QuZG9tTm9kZSkpIHtcbiAgICAgICAgYmxvdC51cGRhdGUobXV0YXRpb25zTWFwLmdldChibG90LmRvbU5vZGUpIHx8IFtdLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb250ZXh0Lm11dGF0aW9uc01hcCA9IG11dGF0aW9uc01hcDtcblxuICAgIGlmIChtdXRhdGlvbnNNYXAuaGFzKHRoaXMuZG9tTm9kZSkpIHtcbiAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgbXV0YXRpb25zTWFwLmdldCh0aGlzLmRvbU5vZGUpLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGltaXplKG11dGF0aW9ucywgY29udGV4dCk7XG4gIH07XG5cbiAgU2Nyb2xsQmxvdC5ibG90TmFtZSA9ICdzY3JvbGwnO1xuICBTY3JvbGxCbG90LmRlZmF1bHRDaGlsZCA9IGJsb2NrO1xuICBTY3JvbGxCbG90LmFsbG93ZWRDaGlsZHJlbiA9IFtibG9jaywgY29udGFpbmVyXTtcbiAgU2Nyb2xsQmxvdC5zY29wZSA9IHNyY19zY29wZS5CTE9DS19CTE9UO1xuICBTY3JvbGxCbG90LnRhZ05hbWUgPSAnRElWJztcbiAgcmV0dXJuIFNjcm9sbEJsb3Q7XG59KGFic3RyYWN0X3BhcmVudCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJsb3Rfc2Nyb2xsID0gKHNjcm9sbF9TY3JvbGxCbG90KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3BhcmNobWVudC9zcmMvYmxvdC90ZXh0LnRzXG52YXIgdGV4dF9leHRlbmRzID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2V4dGVuZHMgfHwgZnVuY3Rpb24gKCkge1xuICB2YXIgX2V4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiBleHRlbmRTdGF0aWNzKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgICBfX3Byb3RvX186IFtdXG4gICAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBkLl9fcHJvdG9fXyA9IGI7XG4gICAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSB7XG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgICB9XG5cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG59KCk7XG5cblxuXG5cbnZhciB0ZXh0X1RleHRCbG90ID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgdGV4dF9leHRlbmRzKFRleHRCbG90LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFRleHRCbG90KHNjcm9sbCwgbm9kZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNjcm9sbCwgbm9kZSkgfHwgdGhpcztcblxuICAgIF90aGlzLnRleHQgPSBfdGhpcy5zdGF0aWNzLnZhbHVlKF90aGlzLmRvbU5vZGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFRleHRCbG90LmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gIH07XG5cbiAgVGV4dEJsb3QudmFsdWUgPSBmdW5jdGlvbiAoZG9tTm9kZSkge1xuICAgIHJldHVybiBkb21Ob2RlLmRhdGE7XG4gIH07XG5cbiAgVGV4dEJsb3QucHJvdG90eXBlLmRlbGV0ZUF0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgICB0aGlzLmRvbU5vZGUuZGF0YSA9IHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBpbmRleCkgKyB0aGlzLnRleHQuc2xpY2UoaW5kZXggKyBsZW5ndGgpO1xuICB9O1xuXG4gIFRleHRCbG90LnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uIChub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5kb21Ob2RlID09PSBub2RlKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBUZXh0QmxvdC5wcm90b3R5cGUuaW5zZXJ0QXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICBpZiAoZGVmID09IG51bGwpIHtcbiAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBpbmRleCkgKyB2YWx1ZSArIHRoaXMudGV4dC5zbGljZShpbmRleCk7XG4gICAgICB0aGlzLmRvbU5vZGUuZGF0YSA9IHRoaXMudGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbnNlcnRBdC5jYWxsKHRoaXMsIGluZGV4LCB2YWx1ZSwgZGVmKTtcbiAgICB9XG4gIH07XG5cbiAgVGV4dEJsb3QucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgfTtcblxuICBUZXh0QmxvdC5wcm90b3R5cGUub3B0aW1pemUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUub3B0aW1pemUuY2FsbCh0aGlzLCBjb250ZXh0KTtcblxuICAgIHRoaXMudGV4dCA9IHRoaXMuc3RhdGljcy52YWx1ZSh0aGlzLmRvbU5vZGUpO1xuXG4gICAgaWYgKHRoaXMudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5leHQgaW5zdGFuY2VvZiBUZXh0QmxvdCAmJiB0aGlzLm5leHQucHJldiA9PT0gdGhpcykge1xuICAgICAgdGhpcy5pbnNlcnRBdCh0aGlzLmxlbmd0aCgpLCB0aGlzLm5leHQudmFsdWUoKSk7XG4gICAgICB0aGlzLm5leHQucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuXG4gIFRleHRCbG90LnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uIChpbmRleCwgX2luY2x1c2l2ZSkge1xuICAgIGlmIChfaW5jbHVzaXZlID09PSB2b2lkIDApIHtcbiAgICAgIF9pbmNsdXNpdmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3RoaXMuZG9tTm9kZSwgaW5kZXhdO1xuICB9O1xuXG4gIFRleHRCbG90LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChpbmRleCwgZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UgPT09IHZvaWQgMCkge1xuICAgICAgZm9yY2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZnRlciA9IHRoaXMuc2Nyb2xsLmNyZWF0ZSh0aGlzLmRvbU5vZGUuc3BsaXRUZXh0KGluZGV4KSk7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGFmdGVyLCB0aGlzLm5leHQgfHwgdW5kZWZpbmVkKTtcbiAgICB0aGlzLnRleHQgPSB0aGlzLnN0YXRpY3MudmFsdWUodGhpcy5kb21Ob2RlKTtcbiAgICByZXR1cm4gYWZ0ZXI7XG4gIH07XG5cbiAgVGV4dEJsb3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtdXRhdGlvbnMsIF9jb250ZXh0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChtdXRhdGlvbnMuc29tZShmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgbXV0YXRpb24udGFyZ2V0ID09PSBfdGhpcy5kb21Ob2RlO1xuICAgIH0pKSB7XG4gICAgICB0aGlzLnRleHQgPSB0aGlzLnN0YXRpY3MudmFsdWUodGhpcy5kb21Ob2RlKTtcbiAgICB9XG4gIH07XG5cbiAgVGV4dEJsb3QucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRleHQ7XG4gIH07XG5cbiAgVGV4dEJsb3QuYmxvdE5hbWUgPSAndGV4dCc7XG4gIFRleHRCbG90LnNjb3BlID0gc3JjX3Njb3BlLklOTElORV9CTE9UO1xuICByZXR1cm4gVGV4dEJsb3Q7XG59KGxlYWYpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBibG90X3RleHQgPSAodGV4dF9UZXh0QmxvdCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9wYXJjaG1lbnQvc3JjL3BhcmNobWVudC50c1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGV2ZW50ZW1pdHRlcjNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2hhc193aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbnN0YW5jZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cblxuXG52YXIgZGVidWcgPSBPYmplY3QoX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSgncXVpbGw6ZXZlbnRzJyk7XG52YXIgRVZFTlRTID0gWydzZWxlY3Rpb25jaGFuZ2UnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnY2xpY2snXTtcblxuaWYgKE9iamVjdChfdXRpbHNfaGFzX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSgpKSB7XG4gIEVWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnFsLWNvbnRhaW5lcicpKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBxdWlsbCA9IF9pbnN0YW5jZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXQobm9kZSk7XG5cbiAgICAgICAgaWYgKHF1aWxsICYmIHF1aWxsLmVtaXR0ZXIpIHtcbiAgICAgICAgICB2YXIgX3F1aWxsJGVtaXR0ZXI7XG5cbiAgICAgICAgICAoX3F1aWxsJGVtaXR0ZXIgPSBxdWlsbC5lbWl0dGVyKS5oYW5kbGVET00uYXBwbHkoX3F1aWxsJGVtaXR0ZXIsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbnZhciBFbWl0dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhFbWl0dGVyLCBfRXZlbnRFbWl0dGVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEVtaXR0ZXIpO1xuXG4gIGZ1bmN0aW9uIEVtaXR0ZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVtaXR0ZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5saXN0ZW5lcnMgPSB7fTtcblxuICAgIF90aGlzLm9uKCdlcnJvcicsIGRlYnVnLmVycm9yKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFbWl0dGVyLCBbe1xuICAgIGtleTogXCJlbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQoKSB7XG4gICAgICB2YXIgX2RlYnVnJGxvZywgX2dldDI7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIChfZGVidWckbG9nID0gZGVidWcubG9nKS5jYWxsLmFwcGx5KF9kZWJ1ZyRsb2csIFtkZWJ1Z10uY29uY2F0KGFyZ3MpKTtcblxuICAgICAgKF9nZXQyID0gX2dldChfZ2V0UHJvdG90eXBlT2YoRW1pdHRlci5wcm90b3R5cGUpLCBcImVtaXRcIiwgdGhpcykpLmNhbGwuYXBwbHkoX2dldDIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRE9NKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICAodGhpcy5saXN0ZW5lcnNbZXZlbnQudHlwZV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfcmVmLm5vZGUsXG4gICAgICAgICAgICBoYW5kbGVyID0gX3JlZi5oYW5kbGVyO1xuXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IG5vZGUgfHwgbm9kZS5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgaGFuZGxlci5hcHBseSh2b2lkIDAsIFtldmVudF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpc3RlbkRPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW5ET00oZXZlbnROYW1lLCBub2RlLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdLnB1c2goe1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRW1pdHRlcjtcbn0oZXZlbnRlbWl0dGVyM19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSk7XG5cbkVtaXR0ZXIuZXZlbnRzID0ge1xuICBFRElUT1JfQ0hBTkdFOiAnZWRpdG9yLWNoYW5nZScsXG4gIFNDUk9MTF9CRUZPUkVfVVBEQVRFOiAnc2Nyb2xsLWJlZm9yZS11cGRhdGUnLFxuICBTQ1JPTExfQkxPVF9NT1VOVDogJ3Njcm9sbC1ibG90LW1vdW50JyxcbiAgU0NST0xMX0JMT1RfVU5NT1VOVDogJ3Njcm9sbC1ibG90LXVubW91bnQnLFxuICBTQ1JPTExfT1BUSU1JWkU6ICdzY3JvbGwtb3B0aW1pemUnLFxuICBTQ1JPTExfVVBEQVRFOiAnc2Nyb2xsLXVwZGF0ZScsXG4gIFNFTEVDVElPTl9DSEFOR0U6ICdzZWxlY3Rpb24tY2hhbmdlJyxcbiAgVEVYVF9DSEFOR0U6ICd0ZXh0LWNoYW5nZScsXG4gIENPTlRFTlRfU0VUVEVEOiAnY29udGVudC1zZXR0ZWQnXG59O1xuRW1pdHRlci5zb3VyY2VzID0ge1xuICBBUEk6ICdhcGknLFxuICBTSUxFTlQ6ICdzaWxlbnQnLFxuICBVU0VSOiAndXNlcidcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEVtaXR0ZXIpO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoLmNsb25lZGVlcC9pbmRleC5qc1xudmFyIGxvZGFzaF9jbG9uZWRlZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbnZhciBsb2Rhc2hfY2xvbmVkZWVwX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGxvZGFzaF9jbG9uZWRlZXApO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2VxdWFsL2luZGV4LmpzXG52YXIgbG9kYXNoX2lzZXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcbnZhciBsb2Rhc2hfaXNlcXVhbF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsb2Rhc2hfaXNlcXVhbCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoLm1lcmdlL2luZGV4LmpzXG52YXIgbG9kYXNoX21lcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG52YXIgbG9kYXNoX21lcmdlX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGxvZGFzaF9tZXJnZSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvcXVpbGwtZGVsdGEvZGlzdC9EZWx0YS5qc1xudmFyIERlbHRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBEZWx0YV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihEZWx0YSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvcGFyY2htZW50L3NyYy9wYXJjaG1lbnQudHMgKyAxNyBtb2R1bGVzXG52YXIgcGFyY2htZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvcmUvc2VsZWN0aW9uLmpzXG52YXIgc2VsZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jsb3RzL2N1cnNvci5qc1xudmFyIGN1cnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYmxvdHMvYmxvY2suanNcbnZhciBibG90c19ibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ibG90cy9icmVhay5qc1xudmFyIGJsb3RzX2JyZWFrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ibG90cy90ZXh0LmpzXG52YXIgYmxvdHNfdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3V0aWxzL3JlbW92ZV9jbGFzcy5qc1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKSB7XG4gIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuXG4gIGlmIChub2RlLmNsYXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb3JlL2VkaXRvci5qc1xuZnVuY3Rpb24gX3RvQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgQVNDSUkgPSAvXlsgLX5dKiQvO1xuXG52YXIgZWRpdG9yX0VkaXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVkaXRvcihzY3JvbGwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRpdG9yKTtcblxuICAgIHRoaXMuc2Nyb2xsID0gc2Nyb2xsO1xuICAgIHRoaXMuZGVsdGEgPSB0aGlzLmdldERlbHRhKCk7XG4gICAgdGhpcy5pbW1lZGlhdGVGb3JtYXRzID0gbmV3IFNldCgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVkaXRvciwgW3tcbiAgICBrZXk6IFwiYWRkSW1tZWRpYXRlRm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEltbWVkaWF0ZUZvcm1hdChuYW1lKSB7XG4gICAgICB0aGlzLmltbWVkaWF0ZUZvcm1hdHMuYWRkKG5hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseURlbHRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5RGVsdGEoZGVsdGEpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc2Nyb2xsLnVwZGF0ZSgpO1xuICAgICAgdmFyIHNjcm9sbExlbmd0aCA9IHRoaXMuc2Nyb2xsLmxlbmd0aCgpO1xuICAgICAgdGhpcy5zY3JvbGwuYmF0Y2hTdGFydCgpO1xuICAgICAgdmFyIG5vcm1hbGl6ZWREZWx0YSA9IG5vcm1hbGl6ZURlbHRhKGRlbHRhKTtcbiAgICAgIHZhciBkZWxldGVEZWx0YSA9IG5ldyBEZWx0YV9kZWZhdWx0LmEoKTtcbiAgICAgIG5vcm1hbGl6ZWREZWx0YS5yZWR1Y2UoZnVuY3Rpb24gKGluZGV4LCBvcCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gRGVsdGFbXCJPcFwiXS5sZW5ndGgob3ApO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IG9wLmF0dHJpYnV0ZXMgfHwge307XG4gICAgICAgIHZhciBhZGRlZE5ld2xpbmUgPSBmYWxzZTtcblxuICAgICAgICBpZiAob3AuaW5zZXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICBkZWxldGVEZWx0YS5yZXRhaW4obGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygb3AuaW5zZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBvcC5pbnNlcnQ7XG4gICAgICAgICAgICBhZGRlZE5ld2xpbmUgPSAhdGV4dC5lbmRzV2l0aCgnXFxuJykgJiYgKHNjcm9sbExlbmd0aCA8PSBpbmRleCB8fCBfdGhpcy5zY3JvbGwuZGVzY2VuZGFudChibG90c19ibG9ja1tcImFcIiAvKiBCbG9ja0VtYmVkICovXSwgaW5kZXgpWzBdKTtcblxuICAgICAgICAgICAgX3RoaXMuc2Nyb2xsLmluc2VydEF0KGluZGV4LCB0ZXh0KTtcblxuICAgICAgICAgICAgdmFyIF90aGlzJHNjcm9sbCRsaW5lID0gX3RoaXMuc2Nyb2xsLmxpbmUoaW5kZXgpLFxuICAgICAgICAgICAgICAgIF90aGlzJHNjcm9sbCRsaW5lMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJHNjcm9sbCRsaW5lLCAyKSxcbiAgICAgICAgICAgICAgICBsaW5lID0gX3RoaXMkc2Nyb2xsJGxpbmUyWzBdLFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IF90aGlzJHNjcm9sbCRsaW5lMlsxXTtcblxuICAgICAgICAgICAgdmFyIGZvcm1hdHMgPSBsb2Rhc2hfbWVyZ2VfZGVmYXVsdCgpKHt9LCBPYmplY3QoYmxvdHNfYmxvY2tbXCJjXCIgLyogYnViYmxlRm9ybWF0cyAqL10pKGxpbmUpKTtcblxuICAgICAgICAgICAgaWYgKGxpbmUgaW5zdGFuY2VvZiBibG90c19ibG9ja1tcImRcIiAvKiBkZWZhdWx0ICovXSkge1xuICAgICAgICAgICAgICB2YXIgX2xpbmUkZGVzY2VuZGFudCA9IGxpbmUuZGVzY2VuZGFudChwYXJjaG1lbnRbXCJMZWFmQmxvdFwiXSwgb2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgIF9saW5lJGRlc2NlbmRhbnQyID0gX3NsaWNlZFRvQXJyYXkoX2xpbmUkZGVzY2VuZGFudCwgMSksXG4gICAgICAgICAgICAgICAgICBsZWFmID0gX2xpbmUkZGVzY2VuZGFudDJbMF07XG5cbiAgICAgICAgICAgICAgZm9ybWF0cyA9IGxvZGFzaF9tZXJnZV9kZWZhdWx0KCkoZm9ybWF0cywgT2JqZWN0KGJsb3RzX2Jsb2NrW1wiY1wiIC8qIGJ1YmJsZUZvcm1hdHMgKi9dKShsZWFmKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBEZWx0YVtcIkF0dHJpYnV0ZU1hcFwiXS5kaWZmKGZvcm1hdHMsIGF0dHJpYnV0ZXMpIHx8IHt9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcC5pbnNlcnQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFyIGtleSA9IE9iamVjdC5rZXlzKG9wLmluc2VydClbMF07IC8vIFRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBrZXlcblxuICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICBhZGRlZE5ld2xpbmUgPSBfdGhpcy5zY3JvbGwucXVlcnkoa2V5LCBwYXJjaG1lbnRbXCJTY29wZVwiXS5JTkxJTkUpICE9IG51bGwgJiYgKHNjcm9sbExlbmd0aCA8PSBpbmRleCB8fCBfdGhpcy5zY3JvbGwuZGVzY2VuZGFudChibG90c19ibG9ja1tcImFcIiAvKiBCbG9ja0VtYmVkICovXSwgaW5kZXgpWzBdKTtcblxuICAgICAgICAgICAgX3RoaXMuc2Nyb2xsLmluc2VydEF0KGluZGV4LCBrZXksIG9wLmluc2VydFtrZXldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY3JvbGxMZW5ndGggKz0gbGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZURlbHRhLnB1c2gob3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcblxuICAgICAgICBfdGhpcy5pbW1lZGlhdGVGb3JtYXRzLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgIGlmIChrZXlzLmluZGV4T2YoZm9ybWF0KSA+IC0xKSB7XG4gICAgICAgICAgICBfdGhpcy5zY3JvbGwuZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgZm9ybWF0LCBhdHRyaWJ1dGVzW2Zvcm1hdF0pO1xuXG4gICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1tmb3JtYXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIF90aGlzLnNjcm9sbC5mb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCBhdHRyaWJ1dGVzW25hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhZGRlZExlbmd0aCA9IGFkZGVkTmV3bGluZSA/IDEgOiAwO1xuICAgICAgICBzY3JvbGxMZW5ndGggKz0gYWRkZWRMZW5ndGg7XG4gICAgICAgIGRlbGV0ZURlbHRhLmRlbGV0ZShhZGRlZExlbmd0aCk7XG4gICAgICAgIHJldHVybiBpbmRleCArIGxlbmd0aCArIGFkZGVkTGVuZ3RoO1xuICAgICAgfSwgMCk7XG4gICAgICBkZWxldGVEZWx0YS5yZWR1Y2UoZnVuY3Rpb24gKGluZGV4LCBvcCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wLmRlbGV0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBfdGhpcy5zY3JvbGwuZGVsZXRlQXQoaW5kZXgsIG9wLmRlbGV0ZSk7XG5cbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXggKyBEZWx0YVtcIk9wXCJdLmxlbmd0aChvcCk7XG4gICAgICB9LCAwKTtcbiAgICAgIHRoaXMuc2Nyb2xsLmJhdGNoRW5kKCk7XG4gICAgICB0aGlzLnNjcm9sbC5vcHRpbWl6ZSgpO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKG5vcm1hbGl6ZWREZWx0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlVGV4dChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB0aGlzLnNjcm9sbC5kZWxldGVBdChpbmRleCwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShuZXcgRGVsdGFfZGVmYXVsdC5hKCkucmV0YWluKGluZGV4KS5kZWxldGUobGVuZ3RoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdExpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0TGluZShpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdGhpcy5zY3JvbGwudXBkYXRlKCk7XG4gICAgICBPYmplY3Qua2V5cyhmb3JtYXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgX3RoaXMyLnNjcm9sbC5saW5lcyhpbmRleCwgTWF0aC5tYXgobGVuZ3RoLCAxKSkuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgIGxpbmUuZm9ybWF0KGZvcm1hdCwgZm9ybWF0c1tmb3JtYXRdKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2Nyb2xsLm9wdGltaXplKCk7XG4gICAgICB2YXIgZGVsdGEgPSBuZXcgRGVsdGFfZGVmYXVsdC5hKCkucmV0YWluKGluZGV4KS5yZXRhaW4obGVuZ3RoLCBsb2Rhc2hfY2xvbmVkZWVwX2RlZmF1bHQoKShmb3JtYXRzKSk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUoZGVsdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFRleHQoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtYXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGZvcm1hdHMpLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBfdGhpczMuc2Nyb2xsLmZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIGZvcm1hdCwgZm9ybWF0c1tmb3JtYXRdKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGRlbHRhID0gbmV3IERlbHRhX2RlZmF1bHQuYSgpLnJldGFpbihpbmRleCkucmV0YWluKGxlbmd0aCwgbG9kYXNoX2Nsb25lZGVlcF9kZWZhdWx0KCkoZm9ybWF0cykpO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGRlbHRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29udGVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGVudHMoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsdGEuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVsdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVsdGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGwubGluZXMoKS5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBsaW5lKSB7XG4gICAgICAgIHJldHVybiBkZWx0YS5jb25jYXQobGluZS5kZWx0YSgpKTtcbiAgICAgIH0sIG5ldyBEZWx0YV9kZWZhdWx0LmEoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JtYXQoaW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgIHZhciBsZWF2ZXMgPSBbXTtcblxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnNjcm9sbC5wYXRoKGluZGV4KS5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgdmFyIF9wYXRoID0gX3NsaWNlZFRvQXJyYXkocGF0aCwgMSksXG4gICAgICAgICAgICAgIGJsb3QgPSBfcGF0aFswXTtcblxuICAgICAgICAgIGlmIChibG90IGluc3RhbmNlb2YgYmxvdHNfYmxvY2tbXCJkXCIgLyogZGVmYXVsdCAqL10pIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goYmxvdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChibG90IGluc3RhbmNlb2YgcGFyY2htZW50W1wiTGVhZkJsb3RcIl0pIHtcbiAgICAgICAgICAgIGxlYXZlcy5wdXNoKGJsb3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lcyA9IHRoaXMuc2Nyb2xsLmxpbmVzKGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBsZWF2ZXMgPSB0aGlzLnNjcm9sbC5kZXNjZW5kYW50cyhwYXJjaG1lbnRbXCJMZWFmQmxvdFwiXSwgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbWFwID0gW2xpbmVzLCBsZWF2ZXNdLm1hcChmdW5jdGlvbiAoYmxvdHMpIHtcbiAgICAgICAgaWYgKGJsb3RzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHt9O1xuICAgICAgICB2YXIgZm9ybWF0cyA9IE9iamVjdChibG90c19ibG9ja1tcImNcIiAvKiBidWJibGVGb3JtYXRzICovXSkoYmxvdHMuc2hpZnQoKSk7XG5cbiAgICAgICAgd2hpbGUgKE9iamVjdC5rZXlzKGZvcm1hdHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgYmxvdCA9IGJsb3RzLnNoaWZ0KCk7XG4gICAgICAgICAgaWYgKGJsb3QgPT0gbnVsbCkgcmV0dXJuIGZvcm1hdHM7XG4gICAgICAgICAgZm9ybWF0cyA9IGNvbWJpbmVGb3JtYXRzKE9iamVjdChibG90c19ibG9ja1tcImNcIiAvKiBidWJibGVGb3JtYXRzICovXSkoYmxvdCksIGZvcm1hdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgICB9KTtcblxuICAgICAgdmFyIF9tYXAyID0gX3NsaWNlZFRvQXJyYXkoX21hcCwgMik7XG5cbiAgICAgIGxpbmVzID0gX21hcDJbMF07XG4gICAgICBsZWF2ZXMgPSBfbWFwMlsxXTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGxpbmVzKSwgbGVhdmVzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SFRNTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIVE1MKGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHZhciBfdGhpcyRzY3JvbGwkbGluZTMgPSB0aGlzLnNjcm9sbC5saW5lKGluZGV4KSxcbiAgICAgICAgICBfdGhpcyRzY3JvbGwkbGluZTQgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRzY3JvbGwkbGluZTMsIDIpLFxuICAgICAgICAgIGxpbmUgPSBfdGhpcyRzY3JvbGwkbGluZTRbMF0sXG4gICAgICAgICAgbGluZU9mZnNldCA9IF90aGlzJHNjcm9sbCRsaW5lNFsxXTtcblxuICAgICAgaWYgKGxpbmUubGVuZ3RoKCkgPj0gbGluZU9mZnNldCArIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY29udmVydEhUTUwobGluZSwgbGluZU9mZnNldCwgbGVuZ3RoLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnZlcnRIVE1MKHRoaXMuc2Nyb2xsLCBpbmRleCwgbGVuZ3RoLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0KGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENvbnRlbnRzKGluZGV4LCBsZW5ndGgpLmZpbHRlcihmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChvcCkge1xuICAgICAgICByZXR1cm4gb3AuaW5zZXJ0O1xuICAgICAgfSkuam9pbignJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEVtYmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEVtYmVkKGluZGV4LCBlbWJlZCwgdmFsdWUpIHtcbiAgICAgIHRoaXMuc2Nyb2xsLmluc2VydEF0KGluZGV4LCBlbWJlZCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKG5ldyBEZWx0YV9kZWZhdWx0LmEoKS5yZXRhaW4oaW5kZXgpLmluc2VydChfZGVmaW5lUHJvcGVydHkoe30sIGVtYmVkLCB2YWx1ZSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRUZXh0KGluZGV4LCB0ZXh0KSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGZvcm1hdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcbicpO1xuICAgICAgdGhpcy5zY3JvbGwuaW5zZXJ0QXQoaW5kZXgsIHRleHQpO1xuICAgICAgT2JqZWN0LmtleXMoZm9ybWF0cykuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIF90aGlzNC5zY3JvbGwuZm9ybWF0QXQoaW5kZXgsIHRleHQubGVuZ3RoLCBmb3JtYXQsIGZvcm1hdHNbZm9ybWF0XSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShuZXcgRGVsdGFfZGVmYXVsdC5hKCkucmV0YWluKGluZGV4KS5pbnNlcnQodGV4dCwgbG9kYXNoX2Nsb25lZGVlcF9kZWZhdWx0KCkoZm9ybWF0cykpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNCbGFua1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0JsYW5rKCkge1xuICAgICAgdmFyIGlzQ29tcG9zaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLnNjcm9sbC5jaGlsZHJlbi5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodGhpcy5zY3JvbGwuY2hpbGRyZW4ubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGJsb2NrID0gdGhpcy5zY3JvbGwuY2hpbGRyZW4uaGVhZDtcbiAgICAgIGlmIChibG9jay5zdGF0aWNzLmJsb3ROYW1lICE9PSBibG90c19ibG9ja1tcImRcIiAvKiBkZWZhdWx0ICovXS5ibG90TmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBibG9jay5jaGlsZHJlbi5oZWFkIGluc3RhbmNlb2YgYmxvdHNfYnJlYWtbXCJhXCIgLyogZGVmYXVsdCAqL107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGb3JtYXQoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgdmFyIHRleHQgPSB0aGlzLmdldFRleHQoaW5kZXgsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBfdGhpcyRzY3JvbGwkbGluZTUgPSB0aGlzLnNjcm9sbC5saW5lKGluZGV4ICsgbGVuZ3RoKSxcbiAgICAgICAgICBfdGhpcyRzY3JvbGwkbGluZTYgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRzY3JvbGwkbGluZTUsIDIpLFxuICAgICAgICAgIGxpbmUgPSBfdGhpcyRzY3JvbGwkbGluZTZbMF0sXG4gICAgICAgICAgb2Zmc2V0ID0gX3RoaXMkc2Nyb2xsJGxpbmU2WzFdO1xuXG4gICAgICB2YXIgc3VmZml4TGVuZ3RoID0gMDtcbiAgICAgIHZhciBzdWZmaXggPSBuZXcgRGVsdGFfZGVmYXVsdC5hKCk7XG5cbiAgICAgIGlmIChsaW5lICE9IG51bGwpIHtcbiAgICAgICAgc3VmZml4TGVuZ3RoID0gbGluZS5sZW5ndGgoKSAtIG9mZnNldDtcbiAgICAgICAgc3VmZml4ID0gbGluZS5kZWx0YSgpLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3VmZml4TGVuZ3RoIC0gMSkuaW5zZXJ0KCdcXG4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRlbnRzID0gdGhpcy5nZXRDb250ZW50cyhpbmRleCwgbGVuZ3RoICsgc3VmZml4TGVuZ3RoKTtcbiAgICAgIHZhciBkaWZmID0gY29udGVudHMuZGlmZihuZXcgRGVsdGFfZGVmYXVsdC5hKCkuaW5zZXJ0KHRleHQpLmNvbmNhdChzdWZmaXgpKTtcbiAgICAgIHZhciBkZWx0YSA9IG5ldyBEZWx0YV9kZWZhdWx0LmEoKS5yZXRhaW4oaW5kZXgpLmNvbmNhdChkaWZmKTtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5RGVsdGEoZGVsdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGNoYW5nZSkge1xuICAgICAgdmFyIG11dGF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICB2YXIgc2VsZWN0aW9uSW5mbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG9sZERlbHRhID0gdGhpcy5kZWx0YTtcblxuICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPT09IDEgJiYgbXV0YXRpb25zWzBdLnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiBtdXRhdGlvbnNbMF0udGFyZ2V0LmRhdGEubWF0Y2goQVNDSUkpICYmIHRoaXMuc2Nyb2xsLmZpbmQobXV0YXRpb25zWzBdLnRhcmdldCkpIHtcbiAgICAgICAgLy8gT3B0aW1pemF0aW9uIGZvciBjaGFyYWN0ZXIgY2hhbmdlc1xuICAgICAgICB2YXIgdGV4dEJsb3QgPSB0aGlzLnNjcm9sbC5maW5kKG11dGF0aW9uc1swXS50YXJnZXQpO1xuICAgICAgICB2YXIgZm9ybWF0cyA9IE9iamVjdChibG90c19ibG9ja1tcImNcIiAvKiBidWJibGVGb3JtYXRzICovXSkodGV4dEJsb3QpO1xuICAgICAgICB2YXIgaW5kZXggPSB0ZXh0QmxvdC5vZmZzZXQodGhpcy5zY3JvbGwpO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBtdXRhdGlvbnNbMF0ub2xkVmFsdWUucmVwbGFjZShjdXJzb3JbXCJhXCIgLyogZGVmYXVsdCAqL10uQ09OVEVOVFMsICcnKTtcbiAgICAgICAgdmFyIG9sZFRleHQgPSBuZXcgRGVsdGFfZGVmYXVsdC5hKCkuaW5zZXJ0KG9sZFZhbHVlKTtcbiAgICAgICAgdmFyIG5ld1RleHQgPSBuZXcgRGVsdGFfZGVmYXVsdC5hKCkuaW5zZXJ0KHRleHRCbG90LnZhbHVlKCkpO1xuICAgICAgICB2YXIgcmVsYXRpdmVTZWxlY3Rpb25JbmZvID0gc2VsZWN0aW9uSW5mbyAmJiB7XG4gICAgICAgICAgb2xkUmFuZ2U6IHNoaWZ0UmFuZ2Uoc2VsZWN0aW9uSW5mby5vbGRSYW5nZSwgLWluZGV4KSxcbiAgICAgICAgICBuZXdSYW5nZTogc2hpZnRSYW5nZShzZWxlY3Rpb25JbmZvLm5ld1JhbmdlLCAtaW5kZXgpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBkaWZmRGVsdGEgPSBuZXcgRGVsdGFfZGVmYXVsdC5hKCkucmV0YWluKGluZGV4KS5jb25jYXQob2xkVGV4dC5kaWZmKG5ld1RleHQsIHJlbGF0aXZlU2VsZWN0aW9uSW5mbykpO1xuICAgICAgICBjaGFuZ2UgPSBkaWZmRGVsdGEucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwgb3ApIHtcbiAgICAgICAgICBpZiAob3AuaW5zZXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsdGEuaW5zZXJ0KG9wLmluc2VydCwgZm9ybWF0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRlbHRhLnB1c2gob3ApO1xuICAgICAgICB9LCBuZXcgRGVsdGFfZGVmYXVsdC5hKCkpO1xuICAgICAgICB0aGlzLmRlbHRhID0gb2xkRGVsdGEuY29tcG9zZShjaGFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWx0YSA9IHRoaXMuZ2V0RGVsdGEoKTtcblxuICAgICAgICBpZiAoIWNoYW5nZSB8fCAhbG9kYXNoX2lzZXF1YWxfZGVmYXVsdCgpKG9sZERlbHRhLmNvbXBvc2UoY2hhbmdlKSwgdGhpcy5kZWx0YSkpIHtcbiAgICAgICAgICBjaGFuZ2UgPSBvbGREZWx0YS5kaWZmKHRoaXMuZGVsdGEsIHNlbGVjdGlvbkluZm8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVkaXRvcjtcbn0oKTtcblxuZnVuY3Rpb24gY29udmVydExpc3RIVE1MKGl0ZW1zLCBsYXN0SW5kZW50LCB0eXBlcykge1xuICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIF9nZXRMaXN0VHlwZSA9IGdldExpc3RUeXBlKHR5cGVzLnBvcCgpKSxcbiAgICAgICAgX2dldExpc3RUeXBlMiA9IF9zbGljZWRUb0FycmF5KF9nZXRMaXN0VHlwZSwgMSksXG4gICAgICAgIF9lbmRUYWcgPSBfZ2V0TGlzdFR5cGUyWzBdO1xuXG4gICAgaWYgKGxhc3RJbmRlbnQgPD0gMCkge1xuICAgICAgcmV0dXJuIFwiPC9saT48L1wiLmNvbmNhdChfZW5kVGFnLCBcIj5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiPC9saT48L1wiLmNvbmNhdChfZW5kVGFnLCBcIj5cIikuY29uY2F0KGNvbnZlcnRMaXN0SFRNTChbXSwgbGFzdEluZGVudCAtIDEsIHR5cGVzKSk7XG4gIH1cblxuICB2YXIgX2l0ZW1zID0gX3RvQXJyYXkoaXRlbXMpLFxuICAgICAgX2l0ZW1zJCA9IF9pdGVtc1swXSxcbiAgICAgIGNoaWxkID0gX2l0ZW1zJC5jaGlsZCxcbiAgICAgIG9mZnNldCA9IF9pdGVtcyQub2Zmc2V0LFxuICAgICAgbGVuZ3RoID0gX2l0ZW1zJC5sZW5ndGgsXG4gICAgICBpbmRlbnQgPSBfaXRlbXMkLmluZGVudCxcbiAgICAgIHR5cGUgPSBfaXRlbXMkLnR5cGUsXG4gICAgICByZXN0ID0gX2l0ZW1zLnNsaWNlKDEpO1xuXG4gIHZhciBfZ2V0TGlzdFR5cGUzID0gZ2V0TGlzdFR5cGUodHlwZSwgY2hpbGQpLFxuICAgICAgX2dldExpc3RUeXBlNCA9IF9zbGljZWRUb0FycmF5KF9nZXRMaXN0VHlwZTMsIDIpLFxuICAgICAgdGFnID0gX2dldExpc3RUeXBlNFswXSxcbiAgICAgIGF0dHJpYnV0ZSA9IF9nZXRMaXN0VHlwZTRbMV07XG5cbiAgaWYgKGluZGVudCA+IGxhc3RJbmRlbnQpIHtcbiAgICB0eXBlcy5wdXNoKHR5cGUpO1xuXG4gICAgaWYgKGluZGVudCA9PT0gbGFzdEluZGVudCArIDEpIHtcbiAgICAgIHJldHVybiBcIjxcIi5jb25jYXQodGFnLCBcIj48bGlcIikuY29uY2F0KGF0dHJpYnV0ZSwgXCI+XCIpLmNvbmNhdChjb252ZXJ0SFRNTChjaGlsZCwgb2Zmc2V0LCBsZW5ndGgpKS5jb25jYXQoY29udmVydExpc3RIVE1MKHJlc3QsIGluZGVudCwgdHlwZXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCI8XCIuY29uY2F0KHRhZywgXCI+PGxpPlwiKS5jb25jYXQoY29udmVydExpc3RIVE1MKGl0ZW1zLCBsYXN0SW5kZW50ICsgMSwgdHlwZXMpKTtcbiAgfVxuXG4gIHZhciBwcmV2aW91c1R5cGUgPSB0eXBlc1t0eXBlcy5sZW5ndGggLSAxXTtcblxuICBpZiAoaW5kZW50ID09PSBsYXN0SW5kZW50ICYmIHR5cGUgPT09IHByZXZpb3VzVHlwZSkge1xuICAgIHJldHVybiBcIjwvbGk+PGxpXCIuY29uY2F0KGF0dHJpYnV0ZSwgXCI+XCIpLmNvbmNhdChjb252ZXJ0SFRNTChjaGlsZCwgb2Zmc2V0LCBsZW5ndGgpKS5jb25jYXQoY29udmVydExpc3RIVE1MKHJlc3QsIGluZGVudCwgdHlwZXMpKTtcbiAgfVxuXG4gIHZhciBfZ2V0TGlzdFR5cGU1ID0gZ2V0TGlzdFR5cGUodHlwZXMucG9wKCkpLFxuICAgICAgX2dldExpc3RUeXBlNiA9IF9zbGljZWRUb0FycmF5KF9nZXRMaXN0VHlwZTUsIDEpLFxuICAgICAgZW5kVGFnID0gX2dldExpc3RUeXBlNlswXTtcblxuICByZXR1cm4gXCI8L2xpPjwvXCIuY29uY2F0KGVuZFRhZywgXCI+XCIpLmNvbmNhdChjb252ZXJ0TGlzdEhUTUwoaXRlbXMsIGxhc3RJbmRlbnQgLSAxLCB0eXBlcykpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0SFRNTChibG90LCBpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpc1Jvb3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgYmxvdC5odG1sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGJsb3QuaHRtbChpbmRleCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChibG90IGluc3RhbmNlb2YgYmxvdHNfdGV4dFtcImFcIiAvKiBkZWZhdWx0ICovXSkge1xuICAgIHJldHVybiBPYmplY3QoYmxvdHNfdGV4dFtcImJcIiAvKiBlc2NhcGVUZXh0ICovXSkoYmxvdC52YWx1ZSgpLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCkpO1xuICB9XG5cbiAgaWYgKGJsb3QuY2hpbGRyZW4pIHtcbiAgICAvLyBUT0RPIGZpeCBBUElcbiAgICBpZiAoYmxvdC5zdGF0aWNzLmJsb3ROYW1lID09PSAnbGlzdC1jb250YWluZXInKSB7XG4gICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgIGJsb3QuY2hpbGRyZW4uZm9yRWFjaEF0KGluZGV4LCBsZW5ndGgsIGZ1bmN0aW9uIChjaGlsZCwgb2Zmc2V0LCBjaGlsZExlbmd0aCkge1xuICAgICAgICB2YXIgZm9ybWF0cyA9IGNoaWxkLmZvcm1hdHMoKTtcbiAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgY2hpbGQ6IGNoaWxkLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgIGxlbmd0aDogY2hpbGRMZW5ndGgsXG4gICAgICAgICAgaW5kZW50OiBmb3JtYXRzLmluZGVudCB8fCAwLFxuICAgICAgICAgIHR5cGU6IGZvcm1hdHMubGlzdFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbnZlcnRMaXN0SFRNTChpdGVtcywgLTEsIFtdKTtcbiAgICB9XG5cbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBibG90LmNoaWxkcmVuLmZvckVhY2hBdChpbmRleCwgbGVuZ3RoLCBmdW5jdGlvbiAoY2hpbGQsIG9mZnNldCwgY2hpbGRMZW5ndGgpIHtcbiAgICAgIHBhcnRzLnB1c2goY29udmVydEhUTUwoY2hpbGQsIG9mZnNldCwgY2hpbGRMZW5ndGgpKTtcbiAgICB9KTtcbiAgICBoYW5kbGVCcmVha0xpbmUoYmxvdC5jaGlsZHJlbiwgcGFydHMpO1xuXG4gICAgaWYgKGlzUm9vdCB8fCBibG90LnN0YXRpY3MuYmxvdE5hbWUgPT09ICdsaXN0Jykge1xuICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuICAgIH1cblxuICAgIHZhciBkb21Ob2RlID0gZXh0cmFjdE5vZGVGcm9tQmxvdChibG90KTtcbiAgICB2YXIgb3V0ZXJIVE1MID0gZG9tTm9kZS5vdXRlckhUTUwsXG4gICAgICAgIGlubmVySFRNTCA9IGRvbU5vZGUuaW5uZXJIVE1MO1xuXG4gICAgdmFyIF9vdXRlckhUTUwkc3BsaXQgPSBvdXRlckhUTUwuc3BsaXQoXCI+XCIuY29uY2F0KGlubmVySFRNTCwgXCI8XCIpKSxcbiAgICAgICAgX291dGVySFRNTCRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfb3V0ZXJIVE1MJHNwbGl0LCAyKSxcbiAgICAgICAgc3RhcnQgPSBfb3V0ZXJIVE1MJHNwbGl0MlswXSxcbiAgICAgICAgZW5kID0gX291dGVySFRNTCRzcGxpdDJbMV07XG5cbiAgICBpZiAoc3RhcnQuaW5kZXhPZignPHRhYmxlJykgPT09IDApIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChzdGFydC5yZXBsYWNlKC8oXFxzZGF0YS0uKz89W1wiJ10uKj9bXCInXSkvZywgJycpLCBcIj5cIikuY29uY2F0KHBhcnRzLmpvaW4oJycpLnJlcGxhY2UoLyhcXHNkYXRhLS4rPz1bXCInXS4qP1tcIiddKS9nLCAnJyksIFwiPFwiKS5jb25jYXQoZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoc3RhcnQsIFwiPlwiKS5jb25jYXQocGFydHMuam9pbignJyksIFwiPFwiKS5jb25jYXQoZW5kKTtcbiAgfVxuXG4gIHJldHVybiBibG90LmRvbU5vZGUub3V0ZXJIVE1MO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVCcmVha0xpbmUobGlua2VkTGlzdCwgcGFydHMpIHtcbiAgaWYgKGxpbmtlZExpc3QubGVuZ3RoID09PSAxICYmIGxpbmtlZExpc3QuaGVhZCBpbnN0YW5jZW9mIGJsb3RzX2JyZWFrW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSB7XG4gICAgcGFydHMucHVzaCgnPGJyPicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3ROb2RlRnJvbUJsb3QoYmxvdCkge1xuICB2YXIgZG9tTm9kZSA9IGJsb3QuZG9tTm9kZS5jbG9uZU5vZGUodHJ1ZSk7XG4gIHJldHVybiByZW1vdmVUYWJsZVNlcnZpY2VDbGFzc2VzKGJsb3QsIGRvbU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVUYWJsZVNlcnZpY2VDbGFzc2VzKGJsb3QsIGRvbU5vZGUpIHtcbiAgdmFyIEJMT1RTX1dJVEhfU0VSVklDRV9DTEFTUyA9IFsndGFibGVDZWxsTGluZScsICd0YWJsZUhlYWRlckNlbGxMaW5lJywgJ3RhYmxlQ2VsbCcsICd0YWJsZUhlYWRlckNlbGwnXTtcblxuICBpZiAoQkxPVFNfV0lUSF9TRVJWSUNFX0NMQVNTLmluY2x1ZGVzKGJsb3Quc3RhdGljcy5ibG90TmFtZSkpIHtcbiAgICByZW1vdmVDbGFzcyhkb21Ob2RlLCBibG90LnN0YXRpY3MuY2xhc3NOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBkb21Ob2RlO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lRm9ybWF0cyhmb3JtYXRzLCBjb21iaW5lZCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoY29tYmluZWQpLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBuYW1lKSB7XG4gICAgaWYgKGZvcm1hdHNbbmFtZV0gPT0gbnVsbCkgcmV0dXJuIG1lcmdlZDtcblxuICAgIGlmIChjb21iaW5lZFtuYW1lXSA9PT0gZm9ybWF0c1tuYW1lXSkge1xuICAgICAgbWVyZ2VkW25hbWVdID0gY29tYmluZWRbbmFtZV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbWJpbmVkW25hbWVdKSkge1xuICAgICAgaWYgKGNvbWJpbmVkW25hbWVdLmluZGV4T2YoZm9ybWF0c1tuYW1lXSkgPCAwKSB7XG4gICAgICAgIG1lcmdlZFtuYW1lXSA9IGNvbWJpbmVkW25hbWVdLmNvbmNhdChbZm9ybWF0c1tuYW1lXV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZWRbbmFtZV0gPSBbY29tYmluZWRbbmFtZV0sIGZvcm1hdHNbbmFtZV1dO1xuICAgIH1cblxuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TGlzdFR5cGUodHlwZSwgY2hpbGQpIHtcbiAgdmFyIHRhZyA9IHR5cGUgPT09ICdvcmRlcmVkJyA/ICdvbCcgOiAndWwnO1xuICB2YXIgYXR0cmlidXRlcyA9IGNoaWxkID8gXCJcIi5jb25jYXQoZ2V0QmxvdE5vZGVBdHRyaWJ1dGVzKGNoaWxkKSkgOiAnJztcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgIHJldHVybiBbdGFnLCBcIlwiLmNvbmNhdChhdHRyaWJ1dGVzLCBcIiBkYXRhLWxpc3Q9XFxcImNoZWNrZWRcXFwiXCIpXTtcblxuICAgIGNhc2UgJ3VuY2hlY2tlZCc6XG4gICAgICByZXR1cm4gW3RhZywgXCJcIi5jb25jYXQoYXR0cmlidXRlcywgXCIgZGF0YS1saXN0PVxcXCJ1bmNoZWNrZWRcXFwiXCIpXTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW3RhZywgYXR0cmlidXRlc107XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmxvdE5vZGVBdHRyaWJ1dGVzKF9yZWYpIHtcbiAgdmFyIGRvbU5vZGUgPSBfcmVmLmRvbU5vZGU7XG5cbiAgaWYgKCFkb21Ob2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBhdHRyaWJ1dGVzID0gZG9tTm9kZS5hdHRyaWJ1dGVzO1xuICB2YXIgYXR0cmlidXRlc1N0cmluZyA9ICcgJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZXNbaV0ubmFtZTtcbiAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW2ldLnZhbHVlO1xuXG4gICAgaWYgKG5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgIHZhbHVlID0gcmVtb3ZlSW5kZW50Q2xhc3ModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5sZW5ndGggJiYgbmFtZS5pbmRleE9mKCdkYXRhLScpID09PSAtMSkge1xuICAgICAgYXR0cmlidXRlc1N0cmluZyArPSBcIlwiLmNvbmNhdChuYW1lLCBcIj1cXFwiXCIpLmNvbmNhdCh2YWx1ZSwgXCJcXFwiXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRyaWJ1dGVzU3RyaW5nLmxlbmd0aCA+IDEgPyBhdHRyaWJ1dGVzU3RyaW5nIDogJyc7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUluZGVudENsYXNzKGNsYXNzU3RyaW5nKSB7XG4gIHJldHVybiBjbGFzc1N0cmluZy5yZXBsYWNlKC9xbC1pbmRlbnQtXFxkL2csICcnKS50cmltKCk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURlbHRhKGRlbHRhKSB7XG4gIHJldHVybiBkZWx0YS5yZWR1Y2UoZnVuY3Rpb24gKG5vcm1hbGl6ZWREZWx0YSwgb3ApIHtcbiAgICBpZiAodHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciB0ZXh0ID0gb3AuaW5zZXJ0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKTtcbiAgICAgIHJldHVybiBub3JtYWxpemVkRGVsdGEuaW5zZXJ0KHRleHQsIG9wLmF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemVkRGVsdGEucHVzaChvcCk7XG4gIH0sIG5ldyBEZWx0YV9kZWZhdWx0LmEoKSk7XG59XG5cbmZ1bmN0aW9uIHNoaWZ0UmFuZ2UoX3JlZjIsIGFtb3VudCkge1xuICB2YXIgaW5kZXggPSBfcmVmMi5pbmRleCxcbiAgICAgIGxlbmd0aCA9IF9yZWYyLmxlbmd0aDtcbiAgcmV0dXJuIG5ldyBzZWxlY3Rpb25bXCJhXCIgLyogUmFuZ2UgKi9dKGluZGV4ICsgYW1vdW50LCBsZW5ndGgpO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBlZGl0b3IgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChlZGl0b3JfRWRpdG9yKTtcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0RlZmluZWQ7IH0pO1xuZnVuY3Rpb24gaXNEZWZpbmVkKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJsb2NrRGVsdGE7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBidWJibGVGb3JtYXRzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQmxvY2tFbWJlZDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEJsb2NrOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYnJlYWtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbmxpbmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90ZXh0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cblxuXG5cbnZhciBORVdMSU5FX0xFTkdUSCA9IDE7XG5cbnZhciBCbG9jayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jsb2NrQmxvdCkge1xuICBfaW5oZXJpdHMoQmxvY2ssIF9CbG9ja0Jsb3QpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQmxvY2spO1xuXG4gIGZ1bmN0aW9uIEJsb2NrKHNjcm9sbCwgZG9tTm9kZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCbG9jayk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNjcm9sbCwgZG9tTm9kZSk7XG4gICAgX3RoaXMuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmxvY2ssIFt7XG4gICAga2V5OiBcImRlbHRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbHRhKCkge1xuICAgICAgaWYgKHRoaXMuY2FjaGUuZGVsdGEgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNhY2hlLmRlbHRhID0gYmxvY2tEZWx0YSh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZGVsdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUF0KGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksIFwiZGVsZXRlQXRcIiwgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoKTtcblxuICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKGxlbmd0aCA8PSAwKSByZXR1cm47XG5cbiAgICAgIGlmICh0aGlzLnNjcm9sbC5xdWVyeShuYW1lLCBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlNjb3BlXCJdLkJMT0NLKSkge1xuICAgICAgICBpZiAoaW5kZXggKyBsZW5ndGggPT09IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgICB0aGlzLmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksIFwiZm9ybWF0QXRcIiwgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgTWF0aC5taW4obGVuZ3RoLCB0aGlzLmxlbmd0aCgpIC0gaW5kZXggLSAxKSwgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICBpZiAoZGVmICE9IG51bGwpIHtcbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgXCJpbnNlcnRBdFwiLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCB2YWx1ZSwgZGVmKTtcblxuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIGxpbmVzID0gdmFsdWUuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHRleHQgPSBsaW5lcy5zaGlmdCgpO1xuXG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMubGVuZ3RoKCkgLSAxIHx8IHRoaXMuY2hpbGRyZW4udGFpbCA9PSBudWxsKSB7XG4gICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgXCJpbnNlcnRBdFwiLCB0aGlzKS5jYWxsKHRoaXMsIE1hdGgubWluKGluZGV4LCB0aGlzLmxlbmd0aCgpIC0gMSksIHRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4udGFpbC5pbnNlcnRBdCh0aGlzLmNoaWxkcmVuLnRhaWwubGVuZ3RoKCksIHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgYmxvY2sgPSB0aGlzO1xuICAgICAgbGluZXMucmVkdWNlKGZ1bmN0aW9uIChsaW5lSW5kZXgsIGxpbmUpIHtcbiAgICAgICAgYmxvY2sgPSBibG9jay5zcGxpdChsaW5lSW5kZXgsIHRydWUpO1xuICAgICAgICBibG9jay5pbnNlcnRBdCgwLCBsaW5lKTtcbiAgICAgICAgcmV0dXJuIGxpbmUubGVuZ3RoO1xuICAgICAgfSwgaW5kZXggKyB0ZXh0Lmxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoYmxvdCwgcmVmKSB7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuY2hpbGRyZW4uaGVhZDtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgXCJpbnNlcnRCZWZvcmVcIiwgdGhpcykuY2FsbCh0aGlzLCBibG90LCByZWYpO1xuXG4gICAgICBpZiAoaGVhZCBpbnN0YW5jZW9mIF9icmVha19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSB7XG4gICAgICAgIGhlYWQucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2FjaGUubGVuZ3RoID0gX2dldChfZ2V0UHJvdG90eXBlT2YoQmxvY2sucHJvdG90eXBlKSwgXCJsZW5ndGhcIiwgdGhpcykuY2FsbCh0aGlzKSArIE5FV0xJTkVfTEVOR1RIO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jYWNoZS5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVDaGlsZHJlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlQ2hpbGRyZW4odGFyZ2V0LCByZWYpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksIFwibW92ZUNoaWxkcmVuXCIsIHRoaXMpLmNhbGwodGhpcywgdGFyZ2V0LCByZWYpO1xuXG4gICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9wdGltaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKGNvbnRleHQpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEJsb2NrLnByb3RvdHlwZSksIFwib3B0aW1pemVcIiwgdGhpcykuY2FsbCh0aGlzLCBjb250ZXh0KTtcblxuICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGgoaW5kZXgpIHtcbiAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCBcInBhdGhcIiwgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUNoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCBcInJlbW92ZUNoaWxkXCIsIHRoaXMpLmNhbGwodGhpcywgY2hpbGQpO1xuXG4gICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNwbGl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0KGluZGV4KSB7XG4gICAgICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoZm9yY2UgJiYgKGluZGV4ID09PSAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKCkgLSBORVdMSU5FX0xFTkdUSCkpIHtcbiAgICAgICAgdmFyIGNsb25lID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShjbG9uZSwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dCk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHQgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihCbG9jay5wcm90b3R5cGUpLCBcInNwbGl0XCIsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIGZvcmNlKTtcblxuICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJsb2NrO1xufShwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkJsb2NrQmxvdFwiXSk7XG5cbkJsb2NrLmJsb3ROYW1lID0gJ2Jsb2NrJztcbkJsb2NrLnRhZ05hbWUgPSAnUCc7XG5CbG9jay5kZWZhdWx0Q2hpbGQgPSBfYnJlYWtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXTtcbkJsb2NrLmFsbG93ZWRDaGlsZHJlbiA9IFtfYnJlYWtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXSwgX2lubGluZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLCBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVtYmVkQmxvdFwiXSwgX3RleHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXV07XG5cbnZhciBCbG9ja0VtYmVkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRW1iZWRCbG90KSB7XG4gIF9pbmhlcml0cyhCbG9ja0VtYmVkLCBfRW1iZWRCbG90KTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihCbG9ja0VtYmVkKTtcblxuICBmdW5jdGlvbiBCbG9ja0VtYmVkKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCbG9ja0VtYmVkKTtcblxuICAgIHJldHVybiBfc3VwZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmxvY2tFbWJlZCwgW3tcbiAgICBrZXk6IFwiYXR0YWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEJsb2NrRW1iZWQucHJvdG90eXBlKSwgXCJhdHRhY2hcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gbmV3IHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQXR0cmlidXRvclN0b3JlXCJdKHRoaXMuZG9tTm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbHRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbHRhKCkge1xuICAgICAgcmV0dXJuIG5ldyBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSgpLmluc2VydCh0aGlzLnZhbHVlKCksIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5mb3JtYXRzKCkpLCB0aGlzLmF0dHJpYnV0ZXMudmFsdWVzKCkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuc2Nyb2xsLnF1ZXJ5KG5hbWUsIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU2NvcGVcIl0uQkxPQ0tfQVRUUklCVVRFKTtcblxuICAgICAgaWYgKGF0dHJpYnV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5hdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnXFxuJykpIHtcbiAgICAgICAgdmFyIGJsb2NrID0gdGhpcy5zY3JvbGwuY3JlYXRlKEJsb2NrLmJsb3ROYW1lKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJsb2NrLCBpbmRleCA9PT0gMCA/IHRoaXMgOiB0aGlzLm5leHQpO1xuICAgICAgICBibG9jay5pbnNlcnRBdCgwLCB2YWx1ZS5zbGljZSgwLCAtMSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQmxvY2tFbWJlZC5wcm90b3R5cGUpLCBcImluc2VydEF0XCIsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIHZhbHVlLCBkZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCbG9ja0VtYmVkO1xufShwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkVtYmVkQmxvdFwiXSk7XG5cbkJsb2NrRW1iZWQuc2NvcGUgPSBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlNjb3BlXCJdLkJMT0NLX0JMT1Q7IC8vIEl0IGlzIGltcG9ydGFudCBmb3IgY3Vyc29yIGJlaGF2aW9yIEJsb2NrRW1iZWRzIHVzZSB0YWdzIHRoYXQgYXJlIGJsb2NrIGxldmVsIGVsZW1lbnRzXG5cbmZ1bmN0aW9uIGJsb2NrRGVsdGEoYmxvdCkge1xuICB2YXIgZmlsdGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICByZXR1cm4gYmxvdC5kZXNjZW5kYW50cyhwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkxlYWZCbG90XCJdKS5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBsZWFmKSB7XG4gICAgaWYgKGxlYWYubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVsdGEuaW5zZXJ0KGxlYWYudmFsdWUoKSwgYnViYmxlRm9ybWF0cyhsZWFmLCB7fSwgZmlsdGVyKSk7XG4gIH0sIG5ldyBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSgpKS5pbnNlcnQoJ1xcbicsIGJ1YmJsZUZvcm1hdHMoYmxvdCkpO1xufVxuXG5mdW5jdGlvbiBidWJibGVGb3JtYXRzKGJsb3QpIHtcbiAgdmFyIGZvcm1hdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgZmlsdGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICBpZiAoYmxvdCA9PSBudWxsKSByZXR1cm4gZm9ybWF0cztcblxuICBpZiAodHlwZW9mIGJsb3QuZm9ybWF0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvcm1hdHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGZvcm1hdHMpLCBibG90LmZvcm1hdHMoKSk7XG5cbiAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAvLyBleGNsdWRlIHN5bnRheCBoaWdobGlnaHRpbmcgZnJvbSBkZWx0YXMgYW5kIGdldEZvcm1hdCgpXG4gICAgICBkZWxldGUgZm9ybWF0c1snY29kZS10b2tlbiddO1xuICAgIH1cbiAgfVxuXG4gIGlmIChibG90LnBhcmVudCA9PSBudWxsIHx8IGJsb3QucGFyZW50LnN0YXRpY3MuYmxvdE5hbWUgPT09ICdzY3JvbGwnIHx8IGJsb3QucGFyZW50LnN0YXRpY3Muc2NvcGUgIT09IGJsb3Quc3RhdGljcy5zY29wZSkge1xuICAgIHJldHVybiBmb3JtYXRzO1xuICB9XG5cbiAgcmV0dXJuIGJ1YmJsZUZvcm1hdHMoYmxvdC5wYXJlbnQsIGZvcm1hdHMsIGZpbHRlcik7XG59XG5cblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFJhbmdlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU2VsZWN0aW9uOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2Nsb25lZGVlcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2Nsb25lZGVlcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGxvZGFzaF9jbG9uZWRlZXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2lzZXF1YWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGxvZGFzaF9pc2VxdWFsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX2lzZXF1YWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXG5cblxuXG5cbnZhciBkZWJ1ZyA9IE9iamVjdChfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0pKCdxdWlsbDpzZWxlY3Rpb24nKTtcblxudmFyIFJhbmdlID0gZnVuY3Rpb24gUmFuZ2UoaW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFuZ2UpO1xuXG4gIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG59O1xuXG52YXIgU2VsZWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2VsZWN0aW9uKHNjcm9sbCwgZW1pdHRlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0aW9uKTtcblxuICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgdGhpcy5zY3JvbGwgPSBzY3JvbGw7XG4gICAgdGhpcy5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuc2Nyb2xsLmRvbU5vZGU7XG4gICAgdGhpcy5jdXJzb3IgPSB0aGlzLnNjcm9sbC5jcmVhdGUoJ2N1cnNvcicsIHRoaXMpOyAvLyBzYXZlZFJhbmdlIGlzIGxhc3Qgbm9uLW51bGwgcmFuZ2VcblxuICAgIHRoaXMuc2F2ZWRSYW5nZSA9IG5ldyBSYW5nZSgwLCAwKTtcbiAgICB0aGlzLmxhc3RSYW5nZSA9IHRoaXMuc2F2ZWRSYW5nZTtcbiAgICB0aGlzLmxhc3ROYXRpdmUgPSBudWxsO1xuICAgIHRoaXMuaGFuZGxlQ29tcG9zaXRpb24oKTtcbiAgICB0aGlzLmhhbmRsZURyYWdnaW5nKCk7XG4gICAgdGhpcy5lbWl0dGVyLmxpc3RlbkRPTSgnc2VsZWN0aW9uY2hhbmdlJywgZG9jdW1lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMubW91c2VEb3duICYmICFfdGhpcy5jb21wb3NpbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChfdGhpcy51cGRhdGUuYmluZChfdGhpcywgX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zb3VyY2VzLlVTRVIpLCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVtaXR0ZXIub24oX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ldmVudHMuU0NST0xMX0JFRk9SRV9VUERBVEUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMuaGFzRm9jdXMoKSkgcmV0dXJuO1xuXG4gICAgICB2YXIgbmF0aXZlID0gX3RoaXMuZ2V0TmF0aXZlUmFuZ2UoKTtcblxuICAgICAgaWYgKG5hdGl2ZSA9PSBudWxsKSByZXR1cm47XG4gICAgICBpZiAobmF0aXZlLnN0YXJ0Lm5vZGUgPT09IF90aGlzLmN1cnNvci50ZXh0Tm9kZSkgcmV0dXJuOyAvLyBjdXJzb3IucmVzdG9yZSgpIHdpbGwgaGFuZGxlXG5cbiAgICAgIF90aGlzLmVtaXR0ZXIub25jZShfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmV2ZW50cy5TQ1JPTExfVVBEQVRFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKF90aGlzLnJvb3QuY29udGFpbnMobmF0aXZlLnN0YXJ0Lm5vZGUpICYmIF90aGlzLnJvb3QuY29udGFpbnMobmF0aXZlLmVuZC5ub2RlKSkge1xuICAgICAgICAgICAgX3RoaXMuc2V0TmF0aXZlUmFuZ2UobmF0aXZlLnN0YXJ0Lm5vZGUsIG5hdGl2ZS5zdGFydC5vZmZzZXQsIG5hdGl2ZS5lbmQubm9kZSwgbmF0aXZlLmVuZC5vZmZzZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLnVwZGF0ZShfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkgey8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmVtaXR0ZXIub24oX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ldmVudHMuU0NST0xMX09QVElNSVpFLCBmdW5jdGlvbiAobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgICBpZiAoY29udGV4dC5yYW5nZSkge1xuICAgICAgICB2YXIgX2NvbnRleHQkcmFuZ2UgPSBjb250ZXh0LnJhbmdlLFxuICAgICAgICAgICAgc3RhcnROb2RlID0gX2NvbnRleHQkcmFuZ2Uuc3RhcnROb2RlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBfY29udGV4dCRyYW5nZS5zdGFydE9mZnNldCxcbiAgICAgICAgICAgIGVuZE5vZGUgPSBfY29udGV4dCRyYW5nZS5lbmROb2RlLFxuICAgICAgICAgICAgZW5kT2Zmc2V0ID0gX2NvbnRleHQkcmFuZ2UuZW5kT2Zmc2V0O1xuXG4gICAgICAgIF90aGlzLnNldE5hdGl2ZVJhbmdlKHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQsIGVuZE5vZGUsIGVuZE9mZnNldCk7XG5cbiAgICAgICAgX3RoaXMudXBkYXRlKF9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc291cmNlcy5TSUxFTlQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlKF9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc291cmNlcy5TSUxFTlQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNlbGVjdGlvbiwgW3tcbiAgICBrZXk6IFwiaGFuZGxlQ29tcG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ29tcG9zaXRpb24oKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5jb21wb3NpbmcgPSB0cnVlO1xuXG4gICAgICAgIF90aGlzMi5zY3JvbGwuYmF0Y2hTdGFydCgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zY3JvbGwuYmF0Y2hFbmQoKTtcblxuICAgICAgICBfdGhpczIuY29tcG9zaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKF90aGlzMi5jdXJzb3IucGFyZW50KSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gX3RoaXMyLmN1cnNvci5yZXN0b3JlKCk7XG5cbiAgICAgICAgICBpZiAoIXJhbmdlKSByZXR1cm47XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuc2V0TmF0aXZlUmFuZ2UocmFuZ2Uuc3RhcnROb2RlLCByYW5nZS5zdGFydE9mZnNldCwgcmFuZ2UuZW5kTm9kZSwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZURyYWdnaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZURyYWdnaW5nKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZW1pdHRlci5saXN0ZW5ET00oJ21vdXNlZG93bicsIGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLm1vdXNlRG93biA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdHRlci5saXN0ZW5ET00oJ21vdXNldXAnLCBkb2N1bWVudC5ib2R5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5tb3VzZURvd24gPSBmYWxzZTtcblxuICAgICAgICBfdGhpczMudXBkYXRlKF9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc291cmNlcy5VU0VSKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgIGlmICh0aGlzLmhhc0ZvY3VzKCkpIHJldHVybjtcbiAgICAgIHRoaXMucm9vdC5mb2N1cygpO1xuICAgICAgdGhpcy5zZXRSYW5nZSh0aGlzLnNhdmVkUmFuZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KF9mb3JtYXQsIHZhbHVlKSB7XG4gICAgICB0aGlzLnNjcm9sbC51cGRhdGUoKTtcbiAgICAgIHZhciBuYXRpdmVSYW5nZSA9IHRoaXMuZ2V0TmF0aXZlUmFuZ2UoKTtcbiAgICAgIGlmIChuYXRpdmVSYW5nZSA9PSBudWxsIHx8ICFuYXRpdmVSYW5nZS5uYXRpdmUuY29sbGFwc2VkIHx8IHRoaXMuc2Nyb2xsLnF1ZXJ5KF9mb3JtYXQsIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiU2NvcGVcIl0uQkxPQ0spKSByZXR1cm47XG5cbiAgICAgIGlmIChuYXRpdmVSYW5nZS5zdGFydC5ub2RlICE9PSB0aGlzLmN1cnNvci50ZXh0Tm9kZSkge1xuICAgICAgICB2YXIgYmxvdCA9IHRoaXMuc2Nyb2xsLmZpbmQobmF0aXZlUmFuZ2Uuc3RhcnQubm9kZSwgZmFsc2UpO1xuICAgICAgICBpZiAoYmxvdCA9PSBudWxsKSByZXR1cm47IC8vIFRPRE8gR2l2ZSBibG90IGFiaWxpdHkgdG8gbm90IHNwbGl0XG5cbiAgICAgICAgaWYgKGJsb3QgaW5zdGFuY2VvZiBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkxlYWZCbG90XCJdKSB7XG4gICAgICAgICAgdmFyIGFmdGVyID0gYmxvdC5zcGxpdChuYXRpdmVSYW5nZS5zdGFydC5vZmZzZXQpO1xuICAgICAgICAgIGJsb3QucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmN1cnNvciwgYWZ0ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsb3QuaW5zZXJ0QmVmb3JlKHRoaXMuY3Vyc29yLCBuYXRpdmVSYW5nZS5zdGFydC5ub2RlKTsgLy8gU2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJzb3IuYXR0YWNoKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3Vyc29yLmZvcm1hdChfZm9ybWF0LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNjcm9sbC5vcHRpbWl6ZSgpO1xuICAgICAgdGhpcy5zZXROYXRpdmVSYW5nZSh0aGlzLmN1cnNvci50ZXh0Tm9kZSwgdGhpcy5jdXJzb3IudGV4dE5vZGUuZGF0YS5sZW5ndGgpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm91bmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kcyhpbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIHZhciBzY3JvbGxMZW5ndGggPSB0aGlzLnNjcm9sbC5sZW5ndGgoKTtcbiAgICAgIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHNjcm9sbExlbmd0aCAtIDEpO1xuICAgICAgbGVuZ3RoID0gTWF0aC5taW4oaW5kZXggKyBsZW5ndGgsIHNjcm9sbExlbmd0aCAtIDEpIC0gaW5kZXg7XG4gICAgICB2YXIgbm9kZTtcblxuICAgICAgdmFyIF90aGlzJHNjcm9sbCRsZWFmID0gdGhpcy5zY3JvbGwubGVhZihpbmRleCksXG4gICAgICAgICAgX3RoaXMkc2Nyb2xsJGxlYWYyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkc2Nyb2xsJGxlYWYsIDIpLFxuICAgICAgICAgIGxlYWYgPSBfdGhpcyRzY3JvbGwkbGVhZjJbMF0sXG4gICAgICAgICAgb2Zmc2V0ID0gX3RoaXMkc2Nyb2xsJGxlYWYyWzFdO1xuXG4gICAgICBpZiAobGVhZiA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIF9sZWFmJHBvc2l0aW9uID0gbGVhZi5wb3NpdGlvbihvZmZzZXQsIHRydWUpO1xuXG4gICAgICB2YXIgX2xlYWYkcG9zaXRpb24yID0gX3NsaWNlZFRvQXJyYXkoX2xlYWYkcG9zaXRpb24sIDIpO1xuXG4gICAgICBub2RlID0gX2xlYWYkcG9zaXRpb24yWzBdO1xuICAgICAgb2Zmc2V0ID0gX2xlYWYkcG9zaXRpb24yWzFdO1xuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcblxuICAgICAgICB2YXIgX3RoaXMkc2Nyb2xsJGxlYWYzID0gdGhpcy5zY3JvbGwubGVhZihpbmRleCArIGxlbmd0aCk7XG5cbiAgICAgICAgdmFyIF90aGlzJHNjcm9sbCRsZWFmNCA9IF9zbGljZWRUb0FycmF5KF90aGlzJHNjcm9sbCRsZWFmMywgMik7XG5cbiAgICAgICAgbGVhZiA9IF90aGlzJHNjcm9sbCRsZWFmNFswXTtcbiAgICAgICAgb2Zmc2V0ID0gX3RoaXMkc2Nyb2xsJGxlYWY0WzFdO1xuICAgICAgICBpZiAobGVhZiA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgX2xlYWYkcG9zaXRpb24zID0gbGVhZi5wb3NpdGlvbihvZmZzZXQsIHRydWUpO1xuXG4gICAgICAgIHZhciBfbGVhZiRwb3NpdGlvbjQgPSBfc2xpY2VkVG9BcnJheShfbGVhZiRwb3NpdGlvbjMsIDIpO1xuXG4gICAgICAgIG5vZGUgPSBfbGVhZiRwb3NpdGlvbjRbMF07XG4gICAgICAgIG9mZnNldCA9IF9sZWFmJHBvc2l0aW9uNFsxXTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpZGUgPSAnbGVmdCc7XG4gICAgICB2YXIgcmVjdDtcblxuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCBub2RlLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0IC0gMSk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgc2lkZSA9ICdyaWdodCc7XG4gICAgICAgIH1cblxuICAgICAgICByZWN0ID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWN0ID0gbGVhZi5kb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAob2Zmc2V0ID4gMCkgc2lkZSA9ICdyaWdodCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJvdHRvbTogcmVjdC50b3AgKyByZWN0LmhlaWdodCxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgbGVmdDogcmVjdFtzaWRlXSxcbiAgICAgICAgcmlnaHQ6IHJlY3Rbc2lkZV0sXG4gICAgICAgIHRvcDogcmVjdC50b3AsXG4gICAgICAgIHdpZHRoOiAwXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXROYXRpdmVSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYXRpdmVSYW5nZSgpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChzZWxlY3Rpb24gPT0gbnVsbCB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA8PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBuYXRpdmVSYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgaWYgKG5hdGl2ZVJhbmdlID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5ub3JtYWxpemVOYXRpdmUobmF0aXZlUmFuZ2UpO1xuICAgICAgZGVidWcuaW5mbygnZ2V0TmF0aXZlUmFuZ2UnLCByYW5nZSk7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlKCkge1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSB0aGlzLmdldE5hdGl2ZVJhbmdlKCk7XG4gICAgICBpZiAobm9ybWFsaXplZCA9PSBudWxsKSByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5ub3JtYWxpemVkVG9SYW5nZShub3JtYWxpemVkKTtcbiAgICAgIHJldHVybiBbcmFuZ2UsIG5vcm1hbGl6ZWRdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNGb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNGb2N1cygpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLnJvb3QgfHwgY29udGFpbnModGhpcy5yb290LCBkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9ybWFsaXplZFRvUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplZFRvUmFuZ2UocmFuZ2UpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgcG9zaXRpb25zID0gW1tyYW5nZS5zdGFydC5ub2RlLCByYW5nZS5zdGFydC5vZmZzZXRdXTtcblxuICAgICAgaWYgKCFyYW5nZS5uYXRpdmUuY29sbGFwc2VkKSB7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKFtyYW5nZS5lbmQubm9kZSwgcmFuZ2UuZW5kLm9mZnNldF0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXhlcyA9IHBvc2l0aW9ucy5tYXAoZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfcG9zaXRpb24gPSBfc2xpY2VkVG9BcnJheShwb3NpdGlvbiwgMiksXG4gICAgICAgICAgICBub2RlID0gX3Bvc2l0aW9uWzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3Bvc2l0aW9uWzFdO1xuXG4gICAgICAgIHZhciBibG90ID0gX3RoaXM0LnNjcm9sbC5maW5kKG5vZGUsIHRydWUpO1xuXG4gICAgICAgIHZhciBpbmRleCA9IGJsb3Qub2Zmc2V0KF90aGlzNC5zY3JvbGwpO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmxvdCBpbnN0YW5jZW9mIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiTGVhZkJsb3RcIl0pIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXggKyBibG90LmluZGV4KG5vZGUsIG9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXggKyBibG90Lmxlbmd0aCgpO1xuICAgICAgfSk7XG4gICAgICB2YXIgZW5kID0gTWF0aC5taW4oTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KGluZGV4ZXMpKSwgdGhpcy5zY3JvbGwubGVuZ3RoKCkgLSAxKTtcbiAgICAgIHZhciBzdGFydCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIFtlbmRdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoaW5kZXhlcykpKTtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9ybWFsaXplTmF0aXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZU5hdGl2ZShuYXRpdmVSYW5nZSkge1xuICAgICAgaWYgKCFjb250YWlucyh0aGlzLnJvb3QsIG5hdGl2ZVJhbmdlLnN0YXJ0Q29udGFpbmVyKSB8fCAhbmF0aXZlUmFuZ2UuY29sbGFwc2VkICYmICFjb250YWlucyh0aGlzLnJvb3QsIG5hdGl2ZVJhbmdlLmVuZENvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZSA9IHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICBub2RlOiBuYXRpdmVSYW5nZS5zdGFydENvbnRhaW5lcixcbiAgICAgICAgICBvZmZzZXQ6IG5hdGl2ZVJhbmdlLnN0YXJ0T2Zmc2V0XG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgIG5vZGU6IG5hdGl2ZVJhbmdlLmVuZENvbnRhaW5lcixcbiAgICAgICAgICBvZmZzZXQ6IG5hdGl2ZVJhbmdlLmVuZE9mZnNldFxuICAgICAgICB9LFxuICAgICAgICBuYXRpdmU6IG5hdGl2ZVJhbmdlXG4gICAgICB9O1xuICAgICAgW3JhbmdlLnN0YXJ0LCByYW5nZS5lbmRdLmZvckVhY2goZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBub2RlID0gcG9zaXRpb24ubm9kZSxcbiAgICAgICAgICAgIG9mZnNldCA9IHBvc2l0aW9uLm9mZnNldDtcblxuICAgICAgICB3aGlsZSAoIShub2RlIGluc3RhbmNlb2YgVGV4dCkgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IG9mZnNldCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT09IG9mZnNldCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuXG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZS5kYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gQ29udGFpbmVyIGNhc2VcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEVtYmVkIGNhc2VcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvc2l0aW9uLm5vZGUgPSBub2RlO1xuICAgICAgICBwb3NpdGlvbi5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZ2VUb05hdGl2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYW5nZVRvTmF0aXZlKHJhbmdlKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGluZGV4ZXMgPSByYW5nZS5jb2xsYXBzZWQgPyBbcmFuZ2UuaW5kZXhdIDogW3JhbmdlLmluZGV4LCByYW5nZS5pbmRleCArIHJhbmdlLmxlbmd0aF07XG4gICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgdmFyIHNjcm9sbExlbmd0aCA9IHRoaXMuc2Nyb2xsLmxlbmd0aCgpO1xuICAgICAgaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCwgaSkge1xuICAgICAgICBpbmRleCA9IE1hdGgubWluKHNjcm9sbExlbmd0aCAtIDEsIGluZGV4KTtcblxuICAgICAgICB2YXIgX3RoaXM1JHNjcm9sbCRsZWFmID0gX3RoaXM1LnNjcm9sbC5sZWFmKGluZGV4KSxcbiAgICAgICAgICAgIF90aGlzNSRzY3JvbGwkbGVhZjIgPSBfc2xpY2VkVG9BcnJheShfdGhpczUkc2Nyb2xsJGxlYWYsIDIpLFxuICAgICAgICAgICAgbGVhZiA9IF90aGlzNSRzY3JvbGwkbGVhZjJbMF0sXG4gICAgICAgICAgICBsZWFmT2Zmc2V0ID0gX3RoaXM1JHNjcm9sbCRsZWFmMlsxXTtcblxuICAgICAgICB2YXIgX2xlYWYkcG9zaXRpb241ID0gbGVhZi5wb3NpdGlvbihsZWFmT2Zmc2V0LCBpICE9PSAwKSxcbiAgICAgICAgICAgIF9sZWFmJHBvc2l0aW9uNiA9IF9zbGljZWRUb0FycmF5KF9sZWFmJHBvc2l0aW9uNSwgMiksXG4gICAgICAgICAgICBub2RlID0gX2xlYWYkcG9zaXRpb242WzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX2xlYWYkcG9zaXRpb242WzFdO1xuXG4gICAgICAgIGFyZ3MucHVzaChub2RlLCBvZmZzZXQpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3MuY29uY2F0KGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2Nyb2xsSW50b1ZpZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoc2Nyb2xsaW5nQ29udGFpbmVyKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmxhc3RSYW5nZTtcbiAgICAgIGlmIChyYW5nZSA9PSBudWxsKSByZXR1cm47XG4gICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMocmFuZ2UuaW5kZXgsIHJhbmdlLmxlbmd0aCk7XG4gICAgICBpZiAoYm91bmRzID09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciBsaW1pdCA9IHRoaXMuc2Nyb2xsLmxlbmd0aCgpIC0gMTtcblxuICAgICAgdmFyIF90aGlzJHNjcm9sbCRsaW5lID0gdGhpcy5zY3JvbGwubGluZShNYXRoLm1pbihyYW5nZS5pbmRleCwgbGltaXQpKSxcbiAgICAgICAgICBfdGhpcyRzY3JvbGwkbGluZTIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRzY3JvbGwkbGluZSwgMSksXG4gICAgICAgICAgZmlyc3QgPSBfdGhpcyRzY3JvbGwkbGluZTJbMF07XG5cbiAgICAgIHZhciBsYXN0ID0gZmlyc3Q7XG5cbiAgICAgIGlmIChyYW5nZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBfdGhpcyRzY3JvbGwkbGluZTMgPSB0aGlzLnNjcm9sbC5saW5lKE1hdGgubWluKHJhbmdlLmluZGV4ICsgcmFuZ2UubGVuZ3RoLCBsaW1pdCkpO1xuXG4gICAgICAgIHZhciBfdGhpcyRzY3JvbGwkbGluZTQgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRzY3JvbGwkbGluZTMsIDEpO1xuXG4gICAgICAgIGxhc3QgPSBfdGhpcyRzY3JvbGwkbGluZTRbMF07XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdCA9PSBudWxsIHx8IGxhc3QgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIHNjcm9sbEJvdW5kcyA9IHNjcm9sbGluZ0NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKGJvdW5kcy50b3AgPCBzY3JvbGxCb3VuZHMudG9wKSB7XG4gICAgICAgIHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3AgLT0gc2Nyb2xsQm91bmRzLnRvcCAtIGJvdW5kcy50b3A7XG4gICAgICB9IGVsc2UgaWYgKGJvdW5kcy5ib3R0b20gPiBzY3JvbGxCb3VuZHMuYm90dG9tKSB7XG4gICAgICAgIHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3AgKz0gYm91bmRzLmJvdHRvbSAtIHNjcm9sbEJvdW5kcy5ib3R0b207XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE5hdGl2ZVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE5hdGl2ZVJhbmdlKHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpIHtcbiAgICAgIHZhciBlbmROb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBzdGFydE5vZGU7XG4gICAgICB2YXIgZW5kT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBzdGFydE9mZnNldDtcbiAgICAgIHZhciBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG4gICAgICBkZWJ1Zy5pbmZvKCdzZXROYXRpdmVSYW5nZScsIHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQsIGVuZE5vZGUsIGVuZE9mZnNldCk7XG5cbiAgICAgIGlmIChzdGFydE5vZGUgIT0gbnVsbCAmJiAodGhpcy5yb290LnBhcmVudE5vZGUgPT0gbnVsbCB8fCBzdGFydE5vZGUucGFyZW50Tm9kZSA9PSBudWxsIHx8IGVuZE5vZGUucGFyZW50Tm9kZSA9PSBudWxsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICBpZiAoc3RhcnROb2RlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHRoaXMucm9vdC5mb2N1cygpO1xuXG4gICAgICAgIHZhciBfcmVmID0gdGhpcy5nZXROYXRpdmVSYW5nZSgpIHx8IHt9LFxuICAgICAgICAgICAgbmF0aXZlID0gX3JlZi5uYXRpdmU7XG5cbiAgICAgICAgaWYgKG5hdGl2ZSA9PSBudWxsIHx8IGZvcmNlIHx8IHN0YXJ0Tm9kZSAhPT0gbmF0aXZlLnN0YXJ0Q29udGFpbmVyIHx8IHN0YXJ0T2Zmc2V0ICE9PSBuYXRpdmUuc3RhcnRPZmZzZXQgfHwgZW5kTm9kZSAhPT0gbmF0aXZlLmVuZENvbnRhaW5lciB8fCBlbmRPZmZzZXQgIT09IG5hdGl2ZS5lbmRPZmZzZXQpIHtcbiAgICAgICAgICBpZiAoc3RhcnROb2RlLnRhZ05hbWUgPT09ICdCUicpIHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gQXJyYXkuZnJvbShzdGFydE5vZGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzKS5pbmRleE9mKHN0YXJ0Tm9kZSk7XG4gICAgICAgICAgICBzdGFydE5vZGUgPSBzdGFydE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZW5kTm9kZS50YWdOYW1lID09PSAnQlInKSB7XG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBBcnJheS5mcm9tKGVuZE5vZGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzKS5pbmRleE9mKGVuZE5vZGUpO1xuICAgICAgICAgICAgZW5kTm9kZSA9IGVuZE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgIHJhbmdlLnNldEVuZChlbmROb2RlLCBlbmRPZmZzZXQpO1xuICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHRoaXMucm9vdC5ibHVyKCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTsgLy8gcm9vdC5ibHVyKCkgbm90IGVub3VnaCBmb3IgSUUxMVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSYW5nZShyYW5nZSkge1xuICAgICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IF9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc291cmNlcy5BUEk7XG5cbiAgICAgIGlmICh0eXBlb2YgZm9yY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNvdXJjZSA9IGZvcmNlO1xuICAgICAgICBmb3JjZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBkZWJ1Zy5pbmZvKCdzZXRSYW5nZScsIHJhbmdlKTtcblxuICAgICAgaWYgKHJhbmdlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnJhbmdlVG9OYXRpdmUocmFuZ2UpO1xuICAgICAgICB0aGlzLnNldE5hdGl2ZVJhbmdlLmFwcGx5KHRoaXMsIF90b0NvbnN1bWFibGVBcnJheShhcmdzKS5jb25jYXQoW2ZvcmNlXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXROYXRpdmVSYW5nZShudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGUoc291cmNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc291cmNlcy5VU0VSO1xuICAgICAgdmFyIG9sZFJhbmdlID0gdGhpcy5sYXN0UmFuZ2U7XG5cbiAgICAgIHZhciBfdGhpcyRnZXRSYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKSxcbiAgICAgICAgICBfdGhpcyRnZXRSYW5nZTIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRnZXRSYW5nZSwgMiksXG4gICAgICAgICAgbGFzdFJhbmdlID0gX3RoaXMkZ2V0UmFuZ2UyWzBdLFxuICAgICAgICAgIG5hdGl2ZVJhbmdlID0gX3RoaXMkZ2V0UmFuZ2UyWzFdO1xuXG4gICAgICB0aGlzLmxhc3RSYW5nZSA9IGxhc3RSYW5nZTtcbiAgICAgIHRoaXMubGFzdE5hdGl2ZSA9IG5hdGl2ZVJhbmdlO1xuXG4gICAgICBpZiAodGhpcy5sYXN0UmFuZ2UgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNhdmVkUmFuZ2UgPSB0aGlzLmxhc3RSYW5nZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFsb2Rhc2hfaXNlcXVhbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQoKShvbGRSYW5nZSwgdGhpcy5sYXN0UmFuZ2UpKSB7XG4gICAgICAgIHZhciBfdGhpcyRlbWl0dGVyO1xuXG4gICAgICAgIGlmICghdGhpcy5jb21wb3NpbmcgJiYgbmF0aXZlUmFuZ2UgIT0gbnVsbCAmJiBuYXRpdmVSYW5nZS5uYXRpdmUuY29sbGFwc2VkICYmIG5hdGl2ZVJhbmdlLnN0YXJ0Lm5vZGUgIT09IHRoaXMuY3Vyc29yLnRleHROb2RlKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5jdXJzb3IucmVzdG9yZSgpO1xuXG4gICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnNldE5hdGl2ZVJhbmdlKHJhbmdlLnN0YXJ0Tm9kZSwgcmFuZ2Uuc3RhcnRPZmZzZXQsIHJhbmdlLmVuZE5vZGUsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ldmVudHMuU0VMRUNUSU9OX0NIQU5HRSwgbG9kYXNoX2Nsb25lZGVlcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQoKSh0aGlzLmxhc3RSYW5nZSksIGxvZGFzaF9jbG9uZWRlZXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0KCkob2xkUmFuZ2UpLCBzb3VyY2VdO1xuXG4gICAgICAgIChfdGhpcyRlbWl0dGVyID0gdGhpcy5lbWl0dGVyKS5lbWl0LmFwcGx5KF90aGlzJGVtaXR0ZXIsIFtfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmV2ZW50cy5FRElUT1JfQ0hBTkdFXS5jb25jYXQoYXJncykpO1xuXG4gICAgICAgIGlmIChzb3VyY2UgIT09IF9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc291cmNlcy5TSUxFTlQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkZW1pdHRlcjI7XG5cbiAgICAgICAgICAoX3RoaXMkZW1pdHRlcjIgPSB0aGlzLmVtaXR0ZXIpLmVtaXQuYXBwbHkoX3RoaXMkZW1pdHRlcjIsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNlbGVjdGlvbjtcbn0oKTtcblxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBkZXNjZW5kYW50KSB7XG4gIHRyeSB7XG4gICAgLy8gRmlyZWZveCBpbnNlcnRzIGluYWNjZXNzaWJsZSBub2RlcyBhcm91bmQgdmlkZW8gZWxlbWVudHNcbiAgICBkZXNjZW5kYW50LnBhcmVudE5vZGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSUUxMSBoYXMgYnVnIHdpdGggVGV4dCBub2Rlc1xuICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzc4MDg3NC9ub2RlLWNvbnRhaW5zLWlzLWluY29ycmVjdFxuXG5cbiAgaWYgKGRlc2NlbmRhbnQgaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgZGVzY2VuZGFudCA9IGRlc2NlbmRhbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnQuY29udGFpbnMoZGVzY2VuZGFudCk7XG59XG5cblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwialwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRhYmxlVGV4dEFsaWduU3R5bGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUYWJsZUJhY2tncm91bmRDb2xvclN0eWxlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVGFibGVCb3JkZXJTdHlsZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRhYmxlQm9yZGVyU3R5bGVTdHlsZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRhYmxlQm9yZGVyV2lkdGhTdHlsZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRhYmxlQm9yZGVyQ29sb3JTdHlsZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFRhYmxlSGVpZ2h0U3R5bGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUYWJsZVdpZHRoU3R5bGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImtcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUYWJsZVdpZHRoQXR0cmlidXRlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVGFibGVIZWlnaHRBdHRyaWJ1dGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUQUJMRV9GT1JNQVRTOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVEFCTEVfQVRUUklCVVRPUlM7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wcmVwYXJlX2F0dHJpYnV0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wcmVwYXJlX3N0eWxlX2F0dHJpYnV0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG5cbnZhciB0YWJsZUNvbmZpZyA9IHtcbiAgbmFtZTogJ3RhYmxlJyxcbiAgYWxsb3dlZFRhZ3M6IFsnVEFCTEUnXVxufTtcbnZhciBUYWJsZUhlaWdodEF0dHJpYnV0ZSA9IE9iamVjdChfcHJlcGFyZV9hdHRyaWJ1dG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKHRhYmxlQ29uZmlnLCAnaGVpZ2h0Jyk7XG52YXIgVGFibGVXaWR0aEF0dHJpYnV0ZSA9IE9iamVjdChfcHJlcGFyZV9hdHRyaWJ1dG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKHRhYmxlQ29uZmlnLCAnd2lkdGgnKTtcbnZhciBUYWJsZUhlaWdodFN0eWxlID0gT2JqZWN0KF9wcmVwYXJlX3N0eWxlX2F0dHJpYnV0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkodGFibGVDb25maWcsICdoZWlnaHQnKTtcbnZhciBUYWJsZVdpZHRoU3R5bGUgPSBPYmplY3QoX3ByZXBhcmVfc3R5bGVfYXR0cmlidXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSh0YWJsZUNvbmZpZywgJ3dpZHRoJyk7XG52YXIgVGFibGVUZXh0QWxpZ25TdHlsZSA9IE9iamVjdChfcHJlcGFyZV9zdHlsZV9hdHRyaWJ1dG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKHRhYmxlQ29uZmlnLCAndGV4dCcsICdhbGlnbicpO1xudmFyIFRhYmxlQmFja2dyb3VuZENvbG9yU3R5bGUgPSBPYmplY3QoX3ByZXBhcmVfc3R5bGVfYXR0cmlidXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSh0YWJsZUNvbmZpZywgJ2JhY2tncm91bmQnLCAnY29sb3InKTtcbnZhciBUYWJsZUJvcmRlclN0eWxlID0gT2JqZWN0KF9wcmVwYXJlX3N0eWxlX2F0dHJpYnV0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkodGFibGVDb25maWcsICdib3JkZXInKTtcbnZhciBUYWJsZUJvcmRlclN0eWxlU3R5bGUgPSBPYmplY3QoX3ByZXBhcmVfc3R5bGVfYXR0cmlidXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSh0YWJsZUNvbmZpZywgJ2JvcmRlcicsICdzdHlsZScpO1xudmFyIFRhYmxlQm9yZGVyV2lkdGhTdHlsZSA9IE9iamVjdChfcHJlcGFyZV9zdHlsZV9hdHRyaWJ1dG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKHRhYmxlQ29uZmlnLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG52YXIgVGFibGVCb3JkZXJDb2xvclN0eWxlID0gT2JqZWN0KF9wcmVwYXJlX3N0eWxlX2F0dHJpYnV0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkodGFibGVDb25maWcsICdib3JkZXInLCAnY29sb3InKTtcbnZhciBUQUJMRV9GT1JNQVRTID0ge1xuICB0YWJsZVRleHRBbGlnbjogVGFibGVUZXh0QWxpZ25TdHlsZSxcbiAgdGFibGVCYWNrZ3JvdW5kQ29sb3I6IFRhYmxlQmFja2dyb3VuZENvbG9yU3R5bGUsXG4gIHRhYmxlQm9yZGVyOiBUYWJsZUJvcmRlclN0eWxlLFxuICB0YWJsZUJvcmRlclN0eWxlOiBUYWJsZUJvcmRlclN0eWxlU3R5bGUsXG4gIHRhYmxlQm9yZGVyV2lkdGg6IFRhYmxlQm9yZGVyV2lkdGhTdHlsZSxcbiAgdGFibGVCb3JkZXJDb2xvcjogVGFibGVCb3JkZXJDb2xvclN0eWxlLFxuICB0YWJsZVdpZHRoOiBUYWJsZVdpZHRoU3R5bGUsXG4gIHRhYmxlSGVpZ2h0OiBUYWJsZUhlaWdodFN0eWxlXG59O1xudmFyIFRBQkxFX0FUVFJJQlVUT1JTID0gW1RhYmxlVGV4dEFsaWduU3R5bGUsIFRhYmxlQmFja2dyb3VuZENvbG9yU3R5bGUsIFRhYmxlQm9yZGVyU3R5bGUsIFRhYmxlQm9yZGVyU3R5bGVTdHlsZSwgVGFibGVCb3JkZXJDb2xvclN0eWxlLCBUYWJsZUJvcmRlcldpZHRoU3R5bGUsIFRhYmxlSGVpZ2h0U3R5bGUsIFRhYmxlV2lkdGhTdHlsZSwgVGFibGVXaWR0aEF0dHJpYnV0ZSwgVGFibGVIZWlnaHRBdHRyaWJ1dGVdLnJlZHVjZShmdW5jdGlvbiAobWVtbywgYXR0cikge1xuICBtZW1vW2F0dHIua2V5TmFtZV0gPSBhdHRyO1xuICByZXR1cm4gbWVtbztcbn0sIHt9KTtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENlbGxWZXJ0aWNhbEFsaWduU3R5bGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDZWxsVGV4dEFsaWduU3R5bGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDZWxsQmFja2dyb3VuZENvbG9yU3R5bGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDZWxsQm9yZGVyU3R5bGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDZWxsQm9yZGVyU3R5bGVTdHlsZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENlbGxCb3JkZXJXaWR0aFN0eWxlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ2VsbEJvcmRlckNvbG9yU3R5bGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDZWxsUGFkZGluZ1N0eWxlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJuXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ2VsbFBhZGRpbmdUb3BTdHlsZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwialwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENlbGxQYWRkaW5nQm90dG9tU3R5bGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImtcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDZWxsUGFkZGluZ0xlZnRTdHlsZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENlbGxQYWRkaW5nUmlnaHRTdHlsZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENlbGxIZWlnaHRTdHlsZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENlbGxXaWR0aFN0eWxlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ2VsbEhlaWdodEF0dHJpYnV0ZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENlbGxXaWR0aEF0dHJpYnV0ZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENFTExfRk9STUFUUzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENFTExfQVRUUklCVVRPUlM7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wcmVwYXJlX2F0dHJpYnV0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wcmVwYXJlX3N0eWxlX2F0dHJpYnV0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG5cbnZhciBjZWxsQ29uZmlnID0ge1xuICBuYW1lOiAnY2VsbCcsXG4gIGFsbG93ZWRUYWdzOiBbJ1RIJywgJ1REJ11cbn07XG52YXIgQ2VsbEhlaWdodEF0dHJpYnV0ZSA9IE9iamVjdChfcHJlcGFyZV9hdHRyaWJ1dG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKGNlbGxDb25maWcsICdoZWlnaHQnKTtcbnZhciBDZWxsV2lkdGhBdHRyaWJ1dGUgPSBPYmplY3QoX3ByZXBhcmVfYXR0cmlidXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKShjZWxsQ29uZmlnLCAnd2lkdGgnKTtcbnZhciBDZWxsSGVpZ2h0U3R5bGUgPSBPYmplY3QoX3ByZXBhcmVfc3R5bGVfYXR0cmlidXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKShjZWxsQ29uZmlnLCAnaGVpZ2h0Jyk7XG52YXIgQ2VsbFdpZHRoU3R5bGUgPSBPYmplY3QoX3ByZXBhcmVfc3R5bGVfYXR0cmlidXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKShjZWxsQ29uZmlnLCAnd2lkdGgnKTtcbnZhciBDZWxsVmVydGljYWxBbGlnblN0eWxlID0gT2JqZWN0KF9wcmVwYXJlX3N0eWxlX2F0dHJpYnV0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoY2VsbENvbmZpZywgJ3ZlcnRpY2FsJywgJ2FsaWduJyk7XG52YXIgQ2VsbFRleHRBbGlnblN0eWxlID0gT2JqZWN0KF9wcmVwYXJlX3N0eWxlX2F0dHJpYnV0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoY2VsbENvbmZpZywgJ3RleHQnLCAnYWxpZ24nKTtcbnZhciBDZWxsQmFja2dyb3VuZENvbG9yU3R5bGUgPSBPYmplY3QoX3ByZXBhcmVfc3R5bGVfYXR0cmlidXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKShjZWxsQ29uZmlnLCAnYmFja2dyb3VuZCcsICdjb2xvcicpO1xudmFyIENlbGxCb3JkZXJTdHlsZSA9IE9iamVjdChfcHJlcGFyZV9zdHlsZV9hdHRyaWJ1dG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKGNlbGxDb25maWcsICdib3JkZXInKTtcbnZhciBDZWxsQm9yZGVyU3R5bGVTdHlsZSA9IE9iamVjdChfcHJlcGFyZV9zdHlsZV9hdHRyaWJ1dG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKGNlbGxDb25maWcsICdib3JkZXInLCAnc3R5bGUnKTtcbnZhciBDZWxsQm9yZGVyV2lkdGhTdHlsZSA9IE9iamVjdChfcHJlcGFyZV9zdHlsZV9hdHRyaWJ1dG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKGNlbGxDb25maWcsICdib3JkZXInLCAnd2lkdGgnKTtcbnZhciBDZWxsQm9yZGVyQ29sb3JTdHlsZSA9IE9iamVjdChfcHJlcGFyZV9zdHlsZV9hdHRyaWJ1dG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKGNlbGxDb25maWcsICdib3JkZXInLCAnY29sb3InKTtcbnZhciBDZWxsUGFkZGluZ1N0eWxlID0gT2JqZWN0KF9wcmVwYXJlX3N0eWxlX2F0dHJpYnV0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoY2VsbENvbmZpZywgJ3BhZGRpbmcnKTtcbnZhciBDZWxsUGFkZGluZ1RvcFN0eWxlID0gT2JqZWN0KF9wcmVwYXJlX3N0eWxlX2F0dHJpYnV0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoY2VsbENvbmZpZywgJ3BhZGRpbmcnLCAndG9wJyk7XG52YXIgQ2VsbFBhZGRpbmdCb3R0b21TdHlsZSA9IE9iamVjdChfcHJlcGFyZV9zdHlsZV9hdHRyaWJ1dG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKGNlbGxDb25maWcsICdwYWRkaW5nJywgJ2JvdHRvbScpO1xudmFyIENlbGxQYWRkaW5nTGVmdFN0eWxlID0gT2JqZWN0KF9wcmVwYXJlX3N0eWxlX2F0dHJpYnV0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoY2VsbENvbmZpZywgJ3BhZGRpbmcnLCAnbGVmdCcpO1xudmFyIENlbGxQYWRkaW5nUmlnaHRTdHlsZSA9IE9iamVjdChfcHJlcGFyZV9zdHlsZV9hdHRyaWJ1dG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKGNlbGxDb25maWcsICdwYWRkaW5nJywgJ3JpZ2h0Jyk7XG52YXIgQ0VMTF9GT1JNQVRTID0ge1xuICBjZWxsQm9yZGVyOiBDZWxsQm9yZGVyU3R5bGUsXG4gIGNlbGxCb3JkZXJTdHlsZTogQ2VsbEJvcmRlclN0eWxlU3R5bGUsXG4gIGNlbGxCb3JkZXJXaWR0aDogQ2VsbEJvcmRlcldpZHRoU3R5bGUsXG4gIGNlbGxCb3JkZXJDb2xvcjogQ2VsbEJvcmRlckNvbG9yU3R5bGUsXG4gIGNlbGxCYWNrZ3JvdW5kQ29sb3I6IENlbGxCYWNrZ3JvdW5kQ29sb3JTdHlsZSxcbiAgY2VsbFBhZGRpbmc6IENlbGxQYWRkaW5nU3R5bGUsXG4gIGNlbGxQYWRkaW5nVG9wOiBDZWxsUGFkZGluZ1RvcFN0eWxlLFxuICBjZWxsUGFkZGluZ0JvdHRvbTogQ2VsbFBhZGRpbmdCb3R0b21TdHlsZSxcbiAgY2VsbFBhZGRpbmdMZWZ0OiBDZWxsUGFkZGluZ0xlZnRTdHlsZSxcbiAgY2VsbFBhZGRpbmdSaWdodDogQ2VsbFBhZGRpbmdSaWdodFN0eWxlLFxuICBjZWxsVmVydGljYWxBbGlnbjogQ2VsbFZlcnRpY2FsQWxpZ25TdHlsZSxcbiAgY2VsbFRleHRBbGlnbjogQ2VsbFRleHRBbGlnblN0eWxlLFxuICBjZWxsV2lkdGg6IENlbGxXaWR0aFN0eWxlLFxuICBjZWxsSGVpZ2h0OiBDZWxsSGVpZ2h0U3R5bGVcbn07XG52YXIgQ0VMTF9BVFRSSUJVVE9SUyA9IFtDZWxsQmFja2dyb3VuZENvbG9yU3R5bGUsIENlbGxCb3JkZXJDb2xvclN0eWxlLCBDZWxsQm9yZGVyU3R5bGUsIENlbGxCb3JkZXJTdHlsZVN0eWxlLCBDZWxsQm9yZGVyV2lkdGhTdHlsZSwgQ2VsbFBhZGRpbmdCb3R0b21TdHlsZSwgQ2VsbFBhZGRpbmdMZWZ0U3R5bGUsIENlbGxQYWRkaW5nUmlnaHRTdHlsZSwgQ2VsbFBhZGRpbmdTdHlsZSwgQ2VsbFBhZGRpbmdUb3BTdHlsZSwgQ2VsbFZlcnRpY2FsQWxpZ25TdHlsZSwgQ2VsbFRleHRBbGlnblN0eWxlLCBDZWxsSGVpZ2h0U3R5bGUsIENlbGxXaWR0aFN0eWxlLCBDZWxsV2lkdGhBdHRyaWJ1dGUsIENlbGxIZWlnaHRBdHRyaWJ1dGVdLnJlZHVjZShmdW5jdGlvbiAobWVtbywgYXR0cikge1xuICBtZW1vW2F0dHIua2V5TmFtZV0gPSBhdHRyO1xuICByZXR1cm4gbWVtbztcbn0sIHt9KTtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5tb2R1bGUuZXhwb3J0cyA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXyg1NCkpKVxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUZXh0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZXNjYXBlVGV4dDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG52YXIgVGV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RleHRCbG90KSB7XG4gIF9pbmhlcml0cyhUZXh0LCBfVGV4dEJsb3QpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVGV4dCk7XG5cbiAgZnVuY3Rpb24gVGV4dCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dCk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gVGV4dDtcbn0ocGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJUZXh0QmxvdFwiXSk7XG5cbmZ1bmN0aW9uIGVzY2FwZVRleHQodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bJjw+XCInXS9nLCBmdW5jdGlvbiAocykge1xuICAgIC8vIGh0dHBzOi8vbG9kYXNoLmNvbS9kb2NzI2VzY2FwZVxuICAgIHZhciBlbnRpdHlNYXAgPSB7XG4gICAgICAnJic6ICcmYW1wOycsXG4gICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICc+JzogJyZndDsnLFxuICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICBcIidcIjogJyYjMzk7J1xuICAgIH07XG4gICAgcmV0dXJuIGVudGl0eU1hcFtzXTtcbiAgfSk7XG59XG5cblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG52YXIgQnJlYWsgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbWJlZEJsb3QpIHtcbiAgX2luaGVyaXRzKEJyZWFrLCBfRW1iZWRCbG90KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEJyZWFrKTtcblxuICBmdW5jdGlvbiBCcmVhaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJlYWspO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJyZWFrLCBbe1xuICAgIGtleTogXCJvcHRpbWl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpbWl6ZSgpIHtcbiAgICAgIGlmICh0aGlzLnByZXYgfHwgdGhpcy5uZXh0KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCcmVhaztcbn0ocGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJFbWJlZEJsb3RcIl0pO1xuXG5CcmVhay5ibG90TmFtZSA9ICdicmVhayc7XG5CcmVhay50YWdOYW1lID0gJ0JSJztcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQnJlYWspO1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwcmVwYXJlU3R5bGVBdHRyaWJ1dG9yOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXR0cmlidXRvcnNfZWxlbWVudF9zdHlsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NhcGl0YWxpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xudmFyIF9leGNsdWRlZCA9IFtcIm5hbWVcIiwgXCJmb3JtYXROYW1lXCJdO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuZnVuY3Rpb24gcHJlcGFyZVN0eWxlQXR0cmlidXRvcihfcmVmLCBwcm9wTmFtZSkge1xuICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIGZvcm1hdE5hbWUgPSBfcmVmLmZvcm1hdE5hbWUsXG4gICAgICBlbGVtZW50Q29uZmlnID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG5cbiAgdmFyIHN1YlByb3BOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnJztcbiAgdmFyIGZ1bGxOYW1lID0gXCJcIi5jb25jYXQocHJvcE5hbWUpLmNvbmNhdChzdWJQcm9wTmFtZSA/IFwiLVwiLmNvbmNhdChzdWJQcm9wTmFtZSkgOiAnJyk7XG4gIHJldHVybiBuZXcgX2F0dHJpYnV0b3JzX2VsZW1lbnRfc3R5bGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXShcIlwiLmNvbmNhdChuYW1lKS5jb25jYXQoT2JqZWN0KF91dGlsc19jYXBpdGFsaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKGZvcm1hdE5hbWUgIT09IG51bGwgJiYgZm9ybWF0TmFtZSAhPT0gdm9pZCAwID8gZm9ybWF0TmFtZSA6IHByb3BOYW1lKSkuY29uY2F0KE9iamVjdChfdXRpbHNfY2FwaXRhbGl6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKShzdWJQcm9wTmFtZSkpLCBmdWxsTmFtZSwgZWxlbWVudENvbmZpZyk7XG59XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgTW9kdWxlID0gZnVuY3Rpb24gTW9kdWxlKHF1aWxsKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kdWxlKTtcblxuICB0aGlzLnF1aWxsID0gcXVpbGw7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG59O1xuXG5Nb2R1bGUuREVGQVVMVFMgPSB7fTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoTW9kdWxlKTtcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cbnZhciBDb250YWluZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db250YWluZXJCbG90KSB7XG4gIF9pbmhlcml0cyhDb250YWluZXIsIF9Db250YWluZXJCbG90KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENvbnRhaW5lcik7XG5cbiAgZnVuY3Rpb24gQ29udGFpbmVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250YWluZXIpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIENvbnRhaW5lcjtcbn0ocGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJDb250YWluZXJCbG90XCJdKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDb250YWluZXIpO1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYnJlYWtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90ZXh0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG5cblxudmFyIElubGluZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lubGluZUJsb3QpIHtcbiAgX2luaGVyaXRzKElubGluZSwgX0lubGluZUJsb3QpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSW5saW5lKTtcblxuICBmdW5jdGlvbiBJbmxpbmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElubGluZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW5saW5lLCBbe1xuICAgIGtleTogXCJmb3JtYXRBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKElubGluZS5jb21wYXJlKHRoaXMuc3RhdGljcy5ibG90TmFtZSwgbmFtZSkgPCAwICYmIHRoaXMuc2Nyb2xsLnF1ZXJ5KG5hbWUsIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiU2NvcGVcIl0uQkxPVCkpIHtcbiAgICAgICAgdmFyIGJsb3QgPSB0aGlzLmlzb2xhdGUoaW5kZXgsIGxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgYmxvdC53cmFwKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoSW5saW5lLnByb3RvdHlwZSksIFwiZm9ybWF0QXRcIiwgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9wdGltaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKGNvbnRleHQpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKElubGluZS5wcm90b3R5cGUpLCBcIm9wdGltaXplXCIsIHRoaXMpLmNhbGwodGhpcywgY29udGV4dCk7XG5cbiAgICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIElubGluZSAmJiBJbmxpbmUuY29tcGFyZSh0aGlzLnN0YXRpY3MuYmxvdE5hbWUsIHRoaXMucGFyZW50LnN0YXRpY3MuYmxvdE5hbWUpID4gMCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQuaXNvbGF0ZSh0aGlzLm9mZnNldCgpLCB0aGlzLmxlbmd0aCgpKTtcbiAgICAgICAgdGhpcy5tb3ZlQ2hpbGRyZW4ocGFyZW50KTtcbiAgICAgICAgcGFyZW50LndyYXAodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY29tcGFyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlKHNlbGYsIG90aGVyKSB7XG4gICAgICB2YXIgc2VsZkluZGV4ID0gSW5saW5lLm9yZGVyLmluZGV4T2Yoc2VsZik7XG4gICAgICB2YXIgb3RoZXJJbmRleCA9IElubGluZS5vcmRlci5pbmRleE9mKG90aGVyKTtcblxuICAgICAgaWYgKHNlbGZJbmRleCA+PSAwIHx8IG90aGVySW5kZXggPj0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZkluZGV4IC0gb3RoZXJJbmRleDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZiA8IG90aGVyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIElubGluZTtcbn0ocGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJJbmxpbmVCbG90XCJdKTtcblxuSW5saW5lLmFsbG93ZWRDaGlsZHJlbiA9IFtJbmxpbmUsIF9icmVha19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLCBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkVtYmVkQmxvdFwiXSwgX3RleHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXV07IC8vIExvd2VyIGluZGV4IG1lYW5zIGRlZXBlciBpbiB0aGUgRE9NIHRyZWUsIHNpbmNlIG5vdCBmb3VuZCAoLTEpIGlzIGZvciBlbWJlZHNcblxuSW5saW5lLm9yZGVyID0gWydjdXJzb3InLCAnaW5saW5lJywgLy8gTXVzdCBiZSBsb3dlclxuJ2xpbmsnLCAvLyBDaHJvbWUgd2FudHMgPGE+IHRvIGJlIGxvd2VyXG4ndW5kZXJsaW5lJywgJ3N0cmlrZScsICdpdGFsaWMnLCAnYm9sZCcsICdzY3JpcHQnLCAnY29kZScgLy8gTXVzdCBiZSBoaWdoZXJcbl07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKElubGluZSk7XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaGFzV2luZG93ID0gZnVuY3Rpb24gaGFzV2luZG93KCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGhhc1dpbmRvdyk7XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlKSB7LyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSAgdHJ1ZSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqXG4gKiBBZGRzIHRoZSBrZXktdmFsdWUgYHBhaXJgIHRvIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gcGFpciBUaGUga2V5LXZhbHVlIHBhaXIgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgbWFwYC5cbiAqL1xuZnVuY3Rpb24gYWRkTWFwRW50cnkobWFwLCBwYWlyKSB7XG4gIC8vIERvbid0IHJldHVybiBgbWFwLnNldGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIG1hcC5zZXQocGFpclswXSwgcGFpclsxXSk7XG4gIHJldHVybiBtYXA7XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgc2V0YC5cbiAqL1xuZnVuY3Rpb24gYWRkU2V0RW50cnkoc2V0LCB2YWx1ZSkge1xuICAvLyBEb24ndCByZXR1cm4gYHNldC5hZGRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBzZXQuYWRkKHZhbHVlKTtcbiAgcmV0dXJuIHNldDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xuICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfX1snZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChjYWNoZSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGNhY2hlLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjYWNoZSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgLy8gU2FmYXJpIDkgbWFrZXMgYGFyZ3VtZW50cy5sZW5ndGhgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHZhciByZXN1bHQgPSAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKVxuICAgID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKVxuICAgIDogW107XG5cbiAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICBza2lwSW5kZXhlcyA9ICEhbGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAnbGVuZ3RoJyB8fCBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNGdWxsXSBTcGVjaWZ5IGEgY2xvbmUgaW5jbHVkaW5nIHN5bWJvbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgaXNGdWxsLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgaWYgKGlzSG9zdE9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVPYmplY3QoaXNGdW5jID8ge30gOiB2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGJhc2VDbG9uZSwgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoIWlzQXJyKSB7XG4gICAgdmFyIHByb3BzID0gaXNGdWxsID8gZ2V0QWxsS2V5cyh2YWx1ZSkgOiBrZXlzKHZhbHVlKTtcbiAgfVxuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGlzRGVlcCwgaXNGdWxsLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDcmVhdGUocHJvdG8pIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHByb3RvKSA/IG9iamVjdENyZWF0ZShwcm90bykgOiB7fTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihidWZmZXIubGVuZ3RoKTtcbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIG1hcC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVNYXAobWFwLCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMobWFwVG9BcnJheShtYXApLCB0cnVlKSA6IG1hcFRvQXJyYXkobWFwKTtcbiAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRNYXBFbnRyeSwgbmV3IG1hcC5jb25zdHJ1Y3Rvcik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU2V0KHNldCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKHNldFRvQXJyYXkoc2V0KSwgdHJ1ZSkgOiBzZXRUb0FycmF5KHNldCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkU2V0RW50cnksIG5ldyBzZXQuY29uc3RydWN0b3IpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gc291cmNlW2tleV0gOiBuZXdWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gbmF0aXZlR2V0U3ltYm9scyA/IG92ZXJBcmcobmF0aXZlR2V0U3ltYm9scywgT2JqZWN0KSA6IHN0dWJBcnJheTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExLFxuLy8gZm9yIGRhdGEgdmlld3MgaW4gRWRnZSA8IDE0LCBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcy5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGNsb25lRnVuYywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVNYXAob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIGNsb25lU2V0KG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIHRydWUsIHRydWUpO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oNTQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKShtb2R1bGUpKSlcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ29kZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENvZGVCbG9ja0NvbnRhaW5lcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENvZGVCbG9jazsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jsb3RzX2Jsb2NrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ibG90c19icmVha19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jsb3RzX2N1cnNvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jsb3RzX2lubGluZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jsb3RzX3RleHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ibG90c19jb250YWluZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb3JlX3F1aWxsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cblxuXG5cblxuXG5cbnZhciBDb2RlQmxvY2tDb250YWluZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db250YWluZXIpIHtcbiAgX2luaGVyaXRzKENvZGVCbG9ja0NvbnRhaW5lciwgX0NvbnRhaW5lcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDb2RlQmxvY2tDb250YWluZXIpO1xuXG4gIGZ1bmN0aW9uIENvZGVCbG9ja0NvbnRhaW5lcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29kZUJsb2NrQ29udGFpbmVyKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2RlQmxvY2tDb250YWluZXIsIFt7XG4gICAga2V5OiBcImNvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29kZShpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdGV4dCA9IHRoaXMuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQubGVuZ3RoKCkgPD0gMSA/ICcnIDogY2hpbGQuZG9tTm9kZS50ZXh0Q29udGVudDtcbiAgICAgIH0pLmpvaW4oJ1xcbicpLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG4gICAgICByZXR1cm4gT2JqZWN0KF9ibG90c190ZXh0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZXNjYXBlVGV4dCAqLyBcImJcIl0pKHRleHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJodG1sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGh0bWwoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgLy8gYFxcbmBzIGFyZSBuZWVkZWQgaW4gb3JkZXIgdG8gc3VwcG9ydCBlbXB0eSBsaW5lcyBhdCB0aGUgYmVnaW5uaW5nIGFuZCB0aGUgZW5kLlxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnNcbiAgICAgIHJldHVybiBcIjxwcmU+XFxuXCIuY29uY2F0KHRoaXMuY29kZShpbmRleCwgbGVuZ3RoKSwgXCJcXG48L3ByZT5cIik7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIGRvbU5vZGUgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihDb2RlQmxvY2tDb250YWluZXIpLCBcImNyZWF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcblxuICAgICAgZG9tTm9kZS5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCBmYWxzZSk7XG4gICAgICByZXR1cm4gZG9tTm9kZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29kZUJsb2NrQ29udGFpbmVyO1xufShfYmxvdHNfY29udGFpbmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xuXG52YXIgQ29kZUJsb2NrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmxvY2spIHtcbiAgX2luaGVyaXRzKENvZGVCbG9jaywgX0Jsb2NrKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihDb2RlQmxvY2spO1xuXG4gIGZ1bmN0aW9uIENvZGVCbG9jaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29kZUJsb2NrKTtcblxuICAgIHJldHVybiBfc3VwZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29kZUJsb2NrLCBudWxsLCBbe1xuICAgIGtleTogXCJyZWdpc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgICAgIF9jb3JlX3F1aWxsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmVnaXN0ZXIoQ29kZUJsb2NrQ29udGFpbmVyKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29kZUJsb2NrO1xufShfYmxvdHNfYmxvY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiZFwiXSk7XG5cbnZhciBDb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW5saW5lKSB7XG4gIF9pbmhlcml0cyhDb2RlLCBfSW5saW5lKTtcblxuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihDb2RlKTtcblxuICBmdW5jdGlvbiBDb2RlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2RlKTtcblxuICAgIHJldHVybiBfc3VwZXIzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gQ29kZTtcbn0oX2Jsb3RzX2lubGluZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuQ29kZS5ibG90TmFtZSA9ICdjb2RlJztcbkNvZGUudGFnTmFtZSA9ICdDT0RFJztcbkNvZGVCbG9jay5ibG90TmFtZSA9ICdjb2RlLWJsb2NrJztcbkNvZGVCbG9jay5jbGFzc05hbWUgPSAncWwtY29kZS1ibG9jayc7XG5Db2RlQmxvY2sudGFnTmFtZSA9ICdESVYnO1xuQ29kZUJsb2NrQ29udGFpbmVyLmJsb3ROYW1lID0gJ2NvZGUtYmxvY2stY29udGFpbmVyJztcbkNvZGVCbG9ja0NvbnRhaW5lci5jbGFzc05hbWUgPSAncWwtY29kZS1ibG9jay1jb250YWluZXInO1xuQ29kZUJsb2NrQ29udGFpbmVyLnRhZ05hbWUgPSAnRElWJztcbkNvZGVCbG9ja0NvbnRhaW5lci5hbGxvd2VkQ2hpbGRyZW4gPSBbQ29kZUJsb2NrXTtcbkNvZGVCbG9jay5hbGxvd2VkQ2hpbGRyZW4gPSBbX2Jsb3RzX3RleHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXSwgX2Jsb3RzX2JyZWFrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0sIF9ibG90c19jdXJzb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXV07XG5Db2RlQmxvY2sucmVxdWlyZWRDb250YWluZXIgPSBDb2RlQmxvY2tDb250YWluZXI7XG5Db2RlQmxvY2suVEFCID0gJyAgJztcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29yZV9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ibG9ja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYnJlYWtfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250YWluZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBpc0xpbmUoYmxvdCkge1xuICByZXR1cm4gYmxvdCBpbnN0YW5jZW9mIF9ibG9ja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJkXCJdIHx8IGJsb3QgaW5zdGFuY2VvZiBfYmxvY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBCbG9ja0VtYmVkICovIFwiYVwiXTtcbn1cblxudmFyIFNjcm9sbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Njcm9sbEJsb3QpIHtcbiAgX2luaGVyaXRzKFNjcm9sbCwgX1Njcm9sbEJsb3QpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2Nyb2xsKTtcblxuICBmdW5jdGlvbiBTY3JvbGwocmVnaXN0cnksIGRvbU5vZGUsIF9yZWYpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgZW1pdHRlciA9IF9yZWYuZW1pdHRlcixcbiAgICAgICAgdG9nZ2xlQmxhbmtDbGFzcyA9IF9yZWYudG9nZ2xlQmxhbmtDbGFzcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY3JvbGwpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZWdpc3RyeSwgZG9tTm9kZSk7XG4gICAgX3RoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgX3RoaXMudG9nZ2xlQmxhbmtDbGFzcyA9IHRvZ2dsZUJsYW5rQ2xhc3M7XG4gICAgX3RoaXMuYmF0Y2ggPSBmYWxzZTtcblxuICAgIF90aGlzLm9wdGltaXplKCk7XG5cbiAgICBfdGhpcy5lbmFibGUoKTtcblxuICAgIF90aGlzLmRvbU5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVEcmFnU3RhcnQoZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2Nyb2xsLCBbe1xuICAgIGtleTogXCJiYXRjaFN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhdGNoU3RhcnQoKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5iYXRjaCkpIHtcbiAgICAgICAgdGhpcy5iYXRjaCA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiYXRjaEVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYXRjaEVuZCgpIHtcbiAgICAgIHZhciBtdXRhdGlvbnMgPSB0aGlzLmJhdGNoO1xuICAgICAgdGhpcy5iYXRjaCA9IGZhbHNlO1xuICAgICAgdGhpcy51cGRhdGUobXV0YXRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRNb3VudChibG90KSB7XG4gICAgICB0aGlzLmVtaXR0ZXIuZW1pdChfY29yZV9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZXZlbnRzLlNDUk9MTF9CTE9UX01PVU5ULCBibG90KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdFVubW91bnQoYmxvdCkge1xuICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoX2NvcmVfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmV2ZW50cy5TQ1JPTExfQkxPVF9VTk1PVU5ULCBibG90KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQXQoaW5kZXgsIGxlbmd0aCkge1xuICAgICAgdmFyIF90aGlzJGxpbmUgPSB0aGlzLmxpbmUoaW5kZXgpLFxuICAgICAgICAgIF90aGlzJGxpbmUyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkbGluZSwgMiksXG4gICAgICAgICAgZmlyc3QgPSBfdGhpcyRsaW5lMlswXSxcbiAgICAgICAgICBvZmZzZXQgPSBfdGhpcyRsaW5lMlsxXTtcblxuICAgICAgdmFyIF90aGlzJGxpbmUzID0gdGhpcy5saW5lKGluZGV4ICsgbGVuZ3RoKSxcbiAgICAgICAgICBfdGhpcyRsaW5lNCA9IF9zbGljZWRUb0FycmF5KF90aGlzJGxpbmUzLCAxKSxcbiAgICAgICAgICBsYXN0ID0gX3RoaXMkbGluZTRbMF07XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFNjcm9sbC5wcm90b3R5cGUpLCBcImRlbGV0ZUF0XCIsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgsIGxlbmd0aCk7XG5cbiAgICAgIGlmIChsYXN0ICE9IG51bGwgJiYgZmlyc3QgIT09IGxhc3QgJiYgb2Zmc2V0ID4gMCkge1xuICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBfYmxvY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBCbG9ja0VtYmVkICovIFwiYVwiXSB8fCBsYXN0IGluc3RhbmNlb2YgX2Jsb2NrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogQmxvY2tFbWJlZCAqLyBcImFcIl0pIHtcbiAgICAgICAgICB0aGlzLm9wdGltaXplKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZiA9IGxhc3QuY2hpbGRyZW4uaGVhZCBpbnN0YW5jZW9mIF9icmVha19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdID8gbnVsbCA6IGxhc3QuY2hpbGRyZW4uaGVhZDtcbiAgICAgICAgZmlyc3QubW92ZUNoaWxkcmVuKGxhc3QsIHJlZik7XG4gICAgICAgIGZpcnN0LnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wdGltaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB2YXIgZW5hYmxlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHRoaXMuZG9tTm9kZS5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIGVuYWJsZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBmb3JtYXQsIHZhbHVlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihTY3JvbGwucHJvdG90eXBlKSwgXCJmb3JtYXRBdFwiLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCBsZW5ndGgsIGZvcm1hdCwgdmFsdWUpO1xuXG4gICAgICB0aGlzLm9wdGltaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZURyYWdTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEcmFnU3RhcnQoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICBpZiAoZGVmID09IG51bGwgfHwgdGhpcy5zY3JvbGwucXVlcnkodmFsdWUsIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiU2NvcGVcIl0uQkxPQ0spID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgYmxvdCA9IHRoaXMuc2Nyb2xsLmNyZWF0ZSh0aGlzLnN0YXRpY3MuZGVmYXVsdENoaWxkLmJsb3ROYW1lKTtcbiAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGJsb3QpO1xuXG4gICAgICAgICAgaWYgKGRlZiA9PSBudWxsICYmIHZhbHVlLmVuZHNXaXRoKCdcXG4nKSkge1xuICAgICAgICAgICAgYmxvdC5pbnNlcnRBdCgwLCB2YWx1ZS5zbGljZSgwLCAtMSksIGRlZik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJsb3QuaW5zZXJ0QXQoMCwgdmFsdWUsIGRlZik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbWJlZCA9IHRoaXMuc2Nyb2xsLmNyZWF0ZSh2YWx1ZSwgZGVmKTtcbiAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGVtYmVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU2Nyb2xsLnByb3RvdHlwZSksIFwiaW5zZXJ0QXRcIiwgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgdmFsdWUsIGRlZik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3B0aW1pemUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0QmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShibG90LCByZWYpIHtcbiAgICAgIGlmIChibG90LnN0YXRpY3Muc2NvcGUgPT09IHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiU2NvcGVcIl0uSU5MSU5FX0JMT1QpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB0aGlzLnNjcm9sbC5jcmVhdGUodGhpcy5zdGF0aWNzLmRlZmF1bHRDaGlsZC5ibG90TmFtZSk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoYmxvdCk7XG5cbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU2Nyb2xsLnByb3RvdHlwZSksIFwiaW5zZXJ0QmVmb3JlXCIsIHRoaXMpLmNhbGwodGhpcywgd3JhcHBlciwgcmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFNjcm9sbC5wcm90b3R5cGUpLCBcImluc2VydEJlZm9yZVwiLCB0aGlzKS5jYWxsKHRoaXMsIGJsb3QsIHJlZik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRW5hYmxlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb21Ob2RlLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICd0cnVlJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVhZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWFmKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoKGluZGV4KS5wb3AoKSB8fCBbbnVsbCwgLTFdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmUoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lKGluZGV4IC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmRlc2NlbmRhbnQoaXNMaW5lLCBpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpbmVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmVzKCkge1xuICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgdmFyIGdldExpbmVzID0gZnVuY3Rpb24gZ2V0TGluZXMoYmxvdCwgYmxvdEluZGV4LCBibG90TGVuZ3RoKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICB2YXIgbGVuZ3RoTGVmdCA9IGJsb3RMZW5ndGg7XG4gICAgICAgIGJsb3QuY2hpbGRyZW4uZm9yRWFjaEF0KGJsb3RJbmRleCwgYmxvdExlbmd0aCwgZnVuY3Rpb24gKGNoaWxkLCBjaGlsZEluZGV4LCBjaGlsZExlbmd0aCkge1xuICAgICAgICAgIGlmIChpc0xpbmUoY2hpbGQpKSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJDb250YWluZXJCbG90XCJdKSB7XG4gICAgICAgICAgICBsaW5lcyA9IGxpbmVzLmNvbmNhdChnZXRMaW5lcyhjaGlsZCwgY2hpbGRJbmRleCwgbGVuZ3RoTGVmdCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxlbmd0aExlZnQgLT0gY2hpbGRMZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZ2V0TGluZXModGhpcywgaW5kZXgsIGxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9wdGltaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKCkge1xuICAgICAgdmFyIG11dGF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICBpZiAodGhpcy5iYXRjaCkgcmV0dXJuO1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihTY3JvbGwucHJvdG90eXBlKSwgXCJvcHRpbWl6ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIG11dGF0aW9ucywgY29udGV4dCk7XG5cbiAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChfY29yZV9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZXZlbnRzLlNDUk9MTF9PUFRJTUlaRSwgbXV0YXRpb25zLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoKGluZGV4KSB7XG4gICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoU2Nyb2xsLnByb3RvdHlwZSksIFwicGF0aFwiLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4KS5zbGljZSgxKTsgLy8gRXhjbHVkZSBzZWxmXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7Ly8gTmV2ZXIgcmVtb3ZlIHNlbGZcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShtdXRhdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5iYXRjaCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtdXRhdGlvbnMpKSB7XG4gICAgICAgICAgdGhpcy5iYXRjaCA9IHRoaXMuYmF0Y2guY29uY2F0KG11dGF0aW9ucyk7XG4gICAgICAgICAgdGhpcy50b2dnbGVCbGFua0NsYXNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2UgPSBfY29yZV9lbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc291cmNlcy5VU0VSO1xuXG4gICAgICBpZiAodHlwZW9mIG11dGF0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc291cmNlID0gbXV0YXRpb25zO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobXV0YXRpb25zKSkge1xuICAgICAgICBtdXRhdGlvbnMgPSB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICB9XG5cbiAgICAgIG11dGF0aW9ucyA9IG11dGF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBfcmVmMi50YXJnZXQ7XG5cbiAgICAgICAgdmFyIGJsb3QgPSBfdGhpczIuZmluZCh0YXJnZXQsIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBibG90ICYmIGJsb3Quc2Nyb2xsID09PSBfdGhpczI7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KF9jb3JlX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ldmVudHMuU0NST0xMX0JFRk9SRV9VUERBVEUsIHNvdXJjZSwgbXV0YXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU2Nyb2xsLnByb3RvdHlwZSksIFwidXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgbXV0YXRpb25zLmNvbmNhdChbXSkpOyAvLyBwYXNzIGNvcHlcblxuXG4gICAgICBpZiAobXV0YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoX2NvcmVfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmV2ZW50cy5TQ1JPTExfVVBEQVRFLCBzb3VyY2UsIG11dGF0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNjcm9sbDtcbn0ocGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJTY3JvbGxCbG90XCJdKTtcblxuU2Nyb2xsLmJsb3ROYW1lID0gJ3Njcm9sbCc7XG5TY3JvbGwuY2xhc3NOYW1lID0gJ3FsLWVkaXRvcic7XG5TY3JvbGwudGFnTmFtZSA9ICdESVYnO1xuU2Nyb2xsLmRlZmF1bHRDaGlsZCA9IF9ibG9ja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJkXCJdO1xuU2Nyb2xsLmFsbG93ZWRDaGlsZHJlbiA9IFtfYmxvY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiZFwiXSwgX2Jsb2NrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogQmxvY2tFbWJlZCAqLyBcImFcIl0sIF9jb250YWluZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXV07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFNjcm9sbCk7XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGJpbmQgPSBGdW5jdGlvblByb3RvdHlwZS5iaW5kO1xudmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xudmFyIGNhbGxCaW5kID0gYmluZCAmJiBiaW5kLmJpbmQoY2FsbCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZCA/IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgY2FsbEJpbmQoY2FsbCwgZm4pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gJiYgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIGxldmVscyA9IFsnZXJyb3InLCAnd2FybicsICdsb2cnLCAnaW5mbyddO1xudmFyIGxldmVsID0gJ3dhcm4nO1xuXG5mdW5jdGlvbiBkZWJ1ZyhtZXRob2QpIHtcbiAgaWYgKGxldmVscy5pbmRleE9mKG1ldGhvZCkgPD0gbGV2ZWxzLmluZGV4T2YobGV2ZWwpKSB7XG4gICAgdmFyIF9jb25zb2xlO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgKF9jb25zb2xlID0gY29uc29sZSlbbWV0aG9kXS5hcHBseShfY29uc29sZSwgYXJncyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXG4gIH1cbn1cblxuZnVuY3Rpb24gbmFtZXNwYWNlKG5zKSB7XG4gIHJldHVybiBsZXZlbHMucmVkdWNlKGZ1bmN0aW9uIChsb2dnZXIsIG1ldGhvZCkge1xuICAgIGxvZ2dlclttZXRob2RdID0gZGVidWcuYmluZChjb25zb2xlLCBtZXRob2QsIG5zKTtcbiAgICByZXR1cm4gbG9nZ2VyO1xuICB9LCB7fSk7XG59XG5cbm5hbWVzcGFjZS5sZXZlbCA9IGZ1bmN0aW9uIChuZXdMZXZlbCkge1xuICBsZXZlbCA9IG5ld0xldmVsO1xufTtcblxuZGVidWcubGV2ZWwgPSBuYW1lc3BhY2UubGV2ZWw7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKG5hbWVzcGFjZSk7XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90ZXh0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG5cbnZhciBDdXJzb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbWJlZEJsb3QpIHtcbiAgX2luaGVyaXRzKEN1cnNvciwgX0VtYmVkQmxvdCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDdXJzb3IpO1xuXG4gIGZ1bmN0aW9uIEN1cnNvcihzY3JvbGwsIGRvbU5vZGUsIHNlbGVjdGlvbikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdXJzb3IpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzY3JvbGwsIGRvbU5vZGUpO1xuICAgIF90aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICBfdGhpcy50ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKEN1cnNvci5DT05URU5UUyk7XG5cbiAgICBfdGhpcy5kb21Ob2RlLmFwcGVuZENoaWxkKF90aGlzLnRleHROb2RlKTtcblxuICAgIF90aGlzLnNhdmVkTGVuZ3RoID0gMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ3Vyc29yLCBbe1xuICAgIGtleTogXCJkZXRhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgLy8gc3VwZXIuZGV0YWNoKCkgd2lsbCBhbHNvIGNsZWFyIGRvbU5vZGUuX19ibG90XG4gICAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbCkgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLnNhdmVkTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEN1cnNvci5wcm90b3R5cGUpLCBcImZvcm1hdFwiLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgd2hpbGUgKHRhcmdldCAhPSBudWxsICYmIHRhcmdldC5zdGF0aWNzLnNjb3BlICE9PSBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIlNjb3BlXCJdLkJMT0NLX0JMT1QpIHtcbiAgICAgICAgaW5kZXggKz0gdGFyZ2V0Lm9mZnNldCh0YXJnZXQucGFyZW50KTtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2F2ZWRMZW5ndGggPSBDdXJzb3IuQ09OVEVOVFMubGVuZ3RoO1xuICAgICAgICB0YXJnZXQub3B0aW1pemUoKTtcbiAgICAgICAgdGFyZ2V0LmZvcm1hdEF0KGluZGV4LCBDdXJzb3IuQ09OVEVOVFMubGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2F2ZWRMZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleChub2RlLCBvZmZzZXQpIHtcbiAgICAgIGlmIChub2RlID09PSB0aGlzLnRleHROb2RlKSByZXR1cm4gMDtcbiAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihDdXJzb3IucHJvdG90eXBlKSwgXCJpbmRleFwiLCB0aGlzKS5jYWxsKHRoaXMsIG5vZGUsIG9mZnNldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zYXZlZExlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gW3RoaXMudGV4dE5vZGUsIHRoaXMudGV4dE5vZGUuZGF0YS5sZW5ndGhdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQ3Vyc29yLnByb3RvdHlwZSksIFwicmVtb3ZlXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzdG9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0b3JlKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLmNvbXBvc2luZyB8fCB0aGlzLnBhcmVudCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsZWN0aW9uLmdldE5hdGl2ZVJhbmdlKCk7IC8vIExpbmsgZm9ybWF0IHdpbGwgaW5zZXJ0IHRleHQgb3V0c2lkZSBvZiBhbmNob3IgdGFnXG5cbiAgICAgIHdoaWxlICh0aGlzLmRvbU5vZGUubGFzdENoaWxkICE9IG51bGwgJiYgdGhpcy5kb21Ob2RlLmxhc3RDaGlsZCAhPT0gdGhpcy50ZXh0Tm9kZSkge1xuICAgICAgICB0aGlzLmRvbU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5kb21Ob2RlLmxhc3RDaGlsZCwgdGhpcy5kb21Ob2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZUZXh0QmxvdCA9IHRoaXMucHJldiBpbnN0YW5jZW9mIF90ZXh0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0gPyB0aGlzLnByZXYgOiBudWxsO1xuICAgICAgdmFyIHByZXZUZXh0TGVuZ3RoID0gcHJldlRleHRCbG90ID8gcHJldlRleHRCbG90Lmxlbmd0aCgpIDogMDtcbiAgICAgIHZhciBuZXh0VGV4dEJsb3QgPSB0aGlzLm5leHQgaW5zdGFuY2VvZiBfdGV4dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdID8gdGhpcy5uZXh0IDogbnVsbDtcbiAgICAgIHZhciBuZXh0VGV4dCA9IG5leHRUZXh0QmxvdCA/IG5leHRUZXh0QmxvdC50ZXh0IDogJyc7XG4gICAgICB2YXIgdGV4dE5vZGUgPSB0aGlzLnRleHROb2RlOyAvLyB0YWtlIHRleHQgZnJvbSBpbnNpZGUgdGhpcyBibG90IGFuZCByZXNldCBpdFxuXG4gICAgICB2YXIgbmV3VGV4dCA9IHRleHROb2RlLmRhdGEuc3BsaXQoQ3Vyc29yLkNPTlRFTlRTKS5qb2luKCcnKTtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBDdXJzb3IuQ09OVEVOVFM7IC8vIHByb2FjdGl2ZWx5IG1lcmdlIFRleHRCbG90cyBhcm91bmQgY3Vyc29yIHNvIHRoYXQgb3B0aW1pemF0aW9uXG4gICAgICAvLyBkb2Vzbid0IGxvc2UgdGhlIGN1cnNvci4gIHRoZSByZWFzb24gd2UgYXJlIGhlcmUgaW4gY3Vyc29yLnJlc3RvcmVcbiAgICAgIC8vIGNvdWxkIGJlIHRoYXQgdGhlIHVzZXIgY2xpY2tlZCBpbiBwcmV2VGV4dEJsb3Qgb3IgbmV4dFRleHRCbG90LCBvclxuICAgICAgLy8gdGhlIHVzZXIgdHlwZWQgc29tZXRoaW5nLlxuXG4gICAgICB2YXIgbWVyZ2VkVGV4dEJsb3Q7XG5cbiAgICAgIGlmIChwcmV2VGV4dEJsb3QpIHtcbiAgICAgICAgbWVyZ2VkVGV4dEJsb3QgPSBwcmV2VGV4dEJsb3Q7XG5cbiAgICAgICAgaWYgKG5ld1RleHQgfHwgbmV4dFRleHRCbG90KSB7XG4gICAgICAgICAgcHJldlRleHRCbG90Lmluc2VydEF0KHByZXZUZXh0QmxvdC5sZW5ndGgoKSwgbmV3VGV4dCArIG5leHRUZXh0KTtcblxuICAgICAgICAgIGlmIChuZXh0VGV4dEJsb3QpIHtcbiAgICAgICAgICAgIG5leHRUZXh0QmxvdC5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobmV4dFRleHRCbG90KSB7XG4gICAgICAgIG1lcmdlZFRleHRCbG90ID0gbmV4dFRleHRCbG90O1xuICAgICAgICBuZXh0VGV4dEJsb3QuaW5zZXJ0QXQoMCwgbmV3VGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3VGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdUZXh0KTtcbiAgICAgICAgbWVyZ2VkVGV4dEJsb3QgPSB0aGlzLnNjcm9sbC5jcmVhdGUobmV3VGV4dE5vZGUpO1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUobWVyZ2VkVGV4dEJsb3QsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbW92ZSgpO1xuXG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHNlbGVjdGlvbiB0byByZXN0b3JlXG4gICAgICAgIHZhciByZW1hcE9mZnNldCA9IGZ1bmN0aW9uIHJlbWFwT2Zmc2V0KG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgIGlmIChwcmV2VGV4dEJsb3QgJiYgbm9kZSA9PT0gcHJldlRleHRCbG90LmRvbU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5vZGUgPT09IHRleHROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldlRleHRMZW5ndGggKyBvZmZzZXQgLSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0VGV4dEJsb3QgJiYgbm9kZSA9PT0gbmV4dFRleHRCbG90LmRvbU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2VGV4dExlbmd0aCArIG5ld1RleHQubGVuZ3RoICsgb2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdGFydCA9IHJlbWFwT2Zmc2V0KHJhbmdlLnN0YXJ0Lm5vZGUsIHJhbmdlLnN0YXJ0Lm9mZnNldCk7XG4gICAgICAgIHZhciBlbmQgPSByZW1hcE9mZnNldChyYW5nZS5lbmQubm9kZSwgcmFuZ2UuZW5kLm9mZnNldCk7XG5cbiAgICAgICAgaWYgKHN0YXJ0ICE9PSBudWxsICYmIGVuZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydE5vZGU6IG1lcmdlZFRleHRCbG90LmRvbU5vZGUsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogc3RhcnQsXG4gICAgICAgICAgICBlbmROb2RlOiBtZXJnZWRUZXh0QmxvdC5kb21Ob2RlLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBlbmRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChtdXRhdGlvbnMuc29tZShmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uLnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJyAmJiBtdXRhdGlvbi50YXJnZXQgPT09IF90aGlzMi50ZXh0Tm9kZTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMucmVzdG9yZSgpO1xuICAgICAgICBpZiAocmFuZ2UpIGNvbnRleHQucmFuZ2UgPSByYW5nZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDdXJzb3I7XG59KHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiRW1iZWRCbG90XCJdKTtcblxuQ3Vyc29yLmJsb3ROYW1lID0gJ2N1cnNvcic7XG5DdXJzb3IuY2xhc3NOYW1lID0gJ3FsLWN1cnNvcic7XG5DdXJzb3IudGFnTmFtZSA9ICdzcGFuJztcbkN1cnNvci5DT05URU5UUyA9IFwiXFx1RkVGRlwiOyAvLyBaZXJvIHdpZHRoIG5vIGJyZWFrIHNwYWNlXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQ3Vyc29yKTtcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29yZV9xdWlsbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmxvdHNfYmxvY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jsb3RzX2JyZWFrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmxvdHNfY29udGFpbmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmxvdHNfY3Vyc29yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmxvdHNfZW1iZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ibG90c19pbmxpbmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ibG90c19zY3JvbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ibG90c190ZXh0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kdWxlc19jbGlwYm9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2R1bGVzX2hpc3RvcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kdWxlc19rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2R1bGVzX3VwbG9hZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbl9jb3JlX3F1aWxsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmVnaXN0ZXIoe1xuICAnYmxvdHMvYmxvY2snOiBfYmxvdHNfYmxvY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiZFwiXSxcbiAgJ2Jsb3RzL2Jsb2NrL2VtYmVkJzogX2Jsb3RzX2Jsb2NrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogQmxvY2tFbWJlZCAqLyBcImFcIl0sXG4gICdibG90cy9icmVhayc6IF9ibG90c19icmVha19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLFxuICAnYmxvdHMvY29udGFpbmVyJzogX2Jsb3RzX2NvbnRhaW5lcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLFxuICAnYmxvdHMvY3Vyc29yJzogX2Jsb3RzX2N1cnNvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLFxuICAnYmxvdHMvZW1iZWQnOiBfYmxvdHNfZW1iZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXSxcbiAgJ2Jsb3RzL2lubGluZSc6IF9ibG90c19pbmxpbmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXSxcbiAgJ2Jsb3RzL3Njcm9sbCc6IF9ibG90c19zY3JvbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXSxcbiAgJ2Jsb3RzL3RleHQnOiBfYmxvdHNfdGV4dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLFxuICAnbW9kdWxlcy9jbGlwYm9hcmQnOiBfbW9kdWxlc19jbGlwYm9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1svKiBkZWZhdWx0ICovIFwiYlwiXSxcbiAgJ21vZHVsZXMvaGlzdG9yeSc6IF9tb2R1bGVzX2hpc3RvcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0sXG4gICdtb2R1bGVzL2tleWJvYXJkJzogX21vZHVsZXNfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bLyogZGVmYXVsdCAqLyBcImJcIl0sXG4gICdtb2R1bGVzL3VwbG9hZGVyJzogX21vZHVsZXNfdXBsb2FkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bLyogZGVmYXVsdCAqLyBcImFcIl1cbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfY29yZV9xdWlsbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8ga2V5Ym9hcmRfS2V5Ym9hcmQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gU0hPUlRLRVk7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gbm9ybWFsaXplOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGRlbGV0ZVJhbmdlOyB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9sb2Rhc2guY2xvbmVkZWVwL2luZGV4LmpzXG52YXIgbG9kYXNoX2Nsb25lZGVlcCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xudmFyIGxvZGFzaF9jbG9uZWRlZXBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX2Nsb25lZGVlcCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoLmlzZXF1YWwvaW5kZXguanNcbnZhciBsb2Rhc2hfaXNlcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xudmFyIGxvZGFzaF9pc2VxdWFsX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGxvZGFzaF9pc2VxdWFsKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9xdWlsbC1kZWx0YS9kaXN0L0RlbHRhLmpzXG52YXIgRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIERlbHRhX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKERlbHRhKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9wYXJjaG1lbnQvc3JjL3BhcmNobWVudC50cyArIDE3IG1vZHVsZXNcbnZhciBwYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29yZS9xdWlsbC5qc1xudmFyIGNvcmVfcXVpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29yZS9sb2dnZXIuanNcbnZhciBsb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvcmUvbW9kdWxlLmpzXG52YXIgY29yZV9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3V0aWxzL2hhc193aW5kb3cuanNcbnZhciBoYXNfd2luZG93ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vdXRpbHMvZ2V0X3Njcm9sbF9pbnRvX3ZpZXdfY29uZmlnLmpzXG5mdW5jdGlvbiBnZXRTY3JvbGxJbnRvVmlld0NvbmZpZyhlbGVtZW50KSB7XG4gIHZhciBfd2luZG93ID0gd2luZG93LFxuICAgICAgd2luZG93SGVpZ2h0ID0gX3dpbmRvdy5pbm5lckhlaWdodDtcblxuICB2YXIgX2VsZW1lbnQkZ2V0Qm91bmRpbmdDID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGVsZW1Ub3AgPSBfZWxlbWVudCRnZXRCb3VuZGluZ0MueSxcbiAgICAgIGVsZW1Cb3R0b20gPSBfZWxlbWVudCRnZXRCb3VuZGluZ0MuYm90dG9tO1xuXG4gIGlmIChlbGVtVG9wIDwgMCkge1xuICAgIHJldHVybiB0cnVlOyAvLyBzY3JvbGwgdG8gdGhlIHRvcFxuICB9XG5cbiAgaWYgKGVsZW1Cb3R0b20gPj0gd2luZG93SGVpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBzY3JvbGwgdG8gdGhlIGJvdHRvbVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL21vZHVsZXMva2V5Ym9hcmQuanNcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgZGVidWcgPSBPYmplY3QobG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSgncXVpbGw6a2V5Ym9hcmQnKTtcbnZhciBLRVlfTkFNRVMgPSB7XG4gIGJhY2tzcGFjZTogJ2JhY2tzcGFjZScsXG4gIHRhYjogJ3RhYicsXG4gIGVudGVyOiAnZW50ZXInLFxuICBlc2NhcGU6ICdlc2NhcGUnLFxuICBwYWdldXA6ICdwYWdlVXAnLFxuICBwYWdlZG93bjogJ3BhZ2VEb3duJyxcbiAgZW5kOiAnZW5kJyxcbiAgaG9tZTogJ2hvbWUnLFxuICBhcnJvd2xlZnQ6ICdsZWZ0QXJyb3cnLFxuICBhcnJvd3VwOiAndXBBcnJvdycsXG4gIGFycm93cmlnaHQ6ICdyaWdodEFycm93JyxcbiAgYXJyb3dkb3duOiAnZG93bkFycm93JyxcbiAgZGVsZXRlOiAnZGVsJyxcbiAgJyAnOiAnc3BhY2UnLFxuICAnKic6ICdhc3RlcmlzaycsXG4gICctJzogJ21pbnVzJyxcbiAgYWx0OiAnYWx0JyxcbiAgY29udHJvbDogJ2NvbnRyb2wnLFxuICBzaGlmdDogJ3NoaWZ0JyxcbiAgLy8gSUUxMTpcbiAgbGVmdDogJ2xlZnRBcnJvdycsXG4gIHVwOiAndXBBcnJvdycsXG4gIHJpZ2h0OiAncmlnaHRBcnJvdycsXG4gIGRvd246ICdkb3duQXJyb3cnLFxuICBtdWx0aXBseTogJ2FzdGVyaXNrJyxcbiAgc3BhY2ViYXI6ICdzcGFjZScsXG4gIGRlbDogJ2RlbCcsXG4gIHN1YnRyYWN0OiAnbWludXMnLFxuICBlc2M6ICdlc2NhcGUnXG59O1xudmFyIEtFWV9DT0RFUyA9IHtcbiAgLy8gaU9TIDEwLjIgYW5kIGxvd2VyIGRpZG4ndCBzdXBwb3J0cyBLZXlib2FyZEV2ZW50LmtleVxuICAnOCc6ICdiYWNrc3BhY2UnLFxuICAnOSc6ICd0YWInLFxuICAnMTMnOiAnZW50ZXInLFxuICAnMjcnOiAnZXNjYXBlJyxcbiAgJzMzJzogJ3BhZ2VVcCcsXG4gICczNCc6ICdwYWdlRG93bicsXG4gICczNSc6ICdlbmQnLFxuICAnMzYnOiAnaG9tZScsXG4gICczNyc6ICdsZWZ0QXJyb3cnLFxuICAnMzgnOiAndXBBcnJvdycsXG4gICczOSc6ICdyaWdodEFycm93JyxcbiAgJzQwJzogJ2Rvd25BcnJvdycsXG4gICc0Nic6ICdkZWwnLFxuICAnMzInOiAnc3BhY2UnLFxuICAnMTA2JzogJ2FzdGVyaXNrJyxcbiAgJzEwOSc6ICdtaW51cycsXG4gICcxODknOiAnbWludXMnLFxuICAnMTczJzogJ21pbnVzJyxcbiAgJzE2JzogJ3NoaWZ0JyxcbiAgJzE3JzogJ2NvbnRyb2wnLFxuICAnMTgnOiAnYWx0J1xufTtcbnZhciBTSE9SVEtFWSA9IE9iamVjdChoYXNfd2luZG93W1wiYVwiIC8qIGRlZmF1bHQgKi9dKSgpICYmIC9NYWMvaS50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgPyAnbWV0YUtleScgOiAnY3RybEtleSc7XG5cbnZhciBrZXlib2FyZF9LZXlib2FyZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX01vZHVsZSkge1xuICBfaW5oZXJpdHMoS2V5Ym9hcmQsIF9Nb2R1bGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoS2V5Ym9hcmQpO1xuXG4gIGZ1bmN0aW9uIEtleWJvYXJkKHF1aWxsLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtleWJvYXJkKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcXVpbGwsIG9wdGlvbnMpO1xuICAgIF90aGlzLmJpbmRpbmdzID0ge307XG4gICAgT2JqZWN0LmtleXMoX3RoaXMub3B0aW9ucy5iaW5kaW5ncykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKF90aGlzLm9wdGlvbnMuYmluZGluZ3NbbmFtZV0pIHtcbiAgICAgICAgX3RoaXMuYWRkQmluZGluZyhfdGhpcy5vcHRpb25zLmJpbmRpbmdzW25hbWVdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF90aGlzLmFkZEludGVybmFsQmluZGluZ3MoKTtcblxuICAgIF90aGlzLmxpc3RlbigpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEtleWJvYXJkLCBbe1xuICAgIGtleTogXCJhZGRJbnRlcm5hbEJpbmRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEludGVybmFsQmluZGluZ3MoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5xdWlsbC5vbmNlKGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uZXZlbnRzLkNPTlRFTlRfU0VUVEVELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5hZGRCaW5kaW5nKHtcbiAgICAgICAgICBrZXk6ICdlbnRlcicsXG4gICAgICAgICAgc2hpZnRLZXk6IG51bGxcbiAgICAgICAgfSwgX3RoaXMyLmhhbmRsZUVudGVyKTtcblxuICAgICAgICBfdGhpczIuYWRkQmluZGluZyh7XG4gICAgICAgICAga2V5OiAnZW50ZXInLFxuICAgICAgICAgIG1ldGFLZXk6IG51bGwsXG4gICAgICAgICAgY3RybEtleTogbnVsbCxcbiAgICAgICAgICBhbHRLZXk6IG51bGxcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge30pO1xuXG4gICAgICAgIGlmIChPYmplY3QoaGFzX3dpbmRvd1tcImFcIiAvKiBkZWZhdWx0ICovXSkoKSAmJiAvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAvLyBOZWVkIHRvIGhhbmRsZSBkZWxldGUgYW5kIGJhY2tzcGFjZSBmb3IgRmlyZWZveCBpbiB0aGUgZ2VuZXJhbCBjYXNlICMxMTcxXG4gICAgICAgICAgX3RoaXMyLmFkZEJpbmRpbmcoe1xuICAgICAgICAgICAga2V5OiAnYmFja3NwYWNlJ1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNvbGxhcHNlZDogdHJ1ZVxuICAgICAgICAgIH0sIF90aGlzMi5oYW5kbGVCYWNrc3BhY2UpO1xuXG4gICAgICAgICAgX3RoaXMyLmFkZEJpbmRpbmcoe1xuICAgICAgICAgICAga2V5OiAnZGVsJ1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNvbGxhcHNlZDogdHJ1ZVxuICAgICAgICAgIH0sIF90aGlzMi5oYW5kbGVEZWxldGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMi5hZGRCaW5kaW5nKHtcbiAgICAgICAgICAgIGtleTogJ2JhY2tzcGFjZSdcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICAgICAgICBwcmVmaXg6IC9eLj8kL1xuICAgICAgICAgIH0sIF90aGlzMi5oYW5kbGVCYWNrc3BhY2UpO1xuXG4gICAgICAgICAgX3RoaXMyLmFkZEJpbmRpbmcoe1xuICAgICAgICAgICAga2V5OiAnZGVsJ1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICAgICAgICAgIHN1ZmZpeDogL14uPyQvXG4gICAgICAgICAgfSwgX3RoaXMyLmhhbmRsZURlbGV0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczIuYWRkQmluZGluZyh7XG4gICAgICAgICAga2V5OiAnYmFja3NwYWNlJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgY29sbGFwc2VkOiBmYWxzZVxuICAgICAgICB9LCBfdGhpczIuaGFuZGxlRGVsZXRlUmFuZ2UpO1xuXG4gICAgICAgIF90aGlzMi5hZGRCaW5kaW5nKHtcbiAgICAgICAgICBrZXk6ICdkZWwnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlXG4gICAgICAgIH0sIF90aGlzMi5oYW5kbGVEZWxldGVSYW5nZSk7XG5cbiAgICAgICAgX3RoaXMyLmFkZEJpbmRpbmcoe1xuICAgICAgICAgIGtleTogJ2JhY2tzcGFjZScsXG4gICAgICAgICAgYWx0S2V5OiBudWxsLFxuICAgICAgICAgIGN0cmxLZXk6IG51bGwsXG4gICAgICAgICAgbWV0YUtleTogbnVsbCxcbiAgICAgICAgICBzaGlmdEtleTogbnVsbFxuICAgICAgICB9LCB7XG4gICAgICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LCBfdGhpczIuaGFuZGxlQmFja3NwYWNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRCaW5kaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEJpbmRpbmcoa2V5QmluZGluZykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBoYW5kbGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciBiaW5kaW5nID0gbm9ybWFsaXplKGtleUJpbmRpbmcpO1xuXG4gICAgICBpZiAoYmluZGluZyA9PSBudWxsKSB7XG4gICAgICAgIGRlYnVnLndhcm4oJ0F0dGVtcHRlZCB0byBhZGQgaW52YWxpZCBrZXlib2FyZCBiaW5kaW5nJywgYmluZGluZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnRleHQgPSB7XG4gICAgICAgICAgaGFuZGxlcjogY29udGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaGFuZGxlciA9IHtcbiAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlQcm9wZXJ5ID0gYmluZGluZy53aGljaCA/ICd3aGljaCcgOiAna2V5JztcbiAgICAgIHZhciBrZXlzID0gQXJyYXkuaXNBcnJheShiaW5kaW5nW2tleVByb3BlcnldKSA/IGJpbmRpbmdba2V5UHJvcGVyeV0gOiBbYmluZGluZ1trZXlQcm9wZXJ5XV07XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgc2luZ2xlQmluZGluZyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBiaW5kaW5nKSwge30sIHtcbiAgICAgICAgICBrZXk6IGtleVxuICAgICAgICB9LCBjb250ZXh0KSwgaGFuZGxlcik7XG5cbiAgICAgICAgX3RoaXMzLmJpbmRpbmdzW3NpbmdsZUJpbmRpbmcua2V5XSA9IF90aGlzMy5iaW5kaW5nc1tzaW5nbGVCaW5kaW5nLmtleV0gfHwgW107XG5cbiAgICAgICAgX3RoaXMzLmJpbmRpbmdzW3NpbmdsZUJpbmRpbmcua2V5XS5wdXNoKHNpbmdsZUJpbmRpbmcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpc3RlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW4oKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdGhpcy5xdWlsbC5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGlmIChldnQuZGVmYXVsdFByZXZlbnRlZCB8fCBldnQuaXNDb21wb3NpbmcpIHJldHVybjtcblxuICAgICAgICBfdGhpczQucmFpc2VPbktleWRvd25DYWxsYmFjayhldnQpO1xuXG4gICAgICAgIHZhciBrZXlOYW1lID0gS2V5Ym9hcmQubm9ybWFsaXplS2V5TmFtZShldnQpO1xuICAgICAgICB2YXIgYmluZGluZ3MgPSAoX3RoaXM0LmJpbmRpbmdzW2tleU5hbWVdIHx8IFtdKS5jb25jYXQoX3RoaXM0LmJpbmRpbmdzW2V2dC53aGljaF0gfHwgW10pO1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGJpbmRpbmdzLmZpbHRlcihmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICAgIHJldHVybiBLZXlib2FyZC5tYXRjaChldnQsIGJpbmRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHJhbmdlID0gX3RoaXM0LnF1aWxsLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGlmIChyYW5nZSA9PSBudWxsIHx8ICFfdGhpczQucXVpbGwuaGFzRm9jdXMoKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBfdGhpczQkcXVpbGwkZ2V0TGluZSA9IF90aGlzNC5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgIF90aGlzNCRxdWlsbCRnZXRMaW5lMiA9IF9zbGljZWRUb0FycmF5KF90aGlzNCRxdWlsbCRnZXRMaW5lLCAyKSxcbiAgICAgICAgICAgIGxpbmUgPSBfdGhpczQkcXVpbGwkZ2V0TGluZTJbMF0sXG4gICAgICAgICAgICBvZmZzZXQgPSBfdGhpczQkcXVpbGwkZ2V0TGluZTJbMV07XG5cbiAgICAgICAgdmFyIF90aGlzNCRxdWlsbCRnZXRMZWFmID0gX3RoaXM0LnF1aWxsLmdldExlYWYocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgICAgX3RoaXM0JHF1aWxsJGdldExlYWYyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXM0JHF1aWxsJGdldExlYWYsIDIpLFxuICAgICAgICAgICAgbGVhZlN0YXJ0ID0gX3RoaXM0JHF1aWxsJGdldExlYWYyWzBdLFxuICAgICAgICAgICAgb2Zmc2V0U3RhcnQgPSBfdGhpczQkcXVpbGwkZ2V0TGVhZjJbMV07XG5cbiAgICAgICAgdmFyIF9yZWYgPSByYW5nZS5sZW5ndGggPT09IDAgPyBbbGVhZlN0YXJ0LCBvZmZzZXRTdGFydF0gOiBfdGhpczQucXVpbGwuZ2V0TGVhZihyYW5nZS5pbmRleCArIHJhbmdlLmxlbmd0aCksXG4gICAgICAgICAgICBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgbGVhZkVuZCA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgb2Zmc2V0RW5kID0gX3JlZjJbMV07XG5cbiAgICAgICAgdmFyIHByZWZpeFRleHQgPSBsZWFmU3RhcnQgaW5zdGFuY2VvZiBwYXJjaG1lbnRbXCJUZXh0QmxvdFwiXSA/IGxlYWZTdGFydC52YWx1ZSgpLnNsaWNlKDAsIG9mZnNldFN0YXJ0KSA6ICcnO1xuICAgICAgICB2YXIgc3VmZml4VGV4dCA9IGxlYWZFbmQgaW5zdGFuY2VvZiBwYXJjaG1lbnRbXCJUZXh0QmxvdFwiXSA/IGxlYWZFbmQudmFsdWUoKS5zbGljZShvZmZzZXRFbmQpIDogJyc7XG4gICAgICAgIHZhciBjdXJDb250ZXh0ID0ge1xuICAgICAgICAgIGNvbGxhcHNlZDogcmFuZ2UubGVuZ3RoID09PSAwLFxuICAgICAgICAgIGVtcHR5OiByYW5nZS5sZW5ndGggPT09IDAgJiYgbGluZS5sZW5ndGgoKSA8PSAxLFxuICAgICAgICAgIGZvcm1hdDogX3RoaXM0LnF1aWxsLmdldEZvcm1hdChyYW5nZSksXG4gICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICBwcmVmaXg6IHByZWZpeFRleHQsXG4gICAgICAgICAgc3VmZml4OiBzdWZmaXhUZXh0LFxuICAgICAgICAgIGV2ZW50OiBldnRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICBtYXRjaGVzLnNvbWUoZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICBpZiAoYmluZGluZy5jb2xsYXBzZWQgIT0gbnVsbCAmJiBiaW5kaW5nLmNvbGxhcHNlZCAhPT0gY3VyQ29udGV4dC5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYmluZGluZy5lbXB0eSAhPSBudWxsICYmIGJpbmRpbmcuZW1wdHkgIT09IGN1ckNvbnRleHQuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYmluZGluZy5vZmZzZXQgIT0gbnVsbCAmJiBiaW5kaW5nLm9mZnNldCAhPT0gY3VyQ29udGV4dC5vZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIC8vIGFueSBmb3JtYXQgaXMgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGJpbmRpbmcuZm9ybWF0LmV2ZXJ5KGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjdXJDb250ZXh0LmZvcm1hdFtuYW1lXSA9PSBudWxsO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihiaW5kaW5nLmZvcm1hdCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBhbGwgZm9ybWF0cyBtdXN0IG1hdGNoXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGJpbmRpbmcuZm9ybWF0KS5ldmVyeShmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICBpZiAoYmluZGluZy5mb3JtYXRbbmFtZV0gPT09IHRydWUpIHJldHVybiBjdXJDb250ZXh0LmZvcm1hdFtuYW1lXSAhPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoYmluZGluZy5mb3JtYXRbbmFtZV0gPT09IGZhbHNlKSByZXR1cm4gY3VyQ29udGV4dC5mb3JtYXRbbmFtZV0gPT0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIGxvZGFzaF9pc2VxdWFsX2RlZmF1bHQoKShiaW5kaW5nLmZvcm1hdFtuYW1lXSwgY3VyQ29udGV4dC5mb3JtYXRbbmFtZV0pO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChiaW5kaW5nLnByZWZpeCAhPSBudWxsICYmICFiaW5kaW5nLnByZWZpeC50ZXN0KGN1ckNvbnRleHQucHJlZml4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChiaW5kaW5nLnN1ZmZpeCAhPSBudWxsICYmICFiaW5kaW5nLnN1ZmZpeC50ZXN0KGN1ckNvbnRleHQuc3VmZml4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBoYW5kbGVyUmVzdWx0ID0gYmluZGluZy5oYW5kbGVyLmNhbGwoX3RoaXM0LCByYW5nZSwgY3VyQ29udGV4dCwgYmluZGluZyk7XG4gICAgICAgICAgdmFyIHByZXZlbnRBZnRlckFsbE1hdGNoZXMgPSBoYW5kbGVyUmVzdWx0ID09PSBudWxsIHx8IGhhbmRsZXJSZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhhbmRsZXJSZXN1bHQucHJldmVudEFmdGVyQWxsTWF0Y2hlcztcbiAgICAgICAgICBwcmV2ZW50ZWQgPSBoYW5kbGVyUmVzdWx0ICE9PSB0cnVlIHx8IHByZXZlbnRBZnRlckFsbE1hdGNoZXM7XG4gICAgICAgICAgcmV0dXJuIHByZXZlbnRlZCAmJiAhcHJldmVudEFmdGVyQWxsTWF0Y2hlcztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHByZXZlbnRlZCkge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFpc2VPbktleWRvd25DYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYWlzZU9uS2V5ZG93bkNhbGxiYWNrKGV2ZW50KSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLm9wdGlvbnMub25LZXlkb3duO1xuXG4gICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQmFja3NwYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUJhY2tzcGFjZShyYW5nZSwgY29udGV4dCkge1xuICAgICAgLy8gQ2hlY2sgZm9yIGFzdHJhbCBzeW1ib2xzXG4gICAgICB2YXIgbGVuZ3RoID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0kLy50ZXN0KGNvbnRleHQucHJlZml4KSA/IDIgOiAxO1xuICAgICAgaWYgKHJhbmdlLmluZGV4ID09PSAwIHx8IHRoaXMucXVpbGwuZ2V0TGVuZ3RoKCkgPD0gMSkgcmV0dXJuO1xuICAgICAgdmFyIGZvcm1hdHMgPSB7fTtcblxuICAgICAgdmFyIF90aGlzJHF1aWxsJGdldExpbmUgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgIF90aGlzJHF1aWxsJGdldExpbmUyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkcXVpbGwkZ2V0TGluZSwgMSksXG4gICAgICAgICAgbGluZSA9IF90aGlzJHF1aWxsJGdldExpbmUyWzBdO1xuXG4gICAgICB2YXIgZGVsdGEgPSBuZXcgRGVsdGFfZGVmYXVsdC5hKCkucmV0YWluKHJhbmdlLmluZGV4IC0gbGVuZ3RoKS5kZWxldGUobGVuZ3RoKTtcblxuICAgICAgaWYgKGNvbnRleHQub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIC8vIEFsd2F5cyBkZWxldGluZyBuZXdsaW5lIGhlcmUsIGxlbmd0aCBhbHdheXMgMVxuICAgICAgICB2YXIgX3RoaXMkcXVpbGwkZ2V0TGluZTMgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXggLSAxKSxcbiAgICAgICAgICAgIF90aGlzJHF1aWxsJGdldExpbmU0ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkcXVpbGwkZ2V0TGluZTMsIDEpLFxuICAgICAgICAgICAgcHJldiA9IF90aGlzJHF1aWxsJGdldExpbmU0WzBdO1xuXG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgdmFyIGlzUHJldkxpbmVFbXB0eSA9IHByZXYuc3RhdGljcy5ibG90TmFtZSA9PT0gJ2Jsb2NrJyAmJiBwcmV2Lmxlbmd0aCgpIDw9IDE7XG5cbiAgICAgICAgICBpZiAoIWlzUHJldkxpbmVFbXB0eSkge1xuICAgICAgICAgICAgdmFyIGN1ckZvcm1hdHMgPSBsaW5lLmZvcm1hdHMoKTtcbiAgICAgICAgICAgIHZhciBwcmV2Rm9ybWF0cyA9IHRoaXMucXVpbGwuZ2V0Rm9ybWF0KHJhbmdlLmluZGV4IC0gMSwgMSk7XG4gICAgICAgICAgICBmb3JtYXRzID0gRGVsdGFbXCJBdHRyaWJ1dGVNYXBcIl0uZGlmZihjdXJGb3JtYXRzLCBwcmV2Rm9ybWF0cykgfHwge307XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhmb3JtYXRzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIC8vIGxpbmUubGVuZ3RoKCkgLSAxIHRhcmdldHMgXFxuIGluIGxpbmUsIGFub3RoZXIgLTEgZm9yIG5ld2xpbmUgYmVpbmcgZGVsZXRlZFxuICAgICAgICAgICAgICB2YXIgZm9ybWF0RGVsdGEgPSBuZXcgRGVsdGFfZGVmYXVsdC5hKCkucmV0YWluKHJhbmdlLmluZGV4ICsgbGluZS5sZW5ndGgoKSAtIDIpLnJldGFpbigxLCBmb3JtYXRzKTtcbiAgICAgICAgICAgICAgZGVsdGEgPSBkZWx0YS5jb21wb3NlKGZvcm1hdERlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgdGhpcy5xdWlsbC5mb2N1cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVEZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRGVsZXRlKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAvLyBDaGVjayBmb3IgYXN0cmFsIHN5bWJvbHNcbiAgICAgIHZhciBsZW5ndGggPSAvXltcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vLnRlc3QoY29udGV4dC5zdWZmaXgpID8gMiA6IDE7XG4gICAgICBpZiAocmFuZ2UuaW5kZXggPj0gdGhpcy5xdWlsbC5nZXRMZW5ndGgoKSAtIGxlbmd0aCkgcmV0dXJuO1xuICAgICAgdmFyIGZvcm1hdHMgPSB7fTtcblxuICAgICAgdmFyIF90aGlzJHF1aWxsJGdldExpbmU1ID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgICAgICBfdGhpcyRxdWlsbCRnZXRMaW5lNiA9IF9zbGljZWRUb0FycmF5KF90aGlzJHF1aWxsJGdldExpbmU1LCAxKSxcbiAgICAgICAgICBsaW5lID0gX3RoaXMkcXVpbGwkZ2V0TGluZTZbMF07XG5cbiAgICAgIHZhciBkZWx0YSA9IG5ldyBEZWx0YV9kZWZhdWx0LmEoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpLmRlbGV0ZShsZW5ndGgpO1xuXG4gICAgICBpZiAoY29udGV4dC5vZmZzZXQgPj0gbGluZS5sZW5ndGgoKSAtIDEpIHtcbiAgICAgICAgdmFyIF90aGlzJHF1aWxsJGdldExpbmU3ID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4ICsgMSksXG4gICAgICAgICAgICBfdGhpcyRxdWlsbCRnZXRMaW5lOCA9IF9zbGljZWRUb0FycmF5KF90aGlzJHF1aWxsJGdldExpbmU3LCAxKSxcbiAgICAgICAgICAgIG5leHQgPSBfdGhpcyRxdWlsbCRnZXRMaW5lOFswXTtcblxuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIHZhciBjdXJGb3JtYXRzID0gbGluZS5mb3JtYXRzKCk7XG4gICAgICAgICAgdmFyIG5leHRGb3JtYXRzID0gdGhpcy5xdWlsbC5nZXRGb3JtYXQocmFuZ2UuaW5kZXgsIDEpO1xuICAgICAgICAgIGZvcm1hdHMgPSBEZWx0YVtcIkF0dHJpYnV0ZU1hcFwiXS5kaWZmKGN1ckZvcm1hdHMsIG5leHRGb3JtYXRzKSB8fCB7fTtcblxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhmb3JtYXRzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZWx0YSA9IGRlbHRhLnJldGFpbihuZXh0Lmxlbmd0aCgpIC0gMSkucmV0YWluKDEsIGZvcm1hdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgICB0aGlzLnF1aWxsLmZvY3VzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZURlbGV0ZVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZURlbGV0ZVJhbmdlKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICB0aGlzLnJhaXNlT25LZXlkb3duQ2FsbGJhY2soY29udGV4dC5ldmVudCk7XG4gICAgICBkZWxldGVSYW5nZSh7XG4gICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgcXVpbGw6IHRoaXMucXVpbGxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5xdWlsbC5mb2N1cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVFbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVFbnRlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBsaW5lRm9ybWF0cyA9IE9iamVjdC5rZXlzKGNvbnRleHQuZm9ybWF0KS5yZWR1Y2UoZnVuY3Rpb24gKGZvcm1hdHMsIGZvcm1hdCkge1xuICAgICAgICBpZiAoX3RoaXM1LnF1aWxsLnNjcm9sbC5xdWVyeShmb3JtYXQsIHBhcmNobWVudFtcIlNjb3BlXCJdLkJMT0NLKSAmJiAhQXJyYXkuaXNBcnJheShjb250ZXh0LmZvcm1hdFtmb3JtYXRdKSkge1xuICAgICAgICAgIGZvcm1hdHNbZm9ybWF0XSA9IGNvbnRleHQuZm9ybWF0W2Zvcm1hdF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICAgIH0sIHt9KTtcbiAgICAgIHZhciBkZWx0YSA9IG5ldyBEZWx0YV9kZWZhdWx0LmEoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpLmRlbGV0ZShyYW5nZS5sZW5ndGgpLmluc2VydCgnXFxuJywgbGluZUZvcm1hdHMpO1xuICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggKyAxLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIHRoaXMucXVpbGwuZm9jdXMoKTtcblxuICAgICAgdmFyIF90aGlzJHF1aWxsJGdldExpbmU5ID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4ICsgMSksXG4gICAgICAgICAgX3RoaXMkcXVpbGwkZ2V0TGluZTEwID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkcXVpbGwkZ2V0TGluZTksIDEpLFxuICAgICAgICAgIGxpbmUgPSBfdGhpcyRxdWlsbCRnZXRMaW5lMTBbMF07XG5cbiAgICAgIHZhciBzY3JvbGxDb25maWcgPSBnZXRTY3JvbGxJbnRvVmlld0NvbmZpZyhsaW5lLmRvbU5vZGUpO1xuXG4gICAgICBpZiAoc2Nyb2xsQ29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgIGxpbmUuZG9tTm9kZS5zY3JvbGxJbnRvVmlldyhzY3JvbGxDb25maWcpO1xuICAgICAgfVxuXG4gICAgICBPYmplY3Qua2V5cyhjb250ZXh0LmZvcm1hdCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAobGluZUZvcm1hdHNbbmFtZV0gIT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZXh0LmZvcm1hdFtuYW1lXSkpIHJldHVybjtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdjb2RlJyB8fCBuYW1lID09PSAnbGluaycpIHJldHVybjtcblxuICAgICAgICBfdGhpczUucmFpc2VPbktleWRvd25DYWxsYmFjayhjb250ZXh0LmV2ZW50KTtcblxuICAgICAgICBfdGhpczUucXVpbGwuZm9ybWF0KG5hbWUsIGNvbnRleHQuZm9ybWF0W25hbWVdLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJtYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaChldnQsIGJpbmRpbmcpIHtcbiAgICAgIGlmIChbJ2FsdEtleScsICdjdHJsS2V5JywgJ21ldGFLZXknLCAnc2hpZnRLZXknXS5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhYmluZGluZ1trZXldICE9PSBldnRba2V5XSAmJiBiaW5kaW5nW2tleV0gIT09IG51bGw7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiaW5kaW5nLmtleSA9PT0gS2V5Ym9hcmQubm9ybWFsaXplS2V5TmFtZShldnQpIHx8IGJpbmRpbmcua2V5ID09PSBldnQud2hpY2g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vcm1hbGl6ZUtleU5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShfcmVmMykge1xuICAgICAgdmFyIGtleSA9IF9yZWYzLmtleSxcbiAgICAgICAgICB3aGljaCA9IF9yZWYzLndoaWNoO1xuICAgICAgdmFyIGlzS2V5U3VwcG9ydGVkID0gISFrZXk7XG4gICAgICB2YXIgbm9ybWFsaXplZEtleSA9IGlzS2V5U3VwcG9ydGVkID8ga2V5IDogd2hpY2g7XG5cbiAgICAgIGlmIChub3JtYWxpemVkS2V5KSB7XG4gICAgICAgIGlmIChpc0tleVN1cHBvcnRlZCkge1xuICAgICAgICAgIG5vcm1hbGl6ZWRLZXkgPSBLRVlfTkFNRVNbbm9ybWFsaXplZEtleS50b0xvd2VyQ2FzZSgpXSB8fCBub3JtYWxpemVkS2V5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vcm1hbGl6ZWRLZXkgPSBLRVlfQ09ERVNbbm9ybWFsaXplZEtleV0gfHwgU3RyaW5nLmZyb21DaGFyQ29kZShub3JtYWxpemVkS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9ybWFsaXplZEtleTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gS2V5Ym9hcmQ7XG59KGNvcmVfbW9kdWxlW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxua2V5Ym9hcmRfS2V5Ym9hcmQuREVGQVVMVFMgPSB7XG4gIGJpbmRpbmdzOiB7XG4gICAgYm9sZDogbWFrZUZvcm1hdEhhbmRsZXIoJ2JvbGQnLCA2NiksXG4gICAgaXRhbGljOiBtYWtlRm9ybWF0SGFuZGxlcignaXRhbGljJywgNzMpLFxuICAgIHVuZGVybGluZTogbWFrZUZvcm1hdEhhbmRsZXIoJ3VuZGVybGluZScsIDg1KSxcbiAgICBpbmRlbnQ6IHtcbiAgICAgIC8vIGhpZ2hsaWdodCB0YWIgb3IgdGFiIGF0IGJlZ2lubmluZyBvZiBsaXN0LCBpbmRlbnQgb3IgYmxvY2txdW90ZVxuICAgICAga2V5OiAndGFiJyxcbiAgICAgIGZvcm1hdDogWydibG9ja3F1b3RlJywgJ2luZGVudCcsICdsaXN0J10sXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmNvbGxhcHNlZCAmJiBjb250ZXh0Lm9mZnNldCAhPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdpbmRlbnQnLCAnKzEnLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG91dGRlbnQ6IHtcbiAgICAgIGtleTogJ3RhYicsXG4gICAgICBzaGlmdEtleTogdHJ1ZSxcbiAgICAgIGZvcm1hdDogWydibG9ja3F1b3RlJywgJ2luZGVudCcsICdsaXN0J10sXG4gICAgICAvLyBoaWdobGlnaHQgdGFiIG9yIHRhYiBhdCBiZWdpbm5pbmcgb2YgbGlzdCwgaW5kZW50IG9yIGJsb2NrcXVvdGVcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY29sbGFwc2VkICYmIGNvbnRleHQub2Zmc2V0ICE9PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2luZGVudCcsICctMScsIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5VU0VSKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ291dGRlbnQgYmFja3NwYWNlJzoge1xuICAgICAga2V5OiAnYmFja3NwYWNlJyxcbiAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICAgIHNoaWZ0S2V5OiBudWxsLFxuICAgICAgbWV0YUtleTogbnVsbCxcbiAgICAgIGN0cmxLZXk6IG51bGwsXG4gICAgICBhbHRLZXk6IG51bGwsXG4gICAgICBmb3JtYXQ6IFsnaW5kZW50JywgJ2xpc3QnXSxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuZm9ybWF0LmluZGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoJ2luZGVudCcsICctMScsIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5VU0VSKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmZvcm1hdC5saXN0ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnF1aWxsLmZvcm1hdCgnbGlzdCcsIGZhbHNlLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdpbmRlbnQgY29kZS1ibG9jayc6IG1ha2VDb2RlQmxvY2tIYW5kbGVyKHRydWUpLFxuICAgICdvdXRkZW50IGNvZGUtYmxvY2snOiBtYWtlQ29kZUJsb2NrSGFuZGxlcihmYWxzZSksXG4gICAgJ3JlbW92ZSB0YWInOiB7XG4gICAgICBrZXk6ICd0YWInLFxuICAgICAgc2hpZnRLZXk6IHRydWUsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBwcmVmaXg6IC9cXHQkLyxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UpIHtcbiAgICAgICAgdGhpcy5xdWlsbC5kZWxldGVUZXh0KHJhbmdlLmluZGV4IC0gMSwgMSwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGFiOiB7XG4gICAgICBrZXk6ICd0YWInLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dC5mb3JtYXQudGFibGUpIHJldHVybiB0cnVlO1xuICAgICAgICB0aGlzLnF1aWxsLmhpc3RvcnkuY3V0b2ZmKCk7XG4gICAgICAgIHZhciBkZWx0YSA9IG5ldyBEZWx0YV9kZWZhdWx0LmEoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpLmRlbGV0ZShyYW5nZS5sZW5ndGgpLmluc2VydCgnXFx0Jyk7XG4gICAgICAgIHRoaXMucXVpbGwudXBkYXRlQ29udGVudHMoZGVsdGEsIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5VU0VSKTtcbiAgICAgICAgdGhpcy5xdWlsbC5oaXN0b3J5LmN1dG9mZigpO1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCArIDEsIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5TSUxFTlQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICAnYmxvY2txdW90ZSBlbXB0eSBlbnRlcic6IHtcbiAgICAgIGtleTogJ2VudGVyJyxcbiAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICAgIGZvcm1hdDogWydibG9ja3F1b3RlJ10sXG4gICAgICBlbXB0eTogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMucXVpbGwuZm9ybWF0KCdibG9ja3F1b3RlJywgZmFsc2UsIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdsaXN0IGVtcHR5IGVudGVyJzoge1xuICAgICAga2V5OiAnZW50ZXInLFxuICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgZm9ybWF0OiBbJ2xpc3QnXSxcbiAgICAgIGVtcHR5OiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgZm9ybWF0cyA9IHtcbiAgICAgICAgICBsaXN0OiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb250ZXh0LmZvcm1hdC5pbmRlbnQpIHtcbiAgICAgICAgICBmb3JtYXRzLmluZGVudCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5xdWlsbC5mb3JtYXRMaW5lKHJhbmdlLmluZGV4LCByYW5nZS5sZW5ndGgsIGZvcm1hdHMsIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdjaGVja2xpc3QgZW50ZXInOiB7XG4gICAgICBrZXk6ICdlbnRlcicsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBmb3JtYXQ6IHtcbiAgICAgICAgbGlzdDogJ2NoZWNrZWQnXG4gICAgICB9LFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSkge1xuICAgICAgICB2YXIgX3RoaXMkcXVpbGwkZ2V0TGluZTExID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgIF90aGlzJHF1aWxsJGdldExpbmUxMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJHF1aWxsJGdldExpbmUxMSwgMiksXG4gICAgICAgICAgICBsaW5lID0gX3RoaXMkcXVpbGwkZ2V0TGluZTEyWzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3RoaXMkcXVpbGwkZ2V0TGluZTEyWzFdO1xuXG4gICAgICAgIHZhciBmb3JtYXRzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBsaW5lLmZvcm1hdHMoKSksIHt9LCB7XG4gICAgICAgICAgbGlzdDogJ2NoZWNrZWQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBkZWx0YSA9IG5ldyBEZWx0YV9kZWZhdWx0LmEoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpLmluc2VydCgnXFxuJywgZm9ybWF0cykucmV0YWluKGxpbmUubGVuZ3RoKCkgLSBvZmZzZXQgLSAxKS5yZXRhaW4oMSwge1xuICAgICAgICAgIGxpc3Q6ICd1bmNoZWNrZWQnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgMSwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICAgIHRoaXMucXVpbGwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdoZWFkZXIgZW50ZXInOiB7XG4gICAgICBrZXk6ICdlbnRlcicsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBmb3JtYXQ6IFsnaGVhZGVyJ10sXG4gICAgICBzdWZmaXg6IC9eJC8sXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyRxdWlsbCRnZXRMaW5lMTMgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgICAgX3RoaXMkcXVpbGwkZ2V0TGluZTE0ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkcXVpbGwkZ2V0TGluZTEzLCAyKSxcbiAgICAgICAgICAgIGxpbmUgPSBfdGhpcyRxdWlsbCRnZXRMaW5lMTRbMF0sXG4gICAgICAgICAgICBvZmZzZXQgPSBfdGhpcyRxdWlsbCRnZXRMaW5lMTRbMV07XG5cbiAgICAgICAgdmFyIGRlbHRhID0gbmV3IERlbHRhX2RlZmF1bHQuYSgpLnJldGFpbihyYW5nZS5pbmRleCkuaW5zZXJ0KCdcXG4nLCBjb250ZXh0LmZvcm1hdCkucmV0YWluKGxpbmUubGVuZ3RoKCkgLSBvZmZzZXQgLSAxKS5yZXRhaW4oMSwge1xuICAgICAgICAgIGhlYWRlcjogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCArIDEsIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5TSUxFTlQpO1xuICAgICAgICB0aGlzLnF1aWxsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnbGlzdCBhdXRvZmlsbCc6IHtcbiAgICAgIGtleTogJ3NwYWNlJyxcbiAgICAgIHNoaWZ0S2V5OiBudWxsLFxuICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgZm9ybWF0OiB7XG4gICAgICAgICdjb2RlLWJsb2NrJzogZmFsc2UsXG4gICAgICAgIGJsb2NrcXVvdGU6IGZhbHNlLFxuICAgICAgICB0YWJsZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBwcmVmaXg6IC9eXFxzKj8oXFxkK1xcLnwtfFxcKnxcXFsgP1xcXXxcXFt4XFxdKSQvLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5xdWlsbC5zY3JvbGwucXVlcnkoJ2xpc3QnKSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbnRleHQucHJlZml4Lmxlbmd0aDtcblxuICAgICAgICB2YXIgX3RoaXMkcXVpbGwkZ2V0TGluZTE1ID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgIF90aGlzJHF1aWxsJGdldExpbmUxNiA9IF9zbGljZWRUb0FycmF5KF90aGlzJHF1aWxsJGdldExpbmUxNSwgMiksXG4gICAgICAgICAgICBsaW5lID0gX3RoaXMkcXVpbGwkZ2V0TGluZTE2WzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3RoaXMkcXVpbGwkZ2V0TGluZTE2WzFdO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPiBsZW5ndGgpIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgc3dpdGNoIChjb250ZXh0LnByZWZpeC50cmltKCkpIHtcbiAgICAgICAgICBjYXNlICdbXSc6XG4gICAgICAgICAgY2FzZSAnWyBdJzpcbiAgICAgICAgICAgIHZhbHVlID0gJ3VuY2hlY2tlZCc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1t4XSc6XG4gICAgICAgICAgICB2YWx1ZSA9ICdjaGVja2VkJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICB2YWx1ZSA9ICdidWxsZXQnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFsdWUgPSAnb3JkZXJlZCc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnF1aWxsLmluc2VydFRleHQocmFuZ2UuaW5kZXgsICcgJywgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB0aGlzLnF1aWxsLmhpc3RvcnkuY3V0b2ZmKCk7XG4gICAgICAgIHZhciBkZWx0YSA9IG5ldyBEZWx0YV9kZWZhdWx0LmEoKS5yZXRhaW4ocmFuZ2UuaW5kZXggLSBvZmZzZXQpLmRlbGV0ZShsZW5ndGggKyAxKS5yZXRhaW4obGluZS5sZW5ndGgoKSAtIDIgLSBvZmZzZXQpLnJldGFpbigxLCB7XG4gICAgICAgICAgbGlzdDogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmFpc2VPbktleWRvd25DYWxsYmFjayhjb250ZXh0LmV2ZW50KTtcbiAgICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgICB0aGlzLnF1aWxsLmhpc3RvcnkuY3V0b2ZmKCk7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4IC0gbGVuZ3RoLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2NvZGUgZXhpdCc6IHtcbiAgICAgIGtleTogJ2VudGVyJyxcbiAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICAgIGZvcm1hdDogWydjb2RlLWJsb2NrJ10sXG4gICAgICBwcmVmaXg6IC9eJC8sXG4gICAgICBzdWZmaXg6IC9eXFxzKiQvLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSkge1xuICAgICAgICB2YXIgX3RoaXMkcXVpbGwkZ2V0TGluZTE3ID0gdGhpcy5xdWlsbC5nZXRMaW5lKHJhbmdlLmluZGV4KSxcbiAgICAgICAgICAgIF90aGlzJHF1aWxsJGdldExpbmUxOCA9IF9zbGljZWRUb0FycmF5KF90aGlzJHF1aWxsJGdldExpbmUxNywgMiksXG4gICAgICAgICAgICBsaW5lID0gX3RoaXMkcXVpbGwkZ2V0TGluZTE4WzBdLFxuICAgICAgICAgICAgb2Zmc2V0ID0gX3RoaXMkcXVpbGwkZ2V0TGluZTE4WzFdO1xuXG4gICAgICAgIHZhciBudW1MaW5lcyA9IDI7XG4gICAgICAgIHZhciBjdXIgPSBsaW5lO1xuXG4gICAgICAgIHdoaWxlIChjdXIgIT0gbnVsbCAmJiBjdXIubGVuZ3RoKCkgPD0gMSAmJiBjdXIuZm9ybWF0cygpWydjb2RlLWJsb2NrJ10pIHtcbiAgICAgICAgICBjdXIgPSBjdXIucHJldjtcbiAgICAgICAgICBudW1MaW5lcyAtPSAxOyAvLyBSZXF1aXNpdGUgcHJldiBsaW5lcyBhcmUgZW1wdHlcblxuICAgICAgICAgIGlmIChudW1MaW5lcyA8PSAwKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBuZXcgRGVsdGFfZGVmYXVsdC5hKCkucmV0YWluKHJhbmdlLmluZGV4ICsgbGluZS5sZW5ndGgoKSAtIG9mZnNldCAtIDIpLnJldGFpbigxLCB7XG4gICAgICAgICAgICAgICdjb2RlLWJsb2NrJzogbnVsbFxuICAgICAgICAgICAgfSkuZGVsZXRlKDEpO1xuICAgICAgICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggLSAxLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdlbWJlZCBsZWZ0JzogbWFrZUVtYmVkQXJyb3dIYW5kbGVyKCdsZWZ0QXJyb3cnLCBmYWxzZSksXG4gICAgJ2VtYmVkIGxlZnQgc2hpZnQnOiBtYWtlRW1iZWRBcnJvd0hhbmRsZXIoJ2xlZnRBcnJvdycsIHRydWUpLFxuICAgICdlbWJlZCByaWdodCc6IG1ha2VFbWJlZEFycm93SGFuZGxlcigncmlnaHRBcnJvdycsIGZhbHNlKSxcbiAgICAnZW1iZWQgcmlnaHQgc2hpZnQnOiBtYWtlRW1iZWRBcnJvd0hhbmRsZXIoJ3JpZ2h0QXJyb3cnLCB0cnVlKVxuICB9XG59O1xuXG5mdW5jdGlvbiBtYWtlQ29kZUJsb2NrSGFuZGxlcihpbmRlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXk6ICd0YWInLFxuICAgIHNoaWZ0S2V5OiAhaW5kZW50LFxuICAgIGZvcm1hdDoge1xuICAgICAgJ2NvZGUtYmxvY2snOiB0cnVlXG4gICAgfSxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlKSB7XG4gICAgICB2YXIgQ29kZUJsb2NrID0gdGhpcy5xdWlsbC5zY3JvbGwucXVlcnkoJ2NvZGUtYmxvY2snKTtcbiAgICAgIHZhciBsaW5lcyA9IHJhbmdlLmxlbmd0aCA9PT0gMCA/IHRoaXMucXVpbGwuZ2V0TGluZXMocmFuZ2UuaW5kZXgsIDEpIDogdGhpcy5xdWlsbC5nZXRMaW5lcyhyYW5nZSk7XG4gICAgICB2YXIgaW5kZXggPSByYW5nZS5pbmRleCxcbiAgICAgICAgICBsZW5ndGggPSByYW5nZS5sZW5ndGg7XG4gICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgICAgIGlmIChpbmRlbnQpIHtcbiAgICAgICAgICBsaW5lLmluc2VydEF0KDAsIENvZGVCbG9jay5UQUIpO1xuXG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGluZGV4ICs9IENvZGVCbG9jay5UQUIubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gQ29kZUJsb2NrLlRBQi5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxpbmUuZG9tTm9kZS50ZXh0Q29udGVudC5pbmRleE9mKENvZGVCbG9jay5UQUIpID09PSAwKSB7XG4gICAgICAgICAgbGluZS5kZWxldGVBdCgwLCBDb2RlQmxvY2suVEFCLmxlbmd0aCk7XG5cbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgaW5kZXggLT0gQ29kZUJsb2NrLlRBQi5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlbmd0aCAtPSBDb2RlQmxvY2suVEFCLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5xdWlsbC51cGRhdGUoY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oaW5kZXgsIGxlbmd0aCwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlNJTEVOVCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlRW1iZWRBcnJvd0hhbmRsZXIoa2V5LCBzaGlmdEtleSkge1xuICB2YXIgX3JlZjQ7XG5cbiAgdmFyIHdoZXJlID0ga2V5ID09PSAnbGVmdEFycm93JyA/ICdwcmVmaXgnIDogJ3N1ZmZpeCc7XG4gIHJldHVybiBfcmVmNCA9IHtcbiAgICBrZXk6IGtleSxcbiAgICBzaGlmdEtleTogc2hpZnRLZXksXG4gICAgYWx0S2V5OiBudWxsXG4gIH0sIF9kZWZpbmVQcm9wZXJ0eShfcmVmNCwgd2hlcmUsIC9eJC8pLCBfZGVmaW5lUHJvcGVydHkoX3JlZjQsIFwiaGFuZGxlclwiLCBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlKSB7XG4gICAgdmFyIGluZGV4ID0gcmFuZ2UuaW5kZXg7XG5cbiAgICBpZiAoa2V5ID09PSAncmlnaHRBcnJvdycpIHtcbiAgICAgIGluZGV4ICs9IHJhbmdlLmxlbmd0aCArIDE7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJHF1aWxsJGdldExlYWYgPSB0aGlzLnF1aWxsLmdldExlYWYoaW5kZXgpLFxuICAgICAgICBfdGhpcyRxdWlsbCRnZXRMZWFmMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJHF1aWxsJGdldExlYWYsIDEpLFxuICAgICAgICBsZWFmID0gX3RoaXMkcXVpbGwkZ2V0TGVhZjJbMF07XG5cbiAgICBpZiAoIShsZWFmIGluc3RhbmNlb2YgcGFyY2htZW50W1wiRW1iZWRCbG90XCJdKSkgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAoa2V5ID09PSAnbGVmdEFycm93Jykge1xuICAgICAgaWYgKHNoaWZ0S2V5KSB7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4IC0gMSwgcmFuZ2UubGVuZ3RoICsgMSwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggLSAxLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaGlmdEtleSkge1xuICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXgsIHJhbmdlLmxlbmd0aCArIDEsIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5VU0VSKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggKyByYW5nZS5sZW5ndGggKyAxLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KSwgX3JlZjQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VGb3JtYXRIYW5kbGVyKGZvcm1hdCwgd2hpY2gpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGZvcm1hdFswXSxcbiAgICB3aGljaDogd2hpY2gsXG4gICAgc2hvcnRLZXk6IHRydWUsXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSwgY29udGV4dCkge1xuICAgICAgdGhpcy5xdWlsbC5mb3JtYXQoZm9ybWF0LCAhY29udGV4dC5mb3JtYXRbZm9ybWF0XSwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJldmVudEFmdGVyQWxsTWF0Y2hlczogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShiaW5kaW5nKSB7XG4gIGlmICh0eXBlb2YgYmluZGluZyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGJpbmRpbmcgPT09ICdudW1iZXInKSB7XG4gICAgYmluZGluZyA9IHtcbiAgICAgIGtleTogYmluZGluZ1xuICAgIH07XG4gIH0gZWxzZSBpZiAoX3R5cGVvZihiaW5kaW5nKSA9PT0gJ29iamVjdCcpIHtcbiAgICBiaW5kaW5nID0gbG9kYXNoX2Nsb25lZGVlcF9kZWZhdWx0KCkoYmluZGluZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoYmluZGluZy5zaG9ydEtleSkge1xuICAgIGJpbmRpbmdbU0hPUlRLRVldID0gYmluZGluZy5zaG9ydEtleTtcbiAgICBkZWxldGUgYmluZGluZy5zaG9ydEtleTtcbiAgfVxuXG4gIHJldHVybiBiaW5kaW5nO1xufVxuXG5mdW5jdGlvbiBkZWxldGVSYW5nZShfcmVmNSkge1xuICB2YXIgcXVpbGwgPSBfcmVmNS5xdWlsbCxcbiAgICAgIHJhbmdlID0gX3JlZjUucmFuZ2U7XG4gIHZhciBsaW5lcyA9IHF1aWxsLmdldExpbmVzKHJhbmdlKTtcbiAgdmFyIGZvcm1hdHMgPSB7fTtcblxuICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgIHZhciBmaXJzdEZvcm1hdHMgPSBsaW5lc1swXS5mb3JtYXRzKCk7XG4gICAgdmFyIGxhc3RGb3JtYXRzID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0uZm9ybWF0cygpO1xuICAgIGZvcm1hdHMgPSBEZWx0YVtcIkF0dHJpYnV0ZU1hcFwiXS5kaWZmKGxhc3RGb3JtYXRzLCBmaXJzdEZvcm1hdHMpIHx8IHt9O1xuICB9XG5cbiAgcXVpbGwuZGVsZXRlVGV4dChyYW5nZSwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuXG4gIGlmIChPYmplY3Qua2V5cyhmb3JtYXRzKS5sZW5ndGggPiAwKSB7XG4gICAgcXVpbGwuZm9ybWF0TGluZShyYW5nZS5pbmRleCwgMSwgZm9ybWF0cywgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICB9XG5cbiAgcXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4LCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuU0lMRU5UKTtcbn1cblxuXG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTMpO1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xuXG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIHN5bWJvbEZvciA9IFN5bWJvbCAmJiBTeW1ib2xbJ2ZvciddO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sIDogU3ltYm9sICYmIFN5bWJvbC53aXRob3V0U2V0dGVyIHx8IHVpZDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhc093bihXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpIHx8ICEoTkFUSVZFX1NZTUJPTCB8fCB0eXBlb2YgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID09ICdzdHJpbmcnKSkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICdTeW1ib2wuJyArIG5hbWU7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzT3duKFN5bWJvbCwgbmFtZSkpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbFtuYW1lXTtcbiAgICB9IGVsc2UgaWYgKFVTRV9TWU1CT0xfQVNfVUlEICYmIHN5bWJvbEZvcikge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gc3ltYm9sRm9yKGRlc2NyaXB0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gIH0gcmV0dXJuIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ2xpcGJvYXJkOyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBtYXRjaEF0dHJpYnV0b3IgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBtYXRjaEJsb3QgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBtYXRjaE5ld2xpbmUgKi9cbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydCBtYXRjaFRleHQgKi9cbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJhdmVyc2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhcHBseUZvcm1hdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlbHRhRW5kc1dpdGg7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocXVpbGxfZGVsdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ibG90c19ibG9ja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29yZV9xdWlsbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29yZV9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb3JlX21vZHVsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Zvcm1hdHNfYWxpZ25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3JtYXRzX2JhY2tncm91bmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3JtYXRzX2NvZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3JtYXRzX2NvbG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm9ybWF0c19kaXJlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm9ybWF0c19mb250X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Zvcm1hdHNfc2l6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9rZXlib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jYXBpdGFsaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGRlYnVnID0gT2JqZWN0KF9jb3JlX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSgncXVpbGw6Y2xpcGJvYXJkJyk7XG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBURVhUX05PREUgPSAzO1xudmFyIENMSVBCT0FSRF9DT05GSUcgPSBbW1RFWFRfTk9ERSwgbWF0Y2hUZXh0XSwgW1RFWFRfTk9ERSwgbWF0Y2hOZXdsaW5lXSwgWydicicsIG1hdGNoQnJlYWtdLCBbRUxFTUVOVF9OT0RFLCBtYXRjaE5ld2xpbmVdLCBbRUxFTUVOVF9OT0RFLCBtYXRjaEJsb3RdLCBbRUxFTUVOVF9OT0RFLCBtYXRjaEF0dHJpYnV0b3JdLCBbRUxFTUVOVF9OT0RFLCBtYXRjaFN0eWxlc10sIFsnbGknLCBtYXRjaEluZGVudF0sIFsnb2wsIHVsJywgbWF0Y2hMaXN0XSwgWydwcmUnLCBtYXRjaENvZGVCbG9ja10sIFsnYicsIG1hdGNoQWxpYXMuYmluZChtYXRjaEFsaWFzLCAnYm9sZCcpXSwgWydpJywgbWF0Y2hBbGlhcy5iaW5kKG1hdGNoQWxpYXMsICdpdGFsaWMnKV0sIFsnc3RyaWtlJywgbWF0Y2hBbGlhcy5iaW5kKG1hdGNoQWxpYXMsICdzdHJpa2UnKV0sIFsnc3R5bGUnLCBtYXRjaElnbm9yZV1dO1xudmFyIEhUTUxfVEVYVF9NQVRDSEVSUyA9IFttYXRjaFRleHQsIG1hdGNoTmV3bGluZV07XG52YXIgQVRUUklCVVRFX0FUVFJJQlVUT1JTID0gW19mb3JtYXRzX2FsaWduX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogQWxpZ25BdHRyaWJ1dGUgKi8gXCJhXCJdLCBfZm9ybWF0c19kaXJlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogRGlyZWN0aW9uQXR0cmlidXRlICovIFwiYVwiXV0ucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBhdHRyKSB7XG4gIG1lbW9bYXR0ci5rZXlOYW1lXSA9IGF0dHI7XG4gIHJldHVybiBtZW1vO1xufSwge30pO1xudmFyIFNUWUxFX0FUVFJJQlVUT1JTID0gW19mb3JtYXRzX2FsaWduX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogQWxpZ25TdHlsZSAqLyBcImNcIl0sIF9mb3JtYXRzX2JhY2tncm91bmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBCYWNrZ3JvdW5kU3R5bGUgKi8gXCJiXCJdLCBfZm9ybWF0c19jb2xvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fWy8qIENvbG9yU3R5bGUgKi8gXCJjXCJdLCBfZm9ybWF0c19kaXJlY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogRGlyZWN0aW9uU3R5bGUgKi8gXCJjXCJdLCBfZm9ybWF0c19mb250X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fWy8qIEZvbnRTdHlsZSAqLyBcImJcIl0sIF9mb3JtYXRzX3NpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bLyogU2l6ZVN0eWxlICovIFwiYlwiXV0ucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBhdHRyKSB7XG4gIG1lbW9bYXR0ci5rZXlOYW1lXSA9IGF0dHI7XG4gIHJldHVybiBtZW1vO1xufSwge30pO1xuXG52YXIgQ2xpcGJvYXJkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTW9kdWxlKSB7XG4gIF9pbmhlcml0cyhDbGlwYm9hcmQsIF9Nb2R1bGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQ2xpcGJvYXJkKTtcblxuICBmdW5jdGlvbiBDbGlwYm9hcmQocXVpbGwsIG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnMkdGFibGVCbG90cztcblxuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGlwYm9hcmQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5xdWlsbC5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ2NvcHknLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIF90aGlzLm9uQ2FwdHVyZUNvcHkoZSwgZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMucXVpbGwucm9vdC5hZGRFdmVudExpc3RlbmVyKCdjdXQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIF90aGlzLm9uQ2FwdHVyZUNvcHkoZSwgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5xdWlsbC5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgX3RoaXMub25DYXB0dXJlUGFzdGUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuXG4gICAgX3RoaXMubWF0Y2hlcnMgPSBbXTtcbiAgICBfdGhpcy50YWJsZUJsb3RzID0gKF9vcHRpb25zJHRhYmxlQmxvdHMgPSBvcHRpb25zLnRhYmxlQmxvdHMpICE9PSBudWxsICYmIF9vcHRpb25zJHRhYmxlQmxvdHMgIT09IHZvaWQgMCA/IF9vcHRpb25zJHRhYmxlQmxvdHMgOiBbXTtcbiAgICBDTElQQk9BUkRfQ09ORklHLmNvbmNhdChfdGhpcy5vcHRpb25zLm1hdGNoZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICBzZWxlY3RvciA9IF9yZWYyWzBdLFxuICAgICAgICAgIG1hdGNoZXIgPSBfcmVmMlsxXTtcblxuICAgICAgX3RoaXMuYWRkTWF0Y2hlcihzZWxlY3RvciwgbWF0Y2hlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENsaXBib2FyZCwgW3tcbiAgICBrZXk6IFwiYWRkTWF0Y2hlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNYXRjaGVyKHNlbGVjdG9yLCBtYXRjaGVyKSB7XG4gICAgICB0aGlzLm1hdGNoZXJzLnB1c2goW3NlbGVjdG9yLCBtYXRjaGVyXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFRhYmxlQmxvdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUYWJsZUJsb3QoYmxvdE5hbWUpIHtcbiAgICAgIHRoaXMudGFibGVCbG90cy5wdXNoKGJsb3ROYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udmVydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0KF9yZWYzKSB7XG4gICAgICB2YXIgaHRtbCA9IF9yZWYzLmh0bWwsXG4gICAgICAgICAgdGV4dCA9IF9yZWYzLnRleHQ7XG4gICAgICB2YXIgZm9ybWF0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIGlmIChmb3JtYXRzW19mb3JtYXRzX2NvZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiY1wiXS5ibG90TmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSgpLmluc2VydCh0ZXh0LCBfZGVmaW5lUHJvcGVydHkoe30sIF9mb3JtYXRzX2NvZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiY1wiXS5ibG90TmFtZSwgZm9ybWF0c1tfZm9ybWF0c19jb2RlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bLyogZGVmYXVsdCAqLyBcImNcIl0uYmxvdE5hbWVdKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBodG1sID8gdGhpcy5hcHBseU1hdGNoZXJzKGh0bWwsIGZvcm1hdHMpIDogdGhpcy5hcHBseVRleHRNYXRjaGVycyh0ZXh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlUZXh0TWF0Y2hlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlUZXh0TWF0Y2hlcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuXG4gICAgICBpZiAodGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hlcnMgPSB0aGlzLnByZXBhcmVUZXh0TWF0Y2hpbmcoKTtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5xdWlsbC5yb290Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgIHZhciBub2RlID0gZWxlbWVudC5jaGlsZE5vZGVzWzBdO1xuICAgICAgcmV0dXJuIG1hdGNoZXJzLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIG1hdGNoZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIobm9kZSwgZGVsdGEsIF90aGlzMi5xdWlsbC5zY3JvbGwpO1xuICAgICAgfSwgbmV3IHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseU1hdGNoZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5TWF0Y2hlcnMoaHRtbCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtYXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGh0bWwsICd0ZXh0L2h0bWwnKTtcbiAgICAgIHZhciBjb250YWluZXIgPSBkb2MuYm9keTtcbiAgICAgIHZhciBub2RlTWF0Y2hlcyA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICAgIHZhciBfdGhpcyRwcmVwYXJlTWF0Y2hpbmcgPSB0aGlzLnByZXBhcmVNYXRjaGluZyhjb250YWluZXIsIG5vZGVNYXRjaGVzKSxcbiAgICAgICAgICBfdGhpcyRwcmVwYXJlTWF0Y2hpbmcyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkcHJlcGFyZU1hdGNoaW5nLCAyKSxcbiAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMgPSBfdGhpcyRwcmVwYXJlTWF0Y2hpbmcyWzBdLFxuICAgICAgICAgIHRleHRNYXRjaGVycyA9IF90aGlzJHByZXBhcmVNYXRjaGluZzJbMV07XG5cbiAgICAgIHZhciBkZWx0YSA9IHRyYXZlcnNlKHRoaXMucXVpbGwuc2Nyb2xsLCBjb250YWluZXIsIGVsZW1lbnRNYXRjaGVycywgdGV4dE1hdGNoZXJzLCBub2RlTWF0Y2hlcyk7IC8vIFJlbW92ZSB0cmFpbGluZyBuZXdsaW5lXG5cbiAgICAgIGlmIChkZWx0YUVuZHNXaXRoKGRlbHRhLCAnXFxuJykgJiYgKGRlbHRhLm9wc1tkZWx0YS5vcHMubGVuZ3RoIC0gMV0uYXR0cmlidXRlcyA9PSBudWxsIHx8IE9iamVjdC52YWx1ZXMoZm9ybWF0cykuc29tZShmdW5jdGlvbiAoYmxvdE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy50YWJsZUJsb3RzLmluY2x1ZGVzKGJsb3ROYW1lKTtcbiAgICAgIH0pKSkge1xuICAgICAgICByZXR1cm4gZGVsdGEuY29tcG9zZShuZXcgcXVpbGxfZGVsdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEoKS5yZXRhaW4oZGVsdGEubGVuZ3RoKCkgLSAxKS5kZWxldGUoMSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhbmdlcm91c2x5UGFzdGVIVE1MXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhbmdlcm91c2x5UGFzdGVIVE1MKGluZGV4LCBodG1sKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBfY29yZV9xdWlsbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNvdXJjZXMuQVBJO1xuXG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLmNvbnZlcnQoe1xuICAgICAgICAgIGh0bWw6IGluZGV4LFxuICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnF1aWxsLnNldENvbnRlbnRzKGRlbHRhLCBodG1sKTtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oMCwgX2NvcmVfcXVpbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGFzdGUgPSB0aGlzLmNvbnZlcnQoe1xuICAgICAgICAgIGh0bWw6IGh0bWwsXG4gICAgICAgICAgdGV4dDogJydcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVpbGwudXBkYXRlQ29udGVudHMobmV3IHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKCkucmV0YWluKGluZGV4KS5jb25jYXQocGFzdGUpLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihpbmRleCArIHBhc3RlLmxlbmd0aCgpLCBfY29yZV9xdWlsbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25DYXB0dXJlQ29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNhcHR1cmVDb3B5KGUpIHtcbiAgICAgIHZhciBpc0N1dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAgIGlmIChlLmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkcXVpbGwkc2VsZWN0aW9uID0gdGhpcy5xdWlsbC5zZWxlY3Rpb24uZ2V0UmFuZ2UoKSxcbiAgICAgICAgICBfdGhpcyRxdWlsbCRzZWxlY3Rpb24yID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkcXVpbGwkc2VsZWN0aW9uLCAxKSxcbiAgICAgICAgICByYW5nZSA9IF90aGlzJHF1aWxsJHNlbGVjdGlvbjJbMF07XG5cbiAgICAgIGlmIChyYW5nZSA9PSBudWxsKSByZXR1cm47XG5cbiAgICAgIHZhciBfdGhpcyRvbkNvcHkgPSB0aGlzLm9uQ29weShyYW5nZSwgaXNDdXQpLFxuICAgICAgICAgIGh0bWwgPSBfdGhpcyRvbkNvcHkuaHRtbCxcbiAgICAgICAgICB0ZXh0ID0gX3RoaXMkb25Db3B5LnRleHQ7XG5cbiAgICAgIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgdGV4dCk7XG4gICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9odG1sJywgaHRtbCk7XG5cbiAgICAgIGlmIChpc0N1dCkge1xuICAgICAgICB0aGlzLnJhaXNlQ2FsbGJhY2soJ29uQ3V0JywgZSk7XG4gICAgICAgIE9iamVjdChfa2V5Ym9hcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bLyogZGVsZXRlUmFuZ2UgKi8gXCJjXCJdKSh7XG4gICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgIHF1aWxsOiB0aGlzLnF1aWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkNhcHR1cmVQYXN0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNhcHR1cmVQYXN0ZShlKSB7XG4gICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkIHx8ICF0aGlzLnF1aWxsLmlzRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yYWlzZUNhbGxiYWNrKCdvblBhc3RlJywgZSk7XG5cbiAgICAgIGlmIChlLmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnF1aWxsLmdldFNlbGVjdGlvbih0cnVlKTtcblxuICAgICAgaWYgKHJhbmdlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaHRtbCA9IGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L2h0bWwnKTtcbiAgICAgIHZhciBmaWxlcyA9IEFycmF5LmZyb20oZS5jbGlwYm9hcmREYXRhLmZpbGVzIHx8IFtdKTtcblxuICAgICAgaWYgKCFodG1sICYmIGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5xdWlsbC51cGxvYWRlci51cGxvYWQocmFuZ2UsIGZpbGVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaHRtbCAmJiBmaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBfRE9NUGFyc2VyJHBhcnNlRnJvbVMgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGh0bWwsICd0ZXh0L2h0bWwnKSxcbiAgICAgICAgICAgIGJvZHkgPSBfRE9NUGFyc2VyJHBhcnNlRnJvbVMuYm9keTtcblxuICAgICAgICB2YXIgZG9jdW1lbnRDb250YWluc0ltYWdlID0gYm9keS5jaGlsZEVsZW1lbnRDb3VudCA9PT0gMSAmJiBib2R5LmZpcnN0RWxlbWVudENoaWxkLnRhZ05hbWUgPT09ICdJTUcnO1xuXG4gICAgICAgIGlmIChkb2N1bWVudENvbnRhaW5zSW1hZ2UpIHtcbiAgICAgICAgICB0aGlzLnF1aWxsLnVwbG9hZGVyLnVwbG9hZChyYW5nZSwgZmlsZXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9IGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG4gICAgICB0aGlzLm9uUGFzdGUocmFuZ2UsIHtcbiAgICAgICAgaHRtbDogaHRtbCxcbiAgICAgICAgdGV4dDogdGV4dFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhaXNlQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmFpc2VDYWxsYmFjayhuYW1lLCBldmVudCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5vcHRpb25zW25hbWVdO1xuXG4gICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Db3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ29weShyYW5nZSkge1xuICAgICAgdmFyIHRleHQgPSB0aGlzLnF1aWxsLmdldFRleHQocmFuZ2UpO1xuICAgICAgdmFyIGh0bWwgPSB0aGlzLnF1aWxsLmdldFNlbWFudGljSFRNTChyYW5nZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBodG1sOiBodG1sLFxuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvblBhc3RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGFzdGUocmFuZ2UsIF9yZWY0KSB7XG4gICAgICB2YXIgdGV4dCA9IF9yZWY0LnRleHQsXG4gICAgICAgICAgaHRtbCA9IF9yZWY0Lmh0bWw7XG4gICAgICB2YXIgZm9ybWF0cyA9IHRoaXMucXVpbGwuZ2V0Rm9ybWF0KHJhbmdlLmluZGV4KTtcbiAgICAgIHZhciBwYXN0ZWREZWx0YSA9IHRoaXMuY29udmVydCh7XG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGh0bWw6IGh0bWxcbiAgICAgIH0sIGZvcm1hdHMpO1xuICAgICAgZGVidWcubG9nKCdvblBhc3RlJywgcGFzdGVkRGVsdGEsIHtcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgaHRtbDogaHRtbFxuICAgICAgfSk7XG4gICAgICB2YXIgZGVsdGEgPSBuZXcgcXVpbGxfZGVsdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEoKS5yZXRhaW4ocmFuZ2UuaW5kZXgpLmRlbGV0ZShyYW5nZS5sZW5ndGgpLmNvbmNhdChwYXN0ZWREZWx0YSk7XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBfY29yZV9xdWlsbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNvdXJjZXMuVVNFUik7IC8vIHJhbmdlLmxlbmd0aCBjb250cmlidXRlcyB0byBkZWx0YS5sZW5ndGgoKVxuXG4gICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihkZWx0YS5sZW5ndGgoKSAtIHJhbmdlLmxlbmd0aCwgX2NvcmVfcXVpbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zb3VyY2VzLlNJTEVOVCk7XG4gICAgICB0aGlzLnF1aWxsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZXBhcmVNYXRjaGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJlTWF0Y2hpbmcoY29udGFpbmVyLCBub2RlTWF0Y2hlcykge1xuICAgICAgdmFyIGVsZW1lbnRNYXRjaGVycyA9IFtdO1xuICAgICAgdmFyIHRleHRNYXRjaGVycyA9IFtdO1xuICAgICAgdGhpcy5tYXRjaGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIHZhciBfcGFpciA9IF9zbGljZWRUb0FycmF5KHBhaXIsIDIpLFxuICAgICAgICAgICAgc2VsZWN0b3IgPSBfcGFpclswXSxcbiAgICAgICAgICAgIG1hdGNoZXIgPSBfcGFpclsxXTtcblxuICAgICAgICBzd2l0Y2ggKHNlbGVjdG9yKSB7XG4gICAgICAgICAgY2FzZSBURVhUX05PREU6XG4gICAgICAgICAgICB0ZXh0TWF0Y2hlcnMucHVzaChtYXRjaGVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBFTEVNRU5UX05PREU6XG4gICAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMucHVzaChtYXRjaGVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIEFycmF5LmZyb20oY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlTWF0Y2hlcy5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IG5vZGVNYXRjaGVzLmdldChub2RlKTtcbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gobWF0Y2hlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZU1hdGNoZXMuc2V0KG5vZGUsIFttYXRjaGVyXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtlbGVtZW50TWF0Y2hlcnMsIHRleHRNYXRjaGVyc107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZXBhcmVUZXh0TWF0Y2hpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZVRleHRNYXRjaGluZygpIHtcbiAgICAgIHZhciB0ZXh0TWF0Y2hlcnMgPSBbbWF0Y2hQbGFpblRleHRdO1xuICAgICAgdGhpcy5tYXRjaGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIHZhciBfcGFpcjIgPSBfc2xpY2VkVG9BcnJheShwYWlyLCAyKSxcbiAgICAgICAgICAgIHNlbGVjdG9yID0gX3BhaXIyWzBdLFxuICAgICAgICAgICAgbWF0Y2hlciA9IF9wYWlyMlsxXTtcblxuICAgICAgICBpZiAoSFRNTF9URVhUX01BVENIRVJTLmluZGV4T2YobWF0Y2hlcikgPT09IC0xICYmIHNlbGVjdG9yID09PSBURVhUX05PREUpIHtcbiAgICAgICAgICB0ZXh0TWF0Y2hlcnMucHVzaChtYXRjaGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGV4dE1hdGNoZXJzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDbGlwYm9hcmQ7XG59KF9jb3JlX21vZHVsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuQ2xpcGJvYXJkLkRFRkFVTFRTID0ge1xuICBtYXRjaGVyczogW11cbn07XG5cbmZ1bmN0aW9uIGFwcGx5Rm9ybWF0KGRlbHRhLCBmb3JtYXQsIHZhbHVlKSB7XG4gIGlmIChfdHlwZW9mKGZvcm1hdCkgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZvcm1hdCkucmVkdWNlKGZ1bmN0aW9uIChuZXdEZWx0YSwga2V5KSB7XG4gICAgICByZXR1cm4gYXBwbHlGb3JtYXQobmV3RGVsdGEsIGtleSwgZm9ybWF0W2tleV0pO1xuICAgIH0sIGRlbHRhKTtcbiAgfVxuXG4gIHJldHVybiBkZWx0YS5yZWR1Y2UoZnVuY3Rpb24gKG5ld0RlbHRhLCBvcCkge1xuICAgIGlmIChvcC5hdHRyaWJ1dGVzICYmIG9wLmF0dHJpYnV0ZXNbZm9ybWF0XSkge1xuICAgICAgcmV0dXJuIG5ld0RlbHRhLnB1c2gob3ApO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXRzID0gdmFsdWUgPyBfZGVmaW5lUHJvcGVydHkoe30sIGZvcm1hdCwgdmFsdWUpIDoge307XG4gICAgcmV0dXJuIG5ld0RlbHRhLmluc2VydChvcC5pbnNlcnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZm9ybWF0cyksIG9wLmF0dHJpYnV0ZXMpKTtcbiAgfSwgbmV3IHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKCkpO1xufVxuXG5mdW5jdGlvbiBkZWx0YUVuZHNXaXRoKGRlbHRhLCB0ZXh0KSB7XG4gIHZhciBlbmRUZXh0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IGRlbHRhLm9wcy5sZW5ndGggLSAxOyBpID49IDAgJiYgZW5kVGV4dC5sZW5ndGggPCB0ZXh0Lmxlbmd0aDsgLS1pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGx1c3BsdXNcbiAgKSB7XG4gICAgdmFyIG9wID0gZGVsdGEub3BzW2ldO1xuICAgIGlmICh0eXBlb2Ygb3AuaW5zZXJ0ICE9PSAnc3RyaW5nJykgYnJlYWs7XG4gICAgZW5kVGV4dCA9IG9wLmluc2VydCArIGVuZFRleHQ7XG4gIH1cblxuICByZXR1cm4gZW5kVGV4dC5zbGljZSgtMSAqIHRleHQubGVuZ3RoKSA9PT0gdGV4dDtcbn1cblxuZnVuY3Rpb24gaXNMaW5lKG5vZGUpIHtcbiAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTsgLy8gRXhjbHVkZSBlbWJlZCBibG9ja3NcblxuICByZXR1cm4gWydhZGRyZXNzJywgJ2FydGljbGUnLCAnYmxvY2txdW90ZScsICdjYW52YXMnLCAnZGQnLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWRlcicsICdpZnJhbWUnLCAnbGknLCAnbWFpbicsICduYXYnLCAnb2wnLCAnb3V0cHV0JywgJ3AnLCAncHJlJywgJ3NlY3Rpb24nLCAndGFibGUnLCAndGQnLCAndHInLCAndWwnLCAndmlkZW8nXS5pbmRleE9mKG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAhPT0gLTE7XG59XG5cbnZhciBwcmVOb2RlcyA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIGlzUHJlKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghcHJlTm9kZXMuaGFzKG5vZGUpKSB7XG4gICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ1BSRScpIHtcbiAgICAgIHByZU5vZGVzLnNldChub2RlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlTm9kZXMuc2V0KG5vZGUsIGlzUHJlKG5vZGUucGFyZW50Tm9kZSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmVOb2Rlcy5nZXQobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHRyYXZlcnNlKHNjcm9sbCwgbm9kZSwgZWxlbWVudE1hdGNoZXJzLCB0ZXh0TWF0Y2hlcnMsIG5vZGVNYXRjaGVzKSB7XG4gIC8vIFBvc3Qtb3JkZXJcbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IG5vZGUuVEVYVF9OT0RFKSB7XG4gICAgcmV0dXJuIHRleHRNYXRjaGVycy5yZWR1Y2UoZnVuY3Rpb24gKGRlbHRhLCBtYXRjaGVyKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcihub2RlLCBkZWx0YSwgc2Nyb2xsKTtcbiAgICB9LCBuZXcgcXVpbGxfZGVsdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEoKSk7XG4gIH1cblxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMgfHwgW10pLnJlZHVjZShmdW5jdGlvbiAoZGVsdGEsIGNoaWxkTm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuRGVsdGEgPSB0cmF2ZXJzZShzY3JvbGwsIGNoaWxkTm9kZSwgZWxlbWVudE1hdGNoZXJzLCB0ZXh0TWF0Y2hlcnMsIG5vZGVNYXRjaGVzKTtcblxuICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgY2hpbGRyZW5EZWx0YSA9IGVsZW1lbnRNYXRjaGVycy5yZWR1Y2UoZnVuY3Rpb24gKHJlZHVjZWREZWx0YSwgbWF0Y2hlcikge1xuICAgICAgICAgIHJldHVybiBtYXRjaGVyKGNoaWxkTm9kZSwgcmVkdWNlZERlbHRhLCBzY3JvbGwpO1xuICAgICAgICB9LCBjaGlsZHJlbkRlbHRhKTtcbiAgICAgICAgY2hpbGRyZW5EZWx0YSA9IChub2RlTWF0Y2hlcy5nZXQoY2hpbGROb2RlKSB8fCBbXSkucmVkdWNlKGZ1bmN0aW9uIChyZWR1Y2VkRGVsdGEsIG1hdGNoZXIpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hlcihjaGlsZE5vZGUsIHJlZHVjZWREZWx0YSwgc2Nyb2xsKTtcbiAgICAgICAgfSwgY2hpbGRyZW5EZWx0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWx0YS5jb25jYXQoY2hpbGRyZW5EZWx0YSk7XG4gICAgfSwgbmV3IHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKCkpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSgpO1xufVxuXG5mdW5jdGlvbiBtYXRjaEFsaWFzKGZvcm1hdCwgbm9kZSwgZGVsdGEpIHtcbiAgcmV0dXJuIGFwcGx5Rm9ybWF0KGRlbHRhLCBmb3JtYXQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBtYXRjaEF0dHJpYnV0b3Iobm9kZSwgZGVsdGEsIHNjcm9sbCkge1xuICBpZiAoWydURCcsICdUSCcsICdUQUJMRSddLmluZGV4T2Yobm9kZS50YWdOYW1lKSA9PT0gLTEpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiQXR0cmlidXRvclwiXS5rZXlzKG5vZGUpO1xuICAgIHZhciBjbGFzc2VzID0gcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDbGFzc0F0dHJpYnV0b3JcIl0ua2V5cyhub2RlKTtcbiAgICB2YXIgc3R5bGVzID0gcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJTdHlsZUF0dHJpYnV0b3JcIl0ua2V5cyhub2RlKTtcbiAgICB2YXIgZm9ybWF0cyA9IHt9O1xuICAgIGF0dHJpYnV0ZXMuY29uY2F0KGNsYXNzZXMpLmNvbmNhdChzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBhdHRyID0gc2Nyb2xsLnF1ZXJ5KG5hbWUsIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU2NvcGVcIl0uQVRUUklCVVRFKTtcblxuICAgICAgaWYgKGF0dHIgIT0gbnVsbCkge1xuICAgICAgICBmb3JtYXRzW2F0dHIuYXR0ck5hbWVdID0gYXR0ci52YWx1ZShub2RlKTtcbiAgICAgICAgaWYgKGZvcm1hdHNbYXR0ci5hdHRyTmFtZV0pIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXR0ciA9IEFUVFJJQlVURV9BVFRSSUJVVE9SU1tuYW1lXTtcblxuICAgICAgaWYgKGF0dHIgIT0gbnVsbCAmJiAoYXR0ci5hdHRyTmFtZSA9PT0gbmFtZSB8fCBhdHRyLmtleU5hbWUgPT09IG5hbWUpKSB7XG4gICAgICAgIGZvcm1hdHNbYXR0ci5hdHRyTmFtZV0gPSBhdHRyLnZhbHVlKG5vZGUpIHx8IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgYXR0ciA9IFNUWUxFX0FUVFJJQlVUT1JTW25hbWVdO1xuXG4gICAgICBpZiAoYXR0ciAhPSBudWxsICYmIChhdHRyLmF0dHJOYW1lID09PSBuYW1lIHx8IGF0dHIua2V5TmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgICAgYXR0ciA9IFNUWUxFX0FUVFJJQlVUT1JTW25hbWVdO1xuICAgICAgICBmb3JtYXRzW2F0dHIuYXR0ck5hbWVdID0gYXR0ci52YWx1ZShub2RlKSB8fCB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGFwcGx5Rm9ybWF0KGRlbHRhLCBmb3JtYXRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIG1hdGNoQmxvdChub2RlLCBkZWx0YSwgc2Nyb2xsKSB7XG4gIHZhciBtYXRjaCA9IHNjcm9sbC5xdWVyeShub2RlKTtcbiAgaWYgKG1hdGNoID09IG51bGwpIHJldHVybiBkZWx0YTtcblxuICBpZiAobWF0Y2gucHJvdG90eXBlIGluc3RhbmNlb2YgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJFbWJlZEJsb3RcIl0pIHtcbiAgICB2YXIgZW1iZWQgPSB7fTtcbiAgICB2YXIgdmFsdWUgPSBtYXRjaC52YWx1ZShub2RlKTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBlbWJlZFttYXRjaC5ibG90TmFtZV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBuZXcgcXVpbGxfZGVsdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEoKS5pbnNlcnQoZW1iZWQsIG1hdGNoLmZvcm1hdHMobm9kZSwgc2Nyb2xsKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChtYXRjaC5wcm90b3R5cGUgaW5zdGFuY2VvZiBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkJsb2NrQmxvdFwiXSAmJiAhZGVsdGFFbmRzV2l0aChkZWx0YSwgJ1xcbicpKSB7XG4gICAgICBkZWx0YS5pbnNlcnQoJ1xcbicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbWF0Y2guZm9ybWF0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGFwcGx5Rm9ybWF0KGRlbHRhLCBtYXRjaC5ibG90TmFtZSwgbWF0Y2guZm9ybWF0cyhub2RlLCBzY3JvbGwpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIG1hdGNoQnJlYWsobm9kZSwgZGVsdGEpIHtcbiAgaWYgKCFkZWx0YUVuZHNXaXRoKGRlbHRhLCAnXFxuJykpIHtcbiAgICBkZWx0YS5pbnNlcnQoJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBtYXRjaENvZGVCbG9jayhub2RlLCBkZWx0YSwgc2Nyb2xsKSB7XG4gIHZhciBtYXRjaCA9IHNjcm9sbC5xdWVyeSgnY29kZS1ibG9jaycpO1xuICB2YXIgbGFuZ3VhZ2UgPSBtYXRjaCA/IG1hdGNoLmZvcm1hdHMobm9kZSwgc2Nyb2xsKSA6IHRydWU7XG4gIHJldHVybiBhcHBseUZvcm1hdChkZWx0YSwgJ2NvZGUtYmxvY2snLCBsYW5ndWFnZSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoSWdub3JlKCkge1xuICByZXR1cm4gbmV3IHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKCk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoSW5kZW50KG5vZGUsIGRlbHRhLCBzY3JvbGwpIHtcbiAgdmFyIG1hdGNoID0gc2Nyb2xsLnF1ZXJ5KG5vZGUpO1xuXG4gIGlmIChtYXRjaCA9PSBudWxsIHx8IG1hdGNoLmJsb3ROYW1lICE9PSAnbGlzdCcgfHwgIWRlbHRhRW5kc1dpdGgoZGVsdGEsICdcXG4nKSkge1xuICAgIHJldHVybiBkZWx0YTtcbiAgfVxuXG4gIHZhciBpbmRlbnQgPSAtMTtcbiAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblxuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAoWydPTCcsICdVTCddLmluZGV4T2YocGFyZW50LnRhZ05hbWUpICE9PSAtMSkge1xuICAgICAgaW5kZW50ICs9IDE7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICBpZiAoaW5kZW50IDw9IDApIHJldHVybiBkZWx0YTtcbiAgcmV0dXJuIGRlbHRhLnJlZHVjZShmdW5jdGlvbiAoY29tcG9zZWQsIG9wKSB7XG4gICAgaWYgKG9wLmF0dHJpYnV0ZXMgJiYgdHlwZW9mIG9wLmF0dHJpYnV0ZXMuaW5kZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGNvbXBvc2VkLnB1c2gob3ApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wb3NlZC5pbnNlcnQob3AuaW5zZXJ0LCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIGluZGVudDogaW5kZW50XG4gICAgfSwgb3AuYXR0cmlidXRlcyB8fCB7fSkpO1xuICB9LCBuZXcgcXVpbGxfZGVsdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEoKSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoTGlzdChub2RlLCBkZWx0YSkge1xuICB2YXIgbGlzdCA9IG5vZGUudGFnTmFtZSA9PT0gJ09MJyA/ICdvcmRlcmVkJyA6ICdidWxsZXQnO1xuICByZXR1cm4gYXBwbHlGb3JtYXQoZGVsdGEsICdsaXN0JywgbGlzdCk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoTmV3bGluZShub2RlLCBkZWx0YSwgc2Nyb2xsKSB7XG4gIGlmICghZGVsdGFFbmRzV2l0aChkZWx0YSwgJ1xcbicpKSB7XG4gICAgaWYgKGlzTGluZShub2RlKSkge1xuICAgICAgcmV0dXJuIGRlbHRhLmluc2VydCgnXFxuJyk7XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhLmxlbmd0aCgpID4gMCAmJiBub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICB2YXIgbmV4dFNpYmxpbmcgPSBub2RlLm5leHRTaWJsaW5nO1xuXG4gICAgICB3aGlsZSAobmV4dFNpYmxpbmcgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNMaW5lKG5leHRTaWJsaW5nKSkge1xuICAgICAgICAgIHJldHVybiBkZWx0YS5pbnNlcnQoJ1xcbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdGNoID0gc2Nyb2xsLnF1ZXJ5KG5leHRTaWJsaW5nKTtcblxuICAgICAgICBpZiAoKG1hdGNoID09PSBudWxsIHx8IG1hdGNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRjaC5wcm90b3R5cGUpIGluc3RhbmNlb2YgX2Jsb3RzX2Jsb2NrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogQmxvY2tFbWJlZCAqLyBcImFcIl0pIHtcbiAgICAgICAgICByZXR1cm4gZGVsdGEuaW5zZXJ0KCdcXG4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZmlyc3RDaGlsZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIG1hdGNoU3R5bGVzKG5vZGUsIGRlbHRhKSB7XG4gIHZhciBmb3JtYXRzID0ge307XG4gIHZhciBzdHlsZSA9IG5vZGUuc3R5bGUgfHwge307XG4gIFsnaGVpZ2h0JywgJ3dpZHRoJ10uZm9yRWFjaChmdW5jdGlvbiAoZGltZW5zaW9uKSB7XG4gICAgdmFyIGlzQ2VsbCA9IFsnVEQnLCAnVEgnXS5pbmRleE9mKG5vZGUudGFnTmFtZSkgIT09IC0xO1xuICAgIHZhciBpc1RhYmxlID0gbm9kZS50YWdOYW1lID09PSAnVEFCTEUnO1xuXG4gICAgaWYgKChpc0NlbGwgfHwgaXNUYWJsZSkgJiYgc3R5bGVbZGltZW5zaW9uXSkge1xuICAgICAgdmFyIG5hbWUgPSBcIlwiLmNvbmNhdChpc1RhYmxlID8gJ3RhYmxlJyA6ICdjZWxsJykuY29uY2F0KE9iamVjdChfdXRpbHNfY2FwaXRhbGl6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoZGltZW5zaW9uKSk7XG4gICAgICBmb3JtYXRzW25hbWVdID0gc3R5bGVbZGltZW5zaW9uXTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChzdHlsZS5mb250U3R5bGUgPT09ICdpdGFsaWMnKSB7XG4gICAgZm9ybWF0cy5pdGFsaWMgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHN0eWxlLnRleHREZWNvcmF0aW9uLmluZGV4T2YoJ3VuZGVybGluZScpICE9PSAtMSkge1xuICAgIGZvcm1hdHMudW5kZXJsaW5lID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzdHlsZS50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdsaW5lLXRocm91Z2gnKSAhPT0gLTEpIHtcbiAgICBmb3JtYXRzLnN0cmlrZSA9IHRydWU7XG4gIH1cblxuICBpZiAoc3R5bGUuZm9udFdlaWdodC5pbmRleE9mKCdib2xkJykgPT09IDAgfHwgcGFyc2VJbnQoc3R5bGUuZm9udFdlaWdodCwgMTApID49IDcwMCkge1xuICAgIGZvcm1hdHMuYm9sZCA9IHRydWU7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID4gMCkge1xuICAgIGRlbHRhID0gYXBwbHlGb3JtYXQoZGVsdGEsIGZvcm1hdHMpO1xuICB9XG5cbiAgaWYgKHBhcnNlRmxvYXQoc3R5bGUudGV4dEluZGVudCB8fCAwKSA+IDApIHtcbiAgICAvLyBDb3VsZCBiZSAwLjVpblxuICAgIHJldHVybiBuZXcgcXVpbGxfZGVsdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEoKS5pbnNlcnQoJ1xcdCcpLmNvbmNhdChkZWx0YSk7XG4gIH1cblxuICByZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUGxhaW5UZXh0KG5vZGUsIGRlbHRhKSB7XG4gIHZhciB0ZXh0ID0gbm9kZS5kYXRhIHx8ICcnO1xuICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpO1xuICByZXR1cm4gZGVsdGEuaW5zZXJ0KHRleHQpO1xufVxuXG5mdW5jdGlvbiBtYXRjaFRleHQobm9kZSwgZGVsdGEpIHtcbiAgdmFyIHRleHQgPSBub2RlLmRhdGE7IC8vIFdvcmQgcmVwcmVzZW50cyBlbXB0eSBsaW5lIHdpdGggPG86cD4mbmJzcDs8L286cD5cblxuICBpZiAobm9kZS5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdPOlAnKSB7XG4gICAgcmV0dXJuIGRlbHRhLmluc2VydCh0ZXh0LnRyaW0oKSk7XG4gIH1cblxuICBpZiAodGV4dC50cmltKCkubGVuZ3RoID09PSAwICYmIHRleHQuaW5kZXhPZignXFxuJykgIT09IC0xKSB7XG4gICAgcmV0dXJuIGRlbHRhO1xuICB9XG5cbiAgaWYgKCFpc1ByZShub2RlKSkge1xuICAgIHZhciByZXBsYWNlciA9IGZ1bmN0aW9uIHJlcGxhY2VyKGNvbGxhcHNlLCBtYXRjaCkge1xuICAgICAgdmFyIHJlcGxhY2VkID0gbWF0Y2gucmVwbGFjZSgvW15cXHUwMGEwXS9nLCAnJyk7IC8vIFxcdTAwYTAgaXMgbmJzcDtcblxuICAgICAgcmV0dXJuIHJlcGxhY2VkLmxlbmd0aCA8IDEgJiYgY29sbGFwc2UgPyAnICcgOiByZXBsYWNlZDtcbiAgICB9O1xuXG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxuL2csICcgJykucmVwbGFjZSgvXFxuL2csICcgJyk7XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxzXFxzKy9nLCByZXBsYWNlci5iaW5kKHJlcGxhY2VyLCB0cnVlKSk7IC8vIGNvbGxhcHNlIHdoaXRlc3BhY2VcblxuICAgIGlmIChub2RlLnByZXZpb3VzU2libGluZyA9PSBudWxsICYmIGlzTGluZShub2RlLnBhcmVudE5vZGUpIHx8IG5vZGUucHJldmlvdXNTaWJsaW5nICE9IG51bGwgJiYgaXNMaW5lKG5vZGUucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXlxccysvLCByZXBsYWNlci5iaW5kKHJlcGxhY2VyLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIGlmIChub2RlLm5leHRTaWJsaW5nID09IG51bGwgJiYgaXNMaW5lKG5vZGUucGFyZW50Tm9kZSkgfHwgbm9kZS5uZXh0U2libGluZyAhPSBudWxsICYmIGlzTGluZShub2RlLm5leHRTaWJsaW5nKSkge1xuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxzKyQvLCByZXBsYWNlci5iaW5kKHJlcGxhY2VyLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWx0YS5pbnNlcnQodGV4dCk7XG59XG5cblxuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSkgey8qKlxuICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gIHRydWUgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAqIGVxdWl2YWxlbnQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIG9iamVjdCA9PT0gb3RoZXI7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXyg1NCksIF9fd2VicGFja19yZXF1aXJlX18oNjEpKG1vZHVsZSkpKVxuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjYXBpdGFsaXplOyB9KTtcbmZ1bmN0aW9uIGNhcGl0YWxpemUodGV4dCkge1xuICByZXR1cm4gdGV4dCA/IHRleHQuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyB0ZXh0LnN1YnN0cmluZygxKSA6ICcnO1xufVxuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDb2xvckF0dHJpYnV0b3I7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDb2xvckNsYXNzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ29sb3JTdHlsZTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cbnZhciBDb2xvckF0dHJpYnV0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHlsZUF0dHJpYnV0b3IpIHtcbiAgX2luaGVyaXRzKENvbG9yQXR0cmlidXRvciwgX1N0eWxlQXR0cmlidXRvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDb2xvckF0dHJpYnV0b3IpO1xuXG4gIGZ1bmN0aW9uIENvbG9yQXR0cmlidXRvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3JBdHRyaWJ1dG9yKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2xvckF0dHJpYnV0b3IsIFt7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGRvbU5vZGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKENvbG9yQXR0cmlidXRvci5wcm90b3R5cGUpLCBcInZhbHVlXCIsIHRoaXMpLmNhbGwodGhpcywgZG9tTm9kZSk7XG5cbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCdyZ2IoJykgIT09IDApIHJldHVybiB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXlteXFxkXSsvLCAnJykucmVwbGFjZSgvW15cXGRdKyQvLCAnJyk7XG4gICAgICB2YXIgaGV4ID0gdmFsdWUuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gXCIwMFwiLmNvbmNhdChwYXJzZUludChjb21wb25lbnQsIDEwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgcmV0dXJuIFwiI1wiLmNvbmNhdChoZXgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2xvckF0dHJpYnV0b3I7XG59KHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiU3R5bGVBdHRyaWJ1dG9yXCJdKTtcblxudmFyIENvbG9yQ2xhc3MgPSBuZXcgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJDbGFzc0F0dHJpYnV0b3JcIl0oJ2NvbG9yJywgJ3FsLWNvbG9yJywge1xuICBzY29wZTogcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJTY29wZVwiXS5JTkxJTkVcbn0pO1xudmFyIENvbG9yU3R5bGUgPSBuZXcgQ29sb3JBdHRyaWJ1dG9yKCdjb2xvcicsICdjb2xvcicsIHtcbiAgc2NvcGU6IHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiU2NvcGVcIl0uSU5MSU5FXG59KTtcblxuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBEaXJlY3Rpb25BdHRyaWJ1dGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBEaXJlY3Rpb25DbGFzczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERpcmVjdGlvblN0eWxlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBjb25maWcgPSB7XG4gIHNjb3BlOiBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIlNjb3BlXCJdLkJMT0NLLFxuICB3aGl0ZWxpc3Q6IFsncnRsJ11cbn07XG52YXIgRGlyZWN0aW9uQXR0cmlidXRlID0gbmV3IHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiQXR0cmlidXRvclwiXSgnZGlyZWN0aW9uJywgJ2RpcicsIGNvbmZpZyk7XG52YXIgRGlyZWN0aW9uQ2xhc3MgPSBuZXcgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJDbGFzc0F0dHJpYnV0b3JcIl0oJ2RpcmVjdGlvbicsICdxbC1kaXJlY3Rpb24nLCBjb25maWcpO1xudmFyIERpcmVjdGlvblN0eWxlID0gbmV3IHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiU3R5bGVBdHRyaWJ1dG9yXCJdKCdkaXJlY3Rpb24nLCAnZGlyZWN0aW9uJywgY29uZmlnKTtcblxuXG4vKioqLyB9KSxcbi8qIDMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QoaXQpLCBrZXkpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSkgey8qKlxuICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gIHRydWUgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQsXG4gICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oNTQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKShtb2R1bGUpKSlcblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQWxpZ25BdHRyaWJ1dGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBbGlnbkNsYXNzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQWxpZ25TdHlsZTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgY29uZmlnID0ge1xuICBzY29wZTogcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJTY29wZVwiXS5CTE9DSyxcbiAgd2hpdGVsaXN0OiBbJ3JpZ2h0JywgJ2NlbnRlcicsICdqdXN0aWZ5J11cbn07XG52YXIgQWxpZ25BdHRyaWJ1dGUgPSBuZXcgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJBdHRyaWJ1dG9yXCJdKCdhbGlnbicsICdhbGlnbicsIGNvbmZpZyk7XG52YXIgQWxpZ25DbGFzcyA9IG5ldyBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkNsYXNzQXR0cmlidXRvclwiXSgnYWxpZ24nLCAncWwtYWxpZ24nLCBjb25maWcpO1xudmFyIEFsaWduU3R5bGUgPSBuZXcgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJTdHlsZUF0dHJpYnV0b3JcIl0oJ2FsaWduJywgJ3RleHQtYWxpZ24nLCBjb25maWcpO1xuXG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuXG52YXIgU3RyaW5nID0gZ2xvYmFsLlN0cmluZztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBUeXBlKGFyZ3VtZW50KSBpcyBPYmplY3RgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNPYmplY3QoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IFR5cGVFcnJvcihTdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cbi8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSlbMV0gIT0gNztcbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBjYWxsLmJpbmQgPyBjYWxsLmJpbmQoY2FsbCkgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsLmFwcGx5KGNhbGwsIGFyZ3VtZW50cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExpbms7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfc2FuaXRpemU7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ibG90c19pbmxpbmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cbnZhciBMaW5rID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW5saW5lKSB7XG4gIF9pbmhlcml0cyhMaW5rLCBfSW5saW5lKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKExpbmspO1xuXG4gIGZ1bmN0aW9uIExpbmsoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmspO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpbmssIFt7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChuYW1lICE9PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUgfHwgIXZhbHVlKSB7XG4gICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKExpbmsucHJvdG90eXBlKSwgXCJmb3JtYXRcIiwgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvbU5vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgdGhpcy5jb25zdHJ1Y3Rvci5zYW5pdGl6ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgIHZhciBub2RlID0gX2dldChfZ2V0UHJvdG90eXBlT2YoTGluayksIFwiY3JlYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIHRoaXMuc2FuaXRpemUodmFsdWUpKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdyZWwnLCAnbm9vcGVuZXIgbm9yZWZlcnJlcicpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsICdfYmxhbmsnKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhbml0aXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhbml0aXplKHVybCkge1xuICAgICAgcmV0dXJuIF9zYW5pdGl6ZSh1cmwsIHRoaXMuUFJPVE9DT0xfV0hJVEVMSVNUKSA/IHVybCA6IHRoaXMuU0FOSVRJWkVEX1VSTDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGluaztcbn0oX2Jsb3RzX2lubGluZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuTGluay5ibG90TmFtZSA9ICdsaW5rJztcbkxpbmsudGFnTmFtZSA9ICdBJztcbkxpbmsuU0FOSVRJWkVEX1VSTCA9ICdhYm91dDpibGFuayc7XG5MaW5rLlBST1RPQ09MX1dISVRFTElTVCA9IFsnaHR0cCcsICdodHRwcycsICdtYWlsdG8nLCAndGVsJ107XG5cbmZ1bmN0aW9uIF9zYW5pdGl6ZSh1cmwsIHByb3RvY29scykge1xuICB2YXIgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBhbmNob3IuaHJlZiA9IHVybDtcbiAgdmFyIHByb3RvY29sID0gYW5jaG9yLmhyZWYuc2xpY2UoMCwgYW5jaG9yLmhyZWYuaW5kZXhPZignOicpKTtcbiAgcmV0dXJuIHByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA+IC0xO1xufVxuXG5cblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAobmV3IFdlYWtNYXAoKSk7XG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEJhY2tncm91bmRDbGFzczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEJhY2tncm91bmRTdHlsZTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb2xvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cblxudmFyIEJhY2tncm91bmRDbGFzcyA9IG5ldyBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkNsYXNzQXR0cmlidXRvclwiXSgnYmFja2dyb3VuZCcsICdxbC1iZycsIHtcbiAgc2NvcGU6IHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiU2NvcGVcIl0uSU5MSU5FXG59KTtcbnZhciBCYWNrZ3JvdW5kU3R5bGUgPSBuZXcgX2NvbG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogQ29sb3JBdHRyaWJ1dG9yICovIFwiYVwiXSgnYmFja2dyb3VuZCcsICdiYWNrZ3JvdW5kLWNvbG9yJywge1xuICBzY29wZTogcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJTY29wZVwiXS5JTkxJTkVcbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEZvbnRTdHlsZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEZvbnRDbGFzczsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG52YXIgY29uZmlnID0ge1xuICBzY29wZTogcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJTY29wZVwiXS5JTkxJTkUsXG4gIHdoaXRlbGlzdDogWydzZXJpZicsICdtb25vc3BhY2UnXVxufTtcbnZhciBGb250Q2xhc3MgPSBuZXcgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJDbGFzc0F0dHJpYnV0b3JcIl0oJ2ZvbnQnLCAncWwtZm9udCcsIGNvbmZpZyk7XG5cbnZhciBGb250U3R5bGVBdHRyaWJ1dG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3R5bGVBdHRyaWJ1dG9yKSB7XG4gIF9pbmhlcml0cyhGb250U3R5bGVBdHRyaWJ1dG9yLCBfU3R5bGVBdHRyaWJ1dG9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEZvbnRTdHlsZUF0dHJpYnV0b3IpO1xuXG4gIGZ1bmN0aW9uIEZvbnRTdHlsZUF0dHJpYnV0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvbnRTdHlsZUF0dHJpYnV0b3IpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZvbnRTdHlsZUF0dHJpYnV0b3IsIFt7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG5vZGUpIHtcbiAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihGb250U3R5bGVBdHRyaWJ1dG9yLnByb3RvdHlwZSksIFwidmFsdWVcIiwgdGhpcykuY2FsbCh0aGlzLCBub2RlKS5yZXBsYWNlKC9bXCInXS9nLCAnJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvbnRTdHlsZUF0dHJpYnV0b3I7XG59KHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiU3R5bGVBdHRyaWJ1dG9yXCJdKTtcblxudmFyIEZvbnRTdHlsZSA9IG5ldyBGb250U3R5bGVBdHRyaWJ1dG9yKCdmb250JywgJ2ZvbnQtZmFtaWx5JywgY29uZmlnKTtcblxuXG4vKioqLyB9KSxcbi8qIDQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTaXplQ2xhc3M7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTaXplU3R5bGU7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIFNpemVDbGFzcyA9IG5ldyBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkNsYXNzQXR0cmlidXRvclwiXSgnc2l6ZScsICdxbC1zaXplJywge1xuICBzY29wZTogcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJTY29wZVwiXS5JTkxJTkUsXG4gIHdoaXRlbGlzdDogWydzbWFsbCcsICdsYXJnZScsICdodWdlJ11cbn0pO1xudmFyIFNpemVTdHlsZSA9IG5ldyBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIlN0eWxlQXR0cmlidXRvclwiXSgnc2l6ZScsICdmb250LXNpemUnLCB7XG4gIHNjb3BlOiBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIlNjb3BlXCJdLklOTElORSxcbiAgd2hpdGVsaXN0OiBbJzEwcHgnLCAnMThweCcsICczMnB4J11cbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRvZ2dsZUF0dHJpYnV0ZTsgfSk7XG5mdW5jdGlvbiB0b2dnbGVBdHRyaWJ1dGUoZG9tTm9kZSwgYXR0ck5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGRvbU5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZG9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jsb3RzX2lubGluZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxudmFyIEJvbGQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbmxpbmUpIHtcbiAgX2luaGVyaXRzKEJvbGQsIF9JbmxpbmUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQm9sZCk7XG5cbiAgZnVuY3Rpb24gQm9sZCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm9sZCk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQm9sZCwgW3tcbiAgICBrZXk6IFwib3B0aW1pemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW1pemUoY29udGV4dCkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQm9sZC5wcm90b3R5cGUpLCBcIm9wdGltaXplXCIsIHRoaXMpLmNhbGwodGhpcywgY29udGV4dCk7XG5cbiAgICAgIGlmICh0aGlzLmRvbU5vZGUudGFnTmFtZSAhPT0gdGhpcy5zdGF0aWNzLnRhZ05hbWVbMF0pIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlV2l0aCh0aGlzLnN0YXRpY3MuYmxvdE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoQm9sZCksIFwiY3JlYXRlXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cygpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCb2xkO1xufShfYmxvdHNfaW5saW5lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xuXG5Cb2xkLmJsb3ROYW1lID0gJ2JvbGQnO1xuQm9sZC50YWdOYW1lID0gWydTVFJPTkcnLCAnQiddO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChCb2xkKTtcblxuLyoqKi8gfSksXG4vKiA0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gSGlzdG9yeTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldExhc3RDaGFuZ2VJbmRleDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb3JlX3F1aWxsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb3JlX21vZHVsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2hhc193aW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cblxuXG5cbnZhciBIaXN0b3J5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTW9kdWxlKSB7XG4gIF9pbmhlcml0cyhIaXN0b3J5LCBfTW9kdWxlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEhpc3RvcnkpO1xuXG4gIGZ1bmN0aW9uIEhpc3RvcnkocXVpbGwsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGlzdG9yeSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHF1aWxsLCBvcHRpb25zKTtcbiAgICBfdGhpcy5sYXN0UmVjb3JkZWQgPSAwO1xuICAgIF90aGlzLmlnbm9yZUNoYW5nZSA9IGZhbHNlO1xuXG4gICAgX3RoaXMuY2xlYXIoKTtcblxuICAgIF90aGlzLnF1aWxsLm9uKF9jb3JlX3F1aWxsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZXZlbnRzLkVESVRPUl9DSEFOR0UsIGZ1bmN0aW9uIChldmVudE5hbWUsIGRlbHRhLCBvbGREZWx0YSwgc291cmNlKSB7XG4gICAgICBpZiAoZXZlbnROYW1lICE9PSBfY29yZV9xdWlsbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmV2ZW50cy5URVhUX0NIQU5HRSB8fCBfdGhpcy5pZ25vcmVDaGFuZ2UpIHJldHVybjtcblxuICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLnVzZXJPbmx5IHx8IHNvdXJjZSA9PT0gX2NvcmVfcXVpbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zb3VyY2VzLlVTRVIpIHtcbiAgICAgICAgX3RoaXMucmVjb3JkKGRlbHRhLCBvbGREZWx0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy50cmFuc2Zvcm0oZGVsdGEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX3RoaXMucXVpbGwua2V5Ym9hcmQuYWRkQmluZGluZyh7XG4gICAgICBrZXk6ICd6JyxcbiAgICAgIHNob3J0S2V5OiB0cnVlXG4gICAgfSwgX3RoaXMudW5kby5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG5cbiAgICBfdGhpcy5xdWlsbC5rZXlib2FyZC5hZGRCaW5kaW5nKHtcbiAgICAgIGtleTogJ3onLFxuICAgICAgc2hvcnRLZXk6IHRydWUsXG4gICAgICBzaGlmdEtleTogdHJ1ZVxuICAgIH0sIF90aGlzLnJlZG8uYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuXG4gICAgaWYgKE9iamVjdChfdXRpbHNfaGFzX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSgpICYmIC9XaW4vaS50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkpIHtcbiAgICAgIF90aGlzLnF1aWxsLmtleWJvYXJkLmFkZEJpbmRpbmcoe1xuICAgICAgICBrZXk6ICd5JyxcbiAgICAgICAgc2hvcnRLZXk6IHRydWVcbiAgICAgIH0sIF90aGlzLnJlZG8uYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkpO1xuICAgIH1cblxuICAgIF90aGlzLnF1aWxsLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5wdXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5pbnB1dFR5cGUgPT09ICdoaXN0b3J5VW5kbycpIHtcbiAgICAgICAgX3RoaXMudW5kbygpO1xuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmlucHV0VHlwZSA9PT0gJ2hpc3RvcnlSZWRvJykge1xuICAgICAgICBfdGhpcy5yZWRvKCk7XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhIaXN0b3J5LCBbe1xuICAgIGtleTogXCJjaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhbmdlKHNvdXJjZSwgZGVzdCkge1xuICAgICAgaWYgKHRoaXMuc3RhY2tbc291cmNlXS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHZhciBkZWx0YSA9IHRoaXMuc3RhY2tbc291cmNlXS5wb3AoKTtcbiAgICAgIHZhciBiYXNlID0gdGhpcy5xdWlsbC5nZXRDb250ZW50cygpO1xuICAgICAgdmFyIGludmVyc2VEZWx0YSA9IGRlbHRhLmludmVydChiYXNlKTtcbiAgICAgIHRoaXMuc3RhY2tbZGVzdF0ucHVzaChpbnZlcnNlRGVsdGEpO1xuICAgICAgdGhpcy5sYXN0UmVjb3JkZWQgPSAwO1xuICAgICAgdGhpcy5pZ25vcmVDaGFuZ2UgPSB0cnVlO1xuICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgX2NvcmVfcXVpbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgdGhpcy5pZ25vcmVDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIHZhciBpbmRleCA9IGdldExhc3RDaGFuZ2VJbmRleCh0aGlzLnF1aWxsLnNjcm9sbCwgZGVsdGEpO1xuICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuc3RhY2sgPSB7XG4gICAgICAgIHVuZG86IFtdLFxuICAgICAgICByZWRvOiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3V0b2ZmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1dG9mZigpIHtcbiAgICAgIHRoaXMubGFzdFJlY29yZGVkID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVjb3JkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29yZChjaGFuZ2VEZWx0YSwgb2xkRGVsdGEpIHtcbiAgICAgIGlmIChjaGFuZ2VEZWx0YS5vcHMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB0aGlzLnN0YWNrLnJlZG8gPSBbXTtcbiAgICAgIHZhciB1bmRvRGVsdGEgPSBjaGFuZ2VEZWx0YS5pbnZlcnQob2xkRGVsdGEpO1xuICAgICAgdmFyIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cbiAgICAgIGlmICh0aGlzLmxhc3RSZWNvcmRlZCArIHRoaXMub3B0aW9ucy5kZWxheSA+IHRpbWVzdGFtcCAmJiB0aGlzLnN0YWNrLnVuZG8ubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLnN0YWNrLnVuZG8ucG9wKCk7XG4gICAgICAgIHVuZG9EZWx0YSA9IHVuZG9EZWx0YS5jb21wb3NlKGRlbHRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdFJlY29yZGVkID0gdGltZXN0YW1wO1xuICAgICAgfVxuXG4gICAgICBpZiAodW5kb0RlbHRhLmxlbmd0aCgpID09PSAwKSByZXR1cm47XG4gICAgICB0aGlzLnN0YWNrLnVuZG8ucHVzaCh1bmRvRGVsdGEpO1xuXG4gICAgICBpZiAodGhpcy5zdGFjay51bmRvLmxlbmd0aCA+IHRoaXMub3B0aW9ucy5tYXhTdGFjaykge1xuICAgICAgICB0aGlzLnN0YWNrLnVuZG8uc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVkb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWRvKCkge1xuICAgICAgdGhpcy5jaGFuZ2UoJ3JlZG8nLCAndW5kbycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtKGRlbHRhKSB7XG4gICAgICB0cmFuc2Zvcm1TdGFjayh0aGlzLnN0YWNrLnVuZG8sIGRlbHRhKTtcbiAgICAgIHRyYW5zZm9ybVN0YWNrKHRoaXMuc3RhY2sucmVkbywgZGVsdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgICB0aGlzLmNoYW5nZSgndW5kbycsICdyZWRvJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhpc3Rvcnk7XG59KF9jb3JlX21vZHVsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuSGlzdG9yeS5ERUZBVUxUUyA9IHtcbiAgZGVsYXk6IDEwMDAsXG4gIG1heFN0YWNrOiAxMDAsXG4gIHVzZXJPbmx5OiBmYWxzZVxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhY2soc3RhY2ssIGRlbHRhKSB7XG4gIHZhciByZW1vdGVEZWx0YSA9IGRlbHRhO1xuXG4gIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgIHZhciBvbGREZWx0YSA9IHN0YWNrW2ldO1xuICAgIHN0YWNrW2ldID0gcmVtb3RlRGVsdGEudHJhbnNmb3JtKG9sZERlbHRhLCB0cnVlKTtcbiAgICByZW1vdGVEZWx0YSA9IG9sZERlbHRhLnRyYW5zZm9ybShyZW1vdGVEZWx0YSk7XG5cbiAgICBpZiAoc3RhY2tbaV0ubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgIHN0YWNrLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kc1dpdGhOZXdsaW5lQ2hhbmdlKHNjcm9sbCwgZGVsdGEpIHtcbiAgdmFyIGxhc3RPcCA9IGRlbHRhLm9wc1tkZWx0YS5vcHMubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0T3AgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChsYXN0T3AuaW5zZXJ0ICE9IG51bGwpIHtcbiAgICByZXR1cm4gdHlwZW9mIGxhc3RPcC5pbnNlcnQgPT09ICdzdHJpbmcnICYmIGxhc3RPcC5pbnNlcnQuZW5kc1dpdGgoJ1xcbicpO1xuICB9XG5cbiAgaWYgKGxhc3RPcC5hdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobGFzdE9wLmF0dHJpYnV0ZXMpLnNvbWUoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHJldHVybiBzY3JvbGwucXVlcnkoYXR0ciwgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJTY29wZVwiXS5CTE9DSykgIT0gbnVsbDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0TGFzdENoYW5nZUluZGV4KHNjcm9sbCwgZGVsdGEpIHtcbiAgdmFyIGRlbGV0ZUxlbmd0aCA9IGRlbHRhLnJlZHVjZShmdW5jdGlvbiAobGVuZ3RoLCBvcCkge1xuICAgIHJldHVybiBsZW5ndGggKyAob3AuZGVsZXRlIHx8IDApO1xuICB9LCAwKTtcbiAgdmFyIGNoYW5nZUluZGV4ID0gZGVsdGEubGVuZ3RoKCkgLSBkZWxldGVMZW5ndGg7XG5cbiAgaWYgKGVuZHNXaXRoTmV3bGluZUNoYW5nZShzY3JvbGwsIGRlbHRhKSkge1xuICAgIGNoYW5nZUluZGV4IC09IDE7XG4gIH1cblxuICByZXR1cm4gY2hhbmdlSW5kZXg7XG59XG5cblxuXG4vKioqLyB9KSxcbi8qIDQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUoaXQpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nyk7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MCk7XG5cbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHByZXBhcmVBdHRyaWJ1dG9yOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXR0cmlidXRvcnNfZWxlbWVudF9hdHRyaWJ1dG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY2FwaXRhbGl6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG52YXIgX2V4Y2x1ZGVkID0gW1wibmFtZVwiXTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuXG5cbmZ1bmN0aW9uIHByZXBhcmVBdHRyaWJ1dG9yKF9yZWYsIGF0dHJOYW1lKSB7XG4gIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgZWxlbWVudENvbmZpZyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuXG4gIHJldHVybiBuZXcgX2F0dHJpYnV0b3JzX2VsZW1lbnRfYXR0cmlidXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKFwiXCIuY29uY2F0KG5hbWUpLmNvbmNhdChPYmplY3QoX3V0aWxzX2NhcGl0YWxpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoYXR0ck5hbWUpKSwgYXR0ck5hbWUsIGVsZW1lbnRDb25maWcpO1xufVxuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtYWtlVGFibGVBcnJvd0hhbmRsZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb3JlX3F1aWxsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mdW5jdGlvbiBtYWtlVGFibGVBcnJvd0hhbmRsZXIodXAsIGZvcm1hdHMpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IHVwID8gJ3VwQXJyb3cnIDogJ2Rvd25BcnJvdycsXG4gICAgY29sbGFwc2VkOiB0cnVlLFxuICAgIGZvcm1hdDogZm9ybWF0cyxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlLCBjb250ZXh0KSB7XG4gICAgICB2YXIga2V5ID0gdXAgPyAncHJldicgOiAnbmV4dCc7XG4gICAgICB2YXIgbGluZSA9IGNvbnRleHQubGluZTtcbiAgICAgIHZhciBjZWxsID0gbGluZS5zdGF0aWNzLmJsb3ROYW1lLmluZGV4T2YoJ0xpbmUnKSA+IC0xID8gbGluZS5wYXJlbnQgOiBsaW5lO1xuICAgICAgdmFyIHRhcmdldFRhYmxlUGFydCA9IGNlbGwucGFyZW50LnBhcmVudFtrZXldO1xuICAgICAgdmFyIHRhcmdldFJvdyA9IGNlbGwucGFyZW50W2tleV0gfHwgKHRhcmdldFRhYmxlUGFydCA9PT0gbnVsbCB8fCB0YXJnZXRUYWJsZVBhcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldFRhYmxlUGFydC5jaGlsZHJlbi5oZWFkKTtcblxuICAgICAgaWYgKHRhcmdldFJvdyAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0YXJnZXRSb3cuc3RhdGljcy5ibG90TmFtZSA9PT0gJ3RhYmxlUm93JyB8fCB0YXJnZXRSb3cuc3RhdGljcy5ibG90TmFtZSA9PT0gJ3RhYmxlSGVhZGVyUm93Jykge1xuICAgICAgICAgIHZhciB0YXJnZXRDZWxsID0gdGFyZ2V0Um93LmNoaWxkcmVuLmhlYWQ7XG4gICAgICAgICAgdmFyIGN1ciA9IGNlbGw7XG5cbiAgICAgICAgICB3aGlsZSAoY3VyLnByZXYgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3VyID0gY3VyLnByZXY7XG4gICAgICAgICAgICB0YXJnZXRDZWxsID0gdGFyZ2V0Q2VsbC5uZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpbmRleCA9IHRhcmdldENlbGwub2Zmc2V0KHRoaXMucXVpbGwuc2Nyb2xsKSArIE1hdGgubWluKGNvbnRleHQub2Zmc2V0LCB0YXJnZXRDZWxsLmxlbmd0aCgpIC0gMSk7XG4gICAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oaW5kZXgsIDAsIF9jb3JlX3F1aWxsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc291cmNlcy5VU0VSKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhcmdldExpbmUgPSBjZWxsLnRhYmxlKClba2V5XTtcblxuICAgICAgICBpZiAodGFyZ2V0TGluZSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHVwKSB7XG4gICAgICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbih0YXJnZXRMaW5lLm9mZnNldCh0aGlzLnF1aWxsLnNjcm9sbCkgKyB0YXJnZXRMaW5lLmxlbmd0aCgpIC0gMSwgMCwgX2NvcmVfcXVpbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbih0YXJnZXRMaW5lLm9mZnNldCh0aGlzLnF1aWxsLnNjcm9sbCksIDAsIF9jb3JlX3F1aWxsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc291cmNlcy5VU0VSKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiA1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJlcGFyZUF0dHJpYnV0ZU1hdGNoZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXR0cmlidXRvcnNfZWxlbWVudF9hdHRyaWJ1dG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXR0cmlidXRvcnNfZWxlbWVudF9zdHlsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Zvcm1hdHNfdGFibGVfYXR0cmlidXRvcnNfY2VsbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZm9ybWF0c190YWJsZV9hdHRyaWJ1dG9yc190YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY2xpcGJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxuXG5cblxuXG5cbnZhciBBVFRSSUJVVE9SUyA9IHtcbiAgdGFibGU6IF9mb3JtYXRzX3RhYmxlX2F0dHJpYnV0b3JzX3RhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogVEFCTEVfQVRUUklCVVRPUlMgKi8gXCJhXCJdLFxuICBjZWxsOiBfZm9ybWF0c190YWJsZV9hdHRyaWJ1dG9yc19jZWxsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogQ0VMTF9BVFRSSUJVVE9SUyAqLyBcImFcIl1cbn07XG5mdW5jdGlvbiBwcmVwYXJlQXR0cmlidXRlTWF0Y2hlcih0eXBlKSB7XG4gIHZhciBhdHRyaWJ1dG9ycyA9IEFUVFJJQlVUT1JTW3R5cGVdO1xuICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGRlbHRhLCBzY3JvbGwpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IF9hdHRyaWJ1dG9yc19lbGVtZW50X2F0dHJpYnV0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5rZXlzKG5vZGUpO1xuICAgIHZhciBzdHlsZXMgPSBfYXR0cmlidXRvcnNfZWxlbWVudF9zdHlsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmtleXMobm9kZSk7XG4gICAgdmFyIGZvcm1hdHMgPSB7fTtcbiAgICBhdHRyaWJ1dGVzLmNvbmNhdChzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBhdHRyID0gc2Nyb2xsLnF1ZXJ5KG5hbWUsIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiU2NvcGVcIl0uQVRUUklCVVRFKTtcblxuICAgICAgaWYgKGF0dHIgIT0gbnVsbCkge1xuICAgICAgICBmb3JtYXRzW2F0dHIuYXR0ck5hbWVdID0gYXR0ci52YWx1ZShub2RlKTtcbiAgICAgICAgaWYgKGZvcm1hdHNbYXR0ci5hdHRyTmFtZV0pIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXR0ciA9IGF0dHJpYnV0b3JzW25hbWVdO1xuXG4gICAgICBpZiAoYXR0ciAhPSBudWxsICYmIChhdHRyLmF0dHJOYW1lID09PSBuYW1lIHx8IGF0dHIua2V5TmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgICAgYXR0ciA9IGF0dHJpYnV0b3JzW25hbWVdO1xuICAgICAgICBmb3JtYXRzW2F0dHIuYXR0ck5hbWVdID0gYXR0ci52YWx1ZShub2RlKSB8fCB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIE9iamVjdChfY2xpcGJvYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogYXBwbHlGb3JtYXQgKi8gXCJhXCJdKShkZWx0YSwgZm9ybWF0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbHRhO1xuICB9O1xufVxuXG4vKioqLyB9KSxcbi8qIDUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgVGhlbWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUaGVtZShxdWlsbCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaGVtZSk7XG5cbiAgICB0aGlzLnF1aWxsID0gcXVpbGw7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm1vZHVsZXMgPSB7fTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUaGVtZSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKF90aGlzLm1vZHVsZXNbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzLmFkZE1vZHVsZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE1vZHVsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNb2R1bGUobmFtZSkge1xuICAgICAgdmFyIE1vZHVsZUNsYXNzID0gdGhpcy5xdWlsbC5jb25zdHJ1Y3Rvci5pbXBvcnQoXCJtb2R1bGVzL1wiLmNvbmNhdChuYW1lKSk7XG4gICAgICB0aGlzLm1vZHVsZXNbbmFtZV0gPSBuZXcgTW9kdWxlQ2xhc3ModGhpcy5xdWlsbCwgdGhpcy5vcHRpb25zLm1vZHVsZXNbbmFtZV0gfHwge30pO1xuICAgICAgcmV0dXJuIHRoaXMubW9kdWxlc1tuYW1lXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGhlbWU7XG59KCk7XG5cblRoZW1lLkRFRkFVTFRTID0ge1xuICBtb2R1bGVzOiB7fVxufTtcblRoZW1lLnRoZW1lcyA9IHtcbiAgZGVmYXVsdDogVGhlbWVcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFRoZW1lKTtcblxuLyoqKi8gfSksXG4vKiA1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cblxuLyoqKi8gfSksXG4vKiA1NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb3JlX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvcmVfbW9kdWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfaGFzX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxuXG5cblxudmFyIFVwbG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTW9kdWxlKSB7XG4gIF9pbmhlcml0cyhVcGxvYWRlciwgX01vZHVsZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihVcGxvYWRlcik7XG5cbiAgZnVuY3Rpb24gVXBsb2FkZXIocXVpbGwsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXBsb2FkZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBxdWlsbCwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5wcmV2ZW50SW1hZ2VVcGxvYWRpbmcoZmFsc2UpO1xuXG4gICAgX3RoaXMuYWRkRHJhZ092ZXJIYW5kbGVyKCk7XG5cbiAgICBfdGhpcy5hZGREcm9wSGFuZGxlcigpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFVwbG9hZGVyLCBbe1xuICAgIGtleTogXCJhZGREcmFnT3ZlckhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRHJhZ092ZXJIYW5kbGVyKCkge1xuICAgICAgaWYgKE9iamVjdChfdXRpbHNfaGFzX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSgpKSB7XG4gICAgICAgIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBpc01zSWUgPSB1YS5pbmRleE9mKCdtc2llICcpICE9PSAtMSB8fCB1YS5pbmRleE9mKCd0cmlkZW50LycpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdlZGdlLycpICE9PSAtMTtcblxuICAgICAgICBpZiAoaXNNc0llKSB7XG4gICAgICAgICAgdGhpcy5xdWlsbC5yb290LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGREcm9wSGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGREcm9wSGFuZGxlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnF1aWxsLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBub0ZpbGVzID0gZS5kYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoID09PSAwO1xuICAgICAgICB2YXIgb25Ecm9wID0gX3RoaXMyLm9wdGlvbnMub25Ecm9wO1xuXG4gICAgICAgIGlmIChvbkRyb3AgJiYgdHlwZW9mIG9uRHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uRHJvcChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub0ZpbGVzIHx8IF90aGlzMi5wcmV2ZW50SW1hZ2VVcGxvYWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBuYXRpdmU7XG5cbiAgICAgICAgaWYgKGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgICAgICBuYXRpdmUgPSBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICAgICAgbmF0aXZlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICBuYXRpdmUuc2V0U3RhcnQocG9zaXRpb24ub2Zmc2V0Tm9kZSwgcG9zaXRpb24ub2Zmc2V0KTtcbiAgICAgICAgICBuYXRpdmUuc2V0RW5kKHBvc2l0aW9uLm9mZnNldE5vZGUsIHBvc2l0aW9uLm9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBfdGhpczIucXVpbGwuc2VsZWN0aW9uLm5vcm1hbGl6ZU5hdGl2ZShuYXRpdmUpO1xuXG4gICAgICAgIHZhciByYW5nZSA9IF90aGlzMi5xdWlsbC5zZWxlY3Rpb24ubm9ybWFsaXplZFRvUmFuZ2Uobm9ybWFsaXplZCk7XG5cbiAgICAgICAgX3RoaXMyLnVwbG9hZChyYW5nZSwgZS5kYXRhVHJhbnNmZXIuZmlsZXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZXZlbnRJbWFnZVVwbG9hZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmV2ZW50SW1hZ2VVcGxvYWRpbmcodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMucHJldmVudEltYWdlVXBsb2FkID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnByZXZlbnRJbWFnZVVwbG9hZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwbG9hZChyYW5nZSwgZmlsZXMsIGZvcmNlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucHJldmVudEltYWdlVXBsb2FkICYmICFmb3JjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGxvYWRzID0gW107XG4gICAgICBBcnJheS5mcm9tKGZpbGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIGlmIChmaWxlICYmIF90aGlzMy5vcHRpb25zLm1pbWV0eXBlcy5pbmRleE9mKGZpbGUudHlwZSkgIT09IC0xKSB7XG4gICAgICAgICAgdXBsb2Fkcy5wdXNoKGZpbGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHVwbG9hZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuaGFuZGxlci5jYWxsKHRoaXMsIHJhbmdlLCB1cGxvYWRzLCB0aGlzLm9wdGlvbnMuaW1hZ2VCbG90KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVXBsb2FkZXI7XG59KF9jb3JlX21vZHVsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuVXBsb2FkZXIuREVGQVVMVFMgPSB7XG4gIG1pbWV0eXBlczogWydpbWFnZS9wbmcnLCAnaW1hZ2UvanBlZycsICdpbWFnZS9wanBlZycsICdpbWFnZS9naWYnLCAnaW1hZ2Uvd2VicCcsICdpbWFnZS9ibXAnLCAnaW1hZ2Uvc3ZnK3htbCcsICdpbWFnZS92bmQubWljcm9zb2Z0Lmljb24nXSxcbiAgaW1hZ2VCbG90OiAnaW1hZ2UnLFxuICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlLCBmaWxlcywgYmxvdE5hbWUpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlcyA9IGZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJlc29sdmUoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChpbWFnZXMpIHtcbiAgICAgIHZhciB1cGRhdGUgPSBpbWFnZXMucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwgaW1hZ2UpIHtcbiAgICAgICAgcmV0dXJuIGRlbHRhLmluc2VydChfZGVmaW5lUHJvcGVydHkoe30sIGJsb3ROYW1lLCBpbWFnZSkpO1xuICAgICAgfSwgbmV3IHF1aWxsX2RlbHRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKCkucmV0YWluKHJhbmdlLmluZGV4KS5kZWxldGUocmFuZ2UubGVuZ3RoKSk7XG5cbiAgICAgIF90aGlzNC5xdWlsbC51cGRhdGVDb250ZW50cyh1cGRhdGUsIF9jb3JlX2VtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zb3VyY2VzLlVTRVIpO1xuXG4gICAgICBfdGhpczQucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgaW1hZ2VzLmxlbmd0aCwgX2NvcmVfZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNvdXJjZXMuU0lMRU5UKTtcbiAgICB9KTtcbiAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoVXBsb2FkZXIpO1xuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUoYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24oZ2xvYmFsW25hbWVzcGFjZV0pIDogZ2xvYmFsW25hbWVzcGFjZV0gJiYgZ2xvYmFsW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA1NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NSkuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oODYpO1xudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzcpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMSk7XG52YXIgaXNGb3JjZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNik7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsW1RBUkdFVF0gfHwgc2V0R2xvYmFsKFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMubm9UYXJnZXRHZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG4vKiA1OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMCk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90ZXh0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG52YXIgR1VBUkRfVEVYVCA9IFwiXFx1RkVGRlwiO1xuXG52YXIgRW1iZWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbWJlZEJsb3QpIHtcbiAgX2luaGVyaXRzKEVtYmVkLCBfRW1iZWRCbG90KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEVtYmVkKTtcblxuICBmdW5jdGlvbiBFbWJlZChzY3JvbGwsIG5vZGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW1iZWQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzY3JvbGwsIG5vZGUpO1xuICAgIF90aGlzLmNvbnRlbnROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG4gICAgX3RoaXMuY29udGVudE5vZGUuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCBmYWxzZSk7XG5cbiAgICBBcnJheS5mcm9tKF90aGlzLmRvbU5vZGUuY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICBfdGhpcy5jb250ZW50Tm9kZS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgIH0pO1xuICAgIF90aGlzLmxlZnRHdWFyZCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKEdVQVJEX1RFWFQpO1xuICAgIF90aGlzLnJpZ2h0R3VhcmQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShHVUFSRF9URVhUKTtcblxuICAgIF90aGlzLmRvbU5vZGUuYXBwZW5kQ2hpbGQoX3RoaXMubGVmdEd1YXJkKTtcblxuICAgIF90aGlzLmRvbU5vZGUuYXBwZW5kQ2hpbGQoX3RoaXMuY29udGVudE5vZGUpO1xuXG4gICAgX3RoaXMuZG9tTm9kZS5hcHBlbmRDaGlsZChfdGhpcy5yaWdodEd1YXJkKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFbWJlZCwgW3tcbiAgICBrZXk6IFwiaW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXgobm9kZSwgb2Zmc2V0KSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy5sZWZ0R3VhcmQpIHJldHVybiAwO1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMucmlnaHRHdWFyZCkgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoRW1iZWQucHJvdG90eXBlKSwgXCJpbmRleFwiLCB0aGlzKS5jYWxsKHRoaXMsIG5vZGUsIG9mZnNldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc3RvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdG9yZShub2RlKSB7XG4gICAgICB2YXIgcmFuZ2U7XG4gICAgICB2YXIgdGV4dE5vZGU7XG4gICAgICB2YXIgdGV4dCA9IG5vZGUuZGF0YS5zcGxpdChHVUFSRF9URVhUKS5qb2luKCcnKTtcblxuICAgICAgaWYgKG5vZGUgPT09IHRoaXMubGVmdEd1YXJkKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXYgaW5zdGFuY2VvZiBfdGV4dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSB7XG4gICAgICAgICAgdmFyIHByZXZMZW5ndGggPSB0aGlzLnByZXYubGVuZ3RoKCk7XG4gICAgICAgICAgdGhpcy5wcmV2Lmluc2VydEF0KHByZXZMZW5ndGgsIHRleHQpO1xuICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnROb2RlOiB0aGlzLnByZXYuZG9tTm9kZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBwcmV2TGVuZ3RoICsgdGV4dC5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuc2Nyb2xsLmNyZWF0ZSh0ZXh0Tm9kZSksIHRoaXMpO1xuICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnROb2RlOiB0ZXh0Tm9kZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiB0ZXh0Lmxlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gdGhpcy5yaWdodEd1YXJkKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQgaW5zdGFuY2VvZiBfdGV4dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSB7XG4gICAgICAgICAgdGhpcy5uZXh0Lmluc2VydEF0KDAsIHRleHQpO1xuICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnROb2RlOiB0aGlzLm5leHQuZG9tTm9kZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiB0ZXh0Lmxlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5zY3JvbGwuY3JlYXRlKHRleHROb2RlKSwgdGhpcy5uZXh0KTtcbiAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZTogdGV4dE5vZGUsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogdGV4dC5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUuZGF0YSA9IEdVQVJEX1RFWFQ7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUobXV0YXRpb25zLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgbXV0YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgKG11dGF0aW9uLnRhcmdldCA9PT0gX3RoaXMyLmxlZnRHdWFyZCB8fCBtdXRhdGlvbi50YXJnZXQgPT09IF90aGlzMi5yaWdodEd1YXJkKSkge1xuICAgICAgICAgIHZhciByYW5nZSA9IF90aGlzMi5yZXN0b3JlKG11dGF0aW9uLnRhcmdldCk7XG5cbiAgICAgICAgICBpZiAocmFuZ2UpIGNvbnRleHQucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVtYmVkO1xufShwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIkVtYmVkQmxvdFwiXSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoRW1iZWQpO1xuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRJZDsgfSk7XG5mdW5jdGlvbiBnZXRJZCgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDYpO1xufVxuXG4vKioqLyB9KSxcbi8qIDYxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3F1aWxsLWRlbHRhL2Rpc3QvRGVsdGEuanNcbnZhciBEZWx0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgRGVsdGFfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oRGVsdGEpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3BhcmNobWVudC9zcmMvcGFyY2htZW50LnRzICsgMTcgbW9kdWxlc1xudmFyIHBhcmNobWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb3JlL3F1aWxsLmpzXG52YXIgcXVpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29yZS9tb2R1bGUuanNcbnZhciBjb3JlX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYmxvdHMvYmxvY2suanNcbnZhciBibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ibG90cy9icmVhay5qc1xudmFyIGJsb3RzX2JyZWFrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ibG90cy9jb250YWluZXIuanNcbnZhciBjb250YWluZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3V0aWxzL2lzX2RlZmluZWQuanNcbnZhciBpc19kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Zvcm1hdHMvdGFibGUvYXR0cmlidXRvcnMvY2VsbC5qc1xudmFyIGF0dHJpYnV0b3JzX2NlbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vZm9ybWF0cy90YWJsZS9hdHRyaWJ1dG9ycy90YWJsZS5qc1xudmFyIGF0dHJpYnV0b3JzX3RhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Zvcm1hdHMvdGFibGUvZ2V0X2lkLmpzXG52YXIgZ2V0X2lkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9mb3JtYXRzL3RhYmxlL3RvZ2dsZV9hdHRyaWJ1dGUuanNcbnZhciB0b2dnbGVfYXR0cmlidXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vZm9ybWF0cy90YWJsZS9pbmRleC5qc1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxuXG5cblxuXG5cblxudmFyIENFTExfSURFTlRJVFlfS0VZUyA9IFsncm93JywgJ2NlbGwnXTtcbnZhciBUQUJMRV9UQUdTID0gWydURCcsICdUSCcsICdUUicsICdUQk9EWScsICdUSEVBRCcsICdUQUJMRSddO1xudmFyIERBVEFfUFJFRklYID0gJ2RhdGEtdGFibGUtJztcblxudmFyIHRhYmxlX0NlbGxMaW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmxvY2spIHtcbiAgX2luaGVyaXRzKENlbGxMaW5lLCBfQmxvY2spO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQ2VsbExpbmUpO1xuXG4gIGZ1bmN0aW9uIENlbGxMaW5lKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDZWxsTGluZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2VsbExpbmUsIFt7XG4gICAga2V5OiBcIm9wdGltaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKCkge1xuICAgICAgdmFyIF9nZXQyO1xuXG4gICAgICB2YXIgcm93SWQgPSB0aGlzLmRvbU5vZGUuZ2V0QXR0cmlidXRlKFwiXCIuY29uY2F0KERBVEFfUFJFRklYLCBcInJvd1wiKSk7XG5cbiAgICAgIGlmICh0aGlzLnN0YXRpY3MucmVxdWlyZWRDb250YWluZXIgJiYgISh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIHRoaXMuc3RhdGljcy5yZXF1aXJlZENvbnRhaW5lcikpIHtcbiAgICAgICAgdmFyIGRvbU5vZGUgPSB0aGlzLmRvbU5vZGU7XG4gICAgICAgIHZhciBmb3JtYXRzID0ge1xuICAgICAgICAgIHJvdzogcm93SWRcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRvcnNfY2VsbFtcImJcIiAvKiBDRUxMX0ZPUk1BVFMgKi9dKS5mb3JFYWNoKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBkb21Ob2RlLmRhdGFzZXRbZm9ybWF0LnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3JtYXRzW2Zvcm1hdF0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndyYXAodGhpcy5zdGF0aWNzLnJlcXVpcmVkQ29udGFpbmVyLmJsb3ROYW1lLCBmb3JtYXRzKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIChfZ2V0MiA9IF9nZXQoX2dldFByb3RvdHlwZU9mKENlbGxMaW5lLnByb3RvdHlwZSksIFwib3B0aW1pemVcIiwgdGhpcykpLmNhbGwuYXBwbHkoX2dldDIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgaXNDZWxsID0gQ0VMTF9JREVOVElUWV9LRVlTLmluZGV4T2YobmFtZSkgPiAtMTtcblxuICAgICAgaWYgKGlzQ2VsbCB8fCBhdHRyaWJ1dG9yc190YWJsZVtcImJcIiAvKiBUQUJMRV9GT1JNQVRTICovXVtuYW1lXSB8fCBhdHRyaWJ1dG9yc19jZWxsW1wiYlwiIC8qIENFTExfRk9STUFUUyAqL11bbmFtZV0pIHtcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gXCJkYXRhLVwiLmNvbmNhdChpc0NlbGwgPyAndGFibGUtJyA6ICcnKS5jb25jYXQobmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgT2JqZWN0KHRvZ2dsZV9hdHRyaWJ1dGVbXCJhXCIgLyogZGVmYXVsdCAqL10pKHRoaXMuZG9tTm9kZSwgYXR0ck5hbWUsIHZhbHVlKTtcblxuICAgICAgICBpZiAoYXR0cmlidXRvcnNfY2VsbFtcImJcIiAvKiBDRUxMX0ZPUk1BVFMgKi9dW25hbWVdKSB7XG4gICAgICAgICAgdmFyIF90aGlzJGNlbGw7XG5cbiAgICAgICAgICAoX3RoaXMkY2VsbCA9IHRoaXMuY2VsbCgpKSA9PT0gbnVsbCB8fCBfdGhpcyRjZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRjZWxsLmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXR0cmlidXRvcnNfdGFibGVbXCJiXCIgLyogVEFCTEVfRk9STUFUUyAqL11bbmFtZV0pIHtcbiAgICAgICAgICB2YXIgX3RoaXMkY2VsbDIsIF90aGlzJGNlbGwyJHRhYmxlO1xuXG4gICAgICAgICAgKF90aGlzJGNlbGwyID0gdGhpcy5jZWxsKCkpID09PSBudWxsIHx8IF90aGlzJGNlbGwyID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RoaXMkY2VsbDIkdGFibGUgPSBfdGhpcyRjZWxsMi50YWJsZSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRjZWxsMiR0YWJsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkY2VsbDIkdGFibGUuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQ2VsbExpbmUucHJvdG90eXBlKSwgXCJmb3JtYXRcIiwgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNlbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2VsbCgpIHtcbiAgICAgIHJldHVybiAncm93JyBpbiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50IDogbnVsbDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKENlbGxMaW5lKSwgXCJjcmVhdGVcIiwgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cbiAgICAgIENFTExfSURFTlRJVFlfS0VZUy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF92YWx1ZSRrZXk7XG5cbiAgICAgICAgdmFyIGlkZW50aXR5TWFya2VyID0ga2V5ID09PSAncm93JyA/IHRhYmxlSWQgOiB0YWJsZV9jZWxsSWQ7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiXCIuY29uY2F0KERBVEFfUFJFRklYKS5jb25jYXQoa2V5KSwgKF92YWx1ZSRrZXkgPSB2YWx1ZVtrZXldKSAhPT0gbnVsbCAmJiBfdmFsdWUka2V5ICE9PSB2b2lkIDAgPyBfdmFsdWUka2V5IDogaWRlbnRpdHlNYXJrZXIoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIENFTExfSURFTlRJVFlfS0VZUy5yZWR1Y2UoZnVuY3Rpb24gKGZvcm1hdHMsIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgYXR0ck5hbWUgPSBcIlwiLmNvbmNhdChEQVRBX1BSRUZJWCkuY29uY2F0KGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgaWYgKGRvbU5vZGUuaGFzQXR0cmlidXRlKGF0dHJOYW1lKSkge1xuICAgICAgICAgIGZvcm1hdHNbYXR0cmlidXRlXSA9IGRvbU5vZGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICAgIH0sIHt9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2VsbExpbmU7XG59KGJsb2NrW1wiZFwiIC8qIGRlZmF1bHQgKi9dKTtcblxudGFibGVfQ2VsbExpbmUuYmxvdE5hbWUgPSAndGFibGVDZWxsTGluZSc7XG50YWJsZV9DZWxsTGluZS5jbGFzc05hbWUgPSAncWwtdGFibGUtY2VsbC1saW5lJztcbnRhYmxlX0NlbGxMaW5lLnRhZ05hbWUgPSAnUCc7XG5cbnZhciBIZWFkZXJDZWxsTGluZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NlbGxMaW5lKSB7XG4gIF9pbmhlcml0cyhIZWFkZXJDZWxsTGluZSwgX0NlbGxMaW5lKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihIZWFkZXJDZWxsTGluZSk7XG5cbiAgZnVuY3Rpb24gSGVhZGVyQ2VsbExpbmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlYWRlckNlbGxMaW5lKTtcblxuICAgIHJldHVybiBfc3VwZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gSGVhZGVyQ2VsbExpbmU7XG59KHRhYmxlX0NlbGxMaW5lKTtcblxuSGVhZGVyQ2VsbExpbmUuYmxvdE5hbWUgPSAndGFibGVIZWFkZXJDZWxsTGluZSc7XG5IZWFkZXJDZWxsTGluZS5jbGFzc05hbWUgPSAncWwtdGFibGUtaGVhZGVyLWNlbGwtbGluZSc7XG5cbnZhciB0YWJsZV9CYXNlQ2VsbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbnRhaW5lcikge1xuICBfaW5oZXJpdHMoQmFzZUNlbGwsIF9Db250YWluZXIpO1xuXG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKEJhc2VDZWxsKTtcblxuICBmdW5jdGlvbiBCYXNlQ2VsbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUNlbGwpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlQ2VsbCwgW3tcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIF9DRUxMX0ZPUk1BVFMkbmFtZTtcblxuICAgICAgKF9DRUxMX0ZPUk1BVFMkbmFtZSA9IGF0dHJpYnV0b3JzX2NlbGxbXCJiXCIgLyogQ0VMTF9GT1JNQVRTICovXVtuYW1lXSkgPT09IG51bGwgfHwgX0NFTExfRk9STUFUUyRuYW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfQ0VMTF9GT1JNQVRTJG5hbWUuYWRkKHRoaXMuZG9tTm9kZSwgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGVja01lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrTWVyZ2UoKSB7XG4gICAgICBpZiAoX2dldChfZ2V0UHJvdG90eXBlT2YoQmFzZUNlbGwucHJvdG90eXBlKSwgXCJjaGVja01lcmdlXCIsIHRoaXMpLmNhbGwodGhpcykgJiYgdGhpcy5uZXh0LmNoaWxkcmVuLmhlYWQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgdGhpc0hlYWQgPSB0aGlzLmNoaWxkcmVuLmhlYWQuZm9ybWF0cygpW3RoaXMuY2hpbGRyZW4uaGVhZC5zdGF0aWNzLmJsb3ROYW1lXTtcbiAgICAgICAgdmFyIHRoaXNUYWlsID0gdGhpcy5jaGlsZHJlbi50YWlsLmZvcm1hdHMoKVt0aGlzLmNoaWxkcmVuLnRhaWwuc3RhdGljcy5ibG90TmFtZV07XG4gICAgICAgIHZhciBuZXh0SGVhZCA9IHRoaXMubmV4dC5jaGlsZHJlbi5oZWFkLmZvcm1hdHMoKVt0aGlzLm5leHQuY2hpbGRyZW4uaGVhZC5zdGF0aWNzLmJsb3ROYW1lXTtcbiAgICAgICAgdmFyIG5leHRUYWlsID0gdGhpcy5uZXh0LmNoaWxkcmVuLnRhaWwuZm9ybWF0cygpW3RoaXMubmV4dC5jaGlsZHJlbi50YWlsLnN0YXRpY3MuYmxvdE5hbWVdO1xuICAgICAgICByZXR1cm4gdGhpc0hlYWQuY2VsbCA9PT0gdGhpc1RhaWwuY2VsbCAmJiB0aGlzSGVhZC5jZWxsID09PSBuZXh0SGVhZC5jZWxsICYmIHRoaXNIZWFkLmNlbGwgPT09IG5leHRUYWlsLmNlbGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKCkge1xuICAgICAgcmV0dXJuIEJhc2VDZWxsLmNlbGxGb3JtYXRzKHRoaXMuZG9tTm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNlbGxPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2VsbE9mZnNldCgpIHtcbiAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm93KCkge1xuICAgICAgcmV0dXJuICd0YWJsZScgaW4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudCA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvd09mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3dPZmZzZXQoKSB7XG4gICAgICBpZiAodGhpcy5yb3coKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3coKS5yb3dPZmZzZXQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0YWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0YWJsZSgpIHtcbiAgICAgIHZhciBfdGhpcyRyb3c7XG5cbiAgICAgIHJldHVybiAoX3RoaXMkcm93ID0gdGhpcy5yb3coKSkgPT09IG51bGwgfHwgX3RoaXMkcm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRyb3cudGFibGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3B0aW1pemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW1pemUoKSB7XG4gICAgICB2YXIgX3RoaXMkZG9tTm9kZSRnZXRBdHRyLCBfZ2V0MztcblxuICAgICAgdmFyIHJvd0lkID0gKF90aGlzJGRvbU5vZGUkZ2V0QXR0ciA9IHRoaXMuZG9tTm9kZS5nZXRBdHRyaWJ1dGUoXCJcIi5jb25jYXQoREFUQV9QUkVGSVgsIFwicm93XCIpKSkgIT09IG51bGwgJiYgX3RoaXMkZG9tTm9kZSRnZXRBdHRyICE9PSB2b2lkIDAgPyBfdGhpcyRkb21Ob2RlJGdldEF0dHIgOiB0aGlzLmRvbU5vZGUuZ2V0QXR0cmlidXRlKFwiXCIuY29uY2F0KERBVEFfUFJFRklYLCBcImhlYWRlci1yb3dcIikpO1xuXG4gICAgICBpZiAodGhpcy5zdGF0aWNzLnJlcXVpcmVkQ29udGFpbmVyICYmICEodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiB0aGlzLnN0YXRpY3MucmVxdWlyZWRDb250YWluZXIpKSB7XG4gICAgICAgIHRoaXMud3JhcCh0aGlzLnN0YXRpY3MucmVxdWlyZWRDb250YWluZXIuYmxvdE5hbWUsIHtcbiAgICAgICAgICByb3c6IHJvd0lkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICAoX2dldDMgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihCYXNlQ2VsbC5wcm90b3R5cGUpLCBcIm9wdGltaXplXCIsIHRoaXMpKS5jYWxsLmFwcGx5KF9nZXQzLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKEJhc2VDZWxsKSwgXCJjcmVhdGVcIiwgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgdmFyIF9DRUxMX0ZPUk1BVFMkZm9ybWF0O1xuXG4gICAgICAgICAgKF9DRUxMX0ZPUk1BVFMkZm9ybWF0ID0gYXR0cmlidXRvcnNfY2VsbFtcImJcIiAvKiBDRUxMX0ZPUk1BVFMgKi9dW2Zvcm1hdF0pID09PSBudWxsIHx8IF9DRUxMX0ZPUk1BVFMkZm9ybWF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfQ0VMTF9GT1JNQVRTJGZvcm1hdC5hZGQobm9kZSwgdmFsdWVbZm9ybWF0XSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2VsbEZvcm1hdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2VsbEZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgdmFyIGZvcm1hdHMgPSB7fTtcblxuICAgICAgaWYgKGRvbU5vZGUuaGFzQXR0cmlidXRlKFwiXCIuY29uY2F0KERBVEFfUFJFRklYLCBcInJvd1wiKSkgfHwgZG9tTm9kZS5oYXNBdHRyaWJ1dGUoXCJcIi5jb25jYXQoREFUQV9QUkVGSVgsIFwiaGVhZGVyLXJvd1wiKSkpIHtcbiAgICAgICAgdmFyIF9kb21Ob2RlJGdldEF0dHJpYnV0ZTtcblxuICAgICAgICBmb3JtYXRzLnJvdyA9IChfZG9tTm9kZSRnZXRBdHRyaWJ1dGUgPSBkb21Ob2RlLmdldEF0dHJpYnV0ZShcIlwiLmNvbmNhdChEQVRBX1BSRUZJWCwgXCJyb3dcIikpKSAhPT0gbnVsbCAmJiBfZG9tTm9kZSRnZXRBdHRyaWJ1dGUgIT09IHZvaWQgMCA/IF9kb21Ob2RlJGdldEF0dHJpYnV0ZSA6IGRvbU5vZGUuZ2V0QXR0cmlidXRlKFwiXCIuY29uY2F0KERBVEFfUFJFRklYLCBcImhlYWRlci1yb3dcIikpO1xuICAgICAgfVxuXG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dG9yc19jZWxsW1wiYlwiIC8qIENFTExfRk9STUFUUyAqL10pLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICB2YXIgX2RvbU5vZGUkZmlyc3RFbGVtZW50O1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IChfZG9tTm9kZSRmaXJzdEVsZW1lbnQgPSBkb21Ob2RlLmZpcnN0RWxlbWVudENoaWxkKSA9PT0gbnVsbCB8fCBfZG9tTm9kZSRmaXJzdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kb21Ob2RlJGZpcnN0RWxlbWVudC5kYXRhc2V0W2Zvcm1hdC50b0xvd2VyQ2FzZSgpXTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBmb3JtYXRzW2Zvcm1hdF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm9ybWF0cztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZUNlbGw7XG59KGNvbnRhaW5lcltcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cbnRhYmxlX0Jhc2VDZWxsLnRhZ05hbWUgPSBbJ1REJywgJ1RIJ107XG5cbnZhciBUYWJsZUNlbGwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQ2VsbCkge1xuICBfaW5oZXJpdHMoVGFibGVDZWxsLCBfQmFzZUNlbGwpO1xuXG4gIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKFRhYmxlQ2VsbCk7XG5cbiAgZnVuY3Rpb24gVGFibGVDZWxsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJsZUNlbGwpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUYWJsZUNlbGwsIFt7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChuYW1lID09PSAncm93Jykge1xuICAgICAgICB0aGlzLmRvbU5vZGUuc2V0QXR0cmlidXRlKFwiXCIuY29uY2F0KERBVEFfUFJFRklYKS5jb25jYXQobmFtZSksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIGNoaWxkLmZvcm1hdChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoVGFibGVDZWxsLnByb3RvdHlwZSksIFwiZm9ybWF0XCIsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgIHZhciBub2RlID0gX2dldChfZ2V0UHJvdG90eXBlT2YoVGFibGVDZWxsKSwgXCJjcmVhdGVcIiwgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cbiAgICAgIHZhciBhdHRyTmFtZSA9IFwiXCIuY29uY2F0KERBVEFfUFJFRklYLCBcInJvd1wiKTtcblxuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUucm93KSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCB2YWx1ZS5yb3cpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGFibGVDZWxsO1xufSh0YWJsZV9CYXNlQ2VsbCk7XG5cblRhYmxlQ2VsbC5ibG90TmFtZSA9ICd0YWJsZUNlbGwnO1xuVGFibGVDZWxsLmNsYXNzTmFtZSA9ICdxbC10YWJsZS1kYXRhLWNlbGwnO1xuVGFibGVDZWxsLmRhdGFBdHRyaWJ1dGUgPSBcIlwiLmNvbmNhdChEQVRBX1BSRUZJWCwgXCJyb3dcIik7XG5cbnZhciBUYWJsZUhlYWRlckNlbGwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQ2VsbDIpIHtcbiAgX2luaGVyaXRzKFRhYmxlSGVhZGVyQ2VsbCwgX0Jhc2VDZWxsMik7XG5cbiAgdmFyIF9zdXBlcjUgPSBfY3JlYXRlU3VwZXIoVGFibGVIZWFkZXJDZWxsKTtcblxuICBmdW5jdGlvbiBUYWJsZUhlYWRlckNlbGwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYmxlSGVhZGVyQ2VsbCk7XG5cbiAgICByZXR1cm4gX3N1cGVyNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRhYmxlSGVhZGVyQ2VsbCwgW3tcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKG5hbWUgPT09ICdyb3cnKSB7XG4gICAgICAgIHRoaXMuZG9tTm9kZS5zZXRBdHRyaWJ1dGUoXCJcIi5jb25jYXQoREFUQV9QUkVGSVgpLmNvbmNhdChuYW1lKSwgdmFsdWUpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgY2hpbGQuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihUYWJsZUhlYWRlckNlbGwucHJvdG90eXBlKSwgXCJmb3JtYXRcIiwgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIG5vZGUgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihUYWJsZUhlYWRlckNlbGwpLCBcImNyZWF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcblxuICAgICAgdmFyIGF0dHJOYW1lID0gXCJcIi5jb25jYXQoREFUQV9QUkVGSVgsIFwiaGVhZGVyLXJvd1wiKTtcblxuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLnJvdykge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgdmFsdWUucm93KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRhYmxlSGVhZGVyQ2VsbDtcbn0odGFibGVfQmFzZUNlbGwpO1xuXG5UYWJsZUhlYWRlckNlbGwudGFnTmFtZSA9IFsnVEgnLCAnVEQnXTtcblRhYmxlSGVhZGVyQ2VsbC5jbGFzc05hbWUgPSAncWwtdGFibGUtaGVhZGVyLWNlbGwnO1xuVGFibGVIZWFkZXJDZWxsLmJsb3ROYW1lID0gJ3RhYmxlSGVhZGVyQ2VsbCc7XG5UYWJsZUhlYWRlckNlbGwuZGF0YUF0dHJpYnV0ZSA9IFwiXCIuY29uY2F0KERBVEFfUFJFRklYLCBcImhlYWRlci1yb3dcIik7XG5cbnZhciB0YWJsZV9CYXNlUm93ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29udGFpbmVyMikge1xuICBfaW5oZXJpdHMoQmFzZVJvdywgX0NvbnRhaW5lcjIpO1xuXG4gIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKEJhc2VSb3cpO1xuXG4gIGZ1bmN0aW9uIEJhc2VSb3coKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VSb3cpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlUm93LCBbe1xuICAgIGtleTogXCJjaGVja01lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrTWVyZ2UoKSB7XG4gICAgICBpZiAoX2dldChfZ2V0UHJvdG90eXBlT2YoQmFzZVJvdy5wcm90b3R5cGUpLCBcImNoZWNrTWVyZ2VcIiwgdGhpcykuY2FsbCh0aGlzKSAmJiBPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkodGhpcy5uZXh0LmNoaWxkcmVuLmhlYWQpKSB7XG4gICAgICAgIHZhciBmb3JtYXROYW1lID0gJ3Jvdyc7XG4gICAgICAgIHZhciB0aGlzSGVhZCA9IHRoaXMuY2hpbGRyZW4uaGVhZC5mb3JtYXRzKCk7XG4gICAgICAgIHZhciB0aGlzVGFpbCA9IHRoaXMuY2hpbGRyZW4udGFpbC5mb3JtYXRzKCk7XG4gICAgICAgIHZhciBuZXh0SGVhZCA9IHRoaXMubmV4dC5jaGlsZHJlbi5oZWFkLmZvcm1hdHMoKTtcbiAgICAgICAgdmFyIG5leHRUYWlsID0gdGhpcy5uZXh0LmNoaWxkcmVuLnRhaWwuZm9ybWF0cygpO1xuICAgICAgICByZXR1cm4gdGhpc0hlYWRbZm9ybWF0TmFtZV0gPT09IHRoaXNUYWlsW2Zvcm1hdE5hbWVdICYmIHRoaXNIZWFkW2Zvcm1hdE5hbWVdID09PSBuZXh0SGVhZFtmb3JtYXROYW1lXSAmJiB0aGlzSGVhZFtmb3JtYXROYW1lXSA9PT0gbmV4dFRhaWxbZm9ybWF0TmFtZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3B0aW1pemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW1pemUoKSB7XG4gICAgICB2YXIgX2dldDQsXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICAoX2dldDQgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihCYXNlUm93LnByb3RvdHlwZSksIFwib3B0aW1pemVcIiwgdGhpcykpLmNhbGwuYXBwbHkoX2dldDQsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuXG4gICAgICB2YXIgZm9ybWF0TmFtZSA9IHRoaXMuY2hpbGRGb3JtYXROYW1lO1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShjaGlsZC5uZXh0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZEZvcm1hdHMgPSBjaGlsZC5mb3JtYXRzKCk7XG4gICAgICAgIHZhciBuZXh0Rm9ybWF0cyA9IGNoaWxkLm5leHQuZm9ybWF0cygpO1xuXG4gICAgICAgIGlmIChjaGlsZEZvcm1hdHNbZm9ybWF0TmFtZV0gIT09IG5leHRGb3JtYXRzW2Zvcm1hdE5hbWVdKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBfdGhpcy5zcGxpdEFmdGVyKGNoaWxkKTtcblxuICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBuZXh0Lm9wdGltaXplKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF90aGlzLnByZXYpIHtcbiAgICAgICAgICAgIF90aGlzLnByZXYub3B0aW1pemUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3dPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm93T2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRhYmxlKCkge1xuICAgICAgdmFyIF90aGlzJHBhcmVudDtcblxuICAgICAgcmV0dXJuIChfdGhpcyRwYXJlbnQgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX3RoaXMkcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoKSB7XG4gICAgICB2YXIgZm9ybWF0cyA9IHt9O1xuICAgICAgdmFyIGF0dHJOYW1lID0gXCJcIi5jb25jYXQoREFUQV9QUkVGSVgsIFwicm93XCIpO1xuXG4gICAgICBpZiAodGhpcy5kb21Ob2RlLmhhc0F0dHJpYnV0ZShhdHRyTmFtZSkpIHtcbiAgICAgICAgZm9ybWF0c1thdHRyTmFtZV0gPSB0aGlzLmRvbU5vZGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIG5vZGUgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihCYXNlUm93KSwgXCJjcmVhdGVcIiwgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwICYmIHZhbHVlLnJvdykge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcIlwiLmNvbmNhdChEQVRBX1BSRUZJWCwgXCJyb3dcIiksIHZhbHVlLnJvdyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlUm93O1xufShjb250YWluZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG50YWJsZV9CYXNlUm93LnRhZ05hbWUgPSAnVFInO1xuXG52YXIgVGFibGVSb3cgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlUm93KSB7XG4gIF9pbmhlcml0cyhUYWJsZVJvdywgX0Jhc2VSb3cpO1xuXG4gIHZhciBfc3VwZXI3ID0gX2NyZWF0ZVN1cGVyKFRhYmxlUm93KTtcblxuICBmdW5jdGlvbiBUYWJsZVJvdyhzY3JvbGwsIGRvbU5vZGUpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYmxlUm93KTtcblxuICAgIF90aGlzMiA9IF9zdXBlcjcuY2FsbCh0aGlzLCBzY3JvbGwsIGRvbU5vZGUpO1xuICAgIF90aGlzMi5jaGlsZEZvcm1hdE5hbWUgPSAndGFibGUnO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICByZXR1cm4gVGFibGVSb3c7XG59KHRhYmxlX0Jhc2VSb3cpO1xuXG5UYWJsZVJvdy5ibG90TmFtZSA9ICd0YWJsZVJvdyc7XG5cbnZhciBUYWJsZUhlYWRlclJvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VSb3cyKSB7XG4gIF9pbmhlcml0cyhUYWJsZUhlYWRlclJvdywgX0Jhc2VSb3cyKTtcblxuICB2YXIgX3N1cGVyOCA9IF9jcmVhdGVTdXBlcihUYWJsZUhlYWRlclJvdyk7XG5cbiAgZnVuY3Rpb24gVGFibGVIZWFkZXJSb3coc2Nyb2xsLCBkb21Ob2RlKSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJsZUhlYWRlclJvdyk7XG5cbiAgICBfdGhpczMgPSBfc3VwZXI4LmNhbGwodGhpcywgc2Nyb2xsLCBkb21Ob2RlKTtcbiAgICBfdGhpczMuY2hpbGRGb3JtYXROYW1lID0gJ3RhYmxlSGVhZGVyQ2VsbCc7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHJldHVybiBUYWJsZUhlYWRlclJvdztcbn0odGFibGVfQmFzZVJvdyk7XG5cblRhYmxlSGVhZGVyUm93LmJsb3ROYW1lID0gJ3RhYmxlSGVhZGVyUm93JztcblxudmFyIHRhYmxlX1Jvd0NvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbnRhaW5lcjMpIHtcbiAgX2luaGVyaXRzKFJvd0NvbnRhaW5lciwgX0NvbnRhaW5lcjMpO1xuXG4gIHZhciBfc3VwZXI5ID0gX2NyZWF0ZVN1cGVyKFJvd0NvbnRhaW5lcik7XG5cbiAgZnVuY3Rpb24gUm93Q29udGFpbmVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3dDb250YWluZXIpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSb3dDb250YWluZXIsIFt7XG4gICAga2V5OiBcIm9wdGltaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKCkge1xuICAgICAgdmFyIF9nZXQ1O1xuXG4gICAgICBpZiAodGhpcy5zdGF0aWNzLnJlcXVpcmVkQ29udGFpbmVyICYmICEodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiB0aGlzLnN0YXRpY3MucmVxdWlyZWRDb250YWluZXIpKSB7XG4gICAgICAgIHZhciBkb21Ob2RlID0gdGhpcy5jaGlsZHJlbi5oZWFkLmNoaWxkcmVuLmhlYWQuY2hpbGRyZW4uaGVhZC5kb21Ob2RlO1xuICAgICAgICB2YXIgZm9ybWF0cyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dG9yc190YWJsZVtcImJcIiAvKiBUQUJMRV9GT1JNQVRTICovXSkuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZG9tTm9kZS5kYXRhc2V0W2Zvcm1hdC50b0xvd2VyQ2FzZSgpXTtcblxuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgZm9ybWF0c1tmb3JtYXRdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53cmFwKHRoaXMuc3RhdGljcy5yZXF1aXJlZENvbnRhaW5lci5ibG90TmFtZSwgZm9ybWF0cyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIChfZ2V0NSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKFJvd0NvbnRhaW5lci5wcm90b3R5cGUpLCBcIm9wdGltaXplXCIsIHRoaXMpKS5jYWxsLmFwcGx5KF9nZXQ1LCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUm93Q29udGFpbmVyO1xufShjb250YWluZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG52YXIgVGFibGVCb2R5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUm93Q29udGFpbmVyKSB7XG4gIF9pbmhlcml0cyhUYWJsZUJvZHksIF9Sb3dDb250YWluZXIpO1xuXG4gIHZhciBfc3VwZXIxMCA9IF9jcmVhdGVTdXBlcihUYWJsZUJvZHkpO1xuXG4gIGZ1bmN0aW9uIFRhYmxlQm9keSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGFibGVCb2R5KTtcblxuICAgIHJldHVybiBfc3VwZXIxMC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIFRhYmxlQm9keTtcbn0odGFibGVfUm93Q29udGFpbmVyKTtcblxuVGFibGVCb2R5LmJsb3ROYW1lID0gJ3RhYmxlQm9keSc7XG5UYWJsZUJvZHkudGFnTmFtZSA9ICdUQk9EWSc7XG5cbnZhciBUYWJsZUhlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Jvd0NvbnRhaW5lcjIpIHtcbiAgX2luaGVyaXRzKFRhYmxlSGVhZGVyLCBfUm93Q29udGFpbmVyMik7XG5cbiAgdmFyIF9zdXBlcjExID0gX2NyZWF0ZVN1cGVyKFRhYmxlSGVhZGVyKTtcblxuICBmdW5jdGlvbiBUYWJsZUhlYWRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGFibGVIZWFkZXIpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjExLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gVGFibGVIZWFkZXI7XG59KHRhYmxlX1Jvd0NvbnRhaW5lcik7XG5cblRhYmxlSGVhZGVyLmJsb3ROYW1lID0gJ3RhYmxlSGVhZGVyJztcblRhYmxlSGVhZGVyLnRhZ05hbWUgPSAnVEhFQUQnO1xuXG52YXIgdGFibGVfVGFibGVDb250YWluZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db250YWluZXI0KSB7XG4gIF9pbmhlcml0cyhUYWJsZUNvbnRhaW5lciwgX0NvbnRhaW5lcjQpO1xuXG4gIHZhciBfc3VwZXIxMiA9IF9jcmVhdGVTdXBlcihUYWJsZUNvbnRhaW5lcik7XG5cbiAgZnVuY3Rpb24gVGFibGVDb250YWluZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYmxlQ29udGFpbmVyKTtcblxuICAgIHJldHVybiBfc3VwZXIxMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRhYmxlQ29udGFpbmVyLCBbe1xuICAgIGtleTogXCJiYWxhbmNlQ2VsbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmFsYW5jZUNlbGxzKCkge1xuICAgICAgdmFyIGhlYWRlclJvd3MgPSB0aGlzLmRlc2NlbmRhbnRzKFRhYmxlSGVhZGVyUm93KTtcbiAgICAgIHZhciBib2R5Um93cyA9IHRoaXMuZGVzY2VuZGFudHMoVGFibGVSb3cpO1xuICAgICAgdmFyIG1heENvbENvdW50ID0gdGhpcy5nZXRNYXhUYWJsZUNvbENvdW50KGhlYWRlclJvd3MsIGJvZHlSb3dzKTtcbiAgICAgIHRoaXMuYmFsYW5jZVJvd3MobWF4Q29sQ291bnQsIGhlYWRlclJvd3MsIFRhYmxlSGVhZGVyQ2VsbCk7XG4gICAgICB0aGlzLmJhbGFuY2VSb3dzKG1heENvbENvdW50LCBib2R5Um93cywgVGFibGVDZWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF4VGFibGVDb2xDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhUYWJsZUNvbENvdW50KGhlYWRlclJvd3MsIGJvZHlSb3dzKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5nZXRNYXhSb3dDb2xDb3VudChoZWFkZXJSb3dzKSwgdGhpcy5nZXRNYXhSb3dDb2xDb3VudChib2R5Um93cykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXhSb3dDb2xDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhSb3dDb2xDb3VudChyb3dzKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICB9KSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiYWxhbmNlUm93c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYWxhbmNlUm93cyhtYXhDb2xDb3VudCwgcm93cywgQ2VsbENsYXNzKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgbmV3IEFycmF5KG1heENvbENvdW50IC0gcm93LmNoaWxkcmVuLmxlbmd0aCkuZmlsbCgwKS5mb3JFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgICBpZiAoT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKHJvdy5jaGlsZHJlbi5oZWFkKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBDZWxsQ2xhc3MuY2VsbEZvcm1hdHMocm93LmNoaWxkcmVuLmhlYWQuZG9tTm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJsb3QgPSBfdGhpczQuc2Nyb2xsLmNyZWF0ZShDZWxsQ2xhc3MuYmxvdE5hbWUsIHZhbHVlKTtcblxuICAgICAgICAgIHZhciBjZWxsTGluZSA9IF90aGlzNC5zY3JvbGwuY3JlYXRlKENlbGxDbGFzcy5hbGxvd2VkQ2hpbGRyZW5bMF0uYmxvdE5hbWUsIHZhbHVlKTtcblxuICAgICAgICAgIGJsb3QuYXBwZW5kQ2hpbGQoY2VsbExpbmUpO1xuICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChibG90KTtcbiAgICAgICAgICBibG90Lm9wdGltaXplKCk7IC8vIEFkZCBicmVhayBibG90XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNlbGxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNlbGxzKGNvbHVtbikge1xuICAgICAgcmV0dXJuIHRoaXMucm93cygpLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiByb3cuY2hpbGRyZW4uYXQoY29sdW1uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVDb2x1bW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQ29sdW1uKGluZGV4KSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgW1RhYmxlSGVhZGVyLCBUYWJsZUJvZHldLmZvckVhY2goZnVuY3Rpb24gKGJsb3QpIHtcbiAgICAgICAgdmFyIF90aGlzNSRkZXNjZW5kYW50cyA9IF90aGlzNS5kZXNjZW5kYW50cyhibG90KSxcbiAgICAgICAgICAgIF90aGlzNSRkZXNjZW5kYW50czIgPSBfc2xpY2VkVG9BcnJheShfdGhpczUkZGVzY2VuZGFudHMsIDEpLFxuICAgICAgICAgICAgdGFibGVQYXJ0ID0gX3RoaXM1JGRlc2NlbmRhbnRzMlswXTtcblxuICAgICAgICBpZiAoIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh0YWJsZVBhcnQpIHx8ICFPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkodGFibGVQYXJ0LmNoaWxkcmVuLmhlYWQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFibGVQYXJ0LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgIHZhciBjZWxsID0gcm93LmNoaWxkcmVuLmF0KGluZGV4KTtcblxuICAgICAgICAgIGlmIChPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkoY2VsbCkpIHtcbiAgICAgICAgICAgIGNlbGwucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRDb2x1bW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Q29sdW1uKGluZGV4KSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgW1RhYmxlSGVhZGVyLCBUYWJsZUJvZHldLmZvckVhY2goZnVuY3Rpb24gKGJsb3QpIHtcbiAgICAgICAgdmFyIF90aGlzNiRkZXNjZW5kYW50cyA9IF90aGlzNi5kZXNjZW5kYW50cyhibG90KSxcbiAgICAgICAgICAgIF90aGlzNiRkZXNjZW5kYW50czIgPSBfc2xpY2VkVG9BcnJheShfdGhpczYkZGVzY2VuZGFudHMsIDEpLFxuICAgICAgICAgICAgdGFibGVQYXJ0ID0gX3RoaXM2JGRlc2NlbmRhbnRzMlswXTtcblxuICAgICAgICBpZiAoIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh0YWJsZVBhcnQpIHx8ICFPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkodGFibGVQYXJ0LmNoaWxkcmVuLmhlYWQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIENlbGxCbG90ID0gYmxvdCA9PT0gVGFibGVIZWFkZXIgPyBUYWJsZUhlYWRlckNlbGwgOiBUYWJsZUNlbGw7XG4gICAgICAgIHZhciBDZWxsTGluZUJsb3QgPSBibG90ID09PSBUYWJsZUhlYWRlciA/IEhlYWRlckNlbGxMaW5lIDogdGFibGVfQ2VsbExpbmU7XG4gICAgICAgIHRhYmxlUGFydC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICB2YXIgcmVmID0gcm93LmNoaWxkcmVuLmF0KGluZGV4KTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBDZWxsTGluZUJsb3QuZm9ybWF0cyhyb3cuY2hpbGRyZW4uaGVhZC5jaGlsZHJlbi5oZWFkLmRvbU5vZGUpO1xuXG4gICAgICAgICAgdmFyIGNlbGwgPSBfdGhpczYuc2Nyb2xsLmNyZWF0ZShDZWxsQmxvdC5ibG90TmFtZSwge1xuICAgICAgICAgICAgcm93OiB2YWx1ZS5yb3dcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBjZWxsTGluZSA9IF90aGlzNi5zY3JvbGwuY3JlYXRlKENlbGxMaW5lQmxvdC5ibG90TmFtZSwge1xuICAgICAgICAgICAgcm93OiB2YWx1ZS5yb3dcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBlbXB0eUxpbmUgPSBfdGhpczYuc2Nyb2xsLmNyZWF0ZShibG90c19icmVha1tcImFcIiAvKiBkZWZhdWx0ICovXS5ibG90TmFtZSk7XG5cbiAgICAgICAgICBjZWxsTGluZS5hcHBlbmRDaGlsZChlbXB0eUxpbmUpO1xuICAgICAgICAgIGNlbGwuYXBwZW5kQ2hpbGQoY2VsbExpbmUpO1xuICAgICAgICAgIHJvdy5pbnNlcnRCZWZvcmUoY2VsbCwgcmVmKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Um93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFJvdyhpbmRleCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGhpcyRkZXNjZW5kYW50cyA9IHRoaXMuZGVzY2VuZGFudHMoVGFibGVCb2R5KSxcbiAgICAgICAgICBfdGhpcyRkZXNjZW5kYW50czIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRkZXNjZW5kYW50cywgMSksXG4gICAgICAgICAgYm9keSA9IF90aGlzJGRlc2NlbmRhbnRzMlswXTtcblxuICAgICAgaWYgKCFPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkoYm9keSkgfHwgIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShib2R5LmNoaWxkcmVuLmhlYWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkID0gdGFibGVJZCgpO1xuICAgICAgdmFyIHJvdyA9IHRoaXMuc2Nyb2xsLmNyZWF0ZShUYWJsZVJvdy5ibG90TmFtZSwge1xuICAgICAgICByb3c6IGlkXG4gICAgICB9KTtcbiAgICAgIGJvZHkuY2hpbGRyZW4uaGVhZC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNlbGwgPSBfdGhpczcuc2Nyb2xsLmNyZWF0ZShUYWJsZUNlbGwuYmxvdE5hbWUsIHtcbiAgICAgICAgICByb3c6IGlkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjZWxsTGluZSA9IF90aGlzNy5zY3JvbGwuY3JlYXRlKHRhYmxlX0NlbGxMaW5lLmJsb3ROYW1lLCB7XG4gICAgICAgICAgcm93OiBpZFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZW1wdHlMaW5lID0gX3RoaXM3LnNjcm9sbC5jcmVhdGUoYmxvdHNfYnJlYWtbXCJhXCIgLyogZGVmYXVsdCAqL10uYmxvdE5hbWUpO1xuXG4gICAgICAgIGNlbGxMaW5lLmFwcGVuZENoaWxkKGVtcHR5TGluZSk7XG4gICAgICAgIGNlbGwuYXBwZW5kQ2hpbGQoY2VsbExpbmUpO1xuICAgICAgICByb3cuYXBwZW5kQ2hpbGQoY2VsbCk7XG4gICAgICB9KTtcbiAgICAgIHZhciByZWYgPSBib2R5LmNoaWxkcmVuLmF0KGluZGV4KTtcbiAgICAgIGJvZHkuaW5zZXJ0QmVmb3JlKHJvdywgcmVmKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0SGVhZGVyUm93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEhlYWRlclJvdygpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMkZGVzY2VuZGFudHMzID0gdGhpcy5kZXNjZW5kYW50cyhUYWJsZUhlYWRlciksXG4gICAgICAgICAgX3RoaXMkZGVzY2VuZGFudHM0ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkZGVzY2VuZGFudHMzLCAxKSxcbiAgICAgICAgICBoZWFkZXIgPSBfdGhpcyRkZXNjZW5kYW50czRbMF07XG5cbiAgICAgIHZhciBfdGhpcyRkZXNjZW5kYW50czUgPSB0aGlzLmRlc2NlbmRhbnRzKFRhYmxlQm9keSksXG4gICAgICAgICAgX3RoaXMkZGVzY2VuZGFudHM2ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkZGVzY2VuZGFudHM1LCAxKSxcbiAgICAgICAgICBib2R5ID0gX3RoaXMkZGVzY2VuZGFudHM2WzBdO1xuXG4gICAgICBpZiAoT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKGhlYWRlcikgfHwgIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShib2R5KSB8fCAhT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKGJvZHkuY2hpbGRyZW4uaGVhZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWQgPSB0YWJsZUlkKCk7XG4gICAgICB2YXIgbmV3SGVhZGVyID0gdGhpcy5zY3JvbGwuY3JlYXRlKFRhYmxlSGVhZGVyLmJsb3ROYW1lKTtcbiAgICAgIHZhciByb3cgPSB0aGlzLnNjcm9sbC5jcmVhdGUoVGFibGVIZWFkZXJSb3cuYmxvdE5hbWUpO1xuICAgICAgdmFyIHJlZiA9IHRoaXMuY2hpbGRyZW4uYXQoMCk7XG4gICAgICBuZXdIZWFkZXIuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgIGJvZHkuY2hpbGRyZW4uaGVhZC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNlbGwgPSBfdGhpczguc2Nyb2xsLmNyZWF0ZShUYWJsZUhlYWRlckNlbGwuYmxvdE5hbWUsIHtcbiAgICAgICAgICByb3c6IGlkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjZWxsTGluZSA9IF90aGlzOC5zY3JvbGwuY3JlYXRlKEhlYWRlckNlbGxMaW5lLmJsb3ROYW1lLCB7XG4gICAgICAgICAgcm93OiBpZFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZW1wdHlMaW5lID0gX3RoaXM4LnNjcm9sbC5jcmVhdGUoYmxvdHNfYnJlYWtbXCJhXCIgLyogZGVmYXVsdCAqL10uYmxvdE5hbWUpO1xuXG4gICAgICAgIGNlbGxMaW5lLmFwcGVuZENoaWxkKGVtcHR5TGluZSk7XG4gICAgICAgIGNlbGwuYXBwZW5kQ2hpbGQoY2VsbExpbmUpO1xuICAgICAgICByb3cuYXBwZW5kQ2hpbGQoY2VsbCk7XG4gICAgICAgIGNlbGwub3B0aW1pemUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobmV3SGVhZGVyLCByZWYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3dzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvd3MoKSB7XG4gICAgICB2YXIgYm9keSA9IHRoaXMuY2hpbGRyZW4uaGVhZDtcbiAgICAgIHJldHVybiBPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkoYm9keSkgPyBib2R5LmNoaWxkcmVuLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgICB9KSA6IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoKSB7XG4gICAgICB2YXIgZm9ybWF0cyA9IHt9O1xuICAgICAgdmFyIGNoaWxkRWxlbSA9IHRoaXMuY2VsbHMoKVswXS5kb21Ob2RlLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRvcnNfdGFibGVbXCJiXCIgLyogVEFCTEVfRk9STUFUUyAqL10pLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBjaGlsZEVsZW0uZGF0YXNldFtmb3JtYXQudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgZm9ybWF0c1tmb3JtYXRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciB0YWJsZUZvcm1hdCA9IGF0dHJpYnV0b3JzX3RhYmxlW1wiYlwiIC8qIFRBQkxFX0ZPUk1BVFMgKi9dW25hbWVdO1xuXG4gICAgICBpZiAodGFibGVGb3JtYXQpIHtcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gXCJkYXRhLVwiLmNvbmNhdChuYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB0aGlzLmNlbGxzKCkuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgIE9iamVjdCh0b2dnbGVfYXR0cmlidXRlW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShjZWxsLmNoaWxkcmVuLmhlYWQuZG9tTm9kZSwgYXR0ck5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRhYmxlRm9ybWF0LmFkZCh0aGlzLmRvbU5vZGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKFRhYmxlQ29udGFpbmVyKSwgXCJjcmVhdGVcIiwgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgdmFyIF9UQUJMRV9GT1JNQVRTJGZvcm1hdDtcblxuICAgICAgICAgIChfVEFCTEVfRk9STUFUUyRmb3JtYXQgPSBhdHRyaWJ1dG9yc190YWJsZVtcImJcIiAvKiBUQUJMRV9GT1JNQVRTICovXVtmb3JtYXRdKSA9PT0gbnVsbCB8fCBfVEFCTEVfRk9STUFUUyRmb3JtYXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9UQUJMRV9GT1JNQVRTJGZvcm1hdC5hZGQobm9kZSwgdmFsdWVbZm9ybWF0XSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGFibGVDb250YWluZXI7XG59KGNvbnRhaW5lcltcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cbnRhYmxlX1RhYmxlQ29udGFpbmVyLmJsb3ROYW1lID0gJ3RhYmxlQ29udGFpbmVyJztcbnRhYmxlX1RhYmxlQ29udGFpbmVyLnRhZ05hbWUgPSAnVEFCTEUnO1xudGFibGVfVGFibGVDb250YWluZXIuYWxsb3dlZENoaWxkcmVuID0gW1RhYmxlSGVhZGVyLCBUYWJsZUJvZHldO1xuVGFibGVCb2R5LnJlcXVpcmVkQ29udGFpbmVyID0gdGFibGVfVGFibGVDb250YWluZXI7XG5UYWJsZUhlYWRlci5yZXF1aXJlZENvbnRhaW5lciA9IHRhYmxlX1RhYmxlQ29udGFpbmVyO1xuVGFibGVCb2R5LmFsbG93ZWRDaGlsZHJlbiA9IFtUYWJsZVJvd107XG5UYWJsZVJvdy5yZXF1aXJlZENvbnRhaW5lciA9IFRhYmxlQm9keTtcblRhYmxlUm93LmFsbG93ZWRDaGlsZHJlbiA9IFtUYWJsZUNlbGxdO1xuVGFibGVDZWxsLnJlcXVpcmVkQ29udGFpbmVyID0gVGFibGVSb3c7XG50YWJsZV9DZWxsTGluZS5yZXF1aXJlZENvbnRhaW5lciA9IFRhYmxlQ2VsbDtcblRhYmxlQ2VsbC5hbGxvd2VkQ2hpbGRyZW4gPSBbdGFibGVfQ2VsbExpbmVdO1xuVGFibGVIZWFkZXIuYWxsb3dlZENoaWxkcmVuID0gW1RhYmxlSGVhZGVyUm93XTtcblRhYmxlSGVhZGVyUm93LnJlcXVpcmVkQ29udGFpbmVyID0gVGFibGVIZWFkZXI7XG5IZWFkZXJDZWxsTGluZS5yZXF1aXJlZENvbnRhaW5lciA9IFRhYmxlSGVhZGVyQ2VsbDtcblRhYmxlSGVhZGVyQ2VsbC5hbGxvd2VkQ2hpbGRyZW4gPSBbSGVhZGVyQ2VsbExpbmVdO1xuVGFibGVIZWFkZXJSb3cuYWxsb3dlZENoaWxkcmVuID0gW1RhYmxlSGVhZGVyQ2VsbF07XG5UYWJsZUhlYWRlckNlbGwucmVxdWlyZWRDb250YWluZXIgPSBUYWJsZUhlYWRlclJvdztcblxuZnVuY3Rpb24gdGFibGVJZCgpIHtcbiAgcmV0dXJuIFwicm93LVwiLmNvbmNhdChPYmplY3QoZ2V0X2lkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSgpKTtcbn1cblxuZnVuY3Rpb24gdGFibGVfY2VsbElkKCkge1xuICByZXR1cm4gXCJjZWxsLVwiLmNvbmNhdChPYmplY3QoZ2V0X2lkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSgpKTtcbn1cblxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbW9kdWxlcy9jbGlwYm9hcmQuanNcbnZhciBjbGlwYm9hcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL21vZHVsZXMvdGFibGUvdXRpbHMvbWFrZV90YWJsZV9hcnJvd19oYW5kbGVyLmpzXG52YXIgbWFrZV90YWJsZV9hcnJvd19oYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9tb2R1bGVzL3RhYmxlL3V0aWxzL3ByZXBhcmVfYXR0cl9tYXRjaGVyLmpzXG52YXIgcHJlcGFyZV9hdHRyX21hdGNoZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9tb2R1bGVzL3RhYmxlL2luZGV4LmpzXG5mdW5jdGlvbiB0YWJsZV90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IHRhYmxlX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyB0YWJsZV90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gdGFibGVfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gdGFibGVfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIHRhYmxlX2FycmF5V2l0aEhvbGVzKGFycikgfHwgdGFibGVfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB0YWJsZV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IHRhYmxlX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIHRhYmxlX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiB0YWJsZV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHRhYmxlX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiB0YWJsZV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gdGFibGVfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gdGFibGVfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiB0YWJsZV9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiB0YWJsZV9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIHRhYmxlX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiB0YWJsZV9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHRhYmxlX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSB0YWJsZV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiB0YWJsZV9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSB0YWJsZV9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gdGFibGVfc2V0UHJvdG90eXBlT2YobywgcCkgeyB0YWJsZV9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gdGFibGVfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gdGFibGVfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHRhYmxlX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IHRhYmxlX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSB0YWJsZV9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gdGFibGVfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIHRhYmxlX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAodGFibGVfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHRhYmxlX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiB0YWJsZV9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiB0YWJsZV9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiB0YWJsZV9nZXRQcm90b3R5cGVPZihvKSB7IHRhYmxlX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHRhYmxlX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgRU1QVFlfUkVTVUxUID0gW251bGwsIG51bGwsIG51bGwsIC0xXTtcblxudmFyIHRhYmxlX1RhYmxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTW9kdWxlKSB7XG4gIHRhYmxlX2luaGVyaXRzKFRhYmxlLCBfTW9kdWxlKTtcblxuICB2YXIgX3N1cGVyID0gdGFibGVfY3JlYXRlU3VwZXIoVGFibGUpO1xuXG4gIGZ1bmN0aW9uIFRhYmxlKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHRhYmxlX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYmxlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgX3RoaXMudGFibGVCbG90cyA9IFt0YWJsZV9DZWxsTGluZS5ibG90TmFtZSwgSGVhZGVyQ2VsbExpbmUuYmxvdE5hbWVdO1xuXG4gICAgX3RoaXMudGFibGVCbG90cy5mb3JFYWNoKGZ1bmN0aW9uIChibG90TmFtZSkge1xuICAgICAgX3RoaXMucXVpbGwuZWRpdG9yLmFkZEltbWVkaWF0ZUZvcm1hdChibG90TmFtZSk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5pbnRlZ3JhdGVDbGlwYm9hcmQoKTtcblxuICAgIF90aGlzLmFkZEtleWJvYXJkSGFuZGxlcnMoKTtcblxuICAgIF90aGlzLmxpc3RlbkJhbGFuY2VDZWxscygpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdGFibGVfY3JlYXRlQ2xhc3MoVGFibGUsIFt7XG4gICAga2V5OiBcImludGVncmF0ZUNsaXBib2FyZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlZ3JhdGVDbGlwYm9hcmQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy50YWJsZUJsb3RzLmZvckVhY2goZnVuY3Rpb24gKGJsb3ROYW1lKSB7XG4gICAgICAgIF90aGlzMi5xdWlsbC5jbGlwYm9hcmQuYWRkVGFibGVCbG90KGJsb3ROYW1lKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5xdWlsbC5jbGlwYm9hcmQuYWRkTWF0Y2hlcigndGQsIHRoJywgbWF0Y2hDZWxsKTtcbiAgICAgIHRoaXMucXVpbGwuY2xpcGJvYXJkLmFkZE1hdGNoZXIoJ3RhYmxlJywgT2JqZWN0KHByZXBhcmVfYXR0cl9tYXRjaGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSgndGFibGUnKSk7XG4gICAgICB0aGlzLnF1aWxsLmNsaXBib2FyZC5hZGRNYXRjaGVyKCd0ZCwgdGgnLCBPYmplY3QocHJlcGFyZV9hdHRyX21hdGNoZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKCdjZWxsJykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRLZXlib2FyZEhhbmRsZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEtleWJvYXJkSGFuZGxlcnMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGJpbmRpbmdzID0gVGFibGUua2V5Ym9hcmRCaW5kaW5ncztcbiAgICAgIE9iamVjdC5rZXlzKGJpbmRpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChiaW5kaW5nc1tuYW1lXSkge1xuICAgICAgICAgIF90aGlzMy5xdWlsbC5rZXlib2FyZC5hZGRCaW5kaW5nKGJpbmRpbmdzW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJhbGFuY2VUYWJsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmFsYW5jZVRhYmxlcygpIHtcbiAgICAgIHRoaXMucXVpbGwuc2Nyb2xsLmRlc2NlbmRhbnRzKHRhYmxlX1RhYmxlQ29udGFpbmVyKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICB0YWJsZS5iYWxhbmNlQ2VsbHMoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVDb2x1bW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQ29sdW1uKCkge1xuICAgICAgdmFyIF90aGlzJGdldFRhYmxlID0gdGhpcy5nZXRUYWJsZSgpLFxuICAgICAgICAgIF90aGlzJGdldFRhYmxlMiA9IHRhYmxlX3NsaWNlZFRvQXJyYXkoX3RoaXMkZ2V0VGFibGUsIDMpLFxuICAgICAgICAgIHRhYmxlID0gX3RoaXMkZ2V0VGFibGUyWzBdLFxuICAgICAgICAgIGNlbGwgPSBfdGhpcyRnZXRUYWJsZTJbMl07XG5cbiAgICAgIGlmICghT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKGNlbGwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGFibGUuZGVsZXRlQ29sdW1uKGNlbGwuY2VsbE9mZnNldCgpKTtcbiAgICAgIHRoaXMucXVpbGwudXBkYXRlKHF1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVSb3coKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0VGFibGUzID0gdGhpcy5nZXRUYWJsZSgpLFxuICAgICAgICAgIF90aGlzJGdldFRhYmxlNCA9IHRhYmxlX3NsaWNlZFRvQXJyYXkoX3RoaXMkZ2V0VGFibGUzLCAyKSxcbiAgICAgICAgICByb3cgPSBfdGhpcyRnZXRUYWJsZTRbMV07XG5cbiAgICAgIGlmICghT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKHJvdykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByb3cucmVtb3ZlKCk7XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZShxdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVUYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVUYWJsZSgpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRUYWJsZTUgPSB0aGlzLmdldFRhYmxlKCksXG4gICAgICAgICAgX3RoaXMkZ2V0VGFibGU2ID0gdGFibGVfc2xpY2VkVG9BcnJheShfdGhpcyRnZXRUYWJsZTUsIDEpLFxuICAgICAgICAgIHRhYmxlID0gX3RoaXMkZ2V0VGFibGU2WzBdO1xuXG4gICAgICBpZiAoIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh0YWJsZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0ID0gdGFibGUub2Zmc2V0KCk7XG4gICAgICB0YWJsZS5yZW1vdmUoKTtcbiAgICAgIHRoaXMucXVpbGwudXBkYXRlKHF1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihvZmZzZXQsIHF1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuU0lMRU5UKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFibGUoKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmICghT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKHJhbmdlKSkge1xuICAgICAgICByZXR1cm4gRU1QVFlfUkVTVUxUO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkcXVpbGwkZ2V0TGluZSA9IHRoaXMucXVpbGwuZ2V0TGluZShyYW5nZS5pbmRleCksXG4gICAgICAgICAgX3RoaXMkcXVpbGwkZ2V0TGluZTIgPSB0YWJsZV9zbGljZWRUb0FycmF5KF90aGlzJHF1aWxsJGdldExpbmUsIDIpLFxuICAgICAgICAgIGNlbGxMaW5lID0gX3RoaXMkcXVpbGwkZ2V0TGluZTJbMF0sXG4gICAgICAgICAgb2Zmc2V0ID0gX3RoaXMkcXVpbGwkZ2V0TGluZTJbMV07XG5cbiAgICAgIGlmICghT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKGNlbGxMaW5lKSB8fCB0aGlzLnRhYmxlQmxvdHMuaW5kZXhPZihjZWxsTGluZS5zdGF0aWNzLmJsb3ROYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIEVNUFRZX1JFU1VMVDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNlbGwgPSBjZWxsTGluZS5wYXJlbnQ7XG4gICAgICB2YXIgcm93ID0gY2VsbC5wYXJlbnQ7XG4gICAgICB2YXIgdGFibGUgPSByb3cucGFyZW50LnBhcmVudDtcbiAgICAgIHJldHVybiBbdGFibGUsIHJvdywgY2VsbCwgb2Zmc2V0XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Q29sdW1uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydENvbHVtbihvZmZzZXQpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIHZhciBfdGhpcyRnZXRUYWJsZTcgPSB0aGlzLmdldFRhYmxlKHJhbmdlKSxcbiAgICAgICAgICBfdGhpcyRnZXRUYWJsZTggPSB0YWJsZV9zbGljZWRUb0FycmF5KF90aGlzJGdldFRhYmxlNywgMyksXG4gICAgICAgICAgdGFibGUgPSBfdGhpcyRnZXRUYWJsZThbMF0sXG4gICAgICAgICAgcm93ID0gX3RoaXMkZ2V0VGFibGU4WzFdLFxuICAgICAgICAgIGNlbGwgPSBfdGhpcyRnZXRUYWJsZThbMl07XG5cbiAgICAgIGlmICghT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKGNlbGwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbHVtbiA9IGNlbGwuY2VsbE9mZnNldCgpO1xuICAgICAgdGFibGUuaW5zZXJ0Q29sdW1uKGNvbHVtbiArIG9mZnNldCk7XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZShxdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgdmFyIHNoaWZ0ID0gcm93LnJvd09mZnNldCgpO1xuXG4gICAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIHNoaWZ0ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgc2hpZnQsIHJhbmdlLmxlbmd0aCwgcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5TSUxFTlQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRDb2x1bW5MZWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydENvbHVtbkxlZnQoKSB7XG4gICAgICB0aGlzLmluc2VydENvbHVtbigwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Q29sdW1uUmlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Q29sdW1uUmlnaHQoKSB7XG4gICAgICB0aGlzLmluc2VydENvbHVtbigxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Um93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFJvdyhvZmZzZXQpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIHZhciBfdGhpcyRnZXRUYWJsZTkgPSB0aGlzLmdldFRhYmxlKHJhbmdlKSxcbiAgICAgICAgICBfdGhpcyRnZXRUYWJsZTEwID0gdGFibGVfc2xpY2VkVG9BcnJheShfdGhpcyRnZXRUYWJsZTksIDMpLFxuICAgICAgICAgIHRhYmxlID0gX3RoaXMkZ2V0VGFibGUxMFswXSxcbiAgICAgICAgICByb3cgPSBfdGhpcyRnZXRUYWJsZTEwWzFdLFxuICAgICAgICAgIGNlbGwgPSBfdGhpcyRnZXRUYWJsZTEwWzJdO1xuXG4gICAgICBpZiAoIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShjZWxsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IHJvdy5yb3dPZmZzZXQoKTtcbiAgICAgIHRhYmxlLmluc2VydFJvdyhpbmRleCArIG9mZnNldCk7XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZShxdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuXG4gICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZSwgcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5TSUxFTlQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggKyByb3cuY2hpbGRyZW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgsIHF1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Um93QWJvdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Um93QWJvdmUoKSB7XG4gICAgICB0aGlzLmluc2VydFJvdygwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Um93QmVsb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Um93QmVsb3coKSB7XG4gICAgICB0aGlzLmluc2VydFJvdygxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0SGVhZGVyUm93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEhlYWRlclJvdygpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIHZhciBfdGhpcyRnZXRUYWJsZTExID0gdGhpcy5nZXRUYWJsZShyYW5nZSksXG4gICAgICAgICAgX3RoaXMkZ2V0VGFibGUxMiA9IHRhYmxlX3NsaWNlZFRvQXJyYXkoX3RoaXMkZ2V0VGFibGUxMSwgMyksXG4gICAgICAgICAgdGFibGUgPSBfdGhpcyRnZXRUYWJsZTEyWzBdLFxuICAgICAgICAgIGNlbGwgPSBfdGhpcyRnZXRUYWJsZTEyWzJdO1xuXG4gICAgICBpZiAoIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShjZWxsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRhYmxlLmluc2VydEhlYWRlclJvdygpO1xuICAgICAgdGhpcy5xdWlsbC51cGRhdGUocXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5VU0VSKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0VGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0VGFibGUocm93cywgY29sdW1ucykge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKCFPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkocmFuZ2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbHRhID0gbmV3IEFycmF5KHJvd3MpLmZpbGwoMCkucmVkdWNlKGZ1bmN0aW9uIChtZW1vKSB7XG4gICAgICAgIHZhciByb3dJZCA9IHRhYmxlSWQoKTtcbiAgICAgICAgbmV3IEFycmF5KGNvbHVtbnMpLmZpbGwoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICBtZW1vLmluc2VydCh0ZXh0LCB7XG4gICAgICAgICAgICB0YWJsZUNlbGxMaW5lOiB7XG4gICAgICAgICAgICAgIHJvdzogcm93SWQsXG4gICAgICAgICAgICAgIGNlbGw6IHRhYmxlSWQoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICB9LCBuZXcgRGVsdGFfZGVmYXVsdC5hKCkucmV0YWluKHJhbmdlLmluZGV4KSk7XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBxdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXgsIHF1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIHRoaXMuYmFsYW5jZVRhYmxlcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0YWJsZUZvcm1hdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGFibGVGb3JtYXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFibGVCbG90cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGlzdGVuQmFsYW5jZUNlbGxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbkJhbGFuY2VDZWxscygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLnF1aWxsLm9uKHF1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmV2ZW50cy5TQ1JPTExfT1BUSU1JWkUsIGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcbiAgICAgICAgbXV0YXRpb25zLnNvbWUoZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgICAgaWYgKFsnVEQnLCAnVEgnLCAnVFInLCAnVEJPRFknLCAnVEhFQUQnLCAnVEFCTEUnXS5pbmRleE9mKG11dGF0aW9uLnRhcmdldC50YWdOYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIF90aGlzNC5xdWlsbC5vbmNlKHF1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmV2ZW50cy5URVhUX0NIQU5HRSwgZnVuY3Rpb24gKGRlbHRhLCBvbGQsIHNvdXJjZSkge1xuICAgICAgICAgICAgICBpZiAoc291cmNlICE9PSBxdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpIHJldHVybjtcblxuICAgICAgICAgICAgICBfdGhpczQuYmFsYW5jZVRhYmxlcygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucXVpbGwub24ocXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uZXZlbnRzLkNPTlRFTlRfU0VUVEVELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC5xdWlsbC5vbmNlKHF1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmV2ZW50cy5URVhUX0NIQU5HRSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNC5iYWxhbmNlVGFibGVzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicmVnaXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgICBxdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5yZWdpc3Rlcih0YWJsZV9DZWxsTGluZSwgdHJ1ZSk7XG4gICAgICBxdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5yZWdpc3RlcihIZWFkZXJDZWxsTGluZSwgdHJ1ZSk7XG4gICAgICBxdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5yZWdpc3RlcihUYWJsZUhlYWRlckNlbGwsIHRydWUpO1xuICAgICAgcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10ucmVnaXN0ZXIoVGFibGVDZWxsLCB0cnVlKTtcbiAgICAgIHF1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnJlZ2lzdGVyKFRhYmxlSGVhZGVyUm93LCB0cnVlKTtcbiAgICAgIHF1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnJlZ2lzdGVyKFRhYmxlUm93LCB0cnVlKTtcbiAgICAgIHF1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnJlZ2lzdGVyKFRhYmxlQm9keSwgdHJ1ZSk7XG4gICAgICBxdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5yZWdpc3RlcihUYWJsZUhlYWRlciwgdHJ1ZSk7XG4gICAgICBxdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5yZWdpc3Rlcih0YWJsZV9UYWJsZUNvbnRhaW5lciwgdHJ1ZSk7XG4gICAgICBbYXR0cmlidXRvcnNfdGFibGVbXCJiXCIgLyogVEFCTEVfRk9STUFUUyAqL10sIGF0dHJpYnV0b3JzX2NlbGxbXCJiXCIgLyogQ0VMTF9GT1JNQVRTICovXV0uZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0cykge1xuICAgICAgICBPYmplY3Qua2V5cyhmb3JtYXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10ucmVnaXN0ZXIoX2RlZmluZVByb3BlcnR5KHt9LCBcImZvcm1hdHMvXCIuY29uY2F0KG5hbWUpLCBmb3JtYXRzW25hbWVdKSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRhYmxlO1xufShjb3JlX21vZHVsZVtcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cbnRhYmxlX1RhYmxlLmtleWJvYXJkQmluZGluZ3MgPSB7XG4gICd0YWJsZSBiYWNrc3BhY2UnOiB7XG4gICAga2V5OiAnYmFja3NwYWNlJyxcbiAgICBmb3JtYXQ6IFsndGFibGVDZWxsTGluZScsICd0YWJsZUhlYWRlckNlbGxMaW5lJ10sXG4gICAgY29sbGFwc2VkOiB0cnVlLFxuICAgIG9mZnNldDogMCxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlKSB7XG4gICAgICB2YXIgX3RoaXMkcXVpbGwkZ2V0TGluZTMgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgIF90aGlzJHF1aWxsJGdldExpbmU0ID0gdGFibGVfc2xpY2VkVG9BcnJheShfdGhpcyRxdWlsbCRnZXRMaW5lMywgMSksXG4gICAgICAgICAgbGluZSA9IF90aGlzJHF1aWxsJGdldExpbmU0WzBdO1xuXG4gICAgICBpZiAoIWxpbmUucHJldiB8fCBbJ3RhYmxlQ2VsbExpbmUnLCAndGFibGVIZWFkZXJDZWxsTGluZSddLmluZGV4T2YobGluZS5wcmV2LnN0YXRpY3MuYmxvdE5hbWUpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcbiAgJ3RhYmxlIGRlbGV0ZSc6IHtcbiAgICBrZXk6ICdkZWwnLFxuICAgIGZvcm1hdDogWyd0YWJsZUNlbGxMaW5lJywgJ3RhYmxlSGVhZGVyQ2VsbExpbmUnXSxcbiAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgc3VmZml4OiAvXiQvLFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7fVxuICB9LFxuICAndGFibGUgY2VsbCBlbnRlcic6IHtcbiAgICBrZXk6ICdlbnRlcicsXG4gICAgc2hpZnRLZXk6IG51bGwsXG4gICAgZm9ybWF0OiBbJ3RhYmxlQ2VsbExpbmUnLCAndGFibGVIZWFkZXJDZWxsTGluZSddLFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpcyRxdWlsbCRzZWxlY3Rpb24sXG4gICAgICAgICAgX3RoaXM1ID0gdGhpcztcblxuICAgICAgaWYgKChfdGhpcyRxdWlsbCRzZWxlY3Rpb24gPSB0aGlzLnF1aWxsLnNlbGVjdGlvbikgIT09IG51bGwgJiYgX3RoaXMkcXVpbGwkc2VsZWN0aW9uICE9PSB2b2lkIDAgJiYgX3RoaXMkcXVpbGwkc2VsZWN0aW9uLmNvbXBvc2luZykgcmV0dXJuO1xuXG4gICAgICBpZiAocmFuZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnF1aWxsLnNjcm9sbC5kZWxldGVBdChyYW5nZS5pbmRleCwgcmFuZ2UubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmVGb3JtYXRzID0gT2JqZWN0LmtleXMoY29udGV4dC5mb3JtYXQpLnJlZHVjZShmdW5jdGlvbiAoZm9ybWF0cywgZm9ybWF0KSB7XG4gICAgICAgIGlmIChfdGhpczUucXVpbGwuc2Nyb2xsLnF1ZXJ5KGZvcm1hdCwgcGFyY2htZW50W1wiU2NvcGVcIl0uQkxPQ0spICYmICFBcnJheS5pc0FycmF5KGNvbnRleHQuZm9ybWF0W2Zvcm1hdF0pKSB7XG4gICAgICAgICAgZm9ybWF0c1tmb3JtYXRdID0gY29udGV4dC5mb3JtYXRbZm9ybWF0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgICAgfSwge30pO1xuICAgICAgdGhpcy5xdWlsbC5pbnNlcnRUZXh0KHJhbmdlLmluZGV4LCAnXFxuJywgbGluZUZvcm1hdHMudGFibGVDZWxsTGluZSwgcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5VU0VSKTtcbiAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgMSwgcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5TSUxFTlQpO1xuICAgICAgdGhpcy5xdWlsbC5mb2N1cygpO1xuICAgICAgT2JqZWN0LmtleXMoY29udGV4dC5mb3JtYXQpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKGxpbmVGb3JtYXRzW25hbWVdICE9IG51bGwpIHJldHVybjtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGV4dC5mb3JtYXRbbmFtZV0pKSByZXR1cm47XG4gICAgICAgIGlmIChuYW1lID09PSAnbGluaycpIHJldHVybjtcblxuICAgICAgICBfdGhpczUucXVpbGwuZm9ybWF0KG5hbWUsIGNvbnRleHQuZm9ybWF0W25hbWVdLCBxdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAndGFibGUgdGFiJzoge1xuICAgIGtleTogJ3RhYicsXG4gICAgc2hpZnRLZXk6IG51bGwsXG4gICAgZm9ybWF0OiBbJ3RhYmxlQ2VsbExpbmUnLCAndGFibGVIZWFkZXJDZWxsTGluZSddLFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgIHZhciBldmVudCA9IGNvbnRleHQuZXZlbnQsXG4gICAgICAgICAgY2VsbCA9IGNvbnRleHQubGluZTtcbiAgICAgIHZhciBvZmZzZXQgPSBjZWxsLm9mZnNldCh0aGlzLnF1aWxsLnNjcm9sbCk7XG5cbiAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihvZmZzZXQgLSAxLCBxdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ob2Zmc2V0ICsgY2VsbC5sZW5ndGgoKSwgcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5VU0VSKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICd0YWJsZSBkb3duJzogT2JqZWN0KG1ha2VfdGFibGVfYXJyb3dfaGFuZGxlcltcImFcIiAvKiBkZWZhdWx0ICovXSkoZmFsc2UsIFsndGFibGVDZWxsTGluZScsICd0YWJsZUhlYWRlckNlbGxMaW5lJ10pLFxuICAndGFibGUgdXAnOiBPYmplY3QobWFrZV90YWJsZV9hcnJvd19oYW5kbGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh0cnVlLCBbJ3RhYmxlQ2VsbExpbmUnLCAndGFibGVIZWFkZXJDZWxsTGluZSddKVxufTtcblxuZnVuY3Rpb24gbWF0Y2hDZWxsKG5vZGUsIGRlbHRhKSB7XG4gIHZhciByb3cgPSBub2RlLnBhcmVudE5vZGU7XG4gIHZhciB0YWJsZSA9IHJvdy5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdUQUJMRScgPyByb3cucGFyZW50Tm9kZSA6IHJvdy5wYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gIHZhciBpc0hlYWRlclJvdyA9IHJvdy5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdUSEVBRCcgPyB0cnVlIDogbnVsbDtcbiAgdmFyIHJvd3MgPSBBcnJheS5mcm9tKHRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RyJykpO1xuICB2YXIgY2VsbHMgPSBBcnJheS5mcm9tKHJvdy5xdWVyeVNlbGVjdG9yQWxsKCd0aCx0ZCcpKTtcbiAgdmFyIHJvd0lkID0gcm93cy5pbmRleE9mKHJvdykgKyAxO1xuICB2YXIgY2VsbElkID0gY2VsbHMuaW5kZXhPZihub2RlKSArIDE7XG4gIHZhciBjZWxsTGluZUJsb3ROYW1lID0gaXNIZWFkZXJSb3cgPyAndGFibGVIZWFkZXJDZWxsTGluZScgOiAndGFibGVDZWxsTGluZSc7XG5cbiAgaWYgKGRlbHRhLmxlbmd0aCgpID09PSAwKSB7XG4gICAgZGVsdGEgPSBuZXcgRGVsdGFfZGVmYXVsdC5hKCkuaW5zZXJ0KCdcXG4nLCBfZGVmaW5lUHJvcGVydHkoe30sIGNlbGxMaW5lQmxvdE5hbWUsIHtcbiAgICAgIHJvdzogcm93SWQsXG4gICAgICBjZWxsOiBjZWxsSWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIGRlbHRhO1xuICB9XG5cbiAgaWYgKCFPYmplY3QoY2xpcGJvYXJkW1wiY1wiIC8qIGRlbHRhRW5kc1dpdGggKi9dKShkZWx0YSwgJ1xcbicpKSB7XG4gICAgZGVsdGEuaW5zZXJ0KCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QoY2xpcGJvYXJkW1wiYVwiIC8qIGFwcGx5Rm9ybWF0ICovXSkoZGVsdGEsIGNlbGxMaW5lQmxvdE5hbWUsIHtcbiAgICByb3c6IHJvd0lkLFxuICAgIGNlbGw6IGNlbGxJZFxuICB9KTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbW9kdWxlc190YWJsZSA9IF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKHRhYmxlX1RhYmxlKTtcblxuLyoqKi8gfSksXG4vKiA2MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG5cbi8qKiovIH0pLFxuLyogNjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcblxudmFyIE9iamVjdCA9IGdsb2JhbC5PYmplY3Q7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA2NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqLyB9KSxcbi8qIDY5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG52YXIgRWxlbWVudEF0dHJpYnV0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BdHRyaWJ1dG9yKSB7XG4gIF9pbmhlcml0cyhFbGVtZW50QXR0cmlidXRvciwgX0F0dHJpYnV0b3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRWxlbWVudEF0dHJpYnV0b3IpO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnRBdHRyaWJ1dG9yKGF0dHJOYW1lLCBrZXlOYW1lKSB7XG4gICAgdmFyIF9vcHRpb25zJGFsbG93ZWRUYWdzO1xuXG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHtcbiAgICAgIGFsbG93ZWRUYWdzOiBbXVxuICAgIH07XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWxlbWVudEF0dHJpYnV0b3IpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBhdHRyTmFtZSwga2V5TmFtZSwgb3B0aW9ucyk7XG4gICAgX3RoaXMuYWxsb3dlZFRhZ3MgPSAoX29wdGlvbnMkYWxsb3dlZFRhZ3MgPSBvcHRpb25zLmFsbG93ZWRUYWdzKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRhbGxvd2VkVGFncyAhPT0gdm9pZCAwID8gX29wdGlvbnMkYWxsb3dlZFRhZ3MgOiBbXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRWxlbWVudEF0dHJpYnV0b3IsIFt7XG4gICAga2V5OiBcImNhbkFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5BZGQobm9kZSwgdmFsdWUpIHtcbiAgICAgIHZhciBpc05vZGVBbGxvd2VkID0gdGhpcy5hbGxvd2VkVGFncy5pbmRleE9mKG5vZGUudGFnTmFtZSkgPiAtMTtcbiAgICAgIHJldHVybiBpc05vZGVBbGxvd2VkICYmIF9nZXQoX2dldFByb3RvdHlwZU9mKEVsZW1lbnRBdHRyaWJ1dG9yLnByb3RvdHlwZSksIFwiY2FuQWRkXCIsIHRoaXMpLmNhbGwodGhpcywgbm9kZSwgdmFsdWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFbGVtZW50QXR0cmlidXRvcjtcbn0ocGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJBdHRyaWJ1dG9yXCJdKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChFbGVtZW50QXR0cmlidXRvcik7XG5cbi8qKiovIH0pLFxuLyogNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cbnZhciBFbGVtZW50U3R5bGVBdHRyaWJ1dG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3R5bGVBdHRyaWJ1dG9yKSB7XG4gIF9pbmhlcml0cyhFbGVtZW50U3R5bGVBdHRyaWJ1dG9yLCBfU3R5bGVBdHRyaWJ1dG9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEVsZW1lbnRTdHlsZUF0dHJpYnV0b3IpO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnRTdHlsZUF0dHJpYnV0b3IoYXR0ck5hbWUsIGtleU5hbWUpIHtcbiAgICB2YXIgX29wdGlvbnMkYWxsb3dlZFRhZ3M7XG5cbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge1xuICAgICAgYWxsb3dlZFRhZ3M6IFtdXG4gICAgfTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGVtZW50U3R5bGVBdHRyaWJ1dG9yKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYXR0ck5hbWUsIGtleU5hbWUsIG9wdGlvbnMpO1xuICAgIF90aGlzLmFsbG93ZWRUYWdzID0gKF9vcHRpb25zJGFsbG93ZWRUYWdzID0gb3B0aW9ucy5hbGxvd2VkVGFncykgIT09IG51bGwgJiYgX29wdGlvbnMkYWxsb3dlZFRhZ3MgIT09IHZvaWQgMCA/IF9vcHRpb25zJGFsbG93ZWRUYWdzIDogW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVsZW1lbnRTdHlsZUF0dHJpYnV0b3IsIFt7XG4gICAga2V5OiBcImNhbkFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5BZGQobm9kZSwgdmFsdWUpIHtcbiAgICAgIHZhciBpc05vZGVBbGxvd2VkID0gdGhpcy5hbGxvd2VkVGFncy5pbmRleE9mKG5vZGUudGFnTmFtZSkgPiAtMTtcbiAgICAgIHJldHVybiBpc05vZGVBbGxvd2VkICYmIF9nZXQoX2dldFByb3RvdHlwZU9mKEVsZW1lbnRTdHlsZUF0dHJpYnV0b3IucHJvdG90eXBlKSwgXCJjYW5BZGRcIiwgdGhpcykuY2FsbCh0aGlzLCBub2RlLCB2YWx1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVsZW1lbnRTdHlsZUF0dHJpYnV0b3I7XG59KHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiU3R5bGVBdHRyaWJ1dG9yXCJdKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChFbGVtZW50U3R5bGVBdHRyaWJ1dG9yKTtcblxuLyoqKi8gfSksXG4vKiA3MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9xdWlsbC1kZWx0YS9kaXN0L0RlbHRhLmpzXG52YXIgRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIERlbHRhX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKERlbHRhKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvcmUvcXVpbGwuanNcbnZhciBjb3JlX3F1aWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvcmUvbW9kdWxlLmpzXG52YXIgY29yZV9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jsb3RzL2Jsb2NrLmpzXG52YXIgYmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYmxvdHMvY29udGFpbmVyLmpzXG52YXIgY29udGFpbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi91dGlscy9pc19kZWZpbmVkLmpzXG52YXIgaXNfZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9mb3JtYXRzL3RhYmxlL2F0dHJpYnV0b3JzL3RhYmxlLmpzXG52YXIgYXR0cmlidXRvcnNfdGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vZm9ybWF0cy90YWJsZS9nZXRfaWQuanNcbnZhciBnZXRfaWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Zvcm1hdHMvdGFibGUvdG9nZ2xlX2F0dHJpYnV0ZS5qc1xudmFyIHRvZ2dsZV9hdHRyaWJ1dGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9mb3JtYXRzL3RhYmxlL2xpdGUuanNcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cblxuXG5cblxudmFyIFRBQkxFX1RBR1MgPSBbJ1REJywgJ1RIJywgJ1RSJywgJ1RCT0RZJywgJ1RIRUFEJywgJ1RBQkxFJ107XG52YXIgREFUQV9QUkVGSVggPSAnZGF0YS10YWJsZWxpdGUtJztcblxudmFyIGxpdGVfQmFzZUNlbGwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CbG9jaykge1xuICBfaW5oZXJpdHMoQmFzZUNlbGwsIF9CbG9jayk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihCYXNlQ2VsbCk7XG5cbiAgZnVuY3Rpb24gQmFzZUNlbGwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VDZWxsKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlQ2VsbCwgW3tcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKGF0dHJpYnV0b3JzX3RhYmxlW1wiYlwiIC8qIFRBQkxFX0ZPUk1BVFMgKi9dW25hbWVdKSB7XG4gICAgICAgIHZhciBfdGhpcyRyb3csIF90aGlzJHJvdyR0YWJsZTtcblxuICAgICAgICB2YXIgYXR0ck5hbWUgPSBcImRhdGEtXCIuY29uY2F0KG5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIE9iamVjdCh0b2dnbGVfYXR0cmlidXRlW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh0aGlzLmRvbU5vZGUsIGF0dHJOYW1lLCB2YWx1ZSk7XG4gICAgICAgIChfdGhpcyRyb3cgPSB0aGlzLnJvdygpKSA9PT0gbnVsbCB8fCBfdGhpcyRyb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdGhpcyRyb3ckdGFibGUgPSBfdGhpcyRyb3cudGFibGUoKSkgPT09IG51bGwgfHwgX3RoaXMkcm93JHRhYmxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRyb3ckdGFibGUuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEJhc2VDZWxsLnByb3RvdHlwZSksIFwiZm9ybWF0XCIsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjZWxsT2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNlbGxPZmZzZXQoKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdygpIHtcbiAgICAgIHJldHVybiAndGFibGUnIGluIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQgOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3dPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm93T2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMucm93KCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93KCkucm93T2Zmc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGFibGUoKSB7XG4gICAgICB2YXIgX3RoaXMkcm93MjtcblxuICAgICAgcmV0dXJuIChfdGhpcyRyb3cyID0gdGhpcy5yb3coKSkgPT09IG51bGwgfHwgX3RoaXMkcm93MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcm93Mi50YWJsZSgpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgIHZhciBub2RlID0gX2dldChfZ2V0UHJvdG90eXBlT2YoQmFzZUNlbGwpLCBcImNyZWF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICB2YXIgYXR0ck5hbWUgPSB0aGlzLmRhdGFBdHRyaWJ1dGU7XG4gICAgICBPYmplY3QodG9nZ2xlX2F0dHJpYnV0ZVtcImFcIiAvKiBkZWZhdWx0ICovXSkobm9kZSwgYXR0ck5hbWUsIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IHRhYmxlSWQoKSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIHZhciBhdHRyTmFtZSA9IHRoaXMuZGF0YUF0dHJpYnV0ZTtcblxuICAgICAgaWYgKGRvbU5vZGUuaGFzQXR0cmlidXRlKGF0dHJOYW1lKSkge1xuICAgICAgICByZXR1cm4gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlQ2VsbDtcbn0oYmxvY2tbXCJkXCIgLyogZGVmYXVsdCAqL10pO1xuXG5saXRlX0Jhc2VDZWxsLnRhZ05hbWUgPSBbJ1REJywgJ1RIJ107XG5cbnZhciBUYWJsZUNlbGwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQ2VsbCkge1xuICBfaW5oZXJpdHMoVGFibGVDZWxsLCBfQmFzZUNlbGwpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKFRhYmxlQ2VsbCk7XG5cbiAgZnVuY3Rpb24gVGFibGVDZWxsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJsZUNlbGwpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUYWJsZUNlbGwsIFt7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChuYW1lID09PSBUYWJsZUNlbGwuYmxvdE5hbWUgJiYgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kb21Ob2RlLnNldEF0dHJpYnV0ZShUYWJsZUNlbGwuZGF0YUF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoVGFibGVDZWxsLnByb3RvdHlwZSksIFwiZm9ybWF0XCIsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUYWJsZUNlbGw7XG59KGxpdGVfQmFzZUNlbGwpO1xuXG5UYWJsZUNlbGwuYmxvdE5hbWUgPSAndGFibGUnO1xuVGFibGVDZWxsLmRhdGFBdHRyaWJ1dGUgPSBcIlwiLmNvbmNhdChEQVRBX1BSRUZJWCwgXCJyb3dcIik7XG5cbnZhciBUYWJsZUhlYWRlckNlbGwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQ2VsbDIpIHtcbiAgX2luaGVyaXRzKFRhYmxlSGVhZGVyQ2VsbCwgX0Jhc2VDZWxsMik7XG5cbiAgdmFyIF9zdXBlcjMgPSBfY3JlYXRlU3VwZXIoVGFibGVIZWFkZXJDZWxsKTtcblxuICBmdW5jdGlvbiBUYWJsZUhlYWRlckNlbGwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYmxlSGVhZGVyQ2VsbCk7XG5cbiAgICByZXR1cm4gX3N1cGVyMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRhYmxlSGVhZGVyQ2VsbCwgW3tcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKG5hbWUgPT09IFRhYmxlSGVhZGVyQ2VsbC5ibG90TmFtZSAmJiB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRvbU5vZGUuc2V0QXR0cmlidXRlKFRhYmxlSGVhZGVyQ2VsbC5kYXRhQXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihUYWJsZUhlYWRlckNlbGwucHJvdG90eXBlKSwgXCJmb3JtYXRcIiwgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRhYmxlSGVhZGVyQ2VsbDtcbn0obGl0ZV9CYXNlQ2VsbCk7XG5cblRhYmxlSGVhZGVyQ2VsbC50YWdOYW1lID0gWydUSCcsICdURCddO1xuVGFibGVIZWFkZXJDZWxsLmJsb3ROYW1lID0gJ3RhYmxlSGVhZGVyQ2VsbCc7XG5UYWJsZUhlYWRlckNlbGwuZGF0YUF0dHJpYnV0ZSA9IFwiXCIuY29uY2F0KERBVEFfUFJFRklYLCBcImhlYWRlci1yb3dcIik7XG5cbnZhciBsaXRlX0Jhc2VSb3cgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db250YWluZXIpIHtcbiAgX2luaGVyaXRzKEJhc2VSb3csIF9Db250YWluZXIpO1xuXG4gIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKEJhc2VSb3cpO1xuXG4gIGZ1bmN0aW9uIEJhc2VSb3coKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VSb3cpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlUm93LCBbe1xuICAgIGtleTogXCJjaGVja01lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrTWVyZ2UoKSB7XG4gICAgICBpZiAoX2dldChfZ2V0UHJvdG90eXBlT2YoQmFzZVJvdy5wcm90b3R5cGUpLCBcImNoZWNrTWVyZ2VcIiwgdGhpcykuY2FsbCh0aGlzKSAmJiBPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkodGhpcy5uZXh0LmNoaWxkcmVuLmhlYWQpKSB7XG4gICAgICAgIHZhciBmb3JtYXROYW1lID0gdGhpcy5jaGlsZEZvcm1hdE5hbWU7XG4gICAgICAgIHZhciB0aGlzSGVhZCA9IHRoaXMuY2hpbGRyZW4uaGVhZC5mb3JtYXRzKCk7XG4gICAgICAgIHZhciB0aGlzVGFpbCA9IHRoaXMuY2hpbGRyZW4udGFpbC5mb3JtYXRzKCk7XG4gICAgICAgIHZhciBuZXh0SGVhZCA9IHRoaXMubmV4dC5jaGlsZHJlbi5oZWFkLmZvcm1hdHMoKTtcbiAgICAgICAgdmFyIG5leHRUYWlsID0gdGhpcy5uZXh0LmNoaWxkcmVuLnRhaWwuZm9ybWF0cygpO1xuICAgICAgICByZXR1cm4gdGhpc0hlYWRbZm9ybWF0TmFtZV0gPT09IHRoaXNUYWlsW2Zvcm1hdE5hbWVdICYmIHRoaXNIZWFkW2Zvcm1hdE5hbWVdID09PSBuZXh0SGVhZFtmb3JtYXROYW1lXSAmJiB0aGlzSGVhZFtmb3JtYXROYW1lXSA9PT0gbmV4dFRhaWxbZm9ybWF0TmFtZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3B0aW1pemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW1pemUoKSB7XG4gICAgICB2YXIgX2dldDIsXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgKF9nZXQyID0gX2dldChfZ2V0UHJvdG90eXBlT2YoQmFzZVJvdy5wcm90b3R5cGUpLCBcIm9wdGltaXplXCIsIHRoaXMpKS5jYWxsLmFwcGx5KF9nZXQyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcblxuICAgICAgdmFyIGZvcm1hdE5hbWUgPSB0aGlzLmNoaWxkRm9ybWF0TmFtZTtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKCFPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkoY2hpbGQubmV4dCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGRGb3JtYXRzID0gY2hpbGQuZm9ybWF0cygpO1xuICAgICAgICB2YXIgbmV4dEZvcm1hdHMgPSBjaGlsZC5uZXh0LmZvcm1hdHMoKTtcblxuICAgICAgICBpZiAoY2hpbGRGb3JtYXRzW2Zvcm1hdE5hbWVdICE9PSBuZXh0Rm9ybWF0c1tmb3JtYXROYW1lXSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gX3RoaXMuc3BsaXRBZnRlcihjaGlsZCk7XG5cbiAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgbmV4dC5vcHRpbWl6ZSgpO1xuICAgICAgICAgIH0gLy8gV2UgbWlnaHQgYmUgYWJsZSB0byBtZXJnZSB3aXRoIHByZXYgbm93XG5cblxuICAgICAgICAgIGlmIChfdGhpcy5wcmV2KSB7XG4gICAgICAgICAgICBfdGhpcy5wcmV2Lm9wdGltaXplKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm93T2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvd09mZnNldCgpIHtcbiAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0YWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0YWJsZSgpIHtcbiAgICAgIHZhciBfdGhpcyRwYXJlbnQ7XG5cbiAgICAgIHJldHVybiAoX3RoaXMkcGFyZW50ID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF90aGlzJHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcGFyZW50LnBhcmVudDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZVJvdztcbn0oY29udGFpbmVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxubGl0ZV9CYXNlUm93LnRhZ05hbWUgPSAnVFInO1xuXG52YXIgVGFibGVSb3cgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlUm93KSB7XG4gIF9pbmhlcml0cyhUYWJsZVJvdywgX0Jhc2VSb3cpO1xuXG4gIHZhciBfc3VwZXI1ID0gX2NyZWF0ZVN1cGVyKFRhYmxlUm93KTtcblxuICBmdW5jdGlvbiBUYWJsZVJvdyhzY3JvbGwsIGRvbU5vZGUpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYmxlUm93KTtcblxuICAgIF90aGlzMiA9IF9zdXBlcjUuY2FsbCh0aGlzLCBzY3JvbGwsIGRvbU5vZGUpO1xuICAgIF90aGlzMi5jaGlsZEZvcm1hdE5hbWUgPSAndGFibGUnO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICByZXR1cm4gVGFibGVSb3c7XG59KGxpdGVfQmFzZVJvdyk7XG5cblRhYmxlUm93LmJsb3ROYW1lID0gJ3RhYmxlUm93JztcblxudmFyIFRhYmxlSGVhZGVyUm93ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVJvdzIpIHtcbiAgX2luaGVyaXRzKFRhYmxlSGVhZGVyUm93LCBfQmFzZVJvdzIpO1xuXG4gIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKFRhYmxlSGVhZGVyUm93KTtcblxuICBmdW5jdGlvbiBUYWJsZUhlYWRlclJvdyhzY3JvbGwsIGRvbU5vZGUpIHtcbiAgICB2YXIgX3RoaXMzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYmxlSGVhZGVyUm93KTtcblxuICAgIF90aGlzMyA9IF9zdXBlcjYuY2FsbCh0aGlzLCBzY3JvbGwsIGRvbU5vZGUpO1xuICAgIF90aGlzMy5jaGlsZEZvcm1hdE5hbWUgPSAndGFibGVIZWFkZXJDZWxsJztcbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG5cbiAgcmV0dXJuIFRhYmxlSGVhZGVyUm93O1xufShsaXRlX0Jhc2VSb3cpO1xuXG5UYWJsZUhlYWRlclJvdy5ibG90TmFtZSA9ICd0YWJsZUhlYWRlclJvdyc7XG5cbnZhciBsaXRlX1Jvd0NvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbnRhaW5lcjIpIHtcbiAgX2luaGVyaXRzKFJvd0NvbnRhaW5lciwgX0NvbnRhaW5lcjIpO1xuXG4gIHZhciBfc3VwZXI3ID0gX2NyZWF0ZVN1cGVyKFJvd0NvbnRhaW5lcik7XG5cbiAgZnVuY3Rpb24gUm93Q29udGFpbmVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3dDb250YWluZXIpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSb3dDb250YWluZXIsIFt7XG4gICAga2V5OiBcIm9wdGltaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKCkge1xuICAgICAgdmFyIF9nZXQzO1xuXG4gICAgICBpZiAodGhpcy5zdGF0aWNzLnJlcXVpcmVkQ29udGFpbmVyICYmICEodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiB0aGlzLnN0YXRpY3MucmVxdWlyZWRDb250YWluZXIpKSB7XG4gICAgICAgIHZhciBkb21Ob2RlID0gdGhpcy5jaGlsZHJlbi5oZWFkLmNoaWxkcmVuLmhlYWQuZG9tTm9kZTtcbiAgICAgICAgdmFyIGZvcm1hdHMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRvcnNfdGFibGVbXCJiXCIgLyogVEFCTEVfRk9STUFUUyAqL10pLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGRvbU5vZGUuZGF0YXNldFtmb3JtYXQudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZvcm1hdHNbZm9ybWF0XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3JhcCh0aGlzLnN0YXRpY3MucmVxdWlyZWRDb250YWluZXIuYmxvdE5hbWUsIGZvcm1hdHMpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICAoX2dldDMgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihSb3dDb250YWluZXIucHJvdG90eXBlKSwgXCJvcHRpbWl6ZVwiLCB0aGlzKSkuY2FsbC5hcHBseShfZ2V0MywgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJvd0NvbnRhaW5lcjtcbn0oY29udGFpbmVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxudmFyIFRhYmxlQm9keSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Jvd0NvbnRhaW5lcikge1xuICBfaW5oZXJpdHMoVGFibGVCb2R5LCBfUm93Q29udGFpbmVyKTtcblxuICB2YXIgX3N1cGVyOCA9IF9jcmVhdGVTdXBlcihUYWJsZUJvZHkpO1xuXG4gIGZ1bmN0aW9uIFRhYmxlQm9keSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGFibGVCb2R5KTtcblxuICAgIHJldHVybiBfc3VwZXI4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gVGFibGVCb2R5O1xufShsaXRlX1Jvd0NvbnRhaW5lcik7XG5cblRhYmxlQm9keS5ibG90TmFtZSA9ICd0YWJsZUJvZHknO1xuVGFibGVCb2R5LnRhZ05hbWUgPSBbJ1RCT0RZJ107XG5cbnZhciBUYWJsZUhlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1Jvd0NvbnRhaW5lcjIpIHtcbiAgX2luaGVyaXRzKFRhYmxlSGVhZGVyLCBfUm93Q29udGFpbmVyMik7XG5cbiAgdmFyIF9zdXBlcjkgPSBfY3JlYXRlU3VwZXIoVGFibGVIZWFkZXIpO1xuXG4gIGZ1bmN0aW9uIFRhYmxlSGVhZGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJsZUhlYWRlcik7XG5cbiAgICByZXR1cm4gX3N1cGVyOS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIFRhYmxlSGVhZGVyO1xufShsaXRlX1Jvd0NvbnRhaW5lcik7XG5cblRhYmxlSGVhZGVyLmJsb3ROYW1lID0gJ3RhYmxlSGVhZGVyJztcblRhYmxlSGVhZGVyLnRhZ05hbWUgPSBbJ1RIRUFEJ107XG5cbnZhciBsaXRlX1RhYmxlQ29udGFpbmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29udGFpbmVyMykge1xuICBfaW5oZXJpdHMoVGFibGVDb250YWluZXIsIF9Db250YWluZXIzKTtcblxuICB2YXIgX3N1cGVyMTAgPSBfY3JlYXRlU3VwZXIoVGFibGVDb250YWluZXIpO1xuXG4gIGZ1bmN0aW9uIFRhYmxlQ29udGFpbmVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJsZUNvbnRhaW5lcik7XG5cbiAgICByZXR1cm4gX3N1cGVyMTAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUYWJsZUNvbnRhaW5lciwgW3tcbiAgICBrZXk6IFwiYmFsYW5jZUNlbGxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhbGFuY2VDZWxscygpIHtcbiAgICAgIHZhciBoZWFkZXJSb3dzID0gdGhpcy5kZXNjZW5kYW50cyhUYWJsZUhlYWRlclJvdyk7XG4gICAgICB2YXIgYm9keVJvd3MgPSB0aGlzLmRlc2NlbmRhbnRzKFRhYmxlUm93KTtcbiAgICAgIHZhciBtYXhDb2xDb3VudCA9IHRoaXMuZ2V0TWF4VGFibGVDb2xDb3VudChoZWFkZXJSb3dzLCBib2R5Um93cyk7XG4gICAgICB0aGlzLmJhbGFuY2VSb3dzKG1heENvbENvdW50LCBoZWFkZXJSb3dzLCBUYWJsZUhlYWRlckNlbGwpO1xuICAgICAgdGhpcy5iYWxhbmNlUm93cyhtYXhDb2xDb3VudCwgYm9keVJvd3MsIFRhYmxlQ2VsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1heFRhYmxlQ29sQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4VGFibGVDb2xDb3VudChoZWFkZXJSb3dzLCBib2R5Um93cykge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuZ2V0TWF4Um93Q29sQ291bnQoaGVhZGVyUm93cyksIHRoaXMuZ2V0TWF4Um93Q29sQ291bnQoYm9keVJvd3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF4Um93Q29sQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4Um93Q29sQ291bnQocm93cykge1xuICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShyb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiByb3cuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgfSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmFsYW5jZVJvd3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmFsYW5jZVJvd3MobWF4Q29sQ291bnQsIHJvd3MsIENlbGxDbGFzcykge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIG5ldyBBcnJheShtYXhDb2xDb3VudCAtIHJvdy5jaGlsZHJlbi5sZW5ndGgpLmZpbGwoMCkuZm9yRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgaWYgKE9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShyb3cuY2hpbGRyZW4uaGVhZCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gQ2VsbENsYXNzLmZvcm1hdHMocm93LmNoaWxkcmVuLmhlYWQuZG9tTm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJsb3QgPSBfdGhpczQuc2Nyb2xsLmNyZWF0ZShDZWxsQ2xhc3MuYmxvdE5hbWUsIHZhbHVlKTtcblxuICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChibG90KTtcbiAgICAgICAgICBibG90Lm9wdGltaXplKCk7IC8vIEFkZCBicmVhayBibG90XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNlbGxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNlbGxzKGNvbHVtbikge1xuICAgICAgcmV0dXJuIHRoaXMucm93cygpLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiByb3cuY2hpbGRyZW4uYXQoY29sdW1uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVDb2x1bW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQ29sdW1uKGluZGV4KSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgW1RhYmxlSGVhZGVyLCBUYWJsZUJvZHldLmZvckVhY2goZnVuY3Rpb24gKGJsb3QpIHtcbiAgICAgICAgdmFyIF90aGlzNSRkZXNjZW5kYW50cyA9IF90aGlzNS5kZXNjZW5kYW50cyhibG90KSxcbiAgICAgICAgICAgIF90aGlzNSRkZXNjZW5kYW50czIgPSBfc2xpY2VkVG9BcnJheShfdGhpczUkZGVzY2VuZGFudHMsIDEpLFxuICAgICAgICAgICAgdGFibGVQYXJ0ID0gX3RoaXM1JGRlc2NlbmRhbnRzMlswXTtcblxuICAgICAgICBpZiAoIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh0YWJsZVBhcnQpIHx8ICFPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkodGFibGVQYXJ0LmNoaWxkcmVuLmhlYWQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFibGVQYXJ0LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgIHZhciBjZWxsID0gcm93LmNoaWxkcmVuLmF0KGluZGV4KTtcblxuICAgICAgICAgIGlmIChPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkoY2VsbCkpIHtcbiAgICAgICAgICAgIGNlbGwucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRDb2x1bW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Q29sdW1uKGluZGV4KSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgW1RhYmxlSGVhZGVyLCBUYWJsZUJvZHldLmZvckVhY2goZnVuY3Rpb24gKGJsb3QpIHtcbiAgICAgICAgdmFyIF90aGlzNiRkZXNjZW5kYW50cyA9IF90aGlzNi5kZXNjZW5kYW50cyhibG90KSxcbiAgICAgICAgICAgIF90aGlzNiRkZXNjZW5kYW50czIgPSBfc2xpY2VkVG9BcnJheShfdGhpczYkZGVzY2VuZGFudHMsIDEpLFxuICAgICAgICAgICAgdGFibGVQYXJ0ID0gX3RoaXM2JGRlc2NlbmRhbnRzMlswXTtcblxuICAgICAgICBpZiAoIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh0YWJsZVBhcnQpIHx8ICFPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkodGFibGVQYXJ0LmNoaWxkcmVuLmhlYWQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIENlbGxCbG90ID0gYmxvdCA9PT0gVGFibGVIZWFkZXIgPyBUYWJsZUhlYWRlckNlbGwgOiBUYWJsZUNlbGw7XG4gICAgICAgIHRhYmxlUGFydC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICB2YXIgcmVmID0gcm93LmNoaWxkcmVuLmF0KGluZGV4KTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBDZWxsQmxvdC5mb3JtYXRzKHJvdy5jaGlsZHJlbi5oZWFkLmRvbU5vZGUpO1xuXG4gICAgICAgICAgdmFyIGNlbGwgPSBfdGhpczYuc2Nyb2xsLmNyZWF0ZShDZWxsQmxvdC5ibG90TmFtZSwgdmFsdWUpO1xuXG4gICAgICAgICAgcm93Lmluc2VydEJlZm9yZShjZWxsLCByZWYpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRSb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Um93KGluZGV4KSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIF90aGlzJGRlc2NlbmRhbnRzID0gdGhpcy5kZXNjZW5kYW50cyhUYWJsZUJvZHkpLFxuICAgICAgICAgIF90aGlzJGRlc2NlbmRhbnRzMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJGRlc2NlbmRhbnRzLCAxKSxcbiAgICAgICAgICBib2R5ID0gX3RoaXMkZGVzY2VuZGFudHMyWzBdO1xuXG4gICAgICBpZiAoIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShib2R5KSB8fCAhT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKGJvZHkuY2hpbGRyZW4uaGVhZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWQgPSB0YWJsZUlkKCk7XG4gICAgICB2YXIgcm93ID0gdGhpcy5zY3JvbGwuY3JlYXRlKFRhYmxlUm93LmJsb3ROYW1lKTtcbiAgICAgIGJvZHkuY2hpbGRyZW4uaGVhZC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNlbGwgPSBfdGhpczcuc2Nyb2xsLmNyZWF0ZShUYWJsZUNlbGwuYmxvdE5hbWUsIGlkKTtcblxuICAgICAgICByb3cuYXBwZW5kQ2hpbGQoY2VsbCk7XG4gICAgICB9KTtcbiAgICAgIHZhciByZWYgPSBib2R5LmNoaWxkcmVuLmF0KGluZGV4KTtcbiAgICAgIGJvZHkuaW5zZXJ0QmVmb3JlKHJvdywgcmVmKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0SGVhZGVyUm93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEhlYWRlclJvdygpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMkZGVzY2VuZGFudHMzID0gdGhpcy5kZXNjZW5kYW50cyhUYWJsZUhlYWRlciksXG4gICAgICAgICAgX3RoaXMkZGVzY2VuZGFudHM0ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkZGVzY2VuZGFudHMzLCAxKSxcbiAgICAgICAgICBoZWFkZXIgPSBfdGhpcyRkZXNjZW5kYW50czRbMF07XG5cbiAgICAgIHZhciBfdGhpcyRkZXNjZW5kYW50czUgPSB0aGlzLmRlc2NlbmRhbnRzKFRhYmxlQm9keSksXG4gICAgICAgICAgX3RoaXMkZGVzY2VuZGFudHM2ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkZGVzY2VuZGFudHM1LCAxKSxcbiAgICAgICAgICBib2R5ID0gX3RoaXMkZGVzY2VuZGFudHM2WzBdO1xuXG4gICAgICBpZiAoT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKGhlYWRlcikgfHwgIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShib2R5KSB8fCAhT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKGJvZHkuY2hpbGRyZW4uaGVhZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWQgPSB0YWJsZUlkKCk7XG4gICAgICB2YXIgbmV3SGVhZGVyID0gdGhpcy5zY3JvbGwuY3JlYXRlKFRhYmxlSGVhZGVyLmJsb3ROYW1lKTtcbiAgICAgIHZhciByb3cgPSB0aGlzLnNjcm9sbC5jcmVhdGUoVGFibGVIZWFkZXJSb3cuYmxvdE5hbWUpO1xuICAgICAgdmFyIHJlZiA9IHRoaXMuY2hpbGRyZW4uYXQoMCk7XG4gICAgICBuZXdIZWFkZXIuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgIGJvZHkuY2hpbGRyZW4uaGVhZC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNlbGwgPSBfdGhpczguc2Nyb2xsLmNyZWF0ZShUYWJsZUhlYWRlckNlbGwuYmxvdE5hbWUsIGlkKTtcblxuICAgICAgICByb3cuYXBwZW5kQ2hpbGQoY2VsbCk7XG4gICAgICAgIGNlbGwub3B0aW1pemUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobmV3SGVhZGVyLCByZWYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3dzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvd3MoKSB7XG4gICAgICB2YXIgYm9keSA9IHRoaXMuY2hpbGRyZW4uaGVhZDtcbiAgICAgIHJldHVybiBPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkoYm9keSkgPyBib2R5LmNoaWxkcmVuLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgICB9KSA6IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoKSB7XG4gICAgICB2YXIgZm9ybWF0cyA9IHt9O1xuICAgICAgdmFyIGNoaWxkRWxlbSA9IHRoaXMuY2VsbHMoKVswXS5kb21Ob2RlO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRvcnNfdGFibGVbXCJiXCIgLyogVEFCTEVfRk9STUFUUyAqL10pLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBjaGlsZEVsZW0uZGF0YXNldFtmb3JtYXQudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgZm9ybWF0c1tmb3JtYXRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciB0YWJsZUZvcm1hdCA9IGF0dHJpYnV0b3JzX3RhYmxlW1wiYlwiIC8qIFRBQkxFX0ZPUk1BVFMgKi9dW25hbWVdO1xuXG4gICAgICBpZiAodGFibGVGb3JtYXQpIHtcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gXCJkYXRhLVwiLmNvbmNhdChuYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB0aGlzLmNlbGxzKCkuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgIE9iamVjdCh0b2dnbGVfYXR0cmlidXRlW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShjZWxsLmRvbU5vZGUsIGF0dHJOYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0YWJsZUZvcm1hdC5hZGQodGhpcy5kb21Ob2RlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIG5vZGUgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihUYWJsZUNvbnRhaW5lciksIFwiY3JlYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgIHZhciBfVEFCTEVfRk9STUFUUyRmb3JtYXQ7XG5cbiAgICAgICAgICAoX1RBQkxFX0ZPUk1BVFMkZm9ybWF0ID0gYXR0cmlidXRvcnNfdGFibGVbXCJiXCIgLyogVEFCTEVfRk9STUFUUyAqL11bZm9ybWF0XSkgPT09IG51bGwgfHwgX1RBQkxFX0ZPUk1BVFMkZm9ybWF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfVEFCTEVfRk9STUFUUyRmb3JtYXQuYWRkKG5vZGUsIHZhbHVlW2Zvcm1hdF0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRhYmxlQ29udGFpbmVyO1xufShjb250YWluZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5saXRlX1RhYmxlQ29udGFpbmVyLmJsb3ROYW1lID0gJ3RhYmxlQ29udGFpbmVyJztcbmxpdGVfVGFibGVDb250YWluZXIudGFnTmFtZSA9ICdUQUJMRSc7XG5saXRlX1RhYmxlQ29udGFpbmVyLmFsbG93ZWRDaGlsZHJlbiA9IFtUYWJsZUhlYWRlciwgVGFibGVCb2R5XTtcblRhYmxlQm9keS5yZXF1aXJlZENvbnRhaW5lciA9IGxpdGVfVGFibGVDb250YWluZXI7XG5UYWJsZUhlYWRlci5yZXF1aXJlZENvbnRhaW5lciA9IGxpdGVfVGFibGVDb250YWluZXI7XG5UYWJsZUJvZHkuYWxsb3dlZENoaWxkcmVuID0gW1RhYmxlUm93XTtcblRhYmxlUm93LnJlcXVpcmVkQ29udGFpbmVyID0gVGFibGVCb2R5O1xuVGFibGVSb3cuYWxsb3dlZENoaWxkcmVuID0gW1RhYmxlQ2VsbF07XG5UYWJsZUNlbGwucmVxdWlyZWRDb250YWluZXIgPSBUYWJsZVJvdztcblRhYmxlSGVhZGVyLmFsbG93ZWRDaGlsZHJlbiA9IFtUYWJsZUhlYWRlclJvd107XG5UYWJsZUhlYWRlclJvdy5yZXF1aXJlZENvbnRhaW5lciA9IFRhYmxlSGVhZGVyO1xuVGFibGVIZWFkZXJSb3cuYWxsb3dlZENoaWxkcmVuID0gW1RhYmxlSGVhZGVyQ2VsbF07XG5UYWJsZUhlYWRlckNlbGwucmVxdWlyZWRDb250YWluZXIgPSBUYWJsZUhlYWRlclJvdztcblxuZnVuY3Rpb24gdGFibGVJZCgpIHtcbiAgcmV0dXJuIFwicm93LVwiLmNvbmNhdChPYmplY3QoZ2V0X2lkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSgpKTtcbn1cblxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbW9kdWxlcy9jbGlwYm9hcmQuanNcbnZhciBjbGlwYm9hcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL21vZHVsZXMvdGFibGUvdXRpbHMvbWFrZV90YWJsZV9hcnJvd19oYW5kbGVyLmpzXG52YXIgbWFrZV90YWJsZV9hcnJvd19oYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbW9kdWxlcy90YWJsZS91dGlscy9pbnNlcnRfcHJfYmVsb3cuanNcblxuXG5mdW5jdGlvbiBpbnNlcnRQYXJhZ3JhcGhBYm92ZShfcmVmKSB7XG4gIHZhciBxdWlsbCA9IF9yZWYucXVpbGwsXG4gICAgICBpbmRleCA9IF9yZWYuaW5kZXgsXG4gICAgICByYW5nZSA9IF9yZWYucmFuZ2U7XG4gIHZhciBpbnNlcnRJbmRleCA9IGluZGV4IC0gMTtcbiAgdmFyIGRlbHRhID0gbmV3IERlbHRhX2RlZmF1bHQuYSgpLnJldGFpbihpbnNlcnRJbmRleCkuaW5zZXJ0KCdcXG4nKTtcbiAgcXVpbGwudXBkYXRlQ29udGVudHMoZGVsdGEsIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5VU0VSKTtcbiAgcXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgMSwgcmFuZ2UubGVuZ3RoLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuU0lMRU5UKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbW9kdWxlcy90YWJsZS91dGlscy9pbnNlcnRfcHJfYWJvdmUuanNcblxuXG5mdW5jdGlvbiBpbnNlcnRQYXJhZ3JhcGhCZWxvdyhfcmVmKSB7XG4gIHZhciBxdWlsbCA9IF9yZWYucXVpbGwsXG4gICAgICBpbmRleCA9IF9yZWYuaW5kZXgsXG4gICAgICB0YWJsZSA9IF9yZWYudGFibGU7XG4gIHZhciBpbnNlcnRJbmRleCA9IGluZGV4ICsgdGFibGUubGVuZ3RoKCk7XG4gIHZhciBkZWx0YSA9IG5ldyBEZWx0YV9kZWZhdWx0LmEoKS5yZXRhaW4oaW5zZXJ0SW5kZXgpLmluc2VydCgnXFxuJyk7XG4gIHF1aWxsLnVwZGF0ZUNvbnRlbnRzKGRlbHRhLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gIHF1aWxsLnNldFNlbGVjdGlvbihpbnNlcnRJbmRleCwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9tb2R1bGVzL3RhYmxlL3V0aWxzL3RhYmxlX3NpZGUuanNcbmZ1bmN0aW9uIHRhYmxlU2lkZShyb3csIGNlbGwsIG9mZnNldCkge1xuICBpZiAocm93LnByZXYgPT0gbnVsbCAmJiByb3cubmV4dCA9PSBudWxsKSB7XG4gICAgaWYgKGNlbGwucHJldiA9PSBudWxsICYmIGNlbGwubmV4dCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0ID09PSAwID8gLTEgOiAxO1xuICAgIH1cblxuICAgIHJldHVybiBjZWxsLnByZXYgPT0gbnVsbCA/IC0xIDogMTtcbiAgfVxuXG4gIGlmIChyb3cucHJldiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKHJvdy5uZXh0ID09IG51bGwpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL21vZHVsZXMvdGFibGUvdXRpbHMvcHJlcGFyZV9hdHRyX21hdGNoZXIuanNcbnZhciBwcmVwYXJlX2F0dHJfbWF0Y2hlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vZm9ybWF0cy90YWJsZS9hdHRyaWJ1dG9ycy9jZWxsLmpzXG52YXIgYXR0cmlidXRvcnNfY2VsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbW9kdWxlcy90YWJsZS9saXRlLmpzXG5mdW5jdGlvbiBsaXRlX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgbGl0ZV90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgbGl0ZV90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gbGl0ZV90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBsaXRlX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBsaXRlX2FycmF5V2l0aEhvbGVzKGFycikgfHwgbGl0ZV9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IGxpdGVfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBsaXRlX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIGxpdGVfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIGxpdGVfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBsaXRlX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBsaXRlX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBsaXRlX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIGxpdGVfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBsaXRlX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIGxpdGVfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBsaXRlX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBsaXRlX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgbGl0ZV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgbGl0ZV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBsaXRlX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIGxpdGVfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGxpdGVfc2V0UHJvdG90eXBlT2YobywgcCkgeyBsaXRlX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBsaXRlX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIGxpdGVfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGxpdGVfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gbGl0ZV9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gbGl0ZV9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gbGl0ZV9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gbGl0ZV9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGxpdGVfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIGxpdGVfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIGxpdGVfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gbGl0ZV9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBsaXRlX2dldFByb3RvdHlwZU9mKG8pIHsgbGl0ZV9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBsaXRlX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIEVNUFRZX1JFU1VMVCA9IFtudWxsLCBudWxsLCBudWxsLCAtMV07XG5cbnZhciBsaXRlX1RhYmxlTGl0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX01vZHVsZSkge1xuICBsaXRlX2luaGVyaXRzKFRhYmxlTGl0ZSwgX01vZHVsZSk7XG5cbiAgdmFyIF9zdXBlciA9IGxpdGVfY3JlYXRlU3VwZXIoVGFibGVMaXRlKTtcblxuICBmdW5jdGlvbiBUYWJsZUxpdGUoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgbGl0ZV9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJsZUxpdGUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwuYXBwbHkoX3N1cGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICBfdGhpcy50YWJsZUJsb3RzID0gW1RhYmxlQ2VsbC5ibG90TmFtZSwgVGFibGVIZWFkZXJDZWxsLmJsb3ROYW1lXTtcblxuICAgIF90aGlzLnRhYmxlQmxvdHMuZm9yRWFjaChmdW5jdGlvbiAoYmxvdE5hbWUpIHtcbiAgICAgIF90aGlzLnF1aWxsLmVkaXRvci5hZGRJbW1lZGlhdGVGb3JtYXQoYmxvdE5hbWUpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMuaW50ZWdyYXRlQ2xpcGJvYXJkKCk7XG5cbiAgICBfdGhpcy5hZGRLZXlib2FyZEhhbmRsZXJzKCk7XG5cbiAgICBfdGhpcy5saXN0ZW5CYWxhbmNlQ2VsbHMoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIGxpdGVfY3JlYXRlQ2xhc3MoVGFibGVMaXRlLCBbe1xuICAgIGtleTogXCJpbnRlZ3JhdGVDbGlwYm9hcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZWdyYXRlQ2xpcGJvYXJkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMudGFibGVCbG90cy5mb3JFYWNoKGZ1bmN0aW9uIChibG90TmFtZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnF1aWxsLmNsaXBib2FyZC5hZGRUYWJsZUJsb3QoYmxvdE5hbWUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnF1aWxsLmNsaXBib2FyZC5hZGRNYXRjaGVyKCd0cicsIG1hdGNoVGFibGUpO1xuICAgICAgdGhpcy5xdWlsbC5jbGlwYm9hcmQuYWRkTWF0Y2hlcigndGFibGUnLCBPYmplY3QocHJlcGFyZV9hdHRyX21hdGNoZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKCd0YWJsZScpKTtcbiAgICAgIHRoaXMucXVpbGwuY2xpcGJvYXJkLmFkZE1hdGNoZXIoJ3RkLCB0aCcsIE9iamVjdChwcmVwYXJlX2F0dHJfbWF0Y2hlcltcImFcIiAvKiBkZWZhdWx0ICovXSkoJ2NlbGwnKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEtleWJvYXJkSGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkS2V5Ym9hcmRIYW5kbGVycygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgYmluZGluZ3MgPSBUYWJsZUxpdGUua2V5Ym9hcmRCaW5kaW5ncztcbiAgICAgIE9iamVjdC5rZXlzKGJpbmRpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChiaW5kaW5nc1tuYW1lXSkge1xuICAgICAgICAgIF90aGlzMy5xdWlsbC5rZXlib2FyZC5hZGRCaW5kaW5nKGJpbmRpbmdzW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJhbGFuY2VUYWJsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmFsYW5jZVRhYmxlcygpIHtcbiAgICAgIHRoaXMucXVpbGwuc2Nyb2xsLmRlc2NlbmRhbnRzKGxpdGVfVGFibGVDb250YWluZXIpLmZvckVhY2goZnVuY3Rpb24gKHRhYmxlKSB7XG4gICAgICAgIHRhYmxlLmJhbGFuY2VDZWxscygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUNvbHVtblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVDb2x1bW4oKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0VGFibGUgPSB0aGlzLmdldFRhYmxlKCksXG4gICAgICAgICAgX3RoaXMkZ2V0VGFibGUyID0gbGl0ZV9zbGljZWRUb0FycmF5KF90aGlzJGdldFRhYmxlLCAzKSxcbiAgICAgICAgICB0YWJsZSA9IF90aGlzJGdldFRhYmxlMlswXSxcbiAgICAgICAgICBjZWxsID0gX3RoaXMkZ2V0VGFibGUyWzJdO1xuXG4gICAgICBpZiAoIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShjZWxsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRhYmxlLmRlbGV0ZUNvbHVtbihjZWxsLmNlbGxPZmZzZXQoKSk7XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZShjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVSb3coKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0VGFibGUzID0gdGhpcy5nZXRUYWJsZSgpLFxuICAgICAgICAgIF90aGlzJGdldFRhYmxlNCA9IGxpdGVfc2xpY2VkVG9BcnJheShfdGhpcyRnZXRUYWJsZTMsIDIpLFxuICAgICAgICAgIHJvdyA9IF90aGlzJGdldFRhYmxlNFsxXTtcblxuICAgICAgaWYgKCFPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkocm93KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJvdy5yZW1vdmUoKTtcbiAgICAgIHRoaXMucXVpbGwudXBkYXRlKGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5VU0VSKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlVGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlVGFibGUoKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0VGFibGU1ID0gdGhpcy5nZXRUYWJsZSgpLFxuICAgICAgICAgIF90aGlzJGdldFRhYmxlNiA9IGxpdGVfc2xpY2VkVG9BcnJheShfdGhpcyRnZXRUYWJsZTUsIDEpLFxuICAgICAgICAgIHRhYmxlID0gX3RoaXMkZ2V0VGFibGU2WzBdO1xuXG4gICAgICBpZiAoIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh0YWJsZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0ID0gdGFibGUub2Zmc2V0KCk7XG4gICAgICB0YWJsZS5yZW1vdmUoKTtcbiAgICAgIHRoaXMucXVpbGwudXBkYXRlKGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5VU0VSKTtcbiAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKG9mZnNldCwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlNJTEVOVCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRhYmxlKCkge1xuICAgICAgdmFyIHJhbmdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnF1aWxsLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAoIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShyYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIEVNUFRZX1JFU1VMVDtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJHF1aWxsJGdldExpbmUgPSB0aGlzLnF1aWxsLmdldExpbmUocmFuZ2UuaW5kZXgpLFxuICAgICAgICAgIF90aGlzJHF1aWxsJGdldExpbmUyID0gbGl0ZV9zbGljZWRUb0FycmF5KF90aGlzJHF1aWxsJGdldExpbmUsIDIpLFxuICAgICAgICAgIGNlbGwgPSBfdGhpcyRxdWlsbCRnZXRMaW5lMlswXSxcbiAgICAgICAgICBvZmZzZXQgPSBfdGhpcyRxdWlsbCRnZXRMaW5lMlsxXTtcblxuICAgICAgaWYgKCFPYmplY3QoaXNfZGVmaW5lZFtcImFcIiAvKiBkZWZhdWx0ICovXSkoY2VsbCkgfHwgdGhpcy50YWJsZUJsb3RzLmluZGV4T2YoY2VsbC5zdGF0aWNzLmJsb3ROYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIEVNUFRZX1JFU1VMVDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJvdyA9IGNlbGwucGFyZW50O1xuICAgICAgdmFyIHRhYmxlID0gcm93LnBhcmVudC5wYXJlbnQ7XG4gICAgICByZXR1cm4gW3RhYmxlLCByb3csIGNlbGwsIG9mZnNldF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydENvbHVtblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRDb2x1bW4ob2Zmc2V0KSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnF1aWxsLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICB2YXIgX3RoaXMkZ2V0VGFibGU3ID0gdGhpcy5nZXRUYWJsZShyYW5nZSksXG4gICAgICAgICAgX3RoaXMkZ2V0VGFibGU4ID0gbGl0ZV9zbGljZWRUb0FycmF5KF90aGlzJGdldFRhYmxlNywgMyksXG4gICAgICAgICAgdGFibGUgPSBfdGhpcyRnZXRUYWJsZThbMF0sXG4gICAgICAgICAgcm93ID0gX3RoaXMkZ2V0VGFibGU4WzFdLFxuICAgICAgICAgIGNlbGwgPSBfdGhpcyRnZXRUYWJsZThbMl07XG5cbiAgICAgIGlmICghT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKGNlbGwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbHVtbiA9IGNlbGwuY2VsbE9mZnNldCgpO1xuICAgICAgdGFibGUuaW5zZXJ0Q29sdW1uKGNvbHVtbiArIG9mZnNldCk7XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZShjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgICB2YXIgc2hpZnQgPSByb3cucm93T2Zmc2V0KCk7XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgc2hpZnQgKz0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXggKyBzaGlmdCwgcmFuZ2UubGVuZ3RoLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuU0lMRU5UKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Q29sdW1uTGVmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRDb2x1bW5MZWZ0KCkge1xuICAgICAgdGhpcy5pbnNlcnRDb2x1bW4oMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydENvbHVtblJpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydENvbHVtblJpZ2h0KCkge1xuICAgICAgdGhpcy5pbnNlcnRDb2x1bW4oMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydFJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRSb3cob2Zmc2V0KSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnF1aWxsLmdldFNlbGVjdGlvbigpO1xuXG4gICAgICB2YXIgX3RoaXMkZ2V0VGFibGU5ID0gdGhpcy5nZXRUYWJsZShyYW5nZSksXG4gICAgICAgICAgX3RoaXMkZ2V0VGFibGUxMCA9IGxpdGVfc2xpY2VkVG9BcnJheShfdGhpcyRnZXRUYWJsZTksIDMpLFxuICAgICAgICAgIHRhYmxlID0gX3RoaXMkZ2V0VGFibGUxMFswXSxcbiAgICAgICAgICByb3cgPSBfdGhpcyRnZXRUYWJsZTEwWzFdLFxuICAgICAgICAgIGNlbGwgPSBfdGhpcyRnZXRUYWJsZTEwWzJdO1xuXG4gICAgICBpZiAoIU9iamVjdChpc19kZWZpbmVkW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShjZWxsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IHJvdy5yb3dPZmZzZXQoKTtcbiAgICAgIHRhYmxlLmluc2VydFJvdyhpbmRleCArIG9mZnNldCk7XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZShjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG5cbiAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLmluZGV4ICsgcm93LmNoaWxkcmVuLmxlbmd0aCwgcmFuZ2UubGVuZ3RoLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Um93QWJvdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Um93QWJvdmUoKSB7XG4gICAgICB0aGlzLmluc2VydFJvdygwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Um93QmVsb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Um93QmVsb3coKSB7XG4gICAgICB0aGlzLmluc2VydFJvdygxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0SGVhZGVyUm93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEhlYWRlclJvdygpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIHZhciBfdGhpcyRnZXRUYWJsZTExID0gdGhpcy5nZXRUYWJsZShyYW5nZSksXG4gICAgICAgICAgX3RoaXMkZ2V0VGFibGUxMiA9IGxpdGVfc2xpY2VkVG9BcnJheShfdGhpcyRnZXRUYWJsZTExLCAzKSxcbiAgICAgICAgICB0YWJsZSA9IF90aGlzJGdldFRhYmxlMTJbMF0sXG4gICAgICAgICAgY2VsbCA9IF90aGlzJGdldFRhYmxlMTJbMl07XG5cbiAgICAgIGlmICghT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKGNlbGwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGFibGUuaW5zZXJ0SGVhZGVyUm93KCk7XG4gICAgICB0aGlzLnF1aWxsLnVwZGF0ZShjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydFRhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFRhYmxlKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmICghT2JqZWN0KGlzX2RlZmluZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pKHJhbmdlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWx0YSA9IG5ldyBBcnJheShyb3dzKS5maWxsKDApLnJlZHVjZShmdW5jdGlvbiAobWVtbykge1xuICAgICAgICB2YXIgdGV4dCA9IG5ldyBBcnJheShjb2x1bW5zKS5maWxsKCdcXG4nKS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIG1lbW8uaW5zZXJ0KHRleHQsIHtcbiAgICAgICAgICB0YWJsZTogdGFibGVJZCgpXG4gICAgICAgIH0pO1xuICAgICAgfSwgbmV3IERlbHRhX2RlZmF1bHQuYSgpLnJldGFpbihyYW5nZS5pbmRleCkpO1xuICAgICAgdGhpcy5xdWlsbC51cGRhdGVDb250ZW50cyhkZWx0YSwgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5zb3VyY2VzLlVTRVIpO1xuICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24ocmFuZ2UuaW5kZXgsIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5TSUxFTlQpO1xuICAgICAgdGhpcy5iYWxhbmNlVGFibGVzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRhYmxlRm9ybWF0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0YWJsZUZvcm1hdHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWJsZUJsb3RzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaXN0ZW5CYWxhbmNlQ2VsbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuQmFsYW5jZUNlbGxzKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHRoaXMucXVpbGwub24oY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5ldmVudHMuU0NST0xMX09QVElNSVpFLCBmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgICAgIG11dGF0aW9ucy5zb21lKGZ1bmN0aW9uIChtdXRhdGlvbikge1xuICAgICAgICAgIGlmIChbJ1REJywgJ1RIJywgJ1RSJywgJ1RCT0RZJywgJ1RIRUFEJywgJ1RBQkxFJ10uaW5kZXhPZihtdXRhdGlvbi50YXJnZXQudGFnTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBfdGhpczQucXVpbGwub25jZShjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmV2ZW50cy5URVhUX0NIQU5HRSwgZnVuY3Rpb24gKGRlbHRhLCBvbGQsIHNvdXJjZSkge1xuICAgICAgICAgICAgICBpZiAoc291cmNlICE9PSBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUikgcmV0dXJuO1xuXG4gICAgICAgICAgICAgIF90aGlzNC5iYWxhbmNlVGFibGVzKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5xdWlsbC5vbihjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmV2ZW50cy5DT05URU5UX1NFVFRFRCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczQucXVpbGwub25jZShjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmV2ZW50cy5URVhUX0NIQU5HRSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNC5iYWxhbmNlVGFibGVzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicmVnaXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgICBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnJlZ2lzdGVyKFRhYmxlSGVhZGVyQ2VsbCwgdHJ1ZSk7XG4gICAgICBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnJlZ2lzdGVyKFRhYmxlQ2VsbCwgdHJ1ZSk7XG4gICAgICBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnJlZ2lzdGVyKFRhYmxlSGVhZGVyUm93LCB0cnVlKTtcbiAgICAgIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10ucmVnaXN0ZXIoVGFibGVSb3csIHRydWUpO1xuICAgICAgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5yZWdpc3RlcihUYWJsZUJvZHksIHRydWUpO1xuICAgICAgY29yZV9xdWlsbFtcImFcIiAvKiBkZWZhdWx0ICovXS5yZWdpc3RlcihUYWJsZUhlYWRlciwgdHJ1ZSk7XG4gICAgICBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnJlZ2lzdGVyKGxpdGVfVGFibGVDb250YWluZXIsIHRydWUpO1xuICAgICAgW2F0dHJpYnV0b3JzX3RhYmxlW1wiYlwiIC8qIFRBQkxFX0ZPUk1BVFMgKi9dLCBhdHRyaWJ1dG9yc19jZWxsW1wiYlwiIC8qIENFTExfRk9STUFUUyAqL11dLmZvckVhY2goZnVuY3Rpb24gKGZvcm1hdHMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybWF0cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10ucmVnaXN0ZXIoX2RlZmluZVByb3BlcnR5KHt9LCBcImZvcm1hdHMvXCIuY29uY2F0KG5hbWUpLCBmb3JtYXRzW25hbWVdKSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRhYmxlTGl0ZTtcbn0oY29yZV9tb2R1bGVbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5saXRlX1RhYmxlTGl0ZS5rZXlib2FyZEJpbmRpbmdzID0ge1xuICAndGFibGUgYmFja3NwYWNlJzoge1xuICAgIGtleTogJ2JhY2tzcGFjZScsXG4gICAgZm9ybWF0OiBbJ3RhYmxlJywgJ3RhYmxlSGVhZGVyQ2VsbCddLFxuICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICBvZmZzZXQ6IDAsXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHt9XG4gIH0sXG4gICd0YWJsZSBkZWxldGUnOiB7XG4gICAga2V5OiAnZGVsJyxcbiAgICBmb3JtYXQ6IFsndGFibGUnLCAndGFibGVIZWFkZXJDZWxsJ10sXG4gICAgY29sbGFwc2VkOiB0cnVlLFxuICAgIHN1ZmZpeDogL14kLyxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge31cbiAgfSxcbiAgJ3RhYmxlIGVudGVyJzoge1xuICAgIGtleTogJ2VudGVyJyxcbiAgICBzaGlmdEtleTogbnVsbCxcbiAgICBmb3JtYXQ6IFsndGFibGUnXSxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHJhbmdlKSB7XG4gICAgICB2YXIgbW9kdWxlID0gdGhpcy5xdWlsbC5nZXRNb2R1bGUoJ3RhYmxlJyk7XG5cbiAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgdmFyIHF1aWxsID0gdGhpcy5xdWlsbDtcblxuICAgICAgICB2YXIgX21vZHVsZSRnZXRUYWJsZSA9IG1vZHVsZS5nZXRUYWJsZShyYW5nZSksXG4gICAgICAgICAgICBfbW9kdWxlJGdldFRhYmxlMiA9IGxpdGVfc2xpY2VkVG9BcnJheShfbW9kdWxlJGdldFRhYmxlLCA0KSxcbiAgICAgICAgICAgIHRhYmxlID0gX21vZHVsZSRnZXRUYWJsZTJbMF0sXG4gICAgICAgICAgICByb3cgPSBfbW9kdWxlJGdldFRhYmxlMlsxXSxcbiAgICAgICAgICAgIGNlbGwgPSBfbW9kdWxlJGdldFRhYmxlMlsyXSxcbiAgICAgICAgICAgIG9mZnNldCA9IF9tb2R1bGUkZ2V0VGFibGUyWzNdO1xuXG4gICAgICAgIHZhciBzaGlmdCA9IHRhYmxlU2lkZShyb3csIGNlbGwsIG9mZnNldCk7XG4gICAgICAgIHZhciBoYXNIZWFkID0gdGFibGUuY2hpbGRyZW4ubGVuZ3RoID4gMSAmJiB0YWJsZS5jaGlsZHJlbi5oZWFkO1xuXG4gICAgICAgIGlmIChzaGlmdCA9PSBudWxsIHx8IHNoaWZ0IDwgMCAmJiBoYXNIZWFkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4ID0gdGFibGUub2Zmc2V0KCk7XG5cbiAgICAgICAgaWYgKHNoaWZ0IDwgMCkge1xuICAgICAgICAgIGluc2VydFBhcmFncmFwaEFib3ZlKHtcbiAgICAgICAgICAgIHF1aWxsOiBxdWlsbCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc2VydFBhcmFncmFwaEJlbG93KHtcbiAgICAgICAgICAgIHF1aWxsOiBxdWlsbCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIHRhYmxlOiB0YWJsZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAndGFibGUgaGVhZGVyIGVudGVyJzoge1xuICAgIGtleTogJ2VudGVyJyxcbiAgICBzaGlmdEtleTogbnVsbCxcbiAgICBmb3JtYXQ6IFsndGFibGVIZWFkZXJDZWxsJ10sXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihyYW5nZSkge1xuICAgICAgdmFyIG1vZHVsZSA9IHRoaXMucXVpbGwuZ2V0TW9kdWxlKCd0YWJsZScpO1xuXG4gICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgIHZhciBxdWlsbCA9IHRoaXMucXVpbGw7XG5cbiAgICAgICAgdmFyIF9tb2R1bGUkZ2V0VGFibGUzID0gbW9kdWxlLmdldFRhYmxlKHJhbmdlKSxcbiAgICAgICAgICAgIF9tb2R1bGUkZ2V0VGFibGU0ID0gbGl0ZV9zbGljZWRUb0FycmF5KF9tb2R1bGUkZ2V0VGFibGUzLCA0KSxcbiAgICAgICAgICAgIHRhYmxlID0gX21vZHVsZSRnZXRUYWJsZTRbMF0sXG4gICAgICAgICAgICByb3cgPSBfbW9kdWxlJGdldFRhYmxlNFsxXSxcbiAgICAgICAgICAgIGNlbGwgPSBfbW9kdWxlJGdldFRhYmxlNFsyXSxcbiAgICAgICAgICAgIG9mZnNldCA9IF9tb2R1bGUkZ2V0VGFibGU0WzNdO1xuXG4gICAgICAgIHZhciBzaGlmdCA9IHRhYmxlU2lkZShyb3csIGNlbGwsIG9mZnNldCk7XG5cbiAgICAgICAgaWYgKHNoaWZ0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXggPSB0YWJsZS5vZmZzZXQoKTtcbiAgICAgICAgdmFyIGhhc0JvZHkgPSB0YWJsZS5jaGlsZHJlbi5sZW5ndGggPiAxICYmIHRhYmxlLmNoaWxkcmVuLnRhaWw7XG5cbiAgICAgICAgaWYgKHNoaWZ0IDwgMCB8fCBzaGlmdCA+IDAgJiYgaGFzQm9keSkge1xuICAgICAgICAgIGluc2VydFBhcmFncmFwaEFib3ZlKHtcbiAgICAgICAgICAgIHF1aWxsOiBxdWlsbCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc2VydFBhcmFncmFwaEJlbG93KHtcbiAgICAgICAgICAgIHF1aWxsOiBxdWlsbCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIHRhYmxlOiB0YWJsZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAndGFibGUgdGFiJzoge1xuICAgIGtleTogJ3RhYicsXG4gICAgc2hpZnRLZXk6IG51bGwsXG4gICAgZm9ybWF0OiBbJ3RhYmxlJywgJ3RhYmxlSGVhZGVyQ2VsbCddLFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIocmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgIHZhciBldmVudCA9IGNvbnRleHQuZXZlbnQsXG4gICAgICAgICAgY2VsbCA9IGNvbnRleHQubGluZTtcbiAgICAgIHZhciBvZmZzZXQgPSBjZWxsLm9mZnNldCh0aGlzLnF1aWxsLnNjcm9sbCk7XG5cbiAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihvZmZzZXQgLSAxLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihvZmZzZXQgKyBjZWxsLmxlbmd0aCgpLCBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNvdXJjZXMuVVNFUik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAndGFibGUgZG93bic6IE9iamVjdChtYWtlX3RhYmxlX2Fycm93X2hhbmRsZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKGZhbHNlLCBbJ3RhYmxlJywgJ3RhYmxlSGVhZGVyQ2VsbCddKSxcbiAgJ3RhYmxlIHVwJzogT2JqZWN0KG1ha2VfdGFibGVfYXJyb3dfaGFuZGxlcltcImFcIiAvKiBkZWZhdWx0ICovXSkodHJ1ZSwgWyd0YWJsZScsICd0YWJsZUhlYWRlckNlbGwnXSlcbn07XG5cbmZ1bmN0aW9uIG1hdGNoVGFibGUobm9kZSwgZGVsdGEpIHtcbiAgdmFyIHRhYmxlID0gbm9kZS5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdUQUJMRScgPyBub2RlLnBhcmVudE5vZGUgOiBub2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgdmFyIGlzSGVhZGVyUm93ID0gbm9kZS5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdUSEVBRCcgPyB0cnVlIDogbnVsbDtcbiAgdmFyIHJvd3MgPSBBcnJheS5mcm9tKHRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RyJykpO1xuICB2YXIgcm93ID0gcm93cy5pbmRleE9mKG5vZGUpICsgMTtcbiAgcmV0dXJuIE9iamVjdChjbGlwYm9hcmRbXCJhXCIgLyogYXBwbHlGb3JtYXQgKi9dKShkZWx0YSwgaXNIZWFkZXJSb3cgPyAndGFibGVIZWFkZXJDZWxsJyA6ICd0YWJsZScsIHJvdyk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGxpdGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChsaXRlX1RhYmxlTGl0ZSk7XG5cbi8qKiovIH0pLFxuLyogNzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFN5bnRheENvZGVCbG9jazsgfSk7XG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgQ29kZVRva2VuICovXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFN5bnRheDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcXVpbGxfZGVsdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcXVpbGxfZGVsdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwYXJjaG1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jsb3RzX2lubGluZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvcmVfcXVpbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvcmVfbW9kdWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmxvdHNfYmxvY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Jsb3RzX2JyZWFrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmxvdHNfY3Vyc29yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmxvdHNfdGV4dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Zvcm1hdHNfY29kZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NsaXBib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19oYXNfd2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBUb2tlbkF0dHJpYnV0b3IgPSBuZXcgcGFyY2htZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJDbGFzc0F0dHJpYnV0b3JcIl0oJ2NvZGUtdG9rZW4nLCAnaGxqcycsIHtcbiAgc2NvcGU6IHBhcmNobWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiU2NvcGVcIl0uSU5MSU5FXG59KTtcblxudmFyIENvZGVUb2tlbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lubGluZSkge1xuICBfaW5oZXJpdHMoQ29kZVRva2VuLCBfSW5saW5lKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKENvZGVUb2tlbik7XG5cbiAgZnVuY3Rpb24gQ29kZVRva2VuKHNjcm9sbCwgZG9tTm9kZSwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29kZVRva2VuKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2Nyb2xsLCBkb21Ob2RlLCB2YWx1ZSk7XG4gICAgVG9rZW5BdHRyaWJ1dG9yLmFkZChfdGhpcy5kb21Ob2RlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvZGVUb2tlbiwgW3tcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChfZm9ybWF0LCB2YWx1ZSkge1xuICAgICAgaWYgKF9mb3JtYXQgIT09IENvZGVUb2tlbi5ibG90TmFtZSkge1xuICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihDb2RlVG9rZW4ucHJvdG90eXBlKSwgXCJmb3JtYXRcIiwgdGhpcykuY2FsbCh0aGlzLCBfZm9ybWF0LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIFRva2VuQXR0cmlidXRvci5hZGQodGhpcy5kb21Ob2RlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBUb2tlbkF0dHJpYnV0b3IucmVtb3ZlKHRoaXMuZG9tTm9kZSk7XG4gICAgICAgIHRoaXMuZG9tTm9kZS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuc3RhdGljcy5jbGFzc05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcHRpbWl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpbWl6ZSgpIHtcbiAgICAgIHZhciBfZ2V0MjtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIChfZ2V0MiA9IF9nZXQoX2dldFByb3RvdHlwZU9mKENvZGVUb2tlbi5wcm90b3R5cGUpLCBcIm9wdGltaXplXCIsIHRoaXMpKS5jYWxsLmFwcGx5KF9nZXQyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcblxuICAgICAgaWYgKCFUb2tlbkF0dHJpYnV0b3IudmFsdWUodGhpcy5kb21Ob2RlKSkge1xuICAgICAgICB0aGlzLnVud3JhcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZvcm1hdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cyhub2RlLCBzY3JvbGwpIHtcbiAgICAgIHdoaWxlIChub2RlICE9IG51bGwgJiYgbm9kZSAhPT0gc2Nyb2xsLmRvbU5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY2xhc3NMaXN0ICYmIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKF9mb3JtYXRzX2NvZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1svKiBkZWZhdWx0ICovIFwiY1wiXS5jbGFzc05hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKENvZGVUb2tlbiksIFwiZm9ybWF0c1wiLCB0aGlzKS5jYWxsKHRoaXMsIG5vZGUsIHNjcm9sbCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2RlVG9rZW47XG59KF9ibG90c19pbmxpbmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXSk7XG5cbkNvZGVUb2tlbi5ibG90TmFtZSA9ICdjb2RlLXRva2VuJztcbkNvZGVUb2tlbi5jbGFzc05hbWUgPSAncWwtdG9rZW4nO1xuXG52YXIgU3ludGF4Q29kZUJsb2NrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29kZUJsb2NrKSB7XG4gIF9pbmhlcml0cyhTeW50YXhDb2RlQmxvY2ssIF9Db2RlQmxvY2spO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKFN5bnRheENvZGVCbG9jayk7XG5cbiAgZnVuY3Rpb24gU3ludGF4Q29kZUJsb2NrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTeW50YXhDb2RlQmxvY2spO1xuXG4gICAgcmV0dXJuIF9zdXBlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTeW50YXhDb2RlQmxvY2ssIFt7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiAvLyBTeW50YXggbW9kdWxlIHdpbGwgcmVnaXN0ZXJcbiAgICBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChuYW1lID09PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUgJiYgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kb21Ob2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1sYW5ndWFnZScsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFN5bnRheENvZGVCbG9jay5wcm90b3R5cGUpLCBcImZvcm1hdFwiLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVdpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVdpdGgobmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuZm9ybWF0QXQoMCwgdGhpcy5sZW5ndGgoKSwgQ29kZVRva2VuLmJsb3ROYW1lLCBmYWxzZSk7XG4gICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoU3ludGF4Q29kZUJsb2NrLnByb3RvdHlwZSksIFwicmVwbGFjZVdpdGhcIiwgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIGRvbU5vZGUgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihTeW50YXhDb2RlQmxvY2spLCBcImNyZWF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZG9tTm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGFuZ3VhZ2UnLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkb21Ob2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWxhbmd1YWdlJykgfHwgJ3BsYWluJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIoKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIFN5bnRheENvZGVCbG9jaztcbn0oX2Zvcm1hdHNfY29kZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fWy8qIGRlZmF1bHQgKi8gXCJjXCJdKTtcblxudmFyIFN5bnRheENvZGVCbG9ja0NvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvZGVCbG9ja0NvbnRhaW5lcikge1xuICBfaW5oZXJpdHMoU3ludGF4Q29kZUJsb2NrQ29udGFpbmVyLCBfQ29kZUJsb2NrQ29udGFpbmVyKTtcblxuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihTeW50YXhDb2RlQmxvY2tDb250YWluZXIpO1xuXG4gIGZ1bmN0aW9uIFN5bnRheENvZGVCbG9ja0NvbnRhaW5lcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ludGF4Q29kZUJsb2NrQ29udGFpbmVyKTtcblxuICAgIHJldHVybiBfc3VwZXIzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3ludGF4Q29kZUJsb2NrQ29udGFpbmVyLCBbe1xuICAgIGtleTogXCJhdHRhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoKCkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU3ludGF4Q29kZUJsb2NrQ29udGFpbmVyLnByb3RvdHlwZSksIFwiYXR0YWNoXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIHRoaXMuZm9yY2VOZXh0ID0gZmFsc2U7XG4gICAgICB0aGlzLnNjcm9sbC5lbWl0TW91bnQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChuYW1lID09PSBTeW50YXhDb2RlQmxvY2suYmxvdE5hbWUpIHtcbiAgICAgICAgdGhpcy5mb3JjZU5leHQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgY2hpbGQuZm9ybWF0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAobmFtZSA9PT0gU3ludGF4Q29kZUJsb2NrLmJsb3ROYW1lKSB7XG4gICAgICAgIHRoaXMuZm9yY2VOZXh0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU3ludGF4Q29kZUJsb2NrQ29udGFpbmVyLnByb3RvdHlwZSksIFwiZm9ybWF0QXRcIiwgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhpZ2hsaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWdobGlnaHQoX2hpZ2hsaWdodCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JjZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uaGVhZCA9PSBudWxsKSByZXR1cm47XG4gICAgICB2YXIgbm9kZXMgPSBBcnJheS5mcm9tKHRoaXMuZG9tTm9kZS5jaGlsZE5vZGVzKS5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgIT09IF90aGlzMi51aU5vZGU7XG4gICAgICB9KTtcbiAgICAgIHZhciB0ZXh0ID0gXCJcIi5jb25jYXQobm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnRleHRDb250ZW50O1xuICAgICAgfSkuam9pbignXFxuJyksIFwiXFxuXCIpO1xuICAgICAgdmFyIGxhbmd1YWdlID0gU3ludGF4Q29kZUJsb2NrLmZvcm1hdHModGhpcy5jaGlsZHJlbi5oZWFkLmRvbU5vZGUpO1xuXG4gICAgICBpZiAoZm9yY2VkIHx8IHRoaXMuZm9yY2VOZXh0IHx8IHRoaXMuY2FjaGVkVGV4dCAhPT0gdGV4dCkge1xuICAgICAgICBpZiAodGV4dC50cmltKCkubGVuZ3RoID4gMCB8fCB0aGlzLmNhY2hlZFRleHQgPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBvbGREZWx0YSA9IHRoaXMuY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwgY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWx0YS5jb25jYXQoT2JqZWN0KF9ibG90c19ibG9ja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGJsb2NrRGVsdGEgKi8gXCJiXCJdKShjaGlsZCwgZmFsc2UpKTtcbiAgICAgICAgICB9LCBuZXcgcXVpbGxfZGVsdGFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEoKSk7XG5cbiAgICAgICAgICB2YXIgZGVsdGEgPSBfaGlnaGxpZ2h0KHRleHQsIGxhbmd1YWdlKTtcblxuICAgICAgICAgIG9sZERlbHRhLmRpZmYoZGVsdGEpLnJlZHVjZShmdW5jdGlvbiAoaW5kZXgsIF9yZWYpIHtcbiAgICAgICAgICAgIHZhciByZXRhaW4gPSBfcmVmLnJldGFpbixcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gX3JlZi5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgLy8gU2hvdWxkIGJlIGFsbCByZXRhaW5zXG4gICAgICAgICAgICBpZiAoIXJldGFpbikgcmV0dXJuIGluZGV4O1xuXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoW1N5bnRheENvZGVCbG9jay5ibG90TmFtZSwgQ29kZVRva2VuLmJsb3ROYW1lXS5pbmRleE9mKGZvcm1hdCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczIuZm9ybWF0QXQoaW5kZXgsIHJldGFpbiwgZm9ybWF0LCBhdHRyaWJ1dGVzW2Zvcm1hdF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbmRleCArIHJldGFpbjtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FjaGVkVGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuZm9yY2VOZXh0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImh0bWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaHRtbChpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgX3RoaXMkY2hpbGRyZW4kZmluZCA9IHRoaXMuY2hpbGRyZW4uZmluZChpbmRleCksXG4gICAgICAgICAgX3RoaXMkY2hpbGRyZW4kZmluZDIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRjaGlsZHJlbiRmaW5kLCAxKSxcbiAgICAgICAgICBjb2RlQmxvY2sgPSBfdGhpcyRjaGlsZHJlbiRmaW5kMlswXTtcblxuICAgICAgdmFyIGxhbmd1YWdlID0gY29kZUJsb2NrID8gU3ludGF4Q29kZUJsb2NrLmZvcm1hdHMoY29kZUJsb2NrLmRvbU5vZGUpIDogJ3BsYWluJztcbiAgICAgIHJldHVybiBcIjxwcmUgZGF0YS1sYW5ndWFnZT1cXFwiXCIuY29uY2F0KGxhbmd1YWdlLCBcIlxcXCI+XFxuXCIpLmNvbmNhdCh0aGlzLmNvZGUoaW5kZXgsIGxlbmd0aCksIFwiXFxuPC9wcmU+XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcHRpbWl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpbWl6ZShjb250ZXh0KSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihTeW50YXhDb2RlQmxvY2tDb250YWluZXIucHJvdG90eXBlKSwgXCJvcHRpbWl6ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuXG4gICAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbCAmJiB0aGlzLmNoaWxkcmVuLmhlYWQgIT0gbnVsbCAmJiB0aGlzLnVpTm9kZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IFN5bnRheENvZGVCbG9jay5mb3JtYXRzKHRoaXMuY2hpbGRyZW4uaGVhZC5kb21Ob2RlKTtcblxuICAgICAgICBpZiAobGFuZ3VhZ2UgIT09IHRoaXMudWlOb2RlLnZhbHVlKSB7XG4gICAgICAgICAgdGhpcy51aU5vZGUudmFsdWUgPSBsYW5ndWFnZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTeW50YXhDb2RlQmxvY2tDb250YWluZXI7XG59KF9mb3JtYXRzX2NvZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1svKiBDb2RlQmxvY2tDb250YWluZXIgKi8gXCJiXCJdKTtcblxuU3ludGF4Q29kZUJsb2NrQ29udGFpbmVyLmFsbG93ZWRDaGlsZHJlbiA9IFtTeW50YXhDb2RlQmxvY2tdO1xuU3ludGF4Q29kZUJsb2NrLnJlcXVpcmVkQ29udGFpbmVyID0gU3ludGF4Q29kZUJsb2NrQ29udGFpbmVyO1xuU3ludGF4Q29kZUJsb2NrLmFsbG93ZWRDaGlsZHJlbiA9IFtDb2RlVG9rZW4sIF9ibG90c19jdXJzb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXSwgX2Jsb3RzX3RleHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiYVwiXSwgX2Jsb3RzX2JyZWFrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl1dO1xuXG52YXIgU3ludGF4ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTW9kdWxlKSB7XG4gIF9pbmhlcml0cyhTeW50YXgsIF9Nb2R1bGUpO1xuXG4gIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKFN5bnRheCk7XG5cbiAgZnVuY3Rpb24gU3ludGF4KHF1aWxsLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTeW50YXgpO1xuXG4gICAgX3RoaXMzID0gX3N1cGVyNC5jYWxsKHRoaXMsIHF1aWxsLCBvcHRpb25zKTtcblxuICAgIGlmIChfdGhpczMub3B0aW9ucy5obGpzID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3ludGF4IG1vZHVsZSByZXF1aXJlcyBoaWdobGlnaHQuanMuIFBsZWFzZSBpbmNsdWRlIHRoZSBsaWJyYXJ5IG9uIHRoZSBwYWdlIGJlZm9yZSBRdWlsbC4nKTtcbiAgICB9XG5cbiAgICBfdGhpczMubGFuZ3VhZ2VzID0gX3RoaXMzLm9wdGlvbnMubGFuZ3VhZ2VzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgX3JlZjIpIHtcbiAgICAgIHZhciBrZXkgPSBfcmVmMi5rZXk7XG4gICAgICBtZW1vW2tleV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwge30pO1xuICAgIF90aGlzMy5oaWdobGlnaHRCbG90ID0gX3RoaXMzLmhpZ2hsaWdodEJsb3QuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMykpO1xuXG4gICAgX3RoaXMzLmluaXRMaXN0ZW5lcigpO1xuXG4gICAgX3RoaXMzLmluaXRUaW1lcigpO1xuXG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTeW50YXgsIFt7XG4gICAga2V5OiBcImluaXRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0TGlzdGVuZXIoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdGhpcy5xdWlsbC5vbihfY29yZV9xdWlsbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmV2ZW50cy5TQ1JPTExfQkxPVF9NT1VOVCwgZnVuY3Rpb24gKGJsb3QpIHtcbiAgICAgICAgaWYgKCEoYmxvdCBpbnN0YW5jZW9mIFN5bnRheENvZGVCbG9ja0NvbnRhaW5lcikpIHJldHVybjtcblxuICAgICAgICB2YXIgc2VsZWN0ID0gX3RoaXM0LnF1aWxsLnJvb3Qub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcblxuICAgICAgICBfdGhpczQub3B0aW9ucy5sYW5ndWFnZXMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICB2YXIga2V5ID0gX3JlZjMua2V5LFxuICAgICAgICAgICAgICBsYWJlbCA9IF9yZWYzLmxhYmVsO1xuICAgICAgICAgIHZhciBvcHRpb24gPSBzZWxlY3Qub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgICBvcHRpb24udGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICAgICAgICBvcHRpb24uc2V0QXR0cmlidXRlKCd2YWx1ZScsIGtleSk7XG4gICAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYmxvdC5mb3JtYXQoU3ludGF4Q29kZUJsb2NrLmJsb3ROYW1lLCBzZWxlY3QudmFsdWUpO1xuXG4gICAgICAgICAgX3RoaXM0LnF1aWxsLnJvb3QuZm9jdXMoKTsgLy8gUHJldmVudCBzY3JvbGxpbmdcblxuXG4gICAgICAgICAgX3RoaXM0LmhpZ2hsaWdodChibG90LCB0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGJsb3QudWlOb2RlID09IG51bGwpIHtcbiAgICAgICAgICBibG90LmF0dGFjaFVJKHNlbGVjdCk7XG5cbiAgICAgICAgICBpZiAoYmxvdC5jaGlsZHJlbi5oZWFkKSB7XG4gICAgICAgICAgICBzZWxlY3QudmFsdWUgPSBTeW50YXhDb2RlQmxvY2suZm9ybWF0cyhibG90LmNoaWxkcmVuLmhlYWQuZG9tTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFRpbWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRUaW1lcigpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5xdWlsbC5vbihfY29yZV9xdWlsbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmV2ZW50cy5TQ1JPTExfT1BUSU1JWkUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczUuaGlnaGxpZ2h0KCk7XG5cbiAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIH0sIF90aGlzNS5vcHRpb25zLmludGVydmFsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoaWdobGlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlnaGxpZ2h0KCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHZhciBibG90ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLnF1aWxsLnNlbGVjdGlvbi5jb21wb3NpbmcpIHJldHVybjtcbiAgICAgIHRoaXMucXVpbGwudXBkYXRlKF9jb3JlX3F1aWxsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc291cmNlcy5VU0VSKTtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB2YXIgYmxvdHMgPSBibG90ID09IG51bGwgPyB0aGlzLnF1aWxsLnNjcm9sbC5kZXNjZW5kYW50cyhTeW50YXhDb2RlQmxvY2tDb250YWluZXIpIDogW2Jsb3RdO1xuICAgICAgYmxvdHMuZm9yRWFjaChmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lci5oaWdobGlnaHQoX3RoaXM2LmhpZ2hsaWdodEJsb3QsIGZvcmNlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5xdWlsbC51cGRhdGUoX2NvcmVfcXVpbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zb3VyY2VzLlNJTEVOVCk7XG5cbiAgICAgIGlmIChyYW5nZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucXVpbGwuc2V0U2VsZWN0aW9uKHJhbmdlLCBfY29yZV9xdWlsbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNvdXJjZXMuU0lMRU5UKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGlnaGxpZ2h0QmxvdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWdobGlnaHRCbG90KHRleHQpIHtcbiAgICAgIHZhciBsYW5ndWFnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3BsYWluJztcbiAgICAgIGxhbmd1YWdlID0gdGhpcy5sYW5ndWFnZXNbbGFuZ3VhZ2VdID8gbGFuZ3VhZ2UgOiAncGxhaW4nO1xuXG4gICAgICBpZiAobGFuZ3VhZ2UgPT09ICdwbGFpbicpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdChfYmxvdHNfdGV4dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fWy8qIGVzY2FwZVRleHQgKi8gXCJiXCJdKSh0ZXh0KS5zcGxpdCgnXFxuJykucmVkdWNlKGZ1bmN0aW9uIChkZWx0YSwgbGluZSwgaSkge1xuICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICBkZWx0YS5pbnNlcnQoJ1xcbicsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgX2Zvcm1hdHNfY29kZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fWy8qIGRlZmF1bHQgKi8gXCJjXCJdLmJsb3ROYW1lLCBsYW5ndWFnZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkZWx0YS5pbnNlcnQobGluZSk7XG4gICAgICAgIH0sIG5ldyBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSgpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMucXVpbGwucm9vdC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoX2Zvcm1hdHNfY29kZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fWy8qIGRlZmF1bHQgKi8gXCJjXCJdLmNsYXNzTmFtZSk7XG4gICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLmhsanMuaGlnaGxpZ2h0KGxhbmd1YWdlLCB0ZXh0KS52YWx1ZTtcbiAgICAgIHJldHVybiBPYmplY3QoX2NsaXBib2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiB0cmF2ZXJzZSAqLyBcImRcIl0pKHRoaXMucXVpbGwuc2Nyb2xsLCBjb250YWluZXIsIFtmdW5jdGlvbiAobm9kZSwgZGVsdGEpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gVG9rZW5BdHRyaWJ1dG9yLnZhbHVlKG5vZGUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBkZWx0YS5jb21wb3NlKG5ldyBxdWlsbF9kZWx0YV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSgpLnJldGFpbihkZWx0YS5sZW5ndGgoKSwgX2RlZmluZVByb3BlcnR5KHt9LCBDb2RlVG9rZW4uYmxvdE5hbWUsIHZhbHVlKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlbHRhO1xuICAgICAgfV0sIFtmdW5jdGlvbiAobm9kZSwgZGVsdGEpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuZGF0YS5zcGxpdCgnXFxuJykucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBub2RlVGV4dCwgaSkge1xuICAgICAgICAgIGlmIChpICE9PSAwKSBtZW1vLmluc2VydCgnXFxuJywgX2RlZmluZVByb3BlcnR5KHt9LCBfZm9ybWF0c19jb2RlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bLyogZGVmYXVsdCAqLyBcImNcIl0uYmxvdE5hbWUsIGxhbmd1YWdlKSk7XG4gICAgICAgICAgcmV0dXJuIG1lbW8uaW5zZXJ0KG5vZGVUZXh0KTtcbiAgICAgICAgfSwgZGVsdGEpO1xuICAgICAgfV0sIG5ldyBXZWFrTWFwKCkpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInJlZ2lzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKCkge1xuICAgICAgX2NvcmVfcXVpbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5yZWdpc3RlcihDb2RlVG9rZW4sIHRydWUpO1xuICAgICAgX2NvcmVfcXVpbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5yZWdpc3RlcihTeW50YXhDb2RlQmxvY2ssIHRydWUpO1xuICAgICAgX2NvcmVfcXVpbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5yZWdpc3RlcihTeW50YXhDb2RlQmxvY2tDb250YWluZXIsIHRydWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTeW50YXg7XG59KF9jb3JlX21vZHVsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuU3ludGF4LkRFRkFVTFRTID0ge1xuICBobGpzOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKE9iamVjdChfdXRpbHNfaGFzX3dpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoKSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5obGpzO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9KCksXG4gIGludGVydmFsOiAxMDAwLFxuICBsYW5ndWFnZXM6IFt7XG4gICAga2V5OiAncGxhaW4nLFxuICAgIGxhYmVsOiAnUGxhaW4nXG4gIH0sIHtcbiAgICBrZXk6ICdiYXNoJyxcbiAgICBsYWJlbDogJ0Jhc2gnXG4gIH0sIHtcbiAgICBrZXk6ICdjcHAnLFxuICAgIGxhYmVsOiAnQysrJ1xuICB9LCB7XG4gICAga2V5OiAnY3MnLFxuICAgIGxhYmVsOiAnQyMnXG4gIH0sIHtcbiAgICBrZXk6ICdjc3MnLFxuICAgIGxhYmVsOiAnQ1NTJ1xuICB9LCB7XG4gICAga2V5OiAnZGlmZicsXG4gICAgbGFiZWw6ICdEaWZmJ1xuICB9LCB7XG4gICAga2V5OiAneG1sJyxcbiAgICBsYWJlbDogJ0hUTUwvWE1MJ1xuICB9LCB7XG4gICAga2V5OiAnamF2YScsXG4gICAgbGFiZWw6ICdKYXZhJ1xuICB9LCB7XG4gICAga2V5OiAnamF2YXNjcmlwdCcsXG4gICAgbGFiZWw6ICdKYXZhc2NyaXB0J1xuICB9LCB7XG4gICAga2V5OiAnbWFya2Rvd24nLFxuICAgIGxhYmVsOiAnTWFya2Rvd24nXG4gIH0sIHtcbiAgICBrZXk6ICdwaHAnLFxuICAgIGxhYmVsOiAnUEhQJ1xuICB9LCB7XG4gICAga2V5OiAncHl0aG9uJyxcbiAgICBsYWJlbDogJ1B5dGhvbidcbiAgfSwge1xuICAgIGtleTogJ3J1YnknLFxuICAgIGxhYmVsOiAnUnVieSdcbiAgfSwge1xuICAgIGtleTogJ3NxbCcsXG4gICAgbGFiZWw6ICdTUUwnXG4gIH1dXG59O1xuXG5cbi8qKiovIH0pLFxuLyogNzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlcm9yaW5maW5pdHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gc2FmZVxuICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSAwID8gMCA6IChudW1iZXIgPiAwID8gZmxvb3IgOiBjZWlsKShudW1iZXIpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDc0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG5cbnZhciBTdHJpbmcgPSBnbG9iYWwuU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZihhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nJyk7XG4gIHJldHVybiBTdHJpbmcoYXJndW1lbnQpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMik7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xudmFyIGNsYXNzb2ZSYXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgT2JqZWN0ID0gZ2xvYmFsLk9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2Bcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRPX1NUUklOR19UQUcpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzcpO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG5cblxuLyoqKi8gfSksXG4vKiA3NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbFtrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG52YXIgdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdHJpbmdTbGljZSh0b1N0cmluZyhpdCksIDgsIC0xKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA3OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhGdW5jdGlvbi50b1N0cmluZyk7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZShzdG9yZS5pbnNwZWN0U291cmNlKSkge1xuICBzdG9yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XG5cblxuLyoqKi8gfSksXG4vKiA4MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNik7XG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KTtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG5cblxuLyoqKi8gfSksXG4vKiA4MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Mik7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlKGZ1bmMpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDgyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG52YXIgdHJ5VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMCk7XG5cbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NhbGxhYmxlKGFyZ3VtZW50KSBpcyB0cnVlYFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93IFR5cGVFcnJvcih0cnlUb1N0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogODMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTMpO1xuXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDg0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKi8gfSksXG4vKiA4NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oODApO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXNPd24oTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoIWNhbGwocHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiwgTywgUCksIE9bUF0pO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDg2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG52YXIgc2V0R2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzkpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2KTtcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSA9IF9fd2VicGFja19yZXF1aXJlX18oMTAyKS5DT05GSUdVUkFCTEU7XG5cbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB1bnNhZmUgPSBvcHRpb25zID8gISFvcHRpb25zLnVuc2FmZSA6IGZhbHNlO1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XG4gIHZhciBub1RhcmdldEdldCA9IG9wdGlvbnMgPyAhIW9wdGlvbnMubm9UYXJnZXRHZXQgOiBmYWxzZTtcbiAgdmFyIG5hbWUgPSBvcHRpb25zICYmIG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xuICB2YXIgc3RhdGU7XG4gIGlmIChpc0NhbGxhYmxlKHZhbHVlKSkge1xuICAgIGlmIChTdHJpbmcobmFtZSkuc2xpY2UoMCwgNykgPT09ICdTeW1ib2woJykge1xuICAgICAgbmFtZSA9ICdbJyArIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuICAgIH1cbiAgICBpZiAoIWhhc093bih2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSh2YWx1ZSwgJ25hbWUnLCBuYW1lKTtcbiAgICB9XG4gICAgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gICAgaWYgKCFzdGF0ZS5zb3VyY2UpIHtcbiAgICAgIHN0YXRlLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICAgIH1cbiAgfVxuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBzZXRHbG9iYWwoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCF1bnNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICB9IGVsc2UgaWYgKCFub1RhcmdldEdldCAmJiBPW2tleV0pIHtcbiAgICBzaW1wbGUgPSB0cnVlO1xuICB9XG4gIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICBlbHNlIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPLCBrZXksIHZhbHVlKTtcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUodGhpcykgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSh0aGlzKTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogODcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpO1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA4OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcblxuXG4vKioqLyB9KSxcbi8qIDg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzgpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xudmFyIGh0bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzOSk7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OCk7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Myk7XG5cbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJ1xuICAgID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudFxuICAgICAgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgLy8gb2xkIElFXG4gICAgICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpXG4gICAgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiA5MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEl0ZXJhdG9yXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxMTYpKTtcbnZhciBPcDtcbihmdW5jdGlvbiAoT3ApIHtcbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvcHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcl8xLmRlZmF1bHQob3BzKTtcbiAgICB9XG4gICAgT3AuaXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgICBmdW5jdGlvbiBsZW5ndGgob3ApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcC5kZWxldGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gb3AuZGVsZXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gb3AucmV0YWluO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnID8gb3AuaW5zZXJ0Lmxlbmd0aCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT3AubGVuZ3RoID0gbGVuZ3RoO1xufSkoT3AgfHwgKE9wID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE9wO1xuXG5cbi8qKiovIH0pLFxuLyogOTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICh0cnVlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuXG5cbi8qKiovIH0pLFxuLyogOTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcbnZhciBzdG9yZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMTkuMScsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAyMSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogOTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG52YXIgdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcygxLjAudG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZygrK2lkICsgcG9zdGZpeCwgMzYpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDk0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIFY4X1ZFUlNJT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMyk7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3Rpbmdcbm1vZHVsZS5leHBvcnRzID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiAmJiBWOF9WRVJTSU9OIDwgNDE7XG59KTtcblxuXG4vKioqLyB9KSxcbi8qIDk1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfU1lNQk9MXG4gICYmICFTeW1ib2wuc2hhbVxuICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuXG5cbi8qKiovIH0pLFxuLyogOTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIE5BVElWRV9XRUFLX01BUCA9IF9fd2VicGFja19yZXF1aXJlX18oMTI1KTtcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Myk7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCB8fCBzaGFyZWQuc3RhdGUpIHtcbiAgdmFyIHN0b3JlID0gc2hhcmVkLnN0YXRlIHx8IChzaGFyZWQuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgdmFyIHdtZ2V0ID0gdW5jdXJyeVRoaXMoc3RvcmUuZ2V0KTtcbiAgdmFyIHdtaGFzID0gdW5jdXJyeVRoaXMoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMoc3RvcmUuc2V0KTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmICh3bWhhcyhzdG9yZSwgaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcbiAgaGlkZGVuS2V5c1tTVEFURV0gPSB0cnVlO1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKGhhc093bihpdCwgU1RBVEUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cblxuLyoqKi8gfSksXG4vKiA5NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aWVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcbi8qIDk4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuXG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDk5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xudmFyIGlzUHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcblxudmFyIE9iamVjdCA9IGdsb2JhbC5PYmplY3Q7XG5cbm1vZHVsZS5leHBvcnRzID0gVVNFX1NZTUJPTF9BU19VSUQgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluKCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZigkU3ltYm9sLnByb3RvdHlwZSwgT2JqZWN0KGl0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIFN0cmluZyA9IGdsb2JhbC5TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vKioqLyB9KSxcbi8qIDEwMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyB8fCAoREVTQ1JJUFRPUlMgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG52YXIgaW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTM0KS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0KTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093bihoaWRkZW5LZXlzLCBrZXkpICYmIGhhc093bihPLCBrZXkpICYmIHB1c2gocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXJPckluZmluaXR5KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OSk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOCk7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2KTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gSXRlcmF0b3JQcm90b3R5cGUgPT0gdW5kZWZpbmVkIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgLy8gRkY0NC0gbGVnYWN5IGl0ZXJhdG9ycyBjYXNlXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbn0pO1xuXG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbmVsc2UgaWYgKElTX1BVUkUpIEl0ZXJhdG9yUHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtQEBpdGVyYXRvclxuaWYgKCFpc0NhbGxhYmxlKEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSkpIHtcbiAgcmVkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMyk7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4KTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oODMpO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKTtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIE9iamVjdCA9IGdsb2JhbC5PYmplY3Q7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxubW9kdWxlLmV4cG9ydHMgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXNPd24ob2JqZWN0LCBJRV9QUk9UTykpIHJldHVybiBvYmplY3RbSUVfUFJPVE9dO1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmIChpc0NhbGxhYmxlKGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpLmY7XG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVEFHLCBTVEFUSUMpIHtcbiAgaWYgKGl0ICYmICFoYXNPd24oaXQgPSBTVEFUSUMgPyBpdCA6IGl0LnByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShpdCwgVE9fU1RSSU5HX1RBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcbnZhciBnZXRNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0TWV0aG9kKGl0LCBJVEVSQVRPUilcbiAgICB8fCBnZXRNZXRob2QoaXQsICdAQGl0ZXJhdG9yJylcbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDExMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xuXG5cbi8qKiovIH0pLFxuLyogMTEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUiwgTUVUSE9EKSB7XG4gIHJldHVybiB1bmN1cnJ5VGhpcyhnbG9iYWxbQ09OU1RSVUNUT1JdLnByb3RvdHlwZVtNRVRIT0RdKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ZlYXR1cmVzL2FycmF5L2Zyb20uanNcbnZhciBmcm9tID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTcpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZmVhdHVyZXMvYXJyYXkvZmlsbC5qc1xudmFyIGZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1Myk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mZWF0dXJlcy9vYmplY3QvdmFsdWVzLmpzXG52YXIgdmFsdWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTkpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZmVhdHVyZXMvc3RyaW5nL2VuZHMtd2l0aC5qc1xudmFyIGVuZHNfd2l0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTY0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wb2x5ZmlsbHMuanNcbi8vIElFMTEgc3VwcG9ydFxyXG5cclxuXHJcblxyXG5cclxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29yZS5qc1xudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Zvcm1hdHMvYWxpZ24uanNcbnZhciBhbGlnbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vZm9ybWF0cy9kaXJlY3Rpb24uanNcbnZhciBkaXJlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9wYXJjaG1lbnQvc3JjL3BhcmNobWVudC50cyArIDE3IG1vZHVsZXNcbnZhciBwYXJjaG1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Zvcm1hdHMvaW5kZW50LmpzXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxudmFyIEluZGVudEF0dHJpYnV0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DbGFzc0F0dHJpYnV0b3IpIHtcbiAgX2luaGVyaXRzKEluZGVudEF0dHJpYnV0b3IsIF9DbGFzc0F0dHJpYnV0b3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSW5kZW50QXR0cmlidXRvcik7XG5cbiAgZnVuY3Rpb24gSW5kZW50QXR0cmlidXRvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5kZW50QXR0cmlidXRvcik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW5kZW50QXR0cmlidXRvciwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAnKzEnIHx8IHZhbHVlID09PSAnLTEnKSB7XG4gICAgICAgIHZhciBpbmRlbnQgPSB0aGlzLnZhbHVlKG5vZGUpIHx8IDA7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICcrMScgPyBpbmRlbnQgKyAxIDogaW5kZW50IC0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKG5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKEluZGVudEF0dHJpYnV0b3IucHJvdG90eXBlKSwgXCJhZGRcIiwgdGhpcykuY2FsbCh0aGlzLCBub2RlLCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbkFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5BZGQobm9kZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihJbmRlbnRBdHRyaWJ1dG9yLnByb3RvdHlwZSksIFwiY2FuQWRkXCIsIHRoaXMpLmNhbGwodGhpcywgbm9kZSwgdmFsdWUpIHx8IF9nZXQoX2dldFByb3RvdHlwZU9mKEluZGVudEF0dHJpYnV0b3IucHJvdG90eXBlKSwgXCJjYW5BZGRcIiwgdGhpcykuY2FsbCh0aGlzLCBub2RlLCBwYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobm9kZSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KF9nZXQoX2dldFByb3RvdHlwZU9mKEluZGVudEF0dHJpYnV0b3IucHJvdG90eXBlKSwgXCJ2YWx1ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIG5vZGUpLCAxMCkgfHwgdW5kZWZpbmVkOyAvLyBEb24ndCByZXR1cm4gTmFOXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEluZGVudEF0dHJpYnV0b3I7XG59KHBhcmNobWVudFtcIkNsYXNzQXR0cmlidXRvclwiXSk7XG5cbnZhciBJbmRlbnRDbGFzcyA9IG5ldyBJbmRlbnRBdHRyaWJ1dG9yKCdpbmRlbnQnLCAncWwtaW5kZW50Jywge1xuICBzY29wZTogcGFyY2htZW50W1wiU2NvcGVcIl0uQkxPQ0ssXG4gIHdoaXRlbGlzdDogWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdXG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGluZGVudCA9IChJbmRlbnRDbGFzcyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYmxvdHMvYmxvY2suanNcbnZhciBibG9jayA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vZm9ybWF0cy9ibG9ja3F1b3RlLmpzXG5mdW5jdGlvbiBibG9ja3F1b3RlX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgYmxvY2txdW90ZV90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgYmxvY2txdW90ZV90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gYmxvY2txdW90ZV90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBibG9ja3F1b3RlX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gYmxvY2txdW90ZV9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBibG9ja3F1b3RlX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBibG9ja3F1b3RlX3NldFByb3RvdHlwZU9mKG8sIHApIHsgYmxvY2txdW90ZV9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gYmxvY2txdW90ZV9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBibG9ja3F1b3RlX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBibG9ja3F1b3RlX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IGJsb2NrcXVvdGVfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGJsb2NrcXVvdGVfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIGJsb2NrcXVvdGVfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIGJsb2NrcXVvdGVfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChibG9ja3F1b3RlX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBibG9ja3F1b3RlX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBibG9ja3F1b3RlX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIGJsb2NrcXVvdGVfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gYmxvY2txdW90ZV9nZXRQcm90b3R5cGVPZihvKSB7IGJsb2NrcXVvdGVfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gYmxvY2txdW90ZV9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxudmFyIEJsb2NrcXVvdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CbG9jaykge1xuICBibG9ja3F1b3RlX2luaGVyaXRzKEJsb2NrcXVvdGUsIF9CbG9jayk7XG5cbiAgdmFyIF9zdXBlciA9IGJsb2NrcXVvdGVfY3JlYXRlU3VwZXIoQmxvY2txdW90ZSk7XG5cbiAgZnVuY3Rpb24gQmxvY2txdW90ZSgpIHtcbiAgICBibG9ja3F1b3RlX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJsb2NrcXVvdGUpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIEJsb2NrcXVvdGU7XG59KGJsb2NrW1wiZFwiIC8qIGRlZmF1bHQgKi9dKTtcblxuQmxvY2txdW90ZS5ibG90TmFtZSA9ICdibG9ja3F1b3RlJztcbkJsb2NrcXVvdGUudGFnTmFtZSA9ICdibG9ja3F1b3RlJztcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJsb2NrcXVvdGUgPSAoQmxvY2txdW90ZSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Zvcm1hdHMvaGVhZGVyLmpzXG5mdW5jdGlvbiBoZWFkZXJfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBoZWFkZXJfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IGhlYWRlcl90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gaGVhZGVyX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGhlYWRlcl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGhlYWRlcl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gaGVhZGVyX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgaGVhZGVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBoZWFkZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gaGVhZGVyX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIGhlYWRlcl9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gaGVhZGVyX3NldFByb3RvdHlwZU9mKG8sIHApIHsgaGVhZGVyX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBoZWFkZXJfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gaGVhZGVyX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBoZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gaGVhZGVyX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBoZWFkZXJfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIGhlYWRlcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gaGVhZGVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoaGVhZGVyX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBoZWFkZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIGhlYWRlcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBoZWFkZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gaGVhZGVyX2dldFByb3RvdHlwZU9mKG8pIHsgaGVhZGVyX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIGhlYWRlcl9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxudmFyIEhlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jsb2NrKSB7XG4gIGhlYWRlcl9pbmhlcml0cyhIZWFkZXIsIF9CbG9jayk7XG5cbiAgdmFyIF9zdXBlciA9IGhlYWRlcl9jcmVhdGVTdXBlcihIZWFkZXIpO1xuXG4gIGZ1bmN0aW9uIEhlYWRlcigpIHtcbiAgICBoZWFkZXJfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGVhZGVyKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGhlYWRlcl9jcmVhdGVDbGFzcyhIZWFkZXIsIG51bGwsIFt7XG4gICAga2V5OiBcImZvcm1hdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cyhkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWdOYW1lLmluZGV4T2YoZG9tTm9kZS50YWdOYW1lKSArIDE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhlYWRlcjtcbn0oYmxvY2tbXCJkXCIgLyogZGVmYXVsdCAqL10pO1xuXG5IZWFkZXIuYmxvdE5hbWUgPSAnaGVhZGVyJztcbkhlYWRlci50YWdOYW1lID0gWydIMScsICdIMicsICdIMycsICdINCcsICdINScsICdINiddO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaGVhZGVyID0gKEhlYWRlcik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYmxvdHMvY29udGFpbmVyLmpzXG52YXIgY29udGFpbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb3JlL3F1aWxsLmpzXG52YXIgY29yZV9xdWlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vZm9ybWF0cy9saXN0LmpzXG5mdW5jdGlvbiBsaXN0X3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgbGlzdF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgbGlzdF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gbGlzdF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBsaXN0X2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBsaXN0X2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgbGlzdF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgbGlzdF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBsaXN0X2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgbGlzdF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgbGlzdF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gbGlzdF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gbGlzdF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBsaXN0X3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBsaXN0X2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gbGlzdF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGxpc3RfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgbGlzdF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gbGlzdF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IGxpc3Rfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIGxpc3Rfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gbGlzdF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gbGlzdF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBsaXN0X2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBsaXN0X2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBsaXN0X3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBsaXN0X3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAobGlzdF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gbGlzdF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gbGlzdF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBsaXN0X2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIGxpc3RfZ2V0UHJvdG90eXBlT2YobykgeyBsaXN0X2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIGxpc3RfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cblxuXG52YXIgTGlzdENvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbnRhaW5lcikge1xuICBsaXN0X2luaGVyaXRzKExpc3RDb250YWluZXIsIF9Db250YWluZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBsaXN0X2NyZWF0ZVN1cGVyKExpc3RDb250YWluZXIpO1xuXG4gIGZ1bmN0aW9uIExpc3RDb250YWluZXIoKSB7XG4gICAgbGlzdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaXN0Q29udGFpbmVyKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBMaXN0Q29udGFpbmVyO1xufShjb250YWluZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5MaXN0Q29udGFpbmVyLmJsb3ROYW1lID0gJ2xpc3QtY29udGFpbmVyJztcbkxpc3RDb250YWluZXIudGFnTmFtZSA9ICdPTCc7XG5cbnZhciBsaXN0X0xpc3RJdGVtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmxvY2spIHtcbiAgbGlzdF9pbmhlcml0cyhMaXN0SXRlbSwgX0Jsb2NrKTtcblxuICB2YXIgX3N1cGVyMiA9IGxpc3RfY3JlYXRlU3VwZXIoTGlzdEl0ZW0pO1xuXG4gIGZ1bmN0aW9uIExpc3RJdGVtKHNjcm9sbCwgZG9tTm9kZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGxpc3RfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGlzdEl0ZW0pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIyLmNhbGwodGhpcywgc2Nyb2xsLCBkb21Ob2RlKTtcbiAgICB2YXIgdWkgPSBkb21Ob2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG4gICAgdmFyIGxpc3RFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiBsaXN0RXZlbnRIYW5kbGVyKGUpIHtcbiAgICAgIGlmICghc2Nyb2xsLmlzRW5hYmxlZCgpKSByZXR1cm47XG5cbiAgICAgIHZhciBmb3JtYXQgPSBfdGhpcy5zdGF0aWNzLmZvcm1hdHMoZG9tTm9kZSwgc2Nyb2xsKTtcblxuICAgICAgaWYgKGZvcm1hdCA9PT0gJ2NoZWNrZWQnKSB7XG4gICAgICAgIF90aGlzLmZvcm1hdCgnbGlzdCcsICd1bmNoZWNrZWQnKTtcblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ3VuY2hlY2tlZCcpIHtcbiAgICAgICAgX3RoaXMuZm9ybWF0KCdsaXN0JywgJ2NoZWNrZWQnKTtcblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHVpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGxpc3RFdmVudEhhbmRsZXIpO1xuICAgIHVpLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBsaXN0RXZlbnRIYW5kbGVyKTtcblxuICAgIF90aGlzLmF0dGFjaFVJKHVpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIGxpc3RfY3JlYXRlQ2xhc3MoTGlzdEl0ZW0sIFt7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChuYW1lID09PSB0aGlzLnN0YXRpY3MuYmxvdE5hbWUgJiYgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kb21Ob2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1saXN0JywgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdF9nZXQobGlzdF9nZXRQcm90b3R5cGVPZihMaXN0SXRlbS5wcm90b3R5cGUpLCBcImZvcm1hdFwiLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZSA9IGxpc3RfZ2V0KGxpc3RfZ2V0UHJvdG90eXBlT2YoTGlzdEl0ZW0pLCBcImNyZWF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1saXN0JywgdmFsdWUpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0cyhkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGlzdCcpIHx8IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XG4gICAgICBjb3JlX3F1aWxsW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnJlZ2lzdGVyKExpc3RDb250YWluZXIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaXN0SXRlbTtcbn0oYmxvY2tbXCJkXCIgLyogZGVmYXVsdCAqL10pO1xuXG5saXN0X0xpc3RJdGVtLmJsb3ROYW1lID0gJ2xpc3QnO1xubGlzdF9MaXN0SXRlbS50YWdOYW1lID0gJ0xJJztcbkxpc3RDb250YWluZXIuYWxsb3dlZENoaWxkcmVuID0gW2xpc3RfTGlzdEl0ZW1dO1xubGlzdF9MaXN0SXRlbS5yZXF1aXJlZENvbnRhaW5lciA9IExpc3RDb250YWluZXI7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9mb3JtYXRzL2JhY2tncm91bmQuanNcbnZhciBiYWNrZ3JvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9mb3JtYXRzL2NvbG9yLmpzXG52YXIgY29sb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Zvcm1hdHMvZm9udC5qc1xudmFyIGZvbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Zvcm1hdHMvc2l6ZS5qc1xudmFyIHNpemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Zvcm1hdHMvYm9sZC5qc1xudmFyIGJvbGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9mb3JtYXRzL2l0YWxpYy5qc1xuZnVuY3Rpb24gaXRhbGljX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgaXRhbGljX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBpdGFsaWNfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIGl0YWxpY190eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBpdGFsaWNfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBpdGFsaWNfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgaXRhbGljX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBpdGFsaWNfc2V0UHJvdG90eXBlT2YobywgcCkgeyBpdGFsaWNfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIGl0YWxpY19zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBpdGFsaWNfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGl0YWxpY19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBpdGFsaWNfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGl0YWxpY19nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gaXRhbGljX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBpdGFsaWNfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChpdGFsaWNfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIGl0YWxpY19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gaXRhbGljX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIGl0YWxpY19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBpdGFsaWNfZ2V0UHJvdG90eXBlT2YobykgeyBpdGFsaWNfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gaXRhbGljX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG52YXIgSXRhbGljID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQm9sZCkge1xuICBpdGFsaWNfaW5oZXJpdHMoSXRhbGljLCBfQm9sZCk7XG5cbiAgdmFyIF9zdXBlciA9IGl0YWxpY19jcmVhdGVTdXBlcihJdGFsaWMpO1xuXG4gIGZ1bmN0aW9uIEl0YWxpYygpIHtcbiAgICBpdGFsaWNfY2xhc3NDYWxsQ2hlY2sodGhpcywgSXRhbGljKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBJdGFsaWM7XG59KGJvbGRbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5JdGFsaWMuYmxvdE5hbWUgPSAnaXRhbGljJztcbkl0YWxpYy50YWdOYW1lID0gWydFTScsICdJJ107XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpdGFsaWMgPSAoSXRhbGljKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9mb3JtYXRzL2xpbmsuanNcbnZhciBmb3JtYXRzX2xpbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jsb3RzL2lubGluZS5qc1xudmFyIGlubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Zvcm1hdHMvc2NyaXB0LmpzXG5mdW5jdGlvbiBzY3JpcHRfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBzY3JpcHRfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IHNjcmlwdF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gc2NyaXB0X3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHNjcmlwdF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIHNjcmlwdF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gc2NyaXB0X2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgc2NyaXB0X2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBzY3JpcHRfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gc2NyaXB0X2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgc2NyaXB0X2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBzY3JpcHRfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IHNjcmlwdF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gc2NyaXB0X2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIHNjcmlwdF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gc2NyaXB0X2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gc2NyaXB0X2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHNjcmlwdF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gc2NyaXB0X3NldFByb3RvdHlwZU9mKG8sIHApIHsgc2NyaXB0X3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBzY3JpcHRfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gc2NyaXB0X2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBzY3JpcHRfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gc2NyaXB0X2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBzY3JpcHRfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHNjcmlwdF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gc2NyaXB0X3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoc2NyaXB0X3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBzY3JpcHRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIHNjcmlwdF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBzY3JpcHRfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gc2NyaXB0X2dldFByb3RvdHlwZU9mKG8pIHsgc2NyaXB0X2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHNjcmlwdF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxudmFyIFNjcmlwdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lubGluZSkge1xuICBzY3JpcHRfaW5oZXJpdHMoU2NyaXB0LCBfSW5saW5lKTtcblxuICB2YXIgX3N1cGVyID0gc2NyaXB0X2NyZWF0ZVN1cGVyKFNjcmlwdCk7XG5cbiAgZnVuY3Rpb24gU2NyaXB0KCkge1xuICAgIHNjcmlwdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY3JpcHQpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgc2NyaXB0X2NyZWF0ZUNsYXNzKFNjcmlwdCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAnc3VwZXInKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdXAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSAnc3ViJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3ViJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzY3JpcHRfZ2V0KHNjcmlwdF9nZXRQcm90b3R5cGVPZihTY3JpcHQpLCBcImNyZWF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXRzKGRvbU5vZGUpIHtcbiAgICAgIGlmIChkb21Ob2RlLnRhZ05hbWUgPT09ICdTVUInKSByZXR1cm4gJ3N1Yic7XG4gICAgICBpZiAoZG9tTm9kZS50YWdOYW1lID09PSAnU1VQJykgcmV0dXJuICdzdXBlcic7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY3JpcHQ7XG59KGlubGluZVtcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cblNjcmlwdC5ibG90TmFtZSA9ICdzY3JpcHQnO1xuU2NyaXB0LnRhZ05hbWUgPSBbJ1NVQicsICdTVVAnXTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNjcmlwdCA9IChTY3JpcHQpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9mb3JtYXRzL3N0cmlrZS5qc1xuZnVuY3Rpb24gc3RyaWtlX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgc3RyaWtlX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBzdHJpa2VfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIHN0cmlrZV90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBzdHJpa2VfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBzdHJpa2VfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgc3RyaWtlX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBzdHJpa2Vfc2V0UHJvdG90eXBlT2YobywgcCkgeyBzdHJpa2Vfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHN0cmlrZV9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBzdHJpa2VfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHN0cmlrZV9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBzdHJpa2VfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IHN0cmlrZV9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gc3RyaWtlX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBzdHJpa2VfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChzdHJpa2VfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHN0cmlrZV9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gc3RyaWtlX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIHN0cmlrZV9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBzdHJpa2VfZ2V0UHJvdG90eXBlT2YobykgeyBzdHJpa2VfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gc3RyaWtlX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG52YXIgU3RyaWtlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQm9sZCkge1xuICBzdHJpa2VfaW5oZXJpdHMoU3RyaWtlLCBfQm9sZCk7XG5cbiAgdmFyIF9zdXBlciA9IHN0cmlrZV9jcmVhdGVTdXBlcihTdHJpa2UpO1xuXG4gIGZ1bmN0aW9uIFN0cmlrZSgpIHtcbiAgICBzdHJpa2VfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyaWtlKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBTdHJpa2U7XG59KGJvbGRbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5TdHJpa2UuYmxvdE5hbWUgPSAnc3RyaWtlJztcblN0cmlrZS50YWdOYW1lID0gWydTJywgJ1NUUklLRSddO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3RyaWtlID0gKFN0cmlrZSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Zvcm1hdHMvdW5kZXJsaW5lLmpzXG5mdW5jdGlvbiB1bmRlcmxpbmVfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyB1bmRlcmxpbmVfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IHVuZGVybGluZV90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gdW5kZXJsaW5lX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHVuZGVybGluZV9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIHVuZGVybGluZV9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSB1bmRlcmxpbmVfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIHVuZGVybGluZV9zZXRQcm90b3R5cGVPZihvLCBwKSB7IHVuZGVybGluZV9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gdW5kZXJsaW5lX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIHVuZGVybGluZV9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gdW5kZXJsaW5lX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IHVuZGVybGluZV9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gdW5kZXJsaW5lX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiB1bmRlcmxpbmVfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIHVuZGVybGluZV9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHVuZGVybGluZV90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gdW5kZXJsaW5lX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiB1bmRlcmxpbmVfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gdW5kZXJsaW5lX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIHVuZGVybGluZV9nZXRQcm90b3R5cGVPZihvKSB7IHVuZGVybGluZV9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiB1bmRlcmxpbmVfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cbnZhciBVbmRlcmxpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbmxpbmUpIHtcbiAgdW5kZXJsaW5lX2luaGVyaXRzKFVuZGVybGluZSwgX0lubGluZSk7XG5cbiAgdmFyIF9zdXBlciA9IHVuZGVybGluZV9jcmVhdGVTdXBlcihVbmRlcmxpbmUpO1xuXG4gIGZ1bmN0aW9uIFVuZGVybGluZSgpIHtcbiAgICB1bmRlcmxpbmVfY2xhc3NDYWxsQ2hlY2sodGhpcywgVW5kZXJsaW5lKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBVbmRlcmxpbmU7XG59KGlubGluZVtcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cblVuZGVybGluZS5ibG90TmFtZSA9ICd1bmRlcmxpbmUnO1xuVW5kZXJsaW5lLnRhZ05hbWUgPSAnVSc7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1bmRlcmxpbmUgPSAoVW5kZXJsaW5lKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ibG90cy9lbWJlZC5qc1xudmFyIGJsb3RzX2VtYmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi91dGlscy9oYXNfd2luZG93LmpzXG52YXIgaGFzX3dpbmRvdyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Zvcm1hdHMvZm9ybXVsYS5qc1xuZnVuY3Rpb24gZm9ybXVsYV90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IGZvcm11bGFfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IGZvcm11bGFfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIGZvcm11bGFfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gZm9ybXVsYV9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGZvcm11bGFfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGZvcm11bGFfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBmb3JtdWxhX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBmb3JtdWxhX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIGZvcm11bGFfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBmb3JtdWxhX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBmb3JtdWxhX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBmb3JtdWxhX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBmb3JtdWxhX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIGZvcm11bGFfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IGZvcm11bGFfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBmb3JtdWxhX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIGZvcm11bGFfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGZvcm11bGFfc2V0UHJvdG90eXBlT2YobywgcCkgeyBmb3JtdWxhX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBmb3JtdWxhX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIGZvcm11bGFfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZvcm11bGFfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gZm9ybXVsYV9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gZm9ybXVsYV9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gZm9ybXVsYV9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gZm9ybXVsYV9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGZvcm11bGFfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIGZvcm11bGFfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIGZvcm11bGFfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gZm9ybXVsYV9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBmb3JtdWxhX2dldFByb3RvdHlwZU9mKG8pIHsgZm9ybXVsYV9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBmb3JtdWxhX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG5cbnZhciBmb3JtdWxhX0Zvcm11bGEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbWJlZCkge1xuICBmb3JtdWxhX2luaGVyaXRzKEZvcm11bGEsIF9FbWJlZCk7XG5cbiAgdmFyIF9zdXBlciA9IGZvcm11bGFfY3JlYXRlU3VwZXIoRm9ybXVsYSk7XG5cbiAgZnVuY3Rpb24gRm9ybXVsYSgpIHtcbiAgICBmb3JtdWxhX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm11bGEpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZm9ybXVsYV9jcmVhdGVDbGFzcyhGb3JtdWxhLCBbe1xuICAgIGtleTogXCJodG1sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGh0bWwoKSB7XG4gICAgICB2YXIgX3RoaXMkdmFsdWUgPSB0aGlzLnZhbHVlKCksXG4gICAgICAgICAgZm9ybXVsYSA9IF90aGlzJHZhbHVlLmZvcm11bGE7XG5cbiAgICAgIHJldHVybiBcIjxzcGFuPlwiLmNvbmNhdChmb3JtdWxhLCBcIjwvc3Bhbj5cIik7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgdmFyIGthdGV4ID0gbnVsbDtcblxuICAgICAgaWYgKE9iamVjdChoYXNfd2luZG93W1wiYVwiIC8qIGRlZmF1bHQgKi9dKSgpKSB7XG4gICAgICAgIGthdGV4ID0gd2luZG93LmthdGV4O1xuICAgICAgfVxuXG4gICAgICBpZiAoa2F0ZXggPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm11bGEgbW9kdWxlIHJlcXVpcmVzIEthVGVYLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IGZvcm11bGFfZ2V0KGZvcm11bGFfZ2V0UHJvdG90eXBlT2YoRm9ybXVsYSksIFwiY3JlYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBrYXRleC5yZW5kZXIodmFsdWUsIG5vZGUsIHtcbiAgICAgICAgICB0aHJvd09uRXJyb3I6IGZhbHNlLFxuICAgICAgICAgIGVycm9yQ29sb3I6ICcjZjAwJ1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9ybXVsYTtcbn0oYmxvdHNfZW1iZWRbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5mb3JtdWxhX0Zvcm11bGEuYmxvdE5hbWUgPSAnZm9ybXVsYSc7XG5mb3JtdWxhX0Zvcm11bGEuY2xhc3NOYW1lID0gJ3FsLWZvcm11bGEnO1xuZm9ybXVsYV9Gb3JtdWxhLnRhZ05hbWUgPSAnU1BBTic7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmb3JtdWxhID0gKGZvcm11bGFfRm9ybXVsYSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Zvcm1hdHMvaW1hZ2UuanNcbmZ1bmN0aW9uIGltYWdlX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgaW1hZ2VfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IGltYWdlX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBpbWFnZV90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBpbWFnZV9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIGltYWdlX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBpbWFnZV9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGltYWdlX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBpbWFnZV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBpbWFnZV9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IGltYWdlX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBpbWFnZV9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gaW1hZ2Vfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIGltYWdlX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIGltYWdlX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBpbWFnZV9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIGltYWdlX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIGltYWdlX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBpbWFnZV9zZXRQcm90b3R5cGVPZihvLCBwKSB7IGltYWdlX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBpbWFnZV9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBpbWFnZV9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gaW1hZ2VfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gaW1hZ2VfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGltYWdlX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBpbWFnZV9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gaW1hZ2VfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChpbWFnZV90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gaW1hZ2VfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIGltYWdlX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIGltYWdlX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIGltYWdlX2dldFByb3RvdHlwZU9mKG8pIHsgaW1hZ2VfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gaW1hZ2VfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuXG5cblxudmFyIEFUVFJJQlVURVMgPSBbJ2FsdCcsICdoZWlnaHQnLCAnd2lkdGgnXTtcblxudmFyIGltYWdlX0ltYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRW1iZWRCbG90KSB7XG4gIGltYWdlX2luaGVyaXRzKEltYWdlLCBfRW1iZWRCbG90KTtcblxuICB2YXIgX3N1cGVyID0gaW1hZ2VfY3JlYXRlU3VwZXIoSW1hZ2UpO1xuXG4gIGZ1bmN0aW9uIEltYWdlKCkge1xuICAgIGltYWdlX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGltYWdlX2NyZWF0ZUNsYXNzKEltYWdlLCBbe1xuICAgIGtleTogXCJmb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAoQVRUUklCVVRFUy5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5kb21Ob2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1hZ2VfZ2V0KGltYWdlX2dldFByb3RvdHlwZU9mKEltYWdlLnByb3RvdHlwZSksIFwiZm9ybWF0XCIsIHRoaXMpLmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgIHZhciBub2RlID0gaW1hZ2VfZ2V0KGltYWdlX2dldFByb3RvdHlwZU9mKEltYWdlKSwgXCJjcmVhdGVcIiwgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzcmMnLCB0aGlzLnNhbml0aXplKHZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIEFUVFJJQlVURVMucmVkdWNlKGZ1bmN0aW9uIChmb3JtYXRzLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGRvbU5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICBmb3JtYXRzW2F0dHJpYnV0ZV0gPSBkb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoKHVybCkge1xuICAgICAgcmV0dXJuIC9cXC4oanBlP2d8Z2lmfHBuZykkLy50ZXN0KHVybCkgfHwgL15kYXRhOmltYWdlXFwvLis7YmFzZTY0Ly50ZXN0KHVybCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZ2lzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKCkge1xuICAgICAgaWYgKE9iamVjdChoYXNfd2luZG93W1wiYVwiIC8qIGRlZmF1bHQgKi9dKSgpICYmIC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBEaXNhYmxlIGltYWdlIHJlc2l6aW5nIGluIEZpcmVmb3hcbiAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnZW5hYmxlT2JqZWN0UmVzaXppbmcnLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB9LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2FuaXRpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FuaXRpemUodXJsKSB7XG4gICAgICByZXR1cm4gT2JqZWN0KGZvcm1hdHNfbGlua1tcImJcIiAvKiBzYW5pdGl6ZSAqL10pKHVybCwgWydodHRwJywgJ2h0dHBzJywgJ2RhdGEnXSkgPyB1cmwgOiAnLy86MCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEltYWdlO1xufShwYXJjaG1lbnRbXCJFbWJlZEJsb3RcIl0pO1xuXG5pbWFnZV9JbWFnZS5ibG90TmFtZSA9ICdpbWFnZSc7XG5pbWFnZV9JbWFnZS50YWdOYW1lID0gJ0lNRyc7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmb3JtYXRzX2ltYWdlID0gKGltYWdlX0ltYWdlKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vZm9ybWF0cy92aWRlby5qc1xuZnVuY3Rpb24gdmlkZW9fdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyB2aWRlb190eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgdmlkZW9fdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIHZpZGVvX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHZpZGVvX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gdmlkZW9fZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIHZpZGVvX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgdmlkZW9fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHZpZGVvX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIHZpZGVvX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgdmlkZW9fZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IHZpZGVvX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSB2aWRlb19zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gdmlkZW9fZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gdmlkZW9fc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IHZpZGVvX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gdmlkZW9faW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgdmlkZW9fc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIHZpZGVvX3NldFByb3RvdHlwZU9mKG8sIHApIHsgdmlkZW9fc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHZpZGVvX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIHZpZGVvX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSB2aWRlb19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSB2aWRlb19nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gdmlkZW9fZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIHZpZGVvX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiB2aWRlb19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHZpZGVvX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiB2aWRlb19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gdmlkZW9fYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gdmlkZW9faXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gdmlkZW9fZ2V0UHJvdG90eXBlT2YobykgeyB2aWRlb19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiB2aWRlb19nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5cblxudmFyIHZpZGVvX0FUVFJJQlVURVMgPSBbJ2hlaWdodCcsICd3aWR0aCddO1xuXG52YXIgdmlkZW9fVmlkZW8gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CbG9ja0VtYmVkKSB7XG4gIHZpZGVvX2luaGVyaXRzKFZpZGVvLCBfQmxvY2tFbWJlZCk7XG5cbiAgdmFyIF9zdXBlciA9IHZpZGVvX2NyZWF0ZVN1cGVyKFZpZGVvKTtcblxuICBmdW5jdGlvbiBWaWRlbygpIHtcbiAgICB2aWRlb19jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWRlbyk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICB2aWRlb19jcmVhdGVDbGFzcyhWaWRlbywgW3tcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKHZpZGVvX0FUVFJJQlVURVMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuZG9tTm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZG9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZGVvX2dldCh2aWRlb19nZXRQcm90b3R5cGVPZihWaWRlby5wcm90b3R5cGUpLCBcImZvcm1hdFwiLCB0aGlzKS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaHRtbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBodG1sKCkge1xuICAgICAgdmFyIF90aGlzJHZhbHVlID0gdGhpcy52YWx1ZSgpLFxuICAgICAgICAgIHZpZGVvID0gX3RoaXMkdmFsdWUudmlkZW87XG5cbiAgICAgIHJldHVybiBcIjxhIGhyZWY9XFxcIlwiLmNvbmNhdCh2aWRlbywgXCJcXFwiPlwiKS5jb25jYXQodmlkZW8sIFwiPC9hPlwiKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZSA9IHZpZGVvX2dldCh2aWRlb19nZXRQcm90b3R5cGVPZihWaWRlbyksIFwiY3JlYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZnJhbWVib3JkZXInLCAnMCcpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2FsbG93ZnVsbHNjcmVlbicsIHRydWUpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHRoaXMuc2FuaXRpemUodmFsdWUpKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdHMoZG9tTm9kZSkge1xuICAgICAgcmV0dXJuIHZpZGVvX0FUVFJJQlVURVMucmVkdWNlKGZ1bmN0aW9uIChmb3JtYXRzLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGRvbU5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICBmb3JtYXRzW2F0dHJpYnV0ZV0gPSBkb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhbml0aXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhbml0aXplKHVybCkge1xuICAgICAgcmV0dXJuIGZvcm1hdHNfbGlua1tcImFcIiAvKiBkZWZhdWx0ICovXS5zYW5pdGl6ZSh1cmwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1uYW1lZC1hcy1kZWZhdWx0LW1lbWJlclxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWaWRlbztcbn0oYmxvY2tbXCJhXCIgLyogQmxvY2tFbWJlZCAqL10pO1xuXG52aWRlb19WaWRlby5ibG90TmFtZSA9ICd2aWRlbyc7XG52aWRlb19WaWRlby5jbGFzc05hbWUgPSAncWwtdmlkZW8nO1xudmlkZW9fVmlkZW8udGFnTmFtZSA9ICdJRlJBTUUnO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdmlkZW8gPSAodmlkZW9fVmlkZW8pO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Zvcm1hdHMvY29kZS5qc1xudmFyIGNvZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL21vZHVsZXMvc3ludGF4LmpzXG52YXIgc3ludGF4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9tb2R1bGVzL3RhYmxlL2luZGV4LmpzICsgMSBtb2R1bGVzXG52YXIgdGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9xdWlsbC1kZWx0YS9kaXN0L0RlbHRhLmpzXG52YXIgRGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIERlbHRhX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKERlbHRhKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ibG90cy9tdWx0aWxpbmVfYnJlYWsuanNcbmZ1bmN0aW9uIG11bHRpbGluZV9icmVha190eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IG11bHRpbGluZV9icmVha190eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgbXVsdGlsaW5lX2JyZWFrX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBtdWx0aWxpbmVfYnJlYWtfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gbXVsdGlsaW5lX2JyZWFrX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gbXVsdGlsaW5lX2JyZWFrX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBtdWx0aWxpbmVfYnJlYWtfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBtdWx0aWxpbmVfYnJlYWtfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIG11bHRpbGluZV9icmVha19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBtdWx0aWxpbmVfYnJlYWtfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgbXVsdGlsaW5lX2JyZWFrX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBtdWx0aWxpbmVfYnJlYWtfc2V0UHJvdG90eXBlT2YobywgcCkgeyBtdWx0aWxpbmVfYnJlYWtfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIG11bHRpbGluZV9icmVha19zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBtdWx0aWxpbmVfYnJlYWtfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IG11bHRpbGluZV9icmVha19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBtdWx0aWxpbmVfYnJlYWtfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IG11bHRpbGluZV9icmVha19nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gbXVsdGlsaW5lX2JyZWFrX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBtdWx0aWxpbmVfYnJlYWtfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChtdWx0aWxpbmVfYnJlYWtfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIG11bHRpbGluZV9icmVha19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gbXVsdGlsaW5lX2JyZWFrX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIG11bHRpbGluZV9icmVha19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBtdWx0aWxpbmVfYnJlYWtfZ2V0UHJvdG90eXBlT2YobykgeyBtdWx0aWxpbmVfYnJlYWtfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gbXVsdGlsaW5lX2JyZWFrX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG52YXIgTXVsdGlsaW5lQnJlYWsgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbWJlZEJsb3QpIHtcbiAgbXVsdGlsaW5lX2JyZWFrX2luaGVyaXRzKE11bHRpbGluZUJyZWFrLCBfRW1iZWRCbG90KTtcblxuICB2YXIgX3N1cGVyID0gbXVsdGlsaW5lX2JyZWFrX2NyZWF0ZVN1cGVyKE11bHRpbGluZUJyZWFrKTtcblxuICBmdW5jdGlvbiBNdWx0aWxpbmVCcmVhaygpIHtcbiAgICBtdWx0aWxpbmVfYnJlYWtfY2xhc3NDYWxsQ2hlY2sodGhpcywgTXVsdGlsaW5lQnJlYWspO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgbXVsdGlsaW5lX2JyZWFrX2NyZWF0ZUNsYXNzKE11bHRpbGluZUJyZWFrLCBbe1xuICAgIGtleTogXCJsZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuICdcXG4nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcHRpbWl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpbWl6ZSgpIHtcbiAgICAgIGlmICghdGhpcy5wcmV2ICYmICF0aGlzLm5leHQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiAnXFxuJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTXVsdGlsaW5lQnJlYWs7XG59KHBhcmNobWVudFtcIkVtYmVkQmxvdFwiXSk7XG5cbk11bHRpbGluZUJyZWFrLmJsb3ROYW1lID0gJ211bHRpbGluZUJyZWFrJztcbk11bHRpbGluZUJyZWFrLnRhZ05hbWUgPSAnQlInO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbXVsdGlsaW5lX2JyZWFrID0gKE11bHRpbGluZUJyZWFrKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb3JlL21vZHVsZS5qc1xudmFyIGNvcmVfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbW9kdWxlcy9tdWx0aWxpbmUuanNcbmZ1bmN0aW9uIG11bHRpbGluZV90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IG11bHRpbGluZV90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgbXVsdGlsaW5lX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBtdWx0aWxpbmVfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gbXVsdGlsaW5lX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gbXVsdGlsaW5lX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBtdWx0aWxpbmVfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBtdWx0aWxpbmVfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIG11bHRpbGluZV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBtdWx0aWxpbmVfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgbXVsdGlsaW5lX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBtdWx0aWxpbmVfc2V0UHJvdG90eXBlT2YobywgcCkgeyBtdWx0aWxpbmVfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIG11bHRpbGluZV9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBtdWx0aWxpbmVfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IG11bHRpbGluZV9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBtdWx0aWxpbmVfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IG11bHRpbGluZV9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gbXVsdGlsaW5lX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBtdWx0aWxpbmVfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChtdWx0aWxpbmVfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIG11bHRpbGluZV9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gbXVsdGlsaW5lX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIG11bHRpbGluZV9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBtdWx0aWxpbmVfZ2V0UHJvdG90eXBlT2YobykgeyBtdWx0aWxpbmVfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gbXVsdGlsaW5lX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG5cblxuXG5mdW5jdGlvbiBicmVha01hdGNoZXIobm9kZSkge1xuICBpZiAoIW5vZGUubmV4dFNpYmxpbmcgJiYgIW5vZGUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBEZWx0YV9kZWZhdWx0LmEoKS5pbnNlcnQoJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEZWx0YV9kZWZhdWx0LmEoKS5pbnNlcnQoe1xuICAgIG11bHRpbGluZUJyZWFrOiAnJ1xuICB9KTtcbn1cblxudmFyIG11bHRpbGluZV9NdWx0aWxpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Nb2R1bGUpIHtcbiAgbXVsdGlsaW5lX2luaGVyaXRzKE11bHRpbGluZSwgX01vZHVsZSk7XG5cbiAgdmFyIF9zdXBlciA9IG11bHRpbGluZV9jcmVhdGVTdXBlcihNdWx0aWxpbmUpO1xuXG4gIGZ1bmN0aW9uIE11bHRpbGluZShxdWlsbCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIG11bHRpbGluZV9jbGFzc0NhbGxDaGVjayh0aGlzLCBNdWx0aWxpbmUpO1xuXG4gICAgdmFyIHBhdGggPSAnYmxvdHMvbXVsdGlsaW5lQnJlYWsnO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcXVpbGwsIG9wdGlvbnMpO1xuICAgIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10ucmVnaXN0ZXIoX2RlZmluZVByb3BlcnR5KHt9LCBwYXRoLCBtdWx0aWxpbmVfYnJlYWspLCB0cnVlKTtcbiAgICBxdWlsbC5rZXlib2FyZC5hZGRCaW5kaW5nKHtcbiAgICAgIGtleTogJ2VudGVyJyxcbiAgICAgIHNoaWZ0S2V5OiB0cnVlXG4gICAgfSwgX3RoaXMuZW50ZXJIYW5kbGVyLmJpbmQobXVsdGlsaW5lX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcbiAgICBxdWlsbC5rZXlib2FyZC5iaW5kaW5ncy5lbnRlci51bnNoaWZ0KHF1aWxsLmtleWJvYXJkLmJpbmRpbmdzLmVudGVyLnBvcCgpKTtcbiAgICBxdWlsbC5jbGlwYm9hcmQuYWRkTWF0Y2hlcignQlInLCBicmVha01hdGNoZXIpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIG11bHRpbGluZV9jcmVhdGVDbGFzcyhNdWx0aWxpbmUsIFt7XG4gICAga2V5OiBcImVudGVySGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnRlckhhbmRsZXIocmFuZ2UpIHtcbiAgICAgIHZhciBjdXJyZW50TGVhZiA9IHRoaXMucXVpbGwuZ2V0TGVhZihyYW5nZS5pbmRleClbMF07XG4gICAgICB2YXIgbmV4dExlYWYgPSB0aGlzLnF1aWxsLmdldExlYWYocmFuZ2UuaW5kZXggKyAxKVswXTtcbiAgICAgIHRoaXMucXVpbGwuaW5zZXJ0RW1iZWQocmFuZ2UuaW5kZXgsICdtdWx0aWxpbmVCcmVhaycsIHRydWUsICd1c2VyJyk7XG5cbiAgICAgIGlmIChuZXh0TGVhZiA9PT0gbnVsbCB8fCBjdXJyZW50TGVhZi5wYXJlbnQgIT09IG5leHRMZWFmLnBhcmVudCkge1xuICAgICAgICB0aGlzLnF1aWxsLmluc2VydEVtYmVkKHJhbmdlLmluZGV4LCAnbXVsdGlsaW5lQnJlYWsnLCB0cnVlLCAndXNlcicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnF1aWxsLnNldFNlbGVjdGlvbihyYW5nZS5pbmRleCArIDEsIGNvcmVfcXVpbGxbXCJhXCIgLyogZGVmYXVsdCAqL10uc291cmNlcy5TSUxFTlQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNdWx0aWxpbmU7XG59KGNvcmVfbW9kdWxlW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbXVsdGlsaW5lID0gKG11bHRpbGluZV9NdWx0aWxpbmUpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL21vZHVsZXMvdGFibGUvbGl0ZS5qcyArIDQgbW9kdWxlc1xudmFyIGxpdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Zvcm1hdHMvdGFibGUvYXR0cmlidXRvcnMvY2VsbC5qc1xudmFyIGNlbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vZm9ybWF0cy90YWJsZS9hdHRyaWJ1dG9ycy90YWJsZS5qc1xudmFyIGF0dHJpYnV0b3JzX3RhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9xdWlsbC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb3JlW1wiZGVmYXVsdFwiXS5yZWdpc3Rlcih7XG4gICdhdHRyaWJ1dG9ycy9hdHRyaWJ1dGUvZGlyZWN0aW9uJzogZGlyZWN0aW9uW1wiYVwiIC8qIERpcmVjdGlvbkF0dHJpYnV0ZSAqL10sXG4gICdhdHRyaWJ1dG9ycy9hdHRyaWJ1dGUvdGFibGVXaWR0aCc6IGF0dHJpYnV0b3JzX3RhYmxlW1wia1wiIC8qIFRhYmxlV2lkdGhBdHRyaWJ1dGUgKi9dLFxuICAnYXR0cmlidXRvcnMvYXR0cmlidXRlL3RhYmxlSGVpZ2h0JzogYXR0cmlidXRvcnNfdGFibGVbXCJoXCIgLyogVGFibGVIZWlnaHRBdHRyaWJ1dGUgKi9dLFxuICAnYXR0cmlidXRvcnMvYXR0cmlidXRlL2NlbGxXaWR0aCc6IGNlbGxbXCJxXCIgLyogQ2VsbFdpZHRoQXR0cmlidXRlICovXSxcbiAgJ2F0dHJpYnV0b3JzL2F0dHJpYnV0ZS9jZWxsSGVpZ2h0JzogY2VsbFtcImhcIiAvKiBDZWxsSGVpZ2h0QXR0cmlidXRlICovXSxcbiAgJ2F0dHJpYnV0b3JzL2NsYXNzL2FsaWduJzogYWxpZ25bXCJiXCIgLyogQWxpZ25DbGFzcyAqL10sXG4gICdhdHRyaWJ1dG9ycy9jbGFzcy9iYWNrZ3JvdW5kJzogYmFja2dyb3VuZFtcImFcIiAvKiBCYWNrZ3JvdW5kQ2xhc3MgKi9dLFxuICAnYXR0cmlidXRvcnMvY2xhc3MvY29sb3InOiBjb2xvcltcImJcIiAvKiBDb2xvckNsYXNzICovXSxcbiAgJ2F0dHJpYnV0b3JzL2NsYXNzL2RpcmVjdGlvbic6IGRpcmVjdGlvbltcImJcIiAvKiBEaXJlY3Rpb25DbGFzcyAqL10sXG4gICdhdHRyaWJ1dG9ycy9jbGFzcy9mb250JzogZm9udFtcImFcIiAvKiBGb250Q2xhc3MgKi9dLFxuICAnYXR0cmlidXRvcnMvY2xhc3Mvc2l6ZSc6IHNpemVbXCJhXCIgLyogU2l6ZUNsYXNzICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2FsaWduJzogYWxpZ25bXCJjXCIgLyogQWxpZ25TdHlsZSAqL10sXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS9iYWNrZ3JvdW5kJzogYmFja2dyb3VuZFtcImJcIiAvKiBCYWNrZ3JvdW5kU3R5bGUgKi9dLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvY29sb3InOiBjb2xvcltcImNcIiAvKiBDb2xvclN0eWxlICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2RpcmVjdGlvbic6IGRpcmVjdGlvbltcImNcIiAvKiBEaXJlY3Rpb25TdHlsZSAqL10sXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS9mb250JzogZm9udFtcImJcIiAvKiBGb250U3R5bGUgKi9dLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvc2l6ZSc6IHNpemVbXCJiXCIgLyogU2l6ZVN0eWxlICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL3RhYmxlVGV4dEFsaWduJzogYXR0cmlidXRvcnNfdGFibGVbXCJqXCIgLyogVGFibGVUZXh0QWxpZ25TdHlsZSAqL10sXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS90YWJsZUJhY2tncm91bmRDb2xvcic6IGF0dHJpYnV0b3JzX3RhYmxlW1wiY1wiIC8qIFRhYmxlQmFja2dyb3VuZENvbG9yU3R5bGUgKi9dLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvdGFibGVCb3JkZXInOiBhdHRyaWJ1dG9yc190YWJsZVtcImVcIiAvKiBUYWJsZUJvcmRlclN0eWxlICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL3RhYmxlQm9yZGVyU3R5bGUnOiBhdHRyaWJ1dG9yc190YWJsZVtcImZcIiAvKiBUYWJsZUJvcmRlclN0eWxlU3R5bGUgKi9dLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvdGFibGVCb3JkZXJDb2xvcic6IGF0dHJpYnV0b3JzX3RhYmxlW1wiZFwiIC8qIFRhYmxlQm9yZGVyQ29sb3JTdHlsZSAqL10sXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS90YWJsZUJvcmRlcldpZHRoJzogYXR0cmlidXRvcnNfdGFibGVbXCJnXCIgLyogVGFibGVCb3JkZXJXaWR0aFN0eWxlICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL3RhYmxlV2lkdGgnOiBhdHRyaWJ1dG9yc190YWJsZVtcImxcIiAvKiBUYWJsZVdpZHRoU3R5bGUgKi9dLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvdGFibGVIZWlnaHQnOiBhdHRyaWJ1dG9yc190YWJsZVtcImlcIiAvKiBUYWJsZUhlaWdodFN0eWxlICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2NlbGxCYWNrZ3JvdW5kJzogY2VsbFtcImNcIiAvKiBDZWxsQmFja2dyb3VuZENvbG9yU3R5bGUgKi9dLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvY2VsbEJvcmRlcic6IGNlbGxbXCJlXCIgLyogQ2VsbEJvcmRlclN0eWxlICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2NlbGxCb3JkZXJTdHlsZSc6IGNlbGxbXCJmXCIgLyogQ2VsbEJvcmRlclN0eWxlU3R5bGUgKi9dLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvY2VsbEJvcmRlcldpZHRoJzogY2VsbFtcImdcIiAvKiBDZWxsQm9yZGVyV2lkdGhTdHlsZSAqL10sXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS9jZWxsQm9yZGVyQ29sb3InOiBjZWxsW1wiZFwiIC8qIENlbGxCb3JkZXJDb2xvclN0eWxlICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2NlbGxQYWRkaW5nJzogY2VsbFtcIm1cIiAvKiBDZWxsUGFkZGluZ1N0eWxlICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2NlbGxQYWRkaW5nVG9wJzogY2VsbFtcIm5cIiAvKiBDZWxsUGFkZGluZ1RvcFN0eWxlICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2NlbGxQYWRkaW5nQm90dG9tJzogY2VsbFtcImpcIiAvKiBDZWxsUGFkZGluZ0JvdHRvbVN0eWxlICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2NlbGxQYWRkaW5nTGVmdCc6IGNlbGxbXCJrXCIgLyogQ2VsbFBhZGRpbmdMZWZ0U3R5bGUgKi9dLFxuICAnYXR0cmlidXRvcnMvc3R5bGUvY2VsbFBhZGRpbmdSaWdodCc6IGNlbGxbXCJsXCIgLyogQ2VsbFBhZGRpbmdSaWdodFN0eWxlICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2NlbGxWZXJ0aWNhbEFsaWduJzogY2VsbFtcInBcIiAvKiBDZWxsVmVydGljYWxBbGlnblN0eWxlICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2NlbGxUZXh0QWxpZ24nOiBjZWxsW1wib1wiIC8qIENlbGxUZXh0QWxpZ25TdHlsZSAqL10sXG4gICdhdHRyaWJ1dG9ycy9zdHlsZS9jZWxsV2lkdGgnOiBjZWxsW1wiclwiIC8qIENlbGxXaWR0aFN0eWxlICovXSxcbiAgJ2F0dHJpYnV0b3JzL3N0eWxlL2NlbGxIZWlnaHQnOiBjZWxsW1wiaVwiIC8qIENlbGxIZWlnaHRTdHlsZSAqL11cbn0sIHRydWUpO1xuY29yZVtcImRlZmF1bHRcIl0ucmVnaXN0ZXIoe1xuICAnZm9ybWF0cy9hbGlnbic6IGFsaWduW1wiYlwiIC8qIEFsaWduQ2xhc3MgKi9dLFxuICAnZm9ybWF0cy9kaXJlY3Rpb24nOiBkaXJlY3Rpb25bXCJiXCIgLyogRGlyZWN0aW9uQ2xhc3MgKi9dLFxuICAnZm9ybWF0cy9pbmRlbnQnOiBpbmRlbnQsXG4gICdmb3JtYXRzL2JhY2tncm91bmQnOiBiYWNrZ3JvdW5kW1wiYlwiIC8qIEJhY2tncm91bmRTdHlsZSAqL10sXG4gICdmb3JtYXRzL2NvbG9yJzogY29sb3JbXCJjXCIgLyogQ29sb3JTdHlsZSAqL10sXG4gICdmb3JtYXRzL2ZvbnQnOiBmb250W1wiYVwiIC8qIEZvbnRDbGFzcyAqL10sXG4gICdmb3JtYXRzL3NpemUnOiBzaXplW1wiYVwiIC8qIFNpemVDbGFzcyAqL10sXG4gICdmb3JtYXRzL2Jsb2NrcXVvdGUnOiBibG9ja3F1b3RlLFxuICAnZm9ybWF0cy9jb2RlLWJsb2NrJzogY29kZVtcImNcIiAvKiBkZWZhdWx0ICovXSxcbiAgJ2Zvcm1hdHMvaGVhZGVyJzogaGVhZGVyLFxuICAnZm9ybWF0cy9saXN0JzogbGlzdF9MaXN0SXRlbSxcbiAgJ2Zvcm1hdHMvYm9sZCc6IGJvbGRbXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gICdmb3JtYXRzL2NvZGUnOiBjb2RlW1wiYVwiIC8qIENvZGUgKi9dLFxuICAnZm9ybWF0cy9pdGFsaWMnOiBpdGFsaWMsXG4gICdmb3JtYXRzL2xpbmsnOiBmb3JtYXRzX2xpbmtbXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gICdmb3JtYXRzL3NjcmlwdCc6IHNjcmlwdCxcbiAgJ2Zvcm1hdHMvc3RyaWtlJzogc3RyaWtlLFxuICAnZm9ybWF0cy91bmRlcmxpbmUnOiB1bmRlcmxpbmUsXG4gICdmb3JtYXRzL2Zvcm11bGEnOiBmb3JtdWxhLFxuICAnZm9ybWF0cy9pbWFnZSc6IGZvcm1hdHNfaW1hZ2UsXG4gICdmb3JtYXRzL3ZpZGVvJzogdmlkZW8sXG4gICd0YWJsZU1vZHVsZXMvbGl0ZSc6IGxpdGVbXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gICd0YWJsZU1vZHVsZXMvbWFpbic6IHRhYmxlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICAnbW9kdWxlcy9zeW50YXgnOiBzeW50YXhbXCJiXCIgLyogZGVmYXVsdCAqL10sXG4gICdtb2R1bGVzL211bHRpbGluZSc6IG11bHRpbGluZSxcbiAgJ21vZHVsZXMvdGFibGUnOiB0YWJsZVtcImFcIiAvKiBkZWZhdWx0ICovXVxufSwgdHJ1ZSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBxdWlsbF8wID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoY29yZVtcImRlZmF1bHRcIl0pO1xuXG4vKioqLyB9KSxcbi8qIDExNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoaXMgbGlicmFyeSBtb2RpZmllcyB0aGUgZGlmZi1wYXRjaC1tYXRjaCBsaWJyYXJ5IGJ5IE5laWwgRnJhc2VyXG4gKiBieSByZW1vdmluZyB0aGUgcGF0Y2ggYW5kIG1hdGNoIGZ1bmN0aW9uYWxpdHkgYW5kIGNlcnRhaW4gYWR2YW5jZWRcbiAqIG9wdGlvbnMgaW4gdGhlIGRpZmYgZnVuY3Rpb24uIFRoZSBvcmlnaW5hbCBsaWNlbnNlIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogPT09XG4gKlxuICogRGlmZiBNYXRjaCBhbmQgUGF0Y2hcbiAqXG4gKiBDb3B5cmlnaHQgMjAwNiBHb29nbGUgSW5jLlxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIFRoZSBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYSBkaWZmIGlzIGFuIGFycmF5IG9mIHR1cGxlczpcbiAqIFtbRElGRl9ERUxFVEUsICdIZWxsbyddLCBbRElGRl9JTlNFUlQsICdHb29kYnllJ10sIFtESUZGX0VRVUFMLCAnIHdvcmxkLiddXVxuICogd2hpY2ggbWVhbnM6IGRlbGV0ZSAnSGVsbG8nLCBhZGQgJ0dvb2RieWUnIGFuZCBrZWVwICcgd29ybGQuJ1xuICovXG52YXIgRElGRl9ERUxFVEUgPSAtMTtcbnZhciBESUZGX0lOU0VSVCA9IDE7XG52YXIgRElGRl9FUVVBTCA9IDA7XG5cblxuLyoqXG4gKiBGaW5kIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byB0ZXh0cy4gIFNpbXBsaWZpZXMgdGhlIHByb2JsZW0gYnkgc3RyaXBwaW5nXG4gKiBhbnkgY29tbW9uIHByZWZpeCBvciBzdWZmaXggb2ZmIHRoZSB0ZXh0cyBiZWZvcmUgZGlmZmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7SW50fE9iamVjdH0gW2N1cnNvcl9wb3NdIEVkaXQgcG9zaXRpb24gaW4gdGV4dDEgb3Igb2JqZWN0IHdpdGggbW9yZSBpbmZvXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKi9cbmZ1bmN0aW9uIGRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIGN1cnNvcl9wb3MsIF9maXhfdW5pY29kZSkge1xuICAvLyBDaGVjayBmb3IgZXF1YWxpdHlcbiAgaWYgKHRleHQxID09PSB0ZXh0Mikge1xuICAgIGlmICh0ZXh0MSkge1xuICAgICAgcmV0dXJuIFtbRElGRl9FUVVBTCwgdGV4dDFdXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKGN1cnNvcl9wb3MgIT0gbnVsbCkge1xuICAgIHZhciBlZGl0ZGlmZiA9IGZpbmRfY3Vyc29yX2VkaXRfZGlmZih0ZXh0MSwgdGV4dDIsIGN1cnNvcl9wb3MpO1xuICAgIGlmIChlZGl0ZGlmZikge1xuICAgICAgcmV0dXJuIGVkaXRkaWZmO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGNvbW1vbiBwcmVmaXggKHNwZWVkdXApLlxuICB2YXIgY29tbW9ubGVuZ3RoID0gZGlmZl9jb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcbiAgdmFyIGNvbW1vbnByZWZpeCA9IHRleHQxLnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuXG4gIC8vIFRyaW0gb2ZmIGNvbW1vbiBzdWZmaXggKHNwZWVkdXApLlxuICBjb21tb25sZW5ndGggPSBkaWZmX2NvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpO1xuICB2YXIgY29tbW9uc3VmZml4ID0gdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKDAsIHRleHQxLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQyLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgZGlmZiBvbiB0aGUgbWlkZGxlIGJsb2NrLlxuICB2YXIgZGlmZnMgPSBkaWZmX2NvbXB1dGVfKHRleHQxLCB0ZXh0Mik7XG5cbiAgLy8gUmVzdG9yZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gIGlmIChjb21tb25wcmVmaXgpIHtcbiAgICBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBjb21tb25wcmVmaXhdKTtcbiAgfVxuICBpZiAoY29tbW9uc3VmZml4KSB7XG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgY29tbW9uc3VmZml4XSk7XG4gIH1cbiAgZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMsIF9maXhfdW5pY29kZSk7XG4gIHJldHVybiBkaWZmcztcbn07XG5cblxuLyoqXG4gKiBGaW5kIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byB0ZXh0cy4gIEFzc3VtZXMgdGhhdCB0aGUgdGV4dHMgZG8gbm90XG4gKiBoYXZlIGFueSBjb21tb24gcHJlZml4IG9yIHN1ZmZpeC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAqL1xuZnVuY3Rpb24gZGlmZl9jb21wdXRlXyh0ZXh0MSwgdGV4dDIpIHtcbiAgdmFyIGRpZmZzO1xuXG4gIGlmICghdGV4dDEpIHtcbiAgICAvLyBKdXN0IGFkZCBzb21lIHRleHQgKHNwZWVkdXApLlxuICAgIHJldHVybiBbW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICB9XG5cbiAgaWYgKCF0ZXh0Mikge1xuICAgIC8vIEp1c3QgZGVsZXRlIHNvbWUgdGV4dCAoc3BlZWR1cCkuXG4gICAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXV07XG4gIH1cblxuICB2YXIgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xuICB2YXIgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcbiAgdmFyIGkgPSBsb25ndGV4dC5pbmRleE9mKHNob3J0dGV4dCk7XG4gIGlmIChpICE9PSAtMSkge1xuICAgIC8vIFNob3J0ZXIgdGV4dCBpcyBpbnNpZGUgdGhlIGxvbmdlciB0ZXh0IChzcGVlZHVwKS5cbiAgICBkaWZmcyA9IFtcbiAgICAgIFtESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpXSxcbiAgICAgIFtESUZGX0VRVUFMLCBzaG9ydHRleHRdLFxuICAgICAgW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHNob3J0dGV4dC5sZW5ndGgpXVxuICAgIF07XG4gICAgLy8gU3dhcCBpbnNlcnRpb25zIGZvciBkZWxldGlvbnMgaWYgZGlmZiBpcyByZXZlcnNlZC5cbiAgICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKSB7XG4gICAgICBkaWZmc1swXVswXSA9IGRpZmZzWzJdWzBdID0gRElGRl9ERUxFVEU7XG4gICAgfVxuICAgIHJldHVybiBkaWZmcztcbiAgfVxuXG4gIGlmIChzaG9ydHRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gU2luZ2xlIGNoYXJhY3RlciBzdHJpbmcuXG4gICAgLy8gQWZ0ZXIgdGhlIHByZXZpb3VzIHNwZWVkdXAsIHRoZSBjaGFyYWN0ZXIgY2FuJ3QgYmUgYW4gZXF1YWxpdHkuXG4gICAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICB9XG5cbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBwcm9ibGVtIGNhbiBiZSBzcGxpdCBpbiB0d28uXG4gIHZhciBobSA9IGRpZmZfaGFsZk1hdGNoXyh0ZXh0MSwgdGV4dDIpO1xuICBpZiAoaG0pIHtcbiAgICAvLyBBIGhhbGYtbWF0Y2ggd2FzIGZvdW5kLCBzb3J0IG91dCB0aGUgcmV0dXJuIGRhdGEuXG4gICAgdmFyIHRleHQxX2EgPSBobVswXTtcbiAgICB2YXIgdGV4dDFfYiA9IGhtWzFdO1xuICAgIHZhciB0ZXh0Ml9hID0gaG1bMl07XG4gICAgdmFyIHRleHQyX2IgPSBobVszXTtcbiAgICB2YXIgbWlkX2NvbW1vbiA9IGhtWzRdO1xuICAgIC8vIFNlbmQgYm90aCBwYWlycyBvZmYgZm9yIHNlcGFyYXRlIHByb2Nlc3NpbmcuXG4gICAgdmFyIGRpZmZzX2EgPSBkaWZmX21haW4odGV4dDFfYSwgdGV4dDJfYSk7XG4gICAgdmFyIGRpZmZzX2IgPSBkaWZmX21haW4odGV4dDFfYiwgdGV4dDJfYik7XG4gICAgLy8gTWVyZ2UgdGhlIHJlc3VsdHMuXG4gICAgcmV0dXJuIGRpZmZzX2EuY29uY2F0KFtbRElGRl9FUVVBTCwgbWlkX2NvbW1vbl1dLCBkaWZmc19iKTtcbiAgfVxuXG4gIHJldHVybiBkaWZmX2Jpc2VjdF8odGV4dDEsIHRleHQyKTtcbn07XG5cblxuLyoqXG4gKiBGaW5kIHRoZSAnbWlkZGxlIHNuYWtlJyBvZiBhIGRpZmYsIHNwbGl0IHRoZSBwcm9ibGVtIGluIHR3b1xuICogYW5kIHJldHVybiB0aGUgcmVjdXJzaXZlbHkgY29uc3RydWN0ZWQgZGlmZi5cbiAqIFNlZSBNeWVycyAxOTg2IHBhcGVyOiBBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgSXRzIFZhcmlhdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkaWZmX2Jpc2VjdF8odGV4dDEsIHRleHQyKSB7XG4gIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cbiAgdmFyIHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgdmFyIHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgdmFyIG1heF9kID0gTWF0aC5jZWlsKCh0ZXh0MV9sZW5ndGggKyB0ZXh0Ml9sZW5ndGgpIC8gMik7XG4gIHZhciB2X29mZnNldCA9IG1heF9kO1xuICB2YXIgdl9sZW5ndGggPSAyICogbWF4X2Q7XG4gIHZhciB2MSA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gIHZhciB2MiA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gIC8vIFNldHRpbmcgYWxsIGVsZW1lbnRzIHRvIC0xIGlzIGZhc3RlciBpbiBDaHJvbWUgJiBGaXJlZm94IHRoYW4gbWl4aW5nXG4gIC8vIGludGVnZXJzIGFuZCB1bmRlZmluZWQuXG4gIGZvciAodmFyIHggPSAwOyB4IDwgdl9sZW5ndGg7IHgrKykge1xuICAgIHYxW3hdID0gLTE7XG4gICAgdjJbeF0gPSAtMTtcbiAgfVxuICB2MVt2X29mZnNldCArIDFdID0gMDtcbiAgdjJbdl9vZmZzZXQgKyAxXSA9IDA7XG4gIHZhciBkZWx0YSA9IHRleHQxX2xlbmd0aCAtIHRleHQyX2xlbmd0aDtcbiAgLy8gSWYgdGhlIHRvdGFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIGlzIG9kZCwgdGhlbiB0aGUgZnJvbnQgcGF0aCB3aWxsIGNvbGxpZGVcbiAgLy8gd2l0aCB0aGUgcmV2ZXJzZSBwYXRoLlxuICB2YXIgZnJvbnQgPSAoZGVsdGEgJSAyICE9PSAwKTtcbiAgLy8gT2Zmc2V0cyBmb3Igc3RhcnQgYW5kIGVuZCBvZiBrIGxvb3AuXG4gIC8vIFByZXZlbnRzIG1hcHBpbmcgb2Ygc3BhY2UgYmV5b25kIHRoZSBncmlkLlxuICB2YXIgazFzdGFydCA9IDA7XG4gIHZhciBrMWVuZCA9IDA7XG4gIHZhciBrMnN0YXJ0ID0gMDtcbiAgdmFyIGsyZW5kID0gMDtcbiAgZm9yICh2YXIgZCA9IDA7IGQgPCBtYXhfZDsgZCsrKSB7XG4gICAgLy8gV2FsayB0aGUgZnJvbnQgcGF0aCBvbmUgc3RlcC5cbiAgICBmb3IgKHZhciBrMSA9IC1kICsgazFzdGFydDsgazEgPD0gZCAtIGsxZW5kOyBrMSArPSAyKSB7XG4gICAgICB2YXIgazFfb2Zmc2V0ID0gdl9vZmZzZXQgKyBrMTtcbiAgICAgIHZhciB4MTtcbiAgICAgIGlmIChrMSA9PT0gLWQgfHwgKGsxICE9PSBkICYmIHYxW2sxX29mZnNldCAtIDFdIDwgdjFbazFfb2Zmc2V0ICsgMV0pKSB7XG4gICAgICAgIHgxID0gdjFbazFfb2Zmc2V0ICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MSA9IHYxW2sxX29mZnNldCAtIDFdICsgMTtcbiAgICAgIH1cbiAgICAgIHZhciB5MSA9IHgxIC0gazE7XG4gICAgICB3aGlsZSAoXG4gICAgICAgIHgxIDwgdGV4dDFfbGVuZ3RoICYmIHkxIDwgdGV4dDJfbGVuZ3RoICYmXG4gICAgICAgIHRleHQxLmNoYXJBdCh4MSkgPT09IHRleHQyLmNoYXJBdCh5MSlcbiAgICAgICkge1xuICAgICAgICB4MSsrO1xuICAgICAgICB5MSsrO1xuICAgICAgfVxuICAgICAgdjFbazFfb2Zmc2V0XSA9IHgxO1xuICAgICAgaWYgKHgxID4gdGV4dDFfbGVuZ3RoKSB7XG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIHJpZ2h0IG9mIHRoZSBncmFwaC5cbiAgICAgICAgazFlbmQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoeTEgPiB0ZXh0Ml9sZW5ndGgpIHtcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgYm90dG9tIG9mIHRoZSBncmFwaC5cbiAgICAgICAgazFzdGFydCArPSAyO1xuICAgICAgfSBlbHNlIGlmIChmcm9udCkge1xuICAgICAgICB2YXIgazJfb2Zmc2V0ID0gdl9vZmZzZXQgKyBkZWx0YSAtIGsxO1xuICAgICAgICBpZiAoazJfb2Zmc2V0ID49IDAgJiYgazJfb2Zmc2V0IDwgdl9sZW5ndGggJiYgdjJbazJfb2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBNaXJyb3IgeDIgb250byB0b3AtbGVmdCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgICAgICB2YXIgeDIgPSB0ZXh0MV9sZW5ndGggLSB2MltrMl9vZmZzZXRdO1xuICAgICAgICAgIGlmICh4MSA+PSB4Mikge1xuICAgICAgICAgICAgLy8gT3ZlcmxhcCBkZXRlY3RlZC5cbiAgICAgICAgICAgIHJldHVybiBkaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgxLCB5MSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2FsayB0aGUgcmV2ZXJzZSBwYXRoIG9uZSBzdGVwLlxuICAgIGZvciAodmFyIGsyID0gLWQgKyBrMnN0YXJ0OyBrMiA8PSBkIC0gazJlbmQ7IGsyICs9IDIpIHtcbiAgICAgIHZhciBrMl9vZmZzZXQgPSB2X29mZnNldCArIGsyO1xuICAgICAgdmFyIHgyO1xuICAgICAgaWYgKGsyID09PSAtZCB8fCAoazIgIT09IGQgJiYgdjJbazJfb2Zmc2V0IC0gMV0gPCB2MltrMl9vZmZzZXQgKyAxXSkpIHtcbiAgICAgICAgeDIgPSB2MltrMl9vZmZzZXQgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gdjJbazJfb2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgfVxuICAgICAgdmFyIHkyID0geDIgLSBrMjtcbiAgICAgIHdoaWxlIChcbiAgICAgICAgeDIgPCB0ZXh0MV9sZW5ndGggJiYgeTIgPCB0ZXh0Ml9sZW5ndGggJiZcbiAgICAgICAgdGV4dDEuY2hhckF0KHRleHQxX2xlbmd0aCAtIHgyIC0gMSkgPT09IHRleHQyLmNoYXJBdCh0ZXh0Ml9sZW5ndGggLSB5MiAtIDEpXG4gICAgICApIHtcbiAgICAgICAgeDIrKztcbiAgICAgICAgeTIrKztcbiAgICAgIH1cbiAgICAgIHYyW2syX29mZnNldF0gPSB4MjtcbiAgICAgIGlmICh4MiA+IHRleHQxX2xlbmd0aCkge1xuICAgICAgICAvLyBSYW4gb2ZmIHRoZSBsZWZ0IG9mIHRoZSBncmFwaC5cbiAgICAgICAgazJlbmQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoeTIgPiB0ZXh0Ml9sZW5ndGgpIHtcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgdG9wIG9mIHRoZSBncmFwaC5cbiAgICAgICAgazJzdGFydCArPSAyO1xuICAgICAgfSBlbHNlIGlmICghZnJvbnQpIHtcbiAgICAgICAgdmFyIGsxX29mZnNldCA9IHZfb2Zmc2V0ICsgZGVsdGEgLSBrMjtcbiAgICAgICAgaWYgKGsxX29mZnNldCA+PSAwICYmIGsxX29mZnNldCA8IHZfbGVuZ3RoICYmIHYxW2sxX29mZnNldF0gIT09IC0xKSB7XG4gICAgICAgICAgdmFyIHgxID0gdjFbazFfb2Zmc2V0XTtcbiAgICAgICAgICB2YXIgeTEgPSB2X29mZnNldCArIHgxIC0gazFfb2Zmc2V0O1xuICAgICAgICAgIC8vIE1pcnJvciB4MiBvbnRvIHRvcC1sZWZ0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAgICAgIHgyID0gdGV4dDFfbGVuZ3RoIC0geDI7XG4gICAgICAgICAgaWYgKHgxID49IHgyKSB7XG4gICAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLlxuICAgICAgICAgICAgcmV0dXJuIGRpZmZfYmlzZWN0U3BsaXRfKHRleHQxLCB0ZXh0MiwgeDEsIHkxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRGlmZiB0b29rIHRvbyBsb25nIGFuZCBoaXQgdGhlIGRlYWRsaW5lIG9yXG4gIC8vIG51bWJlciBvZiBkaWZmcyBlcXVhbHMgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIG5vIGNvbW1vbmFsaXR5IGF0IGFsbC5cbiAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xufTtcblxuXG4vKipcbiAqIEdpdmVuIHRoZSBsb2NhdGlvbiBvZiB0aGUgJ21pZGRsZSBzbmFrZScsIHNwbGl0IHRoZSBkaWZmIGluIHR3byBwYXJ0c1xuICogYW5kIHJlY3Vyc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBJbmRleCBvZiBzcGxpdCBwb2ludCBpbiB0ZXh0MS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IEluZGV4IG9mIHNwbGl0IHBvaW50IGluIHRleHQyLlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICovXG5mdW5jdGlvbiBkaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgsIHkpIHtcbiAgdmFyIHRleHQxYSA9IHRleHQxLnN1YnN0cmluZygwLCB4KTtcbiAgdmFyIHRleHQyYSA9IHRleHQyLnN1YnN0cmluZygwLCB5KTtcbiAgdmFyIHRleHQxYiA9IHRleHQxLnN1YnN0cmluZyh4KTtcbiAgdmFyIHRleHQyYiA9IHRleHQyLnN1YnN0cmluZyh5KTtcblxuICAvLyBDb21wdXRlIGJvdGggZGlmZnMgc2VyaWFsbHkuXG4gIHZhciBkaWZmcyA9IGRpZmZfbWFpbih0ZXh0MWEsIHRleHQyYSk7XG4gIHZhciBkaWZmc2IgPSBkaWZmX21haW4odGV4dDFiLCB0ZXh0MmIpO1xuXG4gIHJldHVybiBkaWZmcy5jb25jYXQoZGlmZnNiKTtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBwcmVmaXggb2YgdHdvIHN0cmluZ3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIHN0YXJ0IG9mIGVhY2hcbiAqICAgICBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGRpZmZfY29tbW9uUHJlZml4KHRleHQxLCB0ZXh0Mikge1xuICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxLmNoYXJBdCgwKSAhPT0gdGV4dDIuY2hhckF0KDApKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gQmluYXJ5IHNlYXJjaC5cbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAwNy8xMC8wOS9cbiAgdmFyIHBvaW50ZXJtaW4gPSAwO1xuICB2YXIgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcbiAgdmFyIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuICB2YXIgcG9pbnRlcnN0YXJ0ID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKFxuICAgICAgdGV4dDEuc3Vic3RyaW5nKHBvaW50ZXJzdGFydCwgcG9pbnRlcm1pZCkgPT1cbiAgICAgIHRleHQyLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpXG4gICAgKSB7XG4gICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcbiAgICAgIHBvaW50ZXJzdGFydCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG5cbiAgaWYgKGlzX3N1cnJvZ2F0ZV9wYWlyX3N0YXJ0KHRleHQxLmNoYXJDb2RlQXQocG9pbnRlcm1pZCAtIDEpKSkge1xuICAgIHBvaW50ZXJtaWQtLTtcbiAgfVxuXG4gIHJldHVybiBwb2ludGVybWlkO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSB0aGUgY29tbW9uIHN1ZmZpeCBvZiB0d28gc3RyaW5ncy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgZW5kIG9mIGVhY2ggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBkaWZmX2NvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpIHtcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MS5zbGljZSgtMSkgIT09IHRleHQyLnNsaWNlKC0xKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIEJpbmFyeSBzZWFyY2guXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXG4gIHZhciBwb2ludGVybWluID0gMDtcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgdmFyIHBvaW50ZXJlbmQgPSAwO1xuICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcbiAgICBpZiAoXG4gICAgICB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDEubGVuZ3RoIC0gcG9pbnRlcmVuZCkgPT1cbiAgICAgIHRleHQyLnN1YnN0cmluZyh0ZXh0Mi5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0Mi5sZW5ndGggLSBwb2ludGVyZW5kKVxuICAgICkge1xuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICBwb2ludGVyZW5kID0gcG9pbnRlcm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlcm1heCA9IHBvaW50ZXJtaWQ7XG4gICAgfVxuICAgIHBvaW50ZXJtaWQgPSBNYXRoLmZsb29yKChwb2ludGVybWF4IC0gcG9pbnRlcm1pbikgLyAyICsgcG9pbnRlcm1pbik7XG4gIH1cblxuICBpZiAoaXNfc3Vycm9nYXRlX3BhaXJfZW5kKHRleHQxLmNoYXJDb2RlQXQodGV4dDEubGVuZ3RoIC0gcG9pbnRlcm1pZCkpKSB7XG4gICAgcG9pbnRlcm1pZC0tO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50ZXJtaWQ7XG59O1xuXG5cbi8qKlxuICogRG8gdGhlIHR3byB0ZXh0cyBzaGFyZSBhIHN1YnN0cmluZyB3aGljaCBpcyBhdCBsZWFzdCBoYWxmIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBsb25nZXIgdGV4dD9cbiAqIFRoaXMgc3BlZWR1cCBjYW4gcHJvZHVjZSBub24tbWluaW1hbCBkaWZmcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBGaXZlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlIHByZWZpeCBvZlxuICogICAgIHRleHQxLCB0aGUgc3VmZml4IG9mIHRleHQxLCB0aGUgcHJlZml4IG9mIHRleHQyLCB0aGUgc3VmZml4IG9mXG4gKiAgICAgdGV4dDIgYW5kIHRoZSBjb21tb24gbWlkZGxlLiAgT3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXG4gKi9cbmZ1bmN0aW9uIGRpZmZfaGFsZk1hdGNoXyh0ZXh0MSwgdGV4dDIpIHtcbiAgdmFyIGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0MjtcbiAgdmFyIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIGlmIChsb25ndGV4dC5sZW5ndGggPCA0IHx8IHNob3J0dGV4dC5sZW5ndGggKiAyIDwgbG9uZ3RleHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7ICAvLyBQb2ludGxlc3MuXG4gIH1cblxuICAvKipcbiAgICogRG9lcyBhIHN1YnN0cmluZyBvZiBzaG9ydHRleHQgZXhpc3Qgd2l0aGluIGxvbmd0ZXh0IHN1Y2ggdGhhdCB0aGUgc3Vic3RyaW5nXG4gICAqIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGxlbmd0aCBvZiBsb25ndGV4dD9cbiAgICogQ2xvc3VyZSwgYnV0IGRvZXMgbm90IHJlZmVyZW5jZSBhbnkgZXh0ZXJuYWwgdmFyaWFibGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9uZ3RleHQgTG9uZ2VyIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0dGV4dCBTaG9ydGVyIHN0cmluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgU3RhcnQgaW5kZXggb2YgcXVhcnRlciBsZW5ndGggc3Vic3RyaW5nIHdpdGhpbiBsb25ndGV4dC5cbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXG4gICAqICAgICBsb25ndGV4dCwgdGhlIHN1ZmZpeCBvZiBsb25ndGV4dCwgdGhlIHByZWZpeCBvZiBzaG9ydHRleHQsIHRoZSBzdWZmaXhcbiAgICogICAgIG9mIHNob3J0dGV4dCBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuICBPciBudWxsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGRpZmZfaGFsZk1hdGNoSV8obG9uZ3RleHQsIHNob3J0dGV4dCwgaSkge1xuICAgIC8vIFN0YXJ0IHdpdGggYSAxLzQgbGVuZ3RoIHN1YnN0cmluZyBhdCBwb3NpdGlvbiBpIGFzIGEgc2VlZC5cbiAgICB2YXIgc2VlZCA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpLCBpICsgTWF0aC5mbG9vcihsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gICAgdmFyIGogPSAtMTtcbiAgICB2YXIgYmVzdF9jb21tb24gPSAnJztcbiAgICB2YXIgYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2I7XG4gICAgd2hpbGUgKChqID0gc2hvcnR0ZXh0LmluZGV4T2Yoc2VlZCwgaiArIDEpKSAhPT0gLTEpIHtcbiAgICAgIHZhciBwcmVmaXhMZW5ndGggPSBkaWZmX2NvbW1vblByZWZpeChcbiAgICAgICAgbG9uZ3RleHQuc3Vic3RyaW5nKGkpLCBzaG9ydHRleHQuc3Vic3RyaW5nKGopKTtcbiAgICAgIHZhciBzdWZmaXhMZW5ndGggPSBkaWZmX2NvbW1vblN1ZmZpeChcbiAgICAgICAgbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpLCBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGopKTtcbiAgICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggPCBzdWZmaXhMZW5ndGggKyBwcmVmaXhMZW5ndGgpIHtcbiAgICAgICAgYmVzdF9jb21tb24gPSBzaG9ydHRleHQuc3Vic3RyaW5nKFxuICAgICAgICAgIGogLSBzdWZmaXhMZW5ndGgsIGopICsgc2hvcnR0ZXh0LnN1YnN0cmluZyhqLCBqICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9sb25ndGV4dF9hID0gbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkgLSBzdWZmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X2xvbmd0ZXh0X2IgPSBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHByZWZpeExlbmd0aCk7XG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EgPSBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGogLSBzdWZmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X3Nob3J0dGV4dF9iID0gc2hvcnR0ZXh0LnN1YnN0cmluZyhqICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJlc3RfY29tbW9uLmxlbmd0aCAqIDIgPj0gbG9uZ3RleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYixcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYiwgYmVzdF9jb21tb25cbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBzZWNvbmQgcXVhcnRlciBpcyB0aGUgc2VlZCBmb3IgYSBoYWxmLW1hdGNoLlxuICB2YXIgaG0xID0gZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LCBNYXRoLmNlaWwobG9uZ3RleHQubGVuZ3RoIC8gNCkpO1xuICAvLyBDaGVjayBhZ2FpbiBiYXNlZCBvbiB0aGUgdGhpcmQgcXVhcnRlci5cbiAgdmFyIGhtMiA9IGRpZmZfaGFsZk1hdGNoSV8obG9uZ3RleHQsIHNob3J0dGV4dCwgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDIpKTtcbiAgdmFyIGhtO1xuICBpZiAoIWhtMSAmJiAhaG0yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIWhtMikge1xuICAgIGhtID0gaG0xO1xuICB9IGVsc2UgaWYgKCFobTEpIHtcbiAgICBobSA9IGhtMjtcbiAgfSBlbHNlIHtcbiAgICAvLyBCb3RoIG1hdGNoZWQuICBTZWxlY3QgdGhlIGxvbmdlc3QuXG4gICAgaG0gPSBobTFbNF0ubGVuZ3RoID4gaG0yWzRdLmxlbmd0aCA/IGhtMSA6IGhtMjtcbiAgfVxuXG4gIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cbiAgdmFyIHRleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2I7XG4gIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcbiAgICB0ZXh0MV9hID0gaG1bMF07XG4gICAgdGV4dDFfYiA9IGhtWzFdO1xuICAgIHRleHQyX2EgPSBobVsyXTtcbiAgICB0ZXh0Ml9iID0gaG1bM107XG4gIH0gZWxzZSB7XG4gICAgdGV4dDJfYSA9IGhtWzBdO1xuICAgIHRleHQyX2IgPSBobVsxXTtcbiAgICB0ZXh0MV9hID0gaG1bMl07XG4gICAgdGV4dDFfYiA9IGhtWzNdO1xuICB9XG4gIHZhciBtaWRfY29tbW9uID0gaG1bNF07XG4gIHJldHVybiBbdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYiwgbWlkX2NvbW1vbl07XG59O1xuXG5cbi8qKlxuICogUmVvcmRlciBhbmQgbWVyZ2UgbGlrZSBlZGl0IHNlY3Rpb25zLiAgTWVyZ2UgZXF1YWxpdGllcy5cbiAqIEFueSBlZGl0IHNlY3Rpb24gY2FuIG1vdmUgYXMgbG9uZyBhcyBpdCBkb2Vzbid0IGNyb3NzIGFuIGVxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheX0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZpeF91bmljb2RlIFdoZXRoZXIgdG8gbm9ybWFsaXplIHRvIGEgdW5pY29kZS1jb3JyZWN0IGRpZmZcbiAqL1xuZnVuY3Rpb24gZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMsIGZpeF91bmljb2RlKSB7XG4gIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsICcnXSk7ICAvLyBBZGQgYSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICB2YXIgcG9pbnRlciA9IDA7XG4gIHZhciBjb3VudF9kZWxldGUgPSAwO1xuICB2YXIgY291bnRfaW5zZXJ0ID0gMDtcbiAgdmFyIHRleHRfZGVsZXRlID0gJyc7XG4gIHZhciB0ZXh0X2luc2VydCA9ICcnO1xuICB2YXIgY29tbW9ubGVuZ3RoO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIGlmIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSAmJiAhZGlmZnNbcG9pbnRlcl1bMV0pIHtcbiAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuXG4gICAgICAgIGNvdW50X2luc2VydCsrO1xuICAgICAgICB0ZXh0X2luc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGNvdW50X2RlbGV0ZSsrO1xuICAgICAgICB0ZXh0X2RlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgdmFyIHByZXZpb3VzX2VxdWFsaXR5ID0gcG9pbnRlciAtIGNvdW50X2luc2VydCAtIGNvdW50X2RlbGV0ZSAtIDE7XG4gICAgICAgIGlmIChmaXhfdW5pY29kZSkge1xuICAgICAgICAgIC8vIHByZXZlbnQgc3BsaXR0aW5nIG9mIHVuaWNvZGUgc3Vycm9nYXRlIHBhaXJzLiAgd2hlbiBmaXhfdW5pY29kZSBpcyB0cnVlLFxuICAgICAgICAgIC8vIHdlIGFzc3VtZSB0aGF0IHRoZSBvbGQgYW5kIG5ldyB0ZXh0IGluIHRoZSBkaWZmIGFyZSBjb21wbGV0ZSBhbmQgY29ycmVjdFxuICAgICAgICAgIC8vIHVuaWNvZGUtZW5jb2RlZCBKUyBzdHJpbmdzLCBidXQgdGhlIHR1cGxlIGJvdW5kYXJpZXMgbWF5IGZhbGwgYmV0d2VlblxuICAgICAgICAgIC8vIHN1cnJvZ2F0ZSBwYWlycy4gIHdlIGZpeCB0aGlzIGJ5IHNoYXZpbmcgb2ZmIHN0cmF5IHN1cnJvZ2F0ZXMgZnJvbSB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHByZXZpb3VzIGVxdWFsaXR5IGFuZCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgZXF1YWxpdHkuICB0aGlzIG1heSBjcmVhdGVcbiAgICAgICAgICAvLyBlbXB0eSBlcXVhbGl0aWVzIG9yIGEgY29tbW9uIHByZWZpeCBvciBzdWZmaXguICBmb3IgZXhhbXBsZSwgaWYgQUIgYW5kIEFDIGFyZVxuICAgICAgICAgIC8vIGVtb2ppcywgYFtbMCwgJ0EnXSwgWy0xLCAnQkEnXSwgWzAsICdDJ11dYCB3b3VsZCB0dXJuIGludG8gZGVsZXRpbmcgJ0FCQUMnIGFuZFxuICAgICAgICAgIC8vIGluc2VydGluZyAnQUMnLCBhbmQgdGhlbiB0aGUgY29tbW9uIHN1ZmZpeCAnQUMnIHdpbGwgYmUgZWxpbWluYXRlZC4gIGluIHRoaXNcbiAgICAgICAgICAvLyBwYXJ0aWN1bGFyIGNhc2UsIGJvdGggZXF1YWxpdGllcyBnbyBhd2F5LCB3ZSBhYnNvcmIgYW55IHByZXZpb3VzIGluZXF1YWxpdGllcyxcbiAgICAgICAgICAvLyBhbmQgd2Uga2VlcCBzY2FubmluZyBmb3IgdGhlIG5leHQgZXF1YWxpdHkgYmVmb3JlIHJld3JpdGluZyB0aGUgdHVwbGVzLlxuICAgICAgICAgIGlmIChwcmV2aW91c19lcXVhbGl0eSA+PSAwICYmIGVuZHNfd2l0aF9wYWlyX3N0YXJ0KGRpZmZzW3ByZXZpb3VzX2VxdWFsaXR5XVsxXSkpIHtcbiAgICAgICAgICAgIHZhciBzdHJheSA9IGRpZmZzW3ByZXZpb3VzX2VxdWFsaXR5XVsxXS5zbGljZSgtMSk7XG4gICAgICAgICAgICBkaWZmc1twcmV2aW91c19lcXVhbGl0eV1bMV0gPSBkaWZmc1twcmV2aW91c19lcXVhbGl0eV1bMV0uc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgdGV4dF9kZWxldGUgPSBzdHJheSArIHRleHRfZGVsZXRlO1xuICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSBzdHJheSArIHRleHRfaW5zZXJ0O1xuICAgICAgICAgICAgaWYgKCFkaWZmc1twcmV2aW91c19lcXVhbGl0eV1bMV0pIHtcbiAgICAgICAgICAgICAgLy8gZW1wdGllZCBvdXQgcHJldmlvdXMgZXF1YWxpdHksIHNvIGRlbGV0ZSBpdCBhbmQgaW5jbHVkZSBwcmV2aW91cyBkZWxldGUvaW5zZXJ0XG4gICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwcmV2aW91c19lcXVhbGl0eSwgMSk7XG4gICAgICAgICAgICAgIHBvaW50ZXItLTtcbiAgICAgICAgICAgICAgdmFyIGsgPSBwcmV2aW91c19lcXVhbGl0eSAtIDE7XG4gICAgICAgICAgICAgIGlmIChkaWZmc1trXSAmJiBkaWZmc1trXVswXSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICAgICAgICBjb3VudF9pbnNlcnQrKztcbiAgICAgICAgICAgICAgICB0ZXh0X2luc2VydCA9IGRpZmZzW2tdWzFdICsgdGV4dF9pbnNlcnQ7XG4gICAgICAgICAgICAgICAgay0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkaWZmc1trXSAmJiBkaWZmc1trXVswXSA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUrKztcbiAgICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IGRpZmZzW2tdWzFdICsgdGV4dF9kZWxldGU7XG4gICAgICAgICAgICAgICAgay0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHByZXZpb3VzX2VxdWFsaXR5ID0gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0c193aXRoX3BhaXJfZW5kKGRpZmZzW3BvaW50ZXJdWzFdKSkge1xuICAgICAgICAgICAgdmFyIHN0cmF5ID0gZGlmZnNbcG9pbnRlcl1bMV0uY2hhckF0KDApO1xuICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyXVsxXS5zbGljZSgxKTtcbiAgICAgICAgICAgIHRleHRfZGVsZXRlICs9IHN0cmF5O1xuICAgICAgICAgICAgdGV4dF9pbnNlcnQgKz0gc3RyYXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSAmJiAhZGlmZnNbcG9pbnRlcl1bMV0pIHtcbiAgICAgICAgICAvLyBmb3IgZW1wdHkgZXF1YWxpdHkgbm90IGF0IGVuZCwgd2FpdCBmb3IgbmV4dCBlcXVhbGl0eVxuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dF9kZWxldGUubGVuZ3RoID4gMCB8fCB0ZXh0X2luc2VydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gbm90ZSB0aGF0IGRpZmZfY29tbW9uUHJlZml4IGFuZCBkaWZmX2NvbW1vblN1ZmZpeCBhcmUgdW5pY29kZS1hd2FyZVxuICAgICAgICAgIGlmICh0ZXh0X2RlbGV0ZS5sZW5ndGggPiAwICYmIHRleHRfaW5zZXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBwcmVmaXhlcy5cbiAgICAgICAgICAgIGNvbW1vbmxlbmd0aCA9IGRpZmZfY29tbW9uUHJlZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2aW91c19lcXVhbGl0eSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZGlmZnNbcHJldmlvdXNfZXF1YWxpdHldWzFdICs9IHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZSgwLCAwLCBbRElGRl9FUVVBTCwgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCldKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBzdWZmaXhlcy5cbiAgICAgICAgICAgIGNvbW1vbmxlbmd0aCA9IGRpZmZfY29tbW9uU3VmZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID1cbiAgICAgICAgICAgICAgICB0ZXh0X2luc2VydC5zdWJzdHJpbmcodGV4dF9pbnNlcnQubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSArIGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgICAgICB0ZXh0X2luc2VydCA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCB0ZXh0X2luc2VydC5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0X2RlbGV0ZS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxuICAgICAgICAgIHZhciBuID0gY291bnRfaW5zZXJ0ICsgY291bnRfZGVsZXRlO1xuICAgICAgICAgIGlmICh0ZXh0X2RlbGV0ZS5sZW5ndGggPT09IDAgJiYgdGV4dF9pbnNlcnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIG4sIG4pO1xuICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dF9kZWxldGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIG4sIG4sIFtESUZGX0lOU0VSVCwgdGV4dF9pbnNlcnRdKTtcbiAgICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gbiArIDE7XG4gICAgICAgICAgfSBlbHNlIGlmICh0ZXh0X2luc2VydC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gbiwgbiwgW0RJRkZfREVMRVRFLCB0ZXh0X2RlbGV0ZV0pO1xuICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBuICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBuLCBuLCBbRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlXSwgW0RJRkZfSU5TRVJULCB0ZXh0X2luc2VydF0pO1xuICAgICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBuICsgMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvaW50ZXIgIT09IDAgJiYgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgLy8gTWVyZ2UgdGhpcyBlcXVhbGl0eSB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRfaW5zZXJ0ID0gMDtcbiAgICAgICAgY291bnRfZGVsZXRlID0gMDtcbiAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcbiAgICAgICAgdGV4dF9pbnNlcnQgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSA9PT0gJycpIHtcbiAgICBkaWZmcy5wb3AoKTsgIC8vIFJlbW92ZSB0aGUgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cbiAgfVxuXG4gIC8vIFNlY29uZCBwYXNzOiBsb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAgLy8gd2hpY2ggY2FuIGJlIHNoaWZ0ZWQgc2lkZXdheXMgdG8gZWxpbWluYXRlIGFuIGVxdWFsaXR5LlxuICAvLyBlLmc6IEE8aW5zPkJBPC9pbnM+QyAtPiA8aW5zPkFCPC9pbnM+QUNcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcbiAgcG9pbnRlciA9IDE7XG4gIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCAmJlxuICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLVxuICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSA9PT0gZGlmZnNbcG9pbnRlciAtIDFdWzFdKSB7XG4gICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArXG4gICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKTtcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpID09XG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSkge1xuICAgICAgICAvLyBTaGlmdCB0aGUgZWRpdCBvdmVyIHRoZSBuZXh0IGVxdWFsaXR5LlxuICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9XG4gICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpICtcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgLy8gSWYgc2hpZnRzIHdlcmUgbWFkZSwgdGhlIGRpZmYgbmVlZHMgcmVvcmRlcmluZyBhbmQgYW5vdGhlciBzaGlmdCBzd2VlcC5cbiAgaWYgKGNoYW5nZXMpIHtcbiAgICBkaWZmX2NsZWFudXBNZXJnZShkaWZmcywgZml4X3VuaWNvZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpc19zdXJyb2dhdGVfcGFpcl9zdGFydChjaGFyQ29kZSkge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRjtcbn1cblxuZnVuY3Rpb24gaXNfc3Vycm9nYXRlX3BhaXJfZW5kKGNoYXJDb2RlKSB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSAweERDMDAgJiYgY2hhckNvZGUgPD0gMHhERkZGO1xufVxuXG5mdW5jdGlvbiBzdGFydHNfd2l0aF9wYWlyX2VuZChzdHIpIHtcbiAgcmV0dXJuIGlzX3N1cnJvZ2F0ZV9wYWlyX2VuZChzdHIuY2hhckNvZGVBdCgwKSk7XG59XG5cbmZ1bmN0aW9uIGVuZHNfd2l0aF9wYWlyX3N0YXJ0KHN0cikge1xuICByZXR1cm4gaXNfc3Vycm9nYXRlX3BhaXJfc3RhcnQoc3RyLmNoYXJDb2RlQXQoc3RyLmxlbmd0aCAtIDEpKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlX2VtcHR5X3R1cGxlcyh0dXBsZXMpIHtcbiAgdmFyIHJldCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHR1cGxlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0dXBsZXNbaV1bMV0ubGVuZ3RoID4gMCkge1xuICAgICAgcmV0LnB1c2godHVwbGVzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gbWFrZV9lZGl0X3NwbGljZShiZWZvcmUsIG9sZE1pZGRsZSwgbmV3TWlkZGxlLCBhZnRlcikge1xuICBpZiAoZW5kc193aXRoX3BhaXJfc3RhcnQoYmVmb3JlKSB8fCBzdGFydHNfd2l0aF9wYWlyX2VuZChhZnRlcikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcmVtb3ZlX2VtcHR5X3R1cGxlcyhbXG4gICAgW0RJRkZfRVFVQUwsIGJlZm9yZV0sXG4gICAgW0RJRkZfREVMRVRFLCBvbGRNaWRkbGVdLFxuICAgIFtESUZGX0lOU0VSVCwgbmV3TWlkZGxlXSxcbiAgICBbRElGRl9FUVVBTCwgYWZ0ZXJdXG4gIF0pO1xufVxuXG5mdW5jdGlvbiBmaW5kX2N1cnNvcl9lZGl0X2RpZmYob2xkVGV4dCwgbmV3VGV4dCwgY3Vyc29yX3Bvcykge1xuICAvLyBub3RlOiB0aGlzIHJ1bnMgYWZ0ZXIgZXF1YWxpdHkgY2hlY2sgaGFzIHJ1bGVkIG91dCBleGFjdCBlcXVhbGl0eVxuICB2YXIgb2xkUmFuZ2UgPSB0eXBlb2YgY3Vyc29yX3BvcyA9PT0gJ251bWJlcicgP1xuICAgIHsgaW5kZXg6IGN1cnNvcl9wb3MsIGxlbmd0aDogMCB9IDogY3Vyc29yX3Bvcy5vbGRSYW5nZTtcbiAgdmFyIG5ld1JhbmdlID0gdHlwZW9mIGN1cnNvcl9wb3MgPT09ICdudW1iZXInID9cbiAgICBudWxsIDogY3Vyc29yX3Bvcy5uZXdSYW5nZTtcbiAgLy8gdGFrZSBpbnRvIGFjY291bnQgdGhlIG9sZCBhbmQgbmV3IHNlbGVjdGlvbiB0byBnZW5lcmF0ZSB0aGUgYmVzdCBkaWZmXG4gIC8vIHBvc3NpYmxlIGZvciBhIHRleHQgZWRpdC4gIGZvciBleGFtcGxlLCBhIHRleHQgY2hhbmdlIGZyb20gXCJ4eHhcIiB0byBcInh4XCJcbiAgLy8gY291bGQgYmUgYSBkZWxldGUgb3IgZm9yd2FyZHMtZGVsZXRlIG9mIGFueSBvbmUgb2YgdGhlIHgncywgb3IgdGhlXG4gIC8vIHJlc3VsdCBvZiBzZWxlY3RpbmcgdHdvIG9mIHRoZSB4J3MgYW5kIHR5cGluZyBcInhcIi5cbiAgdmFyIG9sZExlbmd0aCA9IG9sZFRleHQubGVuZ3RoO1xuICB2YXIgbmV3TGVuZ3RoID0gbmV3VGV4dC5sZW5ndGg7XG4gIGlmIChvbGRSYW5nZS5sZW5ndGggPT09IDAgJiYgKG5ld1JhbmdlID09PSBudWxsIHx8IG5ld1JhbmdlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAvLyBzZWUgaWYgd2UgaGF2ZSBhbiBpbnNlcnQgb3IgZGVsZXRlIGJlZm9yZSBvciBhZnRlciBjdXJzb3JcbiAgICB2YXIgb2xkQ3Vyc29yID0gb2xkUmFuZ2UuaW5kZXg7XG4gICAgdmFyIG9sZEJlZm9yZSA9IG9sZFRleHQuc2xpY2UoMCwgb2xkQ3Vyc29yKTtcbiAgICB2YXIgb2xkQWZ0ZXIgPSBvbGRUZXh0LnNsaWNlKG9sZEN1cnNvcik7XG4gICAgdmFyIG1heWJlTmV3Q3Vyc29yID0gbmV3UmFuZ2UgPyBuZXdSYW5nZS5pbmRleCA6IG51bGw7XG4gICAgZWRpdEJlZm9yZToge1xuICAgICAgLy8gaXMgdGhpcyBhbiBpbnNlcnQgb3IgZGVsZXRlIHJpZ2h0IGJlZm9yZSBvbGRDdXJzb3I/XG4gICAgICB2YXIgbmV3Q3Vyc29yID0gb2xkQ3Vyc29yICsgbmV3TGVuZ3RoIC0gb2xkTGVuZ3RoO1xuICAgICAgaWYgKG1heWJlTmV3Q3Vyc29yICE9PSBudWxsICYmIG1heWJlTmV3Q3Vyc29yICE9PSBuZXdDdXJzb3IpIHtcbiAgICAgICAgYnJlYWsgZWRpdEJlZm9yZTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdDdXJzb3IgPCAwIHx8IG5ld0N1cnNvciA+IG5ld0xlbmd0aCkge1xuICAgICAgICBicmVhayBlZGl0QmVmb3JlO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0JlZm9yZSA9IG5ld1RleHQuc2xpY2UoMCwgbmV3Q3Vyc29yKTtcbiAgICAgIHZhciBuZXdBZnRlciA9IG5ld1RleHQuc2xpY2UobmV3Q3Vyc29yKTtcbiAgICAgIGlmIChuZXdBZnRlciAhPT0gb2xkQWZ0ZXIpIHtcbiAgICAgICAgYnJlYWsgZWRpdEJlZm9yZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcmVmaXhMZW5ndGggPSBNYXRoLm1pbihvbGRDdXJzb3IsIG5ld0N1cnNvcik7XG4gICAgICB2YXIgb2xkUHJlZml4ID0gb2xkQmVmb3JlLnNsaWNlKDAsIHByZWZpeExlbmd0aCk7XG4gICAgICB2YXIgbmV3UHJlZml4ID0gbmV3QmVmb3JlLnNsaWNlKDAsIHByZWZpeExlbmd0aCk7XG4gICAgICBpZiAob2xkUHJlZml4ICE9PSBuZXdQcmVmaXgpIHtcbiAgICAgICAgYnJlYWsgZWRpdEJlZm9yZTtcbiAgICAgIH1cbiAgICAgIHZhciBvbGRNaWRkbGUgPSBvbGRCZWZvcmUuc2xpY2UocHJlZml4TGVuZ3RoKTtcbiAgICAgIHZhciBuZXdNaWRkbGUgPSBuZXdCZWZvcmUuc2xpY2UocHJlZml4TGVuZ3RoKTtcbiAgICAgIHJldHVybiBtYWtlX2VkaXRfc3BsaWNlKG9sZFByZWZpeCwgb2xkTWlkZGxlLCBuZXdNaWRkbGUsIG9sZEFmdGVyKTtcbiAgICB9XG4gICAgZWRpdEFmdGVyOiB7XG4gICAgICAvLyBpcyB0aGlzIGFuIGluc2VydCBvciBkZWxldGUgcmlnaHQgYWZ0ZXIgb2xkQ3Vyc29yP1xuICAgICAgaWYgKG1heWJlTmV3Q3Vyc29yICE9PSBudWxsICYmIG1heWJlTmV3Q3Vyc29yICE9PSBvbGRDdXJzb3IpIHtcbiAgICAgICAgYnJlYWsgZWRpdEFmdGVyO1xuICAgICAgfVxuICAgICAgdmFyIGN1cnNvciA9IG9sZEN1cnNvcjtcbiAgICAgIHZhciBuZXdCZWZvcmUgPSBuZXdUZXh0LnNsaWNlKDAsIGN1cnNvcik7XG4gICAgICB2YXIgbmV3QWZ0ZXIgPSBuZXdUZXh0LnNsaWNlKGN1cnNvcik7XG4gICAgICBpZiAobmV3QmVmb3JlICE9PSBvbGRCZWZvcmUpIHtcbiAgICAgICAgYnJlYWsgZWRpdEFmdGVyO1xuICAgICAgfVxuICAgICAgdmFyIHN1ZmZpeExlbmd0aCA9IE1hdGgubWluKG9sZExlbmd0aCAtIGN1cnNvciwgbmV3TGVuZ3RoIC0gY3Vyc29yKTtcbiAgICAgIHZhciBvbGRTdWZmaXggPSBvbGRBZnRlci5zbGljZShvbGRBZnRlci5sZW5ndGggLSBzdWZmaXhMZW5ndGgpO1xuICAgICAgdmFyIG5ld1N1ZmZpeCA9IG5ld0FmdGVyLnNsaWNlKG5ld0FmdGVyLmxlbmd0aCAtIHN1ZmZpeExlbmd0aCk7XG4gICAgICBpZiAob2xkU3VmZml4ICE9PSBuZXdTdWZmaXgpIHtcbiAgICAgICAgYnJlYWsgZWRpdEFmdGVyO1xuICAgICAgfVxuICAgICAgdmFyIG9sZE1pZGRsZSA9IG9sZEFmdGVyLnNsaWNlKDAsIG9sZEFmdGVyLmxlbmd0aCAtIHN1ZmZpeExlbmd0aCk7XG4gICAgICB2YXIgbmV3TWlkZGxlID0gbmV3QWZ0ZXIuc2xpY2UoMCwgbmV3QWZ0ZXIubGVuZ3RoIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgIHJldHVybiBtYWtlX2VkaXRfc3BsaWNlKG9sZEJlZm9yZSwgb2xkTWlkZGxlLCBuZXdNaWRkbGUsIG9sZFN1ZmZpeCk7XG4gICAgfVxuICB9XG4gIGlmIChvbGRSYW5nZS5sZW5ndGggPiAwICYmIG5ld1JhbmdlICYmIG5ld1JhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJlcGxhY2VSYW5nZToge1xuICAgICAgLy8gc2VlIGlmIGRpZmYgY291bGQgYmUgYSBzcGxpY2Ugb2YgdGhlIG9sZCBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgIHZhciBvbGRQcmVmaXggPSBvbGRUZXh0LnNsaWNlKDAsIG9sZFJhbmdlLmluZGV4KTtcbiAgICAgIHZhciBvbGRTdWZmaXggPSBvbGRUZXh0LnNsaWNlKG9sZFJhbmdlLmluZGV4ICsgb2xkUmFuZ2UubGVuZ3RoKTtcbiAgICAgIHZhciBwcmVmaXhMZW5ndGggPSBvbGRQcmVmaXgubGVuZ3RoO1xuICAgICAgdmFyIHN1ZmZpeExlbmd0aCA9IG9sZFN1ZmZpeC5sZW5ndGg7XG4gICAgICBpZiAobmV3TGVuZ3RoIDwgcHJlZml4TGVuZ3RoICsgc3VmZml4TGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrIHJlcGxhY2VSYW5nZTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdQcmVmaXggPSBuZXdUZXh0LnNsaWNlKDAsIHByZWZpeExlbmd0aCk7XG4gICAgICB2YXIgbmV3U3VmZml4ID0gbmV3VGV4dC5zbGljZShuZXdMZW5ndGggLSBzdWZmaXhMZW5ndGgpO1xuICAgICAgaWYgKG9sZFByZWZpeCAhPT0gbmV3UHJlZml4IHx8IG9sZFN1ZmZpeCAhPT0gbmV3U3VmZml4KSB7XG4gICAgICAgIGJyZWFrIHJlcGxhY2VSYW5nZTtcbiAgICAgIH1cbiAgICAgIHZhciBvbGRNaWRkbGUgPSBvbGRUZXh0LnNsaWNlKHByZWZpeExlbmd0aCwgb2xkTGVuZ3RoIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgIHZhciBuZXdNaWRkbGUgPSBuZXdUZXh0LnNsaWNlKHByZWZpeExlbmd0aCwgbmV3TGVuZ3RoIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgIHJldHVybiBtYWtlX2VkaXRfc3BsaWNlKG9sZFByZWZpeCwgb2xkTWlkZGxlLCBuZXdNaWRkbGUsIG9sZFN1ZmZpeCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRpZmYodGV4dDEsIHRleHQyLCBjdXJzb3JfcG9zKSB7XG4gIC8vIG9ubHkgcGFzcyBmaXhfdW5pY29kZT10cnVlIGF0IHRoZSB0b3AgbGV2ZWwsIG5vdCB3aGVuIGRpZmZfbWFpbiBpc1xuICAvLyByZWN1cnNpdmVseSBpbnZva2VkXG4gIHJldHVybiBkaWZmX21haW4odGV4dDEsIHRleHQyLCBjdXJzb3JfcG9zLCB0cnVlKTtcbn1cblxuZGlmZi5JTlNFUlQgPSBESUZGX0lOU0VSVDtcbmRpZmYuREVMRVRFID0gRElGRl9ERUxFVEU7XG5kaWZmLkVRVUFMID0gRElGRl9FUVVBTDtcblxubW9kdWxlLmV4cG9ydHMgPSBkaWZmO1xuXG5cbi8qKiovIH0pLFxuLyogMTE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9kYXNoX2Nsb25lZGVlcF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTgpKTtcbnZhciBsb2Rhc2hfaXNlcXVhbF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjkpKTtcbnZhciBBdHRyaWJ1dGVNYXA7XG4oZnVuY3Rpb24gKEF0dHJpYnV0ZU1hcCkge1xuICAgIGZ1bmN0aW9uIGNvbXBvc2UoYSwgYiwga2VlcE51bGwpIHtcbiAgICAgICAgaWYgKGEgPT09IHZvaWQgMCkgeyBhID0ge307IH1cbiAgICAgICAgaWYgKGIgPT09IHZvaWQgMCkgeyBiID0ge307IH1cbiAgICAgICAgaWYgKHR5cGVvZiBhICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGIgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGxvZGFzaF9jbG9uZWRlZXBfMS5kZWZhdWx0KGIpO1xuICAgICAgICBpZiAoIWtlZXBOdWxsKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykucmVkdWNlKGZ1bmN0aW9uIChjb3B5LCBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc1trZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29weTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICAgICAgaWYgKGFba2V5XSAhPT0gdW5kZWZpbmVkICYmIGJba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gYVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwID8gYXR0cmlidXRlcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgQXR0cmlidXRlTWFwLmNvbXBvc2UgPSBjb21wb3NlO1xuICAgIGZ1bmN0aW9uIGRpZmYoYSwgYikge1xuICAgICAgICBpZiAoYSA9PT0gdm9pZCAwKSB7IGEgPSB7fTsgfVxuICAgICAgICBpZiAoYiA9PT0gdm9pZCAwKSB7IGIgPSB7fTsgfVxuICAgICAgICBpZiAodHlwZW9mIGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYiA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoYSlcbiAgICAgICAgICAgIC5jb25jYXQoT2JqZWN0LmtleXMoYikpXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhdHRycywga2V5KSB7XG4gICAgICAgICAgICBpZiAoIWxvZGFzaF9pc2VxdWFsXzEuZGVmYXVsdChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gYltrZXldID09PSB1bmRlZmluZWQgPyBudWxsIDogYltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwID8gYXR0cmlidXRlcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgQXR0cmlidXRlTWFwLmRpZmYgPSBkaWZmO1xuICAgIGZ1bmN0aW9uIGludmVydChhdHRyLCBiYXNlKSB7XG4gICAgICAgIGlmIChhdHRyID09PSB2b2lkIDApIHsgYXR0ciA9IHt9OyB9XG4gICAgICAgIGlmIChiYXNlID09PSB2b2lkIDApIHsgYmFzZSA9IHt9OyB9XG4gICAgICAgIGF0dHIgPSBhdHRyIHx8IHt9O1xuICAgICAgICB2YXIgYmFzZUludmVydGVkID0gT2JqZWN0LmtleXMoYmFzZSkucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBrZXkpIHtcbiAgICAgICAgICAgIGlmIChiYXNlW2tleV0gIT09IGF0dHJba2V5XSAmJiBhdHRyW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGJhc2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhdHRyKS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGtleSkge1xuICAgICAgICAgICAgaWYgKGF0dHJba2V5XSAhPT0gYmFzZVtrZXldICYmIGJhc2Vba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVtb1trZXldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9LCBiYXNlSW52ZXJ0ZWQpO1xuICAgIH1cbiAgICBBdHRyaWJ1dGVNYXAuaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShhLCBiLCBwcmlvcml0eSkge1xuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkgeyBwcmlvcml0eSA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGI7IC8vIGIgc2ltcGx5IG92ZXJ3cml0ZXMgdXMgd2l0aG91dCBwcmlvcml0eVxuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoYikucmVkdWNlKGZ1bmN0aW9uIChhdHRycywga2V5KSB7XG4gICAgICAgICAgICBpZiAoYVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gYltrZXldOyAvLyBudWxsIGlzIGEgdmFsaWQgdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdHRycztcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCA/IGF0dHJpYnV0ZXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIEF0dHJpYnV0ZU1hcC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG59KShBdHRyaWJ1dGVNYXAgfHwgKEF0dHJpYnV0ZU1hcCA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBdHRyaWJ1dGVNYXA7XG5cblxuLyoqKi8gfSksXG4vKiAxMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBPcF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOTApKTtcbnZhciBJdGVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJdGVyYXRvcihvcHMpIHtcbiAgICAgICAgdGhpcy5vcHMgPSBvcHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgfVxuICAgIEl0ZXJhdG9yLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZWVrTGVuZ3RoKCkgPCBJbmZpbml0eTtcbiAgICB9O1xuICAgIEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRPcCA9IHRoaXMub3BzW3RoaXMuaW5kZXhdO1xuICAgICAgICBpZiAobmV4dE9wKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICB2YXIgb3BMZW5ndGggPSBPcF8xLmRlZmF1bHQubGVuZ3RoKG5leHRPcCk7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID49IG9wTGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gb3BMZW5ndGggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV4dE9wLmRlbGV0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkZWxldGU6IGxlbmd0aCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldE9wID0ge307XG4gICAgICAgICAgICAgICAgaWYgKG5leHRPcC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldE9wLmF0dHJpYnV0ZXMgPSBuZXh0T3AuYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXh0T3AucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXRPcC5yZXRhaW4gPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBuZXh0T3AuaW5zZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXRPcC5pbnNlcnQgPSBuZXh0T3AuaW5zZXJ0LnN1YnN0cihvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQgc2hvdWxkID09PSAwLCBsZW5ndGggc2hvdWxkID09PSAxXG4gICAgICAgICAgICAgICAgICAgIHJldE9wLmluc2VydCA9IG5leHRPcC5pbnNlcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXRPcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJldGFpbjogSW5maW5pdHkgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSXRlcmF0b3IucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wc1t0aGlzLmluZGV4XTtcbiAgICB9O1xuICAgIEl0ZXJhdG9yLnByb3RvdHlwZS5wZWVrTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcHNbdGhpcy5pbmRleF0pIHtcbiAgICAgICAgICAgIC8vIFNob3VsZCBuZXZlciByZXR1cm4gMCBpZiBvdXIgaW5kZXggaXMgYmVpbmcgbWFuYWdlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgIHJldHVybiBPcF8xLmRlZmF1bHQubGVuZ3RoKHRoaXMub3BzW3RoaXMuaW5kZXhdKSAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJdGVyYXRvci5wcm90b3R5cGUucGVla1R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wc1t0aGlzLmluZGV4XSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wc1t0aGlzLmluZGV4XS5kZWxldGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkZWxldGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMub3BzW3RoaXMuaW5kZXhdLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JldGFpbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2luc2VydCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdyZXRhaW4nO1xuICAgIH07XG4gICAgSXRlcmF0b3IucHJvdG90eXBlLnJlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BzLnNsaWNlKHRoaXMuaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB2YXIgcmVzdCA9IHRoaXMub3BzLnNsaWNlKHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gW25leHRdLmNvbmNhdChyZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEl0ZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEl0ZXJhdG9yO1xuXG5cbi8qKiovIH0pLFxuLyogMTE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXJlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuXG5cbi8qKiovIH0pLFxuLyogMTE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXJlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuXG5cbi8qKiovIH0pLFxuLyogMTE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMTIwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTQzKTtcbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguQXJyYXkuZnJvbTtcblxuXG4vKioqLyB9KSxcbi8qIDEyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNoYXJBdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIxKS5jaGFyQXQ7XG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nik7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyOSk7XG5cbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5kZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICAgIHN0cmluZzogdG9TdHJpbmcoaXRlcmF0ZWQpLFxuICAgIGluZGV4OiAwXG4gIH0pO1xuLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cblxuLyoqKi8gfSksXG4vKiAxMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xuXG52YXIgY2hhckF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcbnZhciBjaGFyQ29kZUF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckNvZGVBdCk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoQ09OVkVSVF9UT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgcG9zKSB7XG4gICAgdmFyIFMgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyT3JJbmZpbml0eShwb3MpO1xuICAgIHZhciBzaXplID0gUy5sZW5ndGg7XG4gICAgdmFyIGZpcnN0LCBzZWNvbmQ7XG4gICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBzaXplKSByZXR1cm4gQ09OVkVSVF9UT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBmaXJzdCA9IGNoYXJDb2RlQXQoUywgcG9zaXRpb24pO1xuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcbiAgICAgIHx8IChzZWNvbmQgPSBjaGFyQ29kZUF0KFMsIHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HXG4gICAgICAgICAgPyBjaGFyQXQoUywgcG9zaXRpb24pXG4gICAgICAgICAgOiBmaXJzdFxuICAgICAgICA6IENPTlZFUlRfVE9fU1RSSU5HXG4gICAgICAgICAgPyBzdHJpbmdTbGljZShTLCBwb3NpdGlvbiwgcG9zaXRpb24gKyAyKVxuICAgICAgICAgIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDEyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmcodGVzdCkgPT09ICdbb2JqZWN0IHpdJztcblxuXG4vKioqLyB9KSxcbi8qIDEyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgdXNlckFnZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjQpO1xuXG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIERlbm8gPSBnbG9iYWwuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucyB8fCBEZW5vICYmIERlbm8udmVyc2lvbjtcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICAvLyBpbiBvbGQgQ2hyb21lLCB2ZXJzaW9ucyBvZiBWOCBpc24ndCBWOCA9IENocm9tZSAvIDEwXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXG4gIHZlcnNpb24gPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG59XG5cbi8vIEJyb3dzZXJGUyBOb2RlSlMgYHByb2Nlc3NgIHBvbHlmaWxsIGluY29ycmVjdGx5IHNldCBgLnY4YCB0byBgMC4wYFxuLy8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVyc2lvbjtcblxuXG4vKioqLyB9KSxcbi8qIDEyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcblxuXG4vKioqLyB9KSxcbi8qIDEyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xudmFyIGluc3BlY3RTb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0NhbGxhYmxlKFdlYWtNYXApICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlKFdlYWtNYXApKTtcblxuXG4vKioqLyB9KSxcbi8qIDEyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KTtcbnZhciBnZXRNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKTtcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjgpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0KGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZChpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbChleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkgfHwgaXNTeW1ib2wocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuY3VycnlUaGlzKHt9LmlzUHJvdG90eXBlT2YpO1xuXG5cbi8qKiovIH0pLFxuLyogMTI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG5cbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuXG4vLyBgT3JkaW5hcnlUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0KHZhbCA9IGNhbGwoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcbnZhciBGdW5jdGlvbk5hbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMik7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOCk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MSk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2KTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcbnZhciBJdGVyYXRvcnNDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDYpO1xuXG52YXIgUFJPUEVSX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIGlmICghSVNfUFVSRSAmJiBnZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICBzZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNDYWxsYWJsZShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdKSkge1xuICAgICAgICAgIHJlZGVmaW5lKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUsIHRydWUpO1xuICAgICAgaWYgKElTX1BVUkUpIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gICAgfVxuICB9XG5cbiAgLy8gZml4IEFycmF5LnByb3RvdHlwZS57IHZhbHVlcywgQEBpdGVyYXRvciB9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoUFJPUEVSX0ZVTkNUSU9OX05BTUUgJiYgREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgaWYgKCFJU19QVVJFICYmIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmFibGVQcm90b3R5cGUsICduYW1lJywgVkFMVUVTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcbiAgICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIGNhbGwobmF0aXZlSXRlcmF0b3IsIHRoaXMpOyB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICByZWRlZmluZShJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSAkKHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoKCFJU19QVVJFIHx8IEZPUkNFRCkgJiYgSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgICByZWRlZmluZShJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IsIGRlZmF1bHRJdGVyYXRvciwgeyBuYW1lOiBERUZBVUxUIH0pO1xuICB9XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcblxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OCk7XG5cbnZhciBPYmplY3QgPSBnbG9iYWwuT2JqZWN0O1xudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMoJycuc3BsaXQpO1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdChpdCwgJycpIDogT2JqZWN0KGl0KTtcbn0gOiBPYmplY3Q7XG5cblxuLyoqKi8gfSksXG4vKiAxMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xudmFyIG93bktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMik7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NSk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzUpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTAzKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDEzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDQpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKioqLyB9KSxcbi8qIDEzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogaXNDYWxsYWJsZShkZXRlY3Rpb24pID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG5cblxuLyoqKi8gfSksXG4vKiAxMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTA2KS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5KTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTA5KTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcbnZhciBvYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDcpO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0KFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxuXG4vKioqLyB9KSxcbi8qIDE0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuLyogMTQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDIpO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gICAgc2V0dGVyID0gdW5jdXJyeVRoaXMoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0KTtcbiAgICBzZXR0ZXIodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0KE8pO1xuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG5cblxuLyoqKi8gfSksXG4vKiAxNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblxudmFyIFN0cmluZyA9IGdsb2JhbC5TdHJpbmc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudCA9PSAnb2JqZWN0JyB8fCBpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyBTdHJpbmcoYXJndW1lbnQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xudmFyIGZyb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0NCk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTIpO1xuXG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1mcm9tIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmFibGUpO1xufSk7XG5cbi8vIGBBcnJheS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxuJCh7IHRhcmdldDogJ0FycmF5Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfSVRFUkFUSU9OIH0sIHtcbiAgZnJvbTogZnJvbVxufSk7XG5cblxuLyoqKi8gfSksXG4vKiAxNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDUpO1xudmFyIGNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0Nik7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDgpO1xudmFyIGlzQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0OSk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3KTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUwKTtcbnZhciBnZXRJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTUxKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwKTtcblxudmFyIEFycmF5ID0gZ2xvYmFsLkFycmF5O1xuXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gIHZhciBJU19DT05TVFJVQ1RPUiA9IGlzQ29uc3RydWN0b3IodGhpcyk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIGlmIChtYXBwaW5nKSBtYXBmbiA9IGJpbmQobWFwZm4sIGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChPKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dCwgdmFsdWU7XG4gIC8vIGlmIHRoZSB0YXJnZXQgaXMgbm90IGl0ZXJhYmxlIG9yIGl0J3MgYW4gYXJyYXkgd2l0aCB0aGUgZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBhIHNpbXBsZSBjYXNlXG4gIGlmIChpdGVyYXRvck1ldGhvZCAmJiAhKHRoaXMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkpIHtcbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKE8sIGl0ZXJhdG9yTWV0aG9kKTtcbiAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgICByZXN1bHQgPSBJU19DT05TVFJVQ1RPUiA/IG5ldyB0aGlzKCkgOiBbXTtcbiAgICBmb3IgKDshKHN0ZXAgPSBjYWxsKG5leHQsIGl0ZXJhdG9yKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgcmVzdWx0ID0gSVNfQ09OU1RSVUNUT1IgPyBuZXcgdGhpcyhsZW5ndGgpIDogQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODIpO1xuXG52YXIgYmluZCA9IHVuY3VycnlUaGlzKHVuY3VycnlUaGlzLmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZShmbik7XG4gIHJldHVybiB0aGF0ID09PSB1bmRlZmluZWQgPyBmbiA6IGJpbmQgPyBiaW5kKGZuLCB0aGF0KSA6IGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0Nyk7XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDE0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG52YXIgZ2V0TWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBraW5kLCB2YWx1ZSkge1xuICB2YXIgaW5uZXJSZXN1bHQsIGlubmVyRXJyb3I7XG4gIGFuT2JqZWN0KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xuICAgIGlmICghaW5uZXJSZXN1bHQpIHtcbiAgICAgIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaW5uZXJSZXN1bHQgPSBjYWxsKGlubmVyUmVzdWx0LCBpdGVyYXRvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW5uZXJFcnJvciA9IHRydWU7XG4gICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgfVxuICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gIGlmIChpbm5lckVycm9yKSB0aHJvdyBpbm5lclJlc3VsdDtcbiAgYW5PYmplY3QoaW5uZXJSZXN1bHQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZVtJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcbnZhciBpbnNwZWN0U291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OSk7XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIGVtcHR5ID0gW107XG52YXIgY29uc3RydWN0ID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi87XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKGNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMpO1xudmFyIElOQ09SUkVDVF9UT19TVFJJTkcgPSAhY29uc3RydWN0b3JSZWdFeHAuZXhlYyhub29wKTtcblxudmFyIGlzQ29uc3RydWN0b3JNb2Rlcm4gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0cnVjdChub29wLCBlbXB0eSwgYXJndW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGlzQ29uc3RydWN0b3JMZWdhY3kgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKGNsYXNzb2YoYXJndW1lbnQpKSB7XG4gICAgY2FzZSAnQXN5bmNGdW5jdGlvbic6XG4gICAgY2FzZSAnR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nOiByZXR1cm4gZmFsc2U7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICB9IHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZShhcmd1bWVudCkpO1xufTtcblxuLy8gYElzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXG5tb2R1bGUuZXhwb3J0cyA9ICFjb25zdHJ1Y3QgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGVkO1xuICByZXR1cm4gaXNDb25zdHJ1Y3Rvck1vZGVybihpc0NvbnN0cnVjdG9yTW9kZXJuLmNhbGwpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZTsgfSlcbiAgICB8fCBjYWxsZWQ7XG59KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xuXG5cbi8qKiovIH0pLFxuLyogMTUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oODApO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE1MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG52YXIgdHJ5VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMCk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMCk7XG5cbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCwgdXNpbmdJdGVyYXRvcikge1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGdldEl0ZXJhdG9yTWV0aG9kKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gIGlmIChhQ2FsbGFibGUoaXRlcmF0b3JNZXRob2QpKSByZXR1cm4gYW5PYmplY3QoY2FsbChpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcbiAgdGhyb3cgVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTUyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1mcm9tLCBuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcbiAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgb2JqZWN0W0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4ZWMob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXJlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuXG5cbi8qKiovIH0pLFxuLyogMTU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXJlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuXG5cbi8qKiovIH0pLFxuLyogMTU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMTU2KTtcbnZhciBlbnRyeVVuYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVVuYmluZCgnQXJyYXknLCAnZmlsbCcpO1xuXG5cbi8qKiovIH0pLFxuLyogMTU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XG52YXIgZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTU3KTtcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTgpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZpbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsbFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuICBmaWxsOiBmaWxsXG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygnZmlsbCcpO1xuXG5cbi8qKiovIH0pLFxuLyogMTU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNCk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3KTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWxsYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbGxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCk7XG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oODkpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG5cbnZhciBVTlNDT1BBQkxFUyA9IHdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5pZiAoQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkge1xuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKEFycmF5UHJvdG90eXBlLCBVTlNDT1BBQkxFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogY3JlYXRlKG51bGwpXG4gIH0pO1xufVxuXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE1OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGFyZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcblxuXG4vKioqLyB9KSxcbi8qIDE2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGFyZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcblxuXG4vKioqLyB9KSxcbi8qIDE2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE2Mik7XG52YXIgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTExKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLk9iamVjdC52YWx1ZXM7XG5cblxuLyoqKi8gfSksXG4vKiAxNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcbnZhciAkdmFsdWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjMpLnZhbHVlcztcblxuLy8gYE9iamVjdC52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QudmFsdWVzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKE8pIHtcbiAgICByZXR1cm4gJHZhbHVlcyhPKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG4vKiAxNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcbnZhciBvYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDcpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTAxKS5mO1xuXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSB1bmN1cnJ5VGhpcygkcHJvcGVydHlJc0VudW1lcmFibGUpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxuLy8gYE9iamVjdC57IGVudHJpZXMsIHZhbHVlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRPX0VOVFJJRVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaSkge1xuICAgICAga2V5ID0ga2V5c1tpKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBwcm9wZXJ0eUlzRW51bWVyYWJsZShPLCBrZXkpKSB7XG4gICAgICAgIHB1c2gocmVzdWx0LCBUT19FTlRSSUVTID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYE9iamVjdC5lbnRyaWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZW50cmllc1xuICBlbnRyaWVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBPYmplY3QudmFsdWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QudmFsdWVzXG4gIHZhbHVlczogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDE2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGFyZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcblxuXG4vKioqLyB9KSxcbi8qIDE2NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGFyZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcblxuXG4vKioqLyB9KSxcbi8qIDE2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE2Nyk7XG52YXIgZW50cnlVbmJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMik7XG5cbm1vZHVsZS5leHBvcnRzID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdlbmRzV2l0aCcpO1xuXG5cbi8qKiovIH0pLFxuLyogMTY3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xudmFyIHVuY3VycnlUaGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NSkuZjtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTA1KTtcbnZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xudmFyIG5vdEFSZWdFeHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OCk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xudmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzApO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXN0cmluZy1wcm90b3R5cGUtZW5kc3dpdGggLS0gc2FmZVxudmFyIHVuJEVuZHNXaXRoID0gdW5jdXJyeVRoaXMoJycuZW5kc1dpdGgpO1xudmFyIHNsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xudmFyIG1pbiA9IE1hdGgubWluO1xuXG52YXIgQ09SUkVDVF9JU19SRUdFWFBfTE9HSUMgPSBjb3JyZWN0SXNSZWdFeHBMb2dpYygnZW5kc1dpdGgnKTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL3B1bGwvNzAyXG52YXIgTUROX1BPTFlGSUxMX0JVRyA9ICFJU19QVVJFICYmICFDT1JSRUNUX0lTX1JFR0VYUF9MT0dJQyAmJiAhIWZ1bmN0aW9uICgpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoU3RyaW5nLnByb3RvdHlwZSwgJ2VuZHNXaXRoJyk7XG4gIHJldHVybiBkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLndyaXRhYmxlO1xufSgpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuZW5kc3dpdGhcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhTUROX1BPTFlGSUxMX0JVRyAmJiAhQ09SUkVDVF9JU19SRUdFWFBfTE9HSUMgfSwge1xuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgZW5kUG9zaXRpb24gPSBAbGVuZ3RoICovKSB7XG4gICAgdmFyIHRoYXQgPSB0b1N0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKTtcbiAgICBub3RBUmVnRXhwKHNlYXJjaFN0cmluZyk7XG4gICAgdmFyIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxlbiA9IHRoYXQubGVuZ3RoO1xuICAgIHZhciBlbmQgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogbWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKTtcbiAgICB2YXIgc2VhcmNoID0gdG9TdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gdW4kRW5kc1dpdGhcbiAgICAgID8gdW4kRW5kc1dpdGgodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHNsaWNlKHRoYXQsIGVuZCAtIHNlYXJjaC5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG4vKiAxNjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIGlzUmVnRXhwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjkpO1xuXG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzUmVnRXhwKGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIlRoZSBtZXRob2QgZG9lc24ndCBhY2NlcHQgcmVndWxhciBleHByZXNzaW9uc1wiKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTY5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xuXG4vLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY2xhc3NvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCgnbWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgdmFyIHJlZ2V4cCA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiBmYWxzZTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNzEgKi8sXG4vKiAxNzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMyk7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pW1wiZGVmYXVsdFwiXTtcbn0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme-quill/dist/dx-quill.js\n");

/***/ }),

/***/ "./node_modules/devextreme-vue/html-editor.js":
/*!****************************************************!*\
  !*** ./node_modules/devextreme-vue/html-editor.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * devextreme-vue\n * Version: 21.2.7\n * Build date: Mon Apr 11 2022\n *\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\n *\n * This software may be modified and distributed under the terms\n * of the MIT license. See the LICENSE file in the root of the project for details.\n *\n * https://github.com/DevExpress/devextreme-vue\n */\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DxVariables = exports.DxToolbarItem = exports.DxToolbar = exports.DxTableResizing = exports.DxTableContextMenuItem = exports.DxTableContextMenu = exports.DxMention = exports.DxMediaResizing = exports.DxItem = exports.DxHtmlEditor = void 0;\nvar html_editor_1 = __importDefault(__webpack_require__(/*! devextreme/ui/html_editor */ \"./node_modules/devextreme/esm/ui/html_editor.js\"));\nvar index_1 = __webpack_require__(/*! ./core/index */ \"./node_modules/devextreme-vue/core/index.js\");\nvar index_2 = __webpack_require__(/*! ./core/index */ \"./node_modules/devextreme-vue/core/index.js\");\nvar DxHtmlEditor = index_1.createComponent({\n    props: {\n        accessKey: String,\n        activeStateEnabled: Boolean,\n        allowSoftLineBreak: Boolean,\n        customizeModules: Function,\n        disabled: Boolean,\n        elementAttr: Object,\n        focusStateEnabled: Boolean,\n        height: [Function, Number, String],\n        hint: String,\n        hoverStateEnabled: Boolean,\n        isValid: Boolean,\n        mediaResizing: Object,\n        mentions: Array,\n        name: String,\n        onContentReady: Function,\n        onDisposing: Function,\n        onFocusIn: Function,\n        onFocusOut: Function,\n        onInitialized: Function,\n        onOptionChanged: Function,\n        onValueChanged: Function,\n        placeholder: String,\n        readOnly: Boolean,\n        rtlEnabled: Boolean,\n        stylingMode: String,\n        tabIndex: Number,\n        tableContextMenu: Object,\n        tableResizing: Object,\n        toolbar: Object,\n        validationError: {},\n        validationErrors: Array,\n        validationMessageMode: String,\n        validationStatus: String,\n        value: {},\n        valueType: String,\n        variables: Object,\n        visible: Boolean,\n        width: [Function, Number, String]\n    },\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:accessKey\": null,\n        \"update:activeStateEnabled\": null,\n        \"update:allowSoftLineBreak\": null,\n        \"update:customizeModules\": null,\n        \"update:disabled\": null,\n        \"update:elementAttr\": null,\n        \"update:focusStateEnabled\": null,\n        \"update:height\": null,\n        \"update:hint\": null,\n        \"update:hoverStateEnabled\": null,\n        \"update:isValid\": null,\n        \"update:mediaResizing\": null,\n        \"update:mentions\": null,\n        \"update:name\": null,\n        \"update:onContentReady\": null,\n        \"update:onDisposing\": null,\n        \"update:onFocusIn\": null,\n        \"update:onFocusOut\": null,\n        \"update:onInitialized\": null,\n        \"update:onOptionChanged\": null,\n        \"update:onValueChanged\": null,\n        \"update:placeholder\": null,\n        \"update:readOnly\": null,\n        \"update:rtlEnabled\": null,\n        \"update:stylingMode\": null,\n        \"update:tabIndex\": null,\n        \"update:tableContextMenu\": null,\n        \"update:tableResizing\": null,\n        \"update:toolbar\": null,\n        \"update:validationError\": null,\n        \"update:validationErrors\": null,\n        \"update:validationMessageMode\": null,\n        \"update:validationStatus\": null,\n        \"update:value\": null,\n        \"update:valueType\": null,\n        \"update:variables\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    model: { prop: \"value\", event: \"update:value\" },\n    computed: {\n        instance: function () {\n            return this.$_instance;\n        }\n    },\n    beforeCreate: function () {\n        this.$_WidgetClass = html_editor_1.default;\n        this.$_hasAsyncTemplate = true;\n        this.$_expectedChildren = {\n            mediaResizing: { isCollectionItem: false, optionName: \"mediaResizing\" },\n            mention: { isCollectionItem: true, optionName: \"mentions\" },\n            tableContextMenu: { isCollectionItem: false, optionName: \"tableContextMenu\" },\n            tableResizing: { isCollectionItem: false, optionName: \"tableResizing\" },\n            toolbar: { isCollectionItem: false, optionName: \"toolbar\" },\n            variables: { isCollectionItem: false, optionName: \"variables\" }\n        };\n    }\n});\nexports.DxHtmlEditor = DxHtmlEditor;\nvar DxItem = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:acceptedValues\": null,\n        \"update:beginGroup\": null,\n        \"update:closeMenuOnClick\": null,\n        \"update:cssClass\": null,\n        \"update:disabled\": null,\n        \"update:formatName\": null,\n        \"update:formatValues\": null,\n        \"update:html\": null,\n        \"update:icon\": null,\n        \"update:items\": null,\n        \"update:locateInMenu\": null,\n        \"update:location\": null,\n        \"update:menuItemTemplate\": null,\n        \"update:name\": null,\n        \"update:options\": null,\n        \"update:selectable\": null,\n        \"update:selected\": null,\n        \"update:showText\": null,\n        \"update:template\": null,\n        \"update:text\": null,\n        \"update:visible\": null,\n        \"update:widget\": null,\n    },\n    props: {\n        acceptedValues: Array,\n        beginGroup: Boolean,\n        closeMenuOnClick: Boolean,\n        cssClass: String,\n        disabled: Boolean,\n        formatName: String,\n        formatValues: Array,\n        html: String,\n        icon: String,\n        items: Array,\n        locateInMenu: String,\n        location: String,\n        menuItemTemplate: {},\n        name: String,\n        options: {},\n        selectable: Boolean,\n        selected: Boolean,\n        showText: String,\n        template: {},\n        text: String,\n        visible: Boolean,\n        widget: String\n    }\n});\nexports.DxItem = DxItem;\nDxItem.$_optionName = \"items\";\nDxItem.$_isCollectionItem = true;\nvar DxMediaResizing = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:allowedTargets\": null,\n        \"update:enabled\": null,\n    },\n    props: {\n        allowedTargets: Array,\n        enabled: Boolean\n    }\n});\nexports.DxMediaResizing = DxMediaResizing;\nDxMediaResizing.$_optionName = \"mediaResizing\";\nvar DxMention = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:dataSource\": null,\n        \"update:displayExpr\": null,\n        \"update:itemTemplate\": null,\n        \"update:marker\": null,\n        \"update:minSearchLength\": null,\n        \"update:searchExpr\": null,\n        \"update:searchTimeout\": null,\n        \"update:template\": null,\n        \"update:valueExpr\": null,\n    },\n    props: {\n        dataSource: [Array, Object, String],\n        displayExpr: [Function, String],\n        itemTemplate: {},\n        marker: String,\n        minSearchLength: Number,\n        searchExpr: [Array, Function, String],\n        searchTimeout: Number,\n        template: {},\n        valueExpr: [Function, String]\n    }\n});\nexports.DxMention = DxMention;\nDxMention.$_optionName = \"mentions\";\nDxMention.$_isCollectionItem = true;\nvar DxTableContextMenu = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:enabled\": null,\n        \"update:items\": null,\n    },\n    props: {\n        enabled: Boolean,\n        items: Array\n    }\n});\nexports.DxTableContextMenu = DxTableContextMenu;\nDxTableContextMenu.$_optionName = \"tableContextMenu\";\nDxTableContextMenu.$_expectedChildren = {\n    item: { isCollectionItem: true, optionName: \"items\" },\n    tableContextMenuItem: { isCollectionItem: true, optionName: \"items\" }\n};\nvar DxTableContextMenuItem = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:beginGroup\": null,\n        \"update:closeMenuOnClick\": null,\n        \"update:disabled\": null,\n        \"update:html\": null,\n        \"update:icon\": null,\n        \"update:items\": null,\n        \"update:name\": null,\n        \"update:selectable\": null,\n        \"update:selected\": null,\n        \"update:template\": null,\n        \"update:text\": null,\n        \"update:visible\": null,\n    },\n    props: {\n        beginGroup: Boolean,\n        closeMenuOnClick: Boolean,\n        disabled: Boolean,\n        html: String,\n        icon: String,\n        items: Array,\n        name: String,\n        selectable: Boolean,\n        selected: Boolean,\n        template: {},\n        text: String,\n        visible: Boolean\n    }\n});\nexports.DxTableContextMenuItem = DxTableContextMenuItem;\nDxTableContextMenuItem.$_optionName = \"items\";\nDxTableContextMenuItem.$_isCollectionItem = true;\nvar DxTableResizing = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:enabled\": null,\n        \"update:minColumnWidth\": null,\n        \"update:minRowHeight\": null,\n    },\n    props: {\n        enabled: Boolean,\n        minColumnWidth: Number,\n        minRowHeight: Number\n    }\n});\nexports.DxTableResizing = DxTableResizing;\nDxTableResizing.$_optionName = \"tableResizing\";\nvar DxToolbar = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:container\": null,\n        \"update:items\": null,\n        \"update:multiline\": null,\n    },\n    props: {\n        container: {},\n        items: Array,\n        multiline: Boolean\n    }\n});\nexports.DxToolbar = DxToolbar;\nDxToolbar.$_optionName = \"toolbar\";\nDxToolbar.$_expectedChildren = {\n    item: { isCollectionItem: true, optionName: \"items\" },\n    toolbarItem: { isCollectionItem: true, optionName: \"items\" }\n};\nvar DxToolbarItem = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:acceptedValues\": null,\n        \"update:cssClass\": null,\n        \"update:disabled\": null,\n        \"update:formatName\": null,\n        \"update:formatValues\": null,\n        \"update:html\": null,\n        \"update:locateInMenu\": null,\n        \"update:location\": null,\n        \"update:menuItemTemplate\": null,\n        \"update:name\": null,\n        \"update:options\": null,\n        \"update:showText\": null,\n        \"update:template\": null,\n        \"update:text\": null,\n        \"update:visible\": null,\n        \"update:widget\": null,\n    },\n    props: {\n        acceptedValues: Array,\n        cssClass: String,\n        disabled: Boolean,\n        formatName: String,\n        formatValues: Array,\n        html: String,\n        locateInMenu: String,\n        location: String,\n        menuItemTemplate: {},\n        name: String,\n        options: {},\n        showText: String,\n        template: {},\n        text: String,\n        visible: Boolean,\n        widget: String\n    }\n});\nexports.DxToolbarItem = DxToolbarItem;\nDxToolbarItem.$_optionName = \"items\";\nDxToolbarItem.$_isCollectionItem = true;\nvar DxVariables = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:dataSource\": null,\n        \"update:escapeChar\": null,\n    },\n    props: {\n        dataSource: [Array, Object, String],\n        escapeChar: [Array, String]\n    }\n});\nexports.DxVariables = DxVariables;\nDxVariables.$_optionName = \"variables\";\nexports.default = DxHtmlEditor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS12dWUvaHRtbC1lZGl0b3IuanM/NmE3MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esb0NBQW9DLG1CQUFPLENBQUMsa0ZBQTJCO0FBQ3ZFLGNBQWMsbUJBQU8sQ0FBQyxpRUFBYztBQUNwQyxjQUFjLG1CQUFPLENBQUMsaUVBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSx1Q0FBdUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdURBQXVEO0FBQ25GLHNCQUFzQixpREFBaUQ7QUFDdkUsK0JBQStCLDBEQUEwRDtBQUN6Riw0QkFBNEIsdURBQXVEO0FBQ25GLHNCQUFzQixpREFBaUQ7QUFDdkUsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUE4QztBQUN6RCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQThDO0FBQ3pELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS12dWUvaHRtbC1lZGl0b3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGRldmV4dHJlbWUtdnVlXG4gKiBWZXJzaW9uOiAyMS4yLjdcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXG4gKlxuICogVGhpcyBzb2Z0d2FyZSBtYXkgYmUgbW9kaWZpZWQgYW5kIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtc1xuICogb2YgdGhlIE1JVCBsaWNlbnNlLiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgcHJvamVjdCBmb3IgZGV0YWlscy5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vRGV2RXhwcmVzcy9kZXZleHRyZW1lLXZ1ZVxuICovXG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EeFZhcmlhYmxlcyA9IGV4cG9ydHMuRHhUb29sYmFySXRlbSA9IGV4cG9ydHMuRHhUb29sYmFyID0gZXhwb3J0cy5EeFRhYmxlUmVzaXppbmcgPSBleHBvcnRzLkR4VGFibGVDb250ZXh0TWVudUl0ZW0gPSBleHBvcnRzLkR4VGFibGVDb250ZXh0TWVudSA9IGV4cG9ydHMuRHhNZW50aW9uID0gZXhwb3J0cy5EeE1lZGlhUmVzaXppbmcgPSBleHBvcnRzLkR4SXRlbSA9IGV4cG9ydHMuRHhIdG1sRWRpdG9yID0gdm9pZCAwO1xudmFyIGh0bWxfZWRpdG9yXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRldmV4dHJlbWUvdWkvaHRtbF9lZGl0b3JcIikpO1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi9jb3JlL2luZGV4XCIpO1xudmFyIGluZGV4XzIgPSByZXF1aXJlKFwiLi9jb3JlL2luZGV4XCIpO1xudmFyIER4SHRtbEVkaXRvciA9IGluZGV4XzEuY3JlYXRlQ29tcG9uZW50KHtcbiAgICBwcm9wczoge1xuICAgICAgICBhY2Nlc3NLZXk6IFN0cmluZyxcbiAgICAgICAgYWN0aXZlU3RhdGVFbmFibGVkOiBCb29sZWFuLFxuICAgICAgICBhbGxvd1NvZnRMaW5lQnJlYWs6IEJvb2xlYW4sXG4gICAgICAgIGN1c3RvbWl6ZU1vZHVsZXM6IEZ1bmN0aW9uLFxuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICAgICAgZWxlbWVudEF0dHI6IE9iamVjdCxcbiAgICAgICAgZm9jdXNTdGF0ZUVuYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIGhlaWdodDogW0Z1bmN0aW9uLCBOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIGhpbnQ6IFN0cmluZyxcbiAgICAgICAgaG92ZXJTdGF0ZUVuYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIGlzVmFsaWQ6IEJvb2xlYW4sXG4gICAgICAgIG1lZGlhUmVzaXppbmc6IE9iamVjdCxcbiAgICAgICAgbWVudGlvbnM6IEFycmF5LFxuICAgICAgICBuYW1lOiBTdHJpbmcsXG4gICAgICAgIG9uQ29udGVudFJlYWR5OiBGdW5jdGlvbixcbiAgICAgICAgb25EaXNwb3Npbmc6IEZ1bmN0aW9uLFxuICAgICAgICBvbkZvY3VzSW46IEZ1bmN0aW9uLFxuICAgICAgICBvbkZvY3VzT3V0OiBGdW5jdGlvbixcbiAgICAgICAgb25Jbml0aWFsaXplZDogRnVuY3Rpb24sXG4gICAgICAgIG9uT3B0aW9uQ2hhbmdlZDogRnVuY3Rpb24sXG4gICAgICAgIG9uVmFsdWVDaGFuZ2VkOiBGdW5jdGlvbixcbiAgICAgICAgcGxhY2Vob2xkZXI6IFN0cmluZyxcbiAgICAgICAgcmVhZE9ubHk6IEJvb2xlYW4sXG4gICAgICAgIHJ0bEVuYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIHN0eWxpbmdNb2RlOiBTdHJpbmcsXG4gICAgICAgIHRhYkluZGV4OiBOdW1iZXIsXG4gICAgICAgIHRhYmxlQ29udGV4dE1lbnU6IE9iamVjdCxcbiAgICAgICAgdGFibGVSZXNpemluZzogT2JqZWN0LFxuICAgICAgICB0b29sYmFyOiBPYmplY3QsXG4gICAgICAgIHZhbGlkYXRpb25FcnJvcjoge30sXG4gICAgICAgIHZhbGlkYXRpb25FcnJvcnM6IEFycmF5LFxuICAgICAgICB2YWxpZGF0aW9uTWVzc2FnZU1vZGU6IFN0cmluZyxcbiAgICAgICAgdmFsaWRhdGlvblN0YXR1czogU3RyaW5nLFxuICAgICAgICB2YWx1ZToge30sXG4gICAgICAgIHZhbHVlVHlwZTogU3RyaW5nLFxuICAgICAgICB2YXJpYWJsZXM6IE9iamVjdCxcbiAgICAgICAgdmlzaWJsZTogQm9vbGVhbixcbiAgICAgICAgd2lkdGg6IFtGdW5jdGlvbiwgTnVtYmVyLCBTdHJpbmddXG4gICAgfSxcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphY2Nlc3NLZXlcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWN0aXZlU3RhdGVFbmFibGVkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFsbG93U29mdExpbmVCcmVha1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjdXN0b21pemVNb2R1bGVzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRpc2FibGVkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmVsZW1lbnRBdHRyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZvY3VzU3RhdGVFbmFibGVkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhlaWdodFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpoaW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyU3RhdGVFbmFibGVkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmlzVmFsaWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWVkaWFSZXNpemluZ1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptZW50aW9uc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpuYW1lXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uQ29udGVudFJlYWR5XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uRGlzcG9zaW5nXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uRm9jdXNJblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvbkZvY3VzT3V0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uSW5pdGlhbGl6ZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b25PcHRpb25DaGFuZ2VkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uVmFsdWVDaGFuZ2VkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBsYWNlaG9sZGVyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnJlYWRPbmx5XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnJ0bEVuYWJsZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3R5bGluZ01vZGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGFiSW5kZXhcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGFibGVDb250ZXh0TWVudVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0YWJsZVJlc2l6aW5nXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRvb2xiYXJcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmFsaWRhdGlvbkVycm9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZhbGlkYXRpb25FcnJvcnNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmFsaWRhdGlvbk1lc3NhZ2VNb2RlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZhbGlkYXRpb25TdGF0dXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmFsdWVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmFsdWVUeXBlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZhcmlhYmxlc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBtb2RlbDogeyBwcm9wOiBcInZhbHVlXCIsIGV2ZW50OiBcInVwZGF0ZTp2YWx1ZVwiIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgaW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRfaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLiRfV2lkZ2V0Q2xhc3MgPSBodG1sX2VkaXRvcl8xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMuJF9oYXNBc3luY1RlbXBsYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kX2V4cGVjdGVkQ2hpbGRyZW4gPSB7XG4gICAgICAgICAgICBtZWRpYVJlc2l6aW5nOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcIm1lZGlhUmVzaXppbmdcIiB9LFxuICAgICAgICAgICAgbWVudGlvbjogeyBpc0NvbGxlY3Rpb25JdGVtOiB0cnVlLCBvcHRpb25OYW1lOiBcIm1lbnRpb25zXCIgfSxcbiAgICAgICAgICAgIHRhYmxlQ29udGV4dE1lbnU6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwidGFibGVDb250ZXh0TWVudVwiIH0sXG4gICAgICAgICAgICB0YWJsZVJlc2l6aW5nOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInRhYmxlUmVzaXppbmdcIiB9LFxuICAgICAgICAgICAgdG9vbGJhcjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJ0b29sYmFyXCIgfSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJ2YXJpYWJsZXNcIiB9XG4gICAgICAgIH07XG4gICAgfVxufSk7XG5leHBvcnRzLkR4SHRtbEVkaXRvciA9IER4SHRtbEVkaXRvcjtcbnZhciBEeEl0ZW0gPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFjY2VwdGVkVmFsdWVzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJlZ2luR3JvdXBcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y2xvc2VNZW51T25DbGlja1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjc3NDbGFzc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkaXNhYmxlZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpmb3JtYXROYW1lXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZvcm1hdFZhbHVlc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpodG1sXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmljb25cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aXRlbXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bG9jYXRlSW5NZW51XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmxvY2F0aW9uXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1lbnVJdGVtVGVtcGxhdGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bmFtZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvcHRpb25zXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNlbGVjdGFibGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2VsZWN0ZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2hvd1RleHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGVtcGxhdGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGV4dFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZGdldFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWNjZXB0ZWRWYWx1ZXM6IEFycmF5LFxuICAgICAgICBiZWdpbkdyb3VwOiBCb29sZWFuLFxuICAgICAgICBjbG9zZU1lbnVPbkNsaWNrOiBCb29sZWFuLFxuICAgICAgICBjc3NDbGFzczogU3RyaW5nLFxuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICAgICAgZm9ybWF0TmFtZTogU3RyaW5nLFxuICAgICAgICBmb3JtYXRWYWx1ZXM6IEFycmF5LFxuICAgICAgICBodG1sOiBTdHJpbmcsXG4gICAgICAgIGljb246IFN0cmluZyxcbiAgICAgICAgaXRlbXM6IEFycmF5LFxuICAgICAgICBsb2NhdGVJbk1lbnU6IFN0cmluZyxcbiAgICAgICAgbG9jYXRpb246IFN0cmluZyxcbiAgICAgICAgbWVudUl0ZW1UZW1wbGF0ZToge30sXG4gICAgICAgIG5hbWU6IFN0cmluZyxcbiAgICAgICAgb3B0aW9uczoge30sXG4gICAgICAgIHNlbGVjdGFibGU6IEJvb2xlYW4sXG4gICAgICAgIHNlbGVjdGVkOiBCb29sZWFuLFxuICAgICAgICBzaG93VGV4dDogU3RyaW5nLFxuICAgICAgICB0ZW1wbGF0ZToge30sXG4gICAgICAgIHRleHQ6IFN0cmluZyxcbiAgICAgICAgdmlzaWJsZTogQm9vbGVhbixcbiAgICAgICAgd2lkZ2V0OiBTdHJpbmdcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhJdGVtID0gRHhJdGVtO1xuRHhJdGVtLiRfb3B0aW9uTmFtZSA9IFwiaXRlbXNcIjtcbkR4SXRlbS4kX2lzQ29sbGVjdGlvbkl0ZW0gPSB0cnVlO1xudmFyIER4TWVkaWFSZXNpemluZyA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWxsb3dlZFRhcmdldHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZW5hYmxlZFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWxsb3dlZFRhcmdldHM6IEFycmF5LFxuICAgICAgICBlbmFibGVkOiBCb29sZWFuXG4gICAgfVxufSk7XG5leHBvcnRzLkR4TWVkaWFSZXNpemluZyA9IER4TWVkaWFSZXNpemluZztcbkR4TWVkaWFSZXNpemluZy4kX29wdGlvbk5hbWUgPSBcIm1lZGlhUmVzaXppbmdcIjtcbnZhciBEeE1lbnRpb24gPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRhdGFTb3VyY2VcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGlzcGxheUV4cHJcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aXRlbVRlbXBsYXRlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1hcmtlclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptaW5TZWFyY2hMZW5ndGhcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2VhcmNoRXhwclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzZWFyY2hUaW1lb3V0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRlbXBsYXRlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZhbHVlRXhwclwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZGF0YVNvdXJjZTogW0FycmF5LCBPYmplY3QsIFN0cmluZ10sXG4gICAgICAgIGRpc3BsYXlFeHByOiBbRnVuY3Rpb24sIFN0cmluZ10sXG4gICAgICAgIGl0ZW1UZW1wbGF0ZToge30sXG4gICAgICAgIG1hcmtlcjogU3RyaW5nLFxuICAgICAgICBtaW5TZWFyY2hMZW5ndGg6IE51bWJlcixcbiAgICAgICAgc2VhcmNoRXhwcjogW0FycmF5LCBGdW5jdGlvbiwgU3RyaW5nXSxcbiAgICAgICAgc2VhcmNoVGltZW91dDogTnVtYmVyLFxuICAgICAgICB0ZW1wbGF0ZToge30sXG4gICAgICAgIHZhbHVlRXhwcjogW0Z1bmN0aW9uLCBTdHJpbmddXG4gICAgfVxufSk7XG5leHBvcnRzLkR4TWVudGlvbiA9IER4TWVudGlvbjtcbkR4TWVudGlvbi4kX29wdGlvbk5hbWUgPSBcIm1lbnRpb25zXCI7XG5EeE1lbnRpb24uJF9pc0NvbGxlY3Rpb25JdGVtID0gdHJ1ZTtcbnZhciBEeFRhYmxlQ29udGV4dE1lbnUgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmVuYWJsZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aXRlbXNcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGVuYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIGl0ZW1zOiBBcnJheVxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFRhYmxlQ29udGV4dE1lbnUgPSBEeFRhYmxlQ29udGV4dE1lbnU7XG5EeFRhYmxlQ29udGV4dE1lbnUuJF9vcHRpb25OYW1lID0gXCJ0YWJsZUNvbnRleHRNZW51XCI7XG5EeFRhYmxlQ29udGV4dE1lbnUuJF9leHBlY3RlZENoaWxkcmVuID0ge1xuICAgIGl0ZW06IHsgaXNDb2xsZWN0aW9uSXRlbTogdHJ1ZSwgb3B0aW9uTmFtZTogXCJpdGVtc1wiIH0sXG4gICAgdGFibGVDb250ZXh0TWVudUl0ZW06IHsgaXNDb2xsZWN0aW9uSXRlbTogdHJ1ZSwgb3B0aW9uTmFtZTogXCJpdGVtc1wiIH1cbn07XG52YXIgRHhUYWJsZUNvbnRleHRNZW51SXRlbSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YmVnaW5Hcm91cFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjbG9zZU1lbnVPbkNsaWNrXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRpc2FibGVkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmh0bWxcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aWNvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTppdGVtc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpuYW1lXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNlbGVjdGFibGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2VsZWN0ZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGVtcGxhdGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGV4dFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBiZWdpbkdyb3VwOiBCb29sZWFuLFxuICAgICAgICBjbG9zZU1lbnVPbkNsaWNrOiBCb29sZWFuLFxuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICAgICAgaHRtbDogU3RyaW5nLFxuICAgICAgICBpY29uOiBTdHJpbmcsXG4gICAgICAgIGl0ZW1zOiBBcnJheSxcbiAgICAgICAgbmFtZTogU3RyaW5nLFxuICAgICAgICBzZWxlY3RhYmxlOiBCb29sZWFuLFxuICAgICAgICBzZWxlY3RlZDogQm9vbGVhbixcbiAgICAgICAgdGVtcGxhdGU6IHt9LFxuICAgICAgICB0ZXh0OiBTdHJpbmcsXG4gICAgICAgIHZpc2libGU6IEJvb2xlYW5cbiAgICB9XG59KTtcbmV4cG9ydHMuRHhUYWJsZUNvbnRleHRNZW51SXRlbSA9IER4VGFibGVDb250ZXh0TWVudUl0ZW07XG5EeFRhYmxlQ29udGV4dE1lbnVJdGVtLiRfb3B0aW9uTmFtZSA9IFwiaXRlbXNcIjtcbkR4VGFibGVDb250ZXh0TWVudUl0ZW0uJF9pc0NvbGxlY3Rpb25JdGVtID0gdHJ1ZTtcbnZhciBEeFRhYmxlUmVzaXppbmcgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmVuYWJsZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWluQ29sdW1uV2lkdGhcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWluUm93SGVpZ2h0XCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBlbmFibGVkOiBCb29sZWFuLFxuICAgICAgICBtaW5Db2x1bW5XaWR0aDogTnVtYmVyLFxuICAgICAgICBtaW5Sb3dIZWlnaHQ6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFRhYmxlUmVzaXppbmcgPSBEeFRhYmxlUmVzaXppbmc7XG5EeFRhYmxlUmVzaXppbmcuJF9vcHRpb25OYW1lID0gXCJ0YWJsZVJlc2l6aW5nXCI7XG52YXIgRHhUb29sYmFyID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb250YWluZXJcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aXRlbXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bXVsdGlsaW5lXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBjb250YWluZXI6IHt9LFxuICAgICAgICBpdGVtczogQXJyYXksXG4gICAgICAgIG11bHRpbGluZTogQm9vbGVhblxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFRvb2xiYXIgPSBEeFRvb2xiYXI7XG5EeFRvb2xiYXIuJF9vcHRpb25OYW1lID0gXCJ0b29sYmFyXCI7XG5EeFRvb2xiYXIuJF9leHBlY3RlZENoaWxkcmVuID0ge1xuICAgIGl0ZW06IHsgaXNDb2xsZWN0aW9uSXRlbTogdHJ1ZSwgb3B0aW9uTmFtZTogXCJpdGVtc1wiIH0sXG4gICAgdG9vbGJhckl0ZW06IHsgaXNDb2xsZWN0aW9uSXRlbTogdHJ1ZSwgb3B0aW9uTmFtZTogXCJpdGVtc1wiIH1cbn07XG52YXIgRHhUb29sYmFySXRlbSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWNjZXB0ZWRWYWx1ZXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y3NzQ2xhc3NcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGlzYWJsZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9ybWF0TmFtZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpmb3JtYXRWYWx1ZXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aHRtbFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpsb2NhdGVJbk1lbnVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bG9jYXRpb25cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWVudUl0ZW1UZW1wbGF0ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpuYW1lXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9wdGlvbnNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2hvd1RleHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGVtcGxhdGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGV4dFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZGdldFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWNjZXB0ZWRWYWx1ZXM6IEFycmF5LFxuICAgICAgICBjc3NDbGFzczogU3RyaW5nLFxuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICAgICAgZm9ybWF0TmFtZTogU3RyaW5nLFxuICAgICAgICBmb3JtYXRWYWx1ZXM6IEFycmF5LFxuICAgICAgICBodG1sOiBTdHJpbmcsXG4gICAgICAgIGxvY2F0ZUluTWVudTogU3RyaW5nLFxuICAgICAgICBsb2NhdGlvbjogU3RyaW5nLFxuICAgICAgICBtZW51SXRlbVRlbXBsYXRlOiB7fSxcbiAgICAgICAgbmFtZTogU3RyaW5nLFxuICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgc2hvd1RleHQ6IFN0cmluZyxcbiAgICAgICAgdGVtcGxhdGU6IHt9LFxuICAgICAgICB0ZXh0OiBTdHJpbmcsXG4gICAgICAgIHZpc2libGU6IEJvb2xlYW4sXG4gICAgICAgIHdpZGdldDogU3RyaW5nXG4gICAgfVxufSk7XG5leHBvcnRzLkR4VG9vbGJhckl0ZW0gPSBEeFRvb2xiYXJJdGVtO1xuRHhUb29sYmFySXRlbS4kX29wdGlvbk5hbWUgPSBcIml0ZW1zXCI7XG5EeFRvb2xiYXJJdGVtLiRfaXNDb2xsZWN0aW9uSXRlbSA9IHRydWU7XG52YXIgRHhWYXJpYWJsZXMgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRhdGFTb3VyY2VcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZXNjYXBlQ2hhclwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZGF0YVNvdXJjZTogW0FycmF5LCBPYmplY3QsIFN0cmluZ10sXG4gICAgICAgIGVzY2FwZUNoYXI6IFtBcnJheSwgU3RyaW5nXVxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFZhcmlhYmxlcyA9IER4VmFyaWFibGVzO1xuRHhWYXJpYWJsZXMuJF9vcHRpb25OYW1lID0gXCJ2YXJpYWJsZXNcIjtcbmV4cG9ydHMuZGVmYXVsdCA9IER4SHRtbEVkaXRvcjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme-vue/html-editor.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/color_box.js":
/*!*****************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/color_box.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _color_box_color_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color_box/color_box */ \"./node_modules/devextreme/esm/ui/color_box/color_box.js\");\n/**\r\n * DevExtreme (esm/ui/color_box.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (_color_box_color_box__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvY29sb3JfYm94LmpzPzVjODYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkM7QUFDOUIsMkhBQVEsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9jb2xvcl9ib3guanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3VpL2NvbG9yX2JveC5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IENvbG9yQm94IGZyb20gXCIuL2NvbG9yX2JveC9jb2xvcl9ib3hcIjtcclxuZXhwb3J0IGRlZmF1bHQgQ29sb3JCb3g7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/color_box.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/color_box/color_box.js":
/*!***************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/color_box/color_box.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/* harmony import */ var _events_core_events_engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../events/core/events_engine */ \"./node_modules/devextreme/esm/events/core/events_engine.js\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../color */ \"./node_modules/devextreme/esm/color.js\");\n/* harmony import */ var _color_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color_view */ \"./node_modules/devextreme/esm/ui/color_box/color_view.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _core_component_registrator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/component_registrator */ \"./node_modules/devextreme/esm/core/component_registrator.js\");\n/* harmony import */ var _drop_down_editor_ui_drop_down_editor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../drop_down_editor/ui.drop_down_editor */ \"./node_modules/devextreme/esm/ui/drop_down_editor/ui.drop_down_editor.js\");\n/**\r\n * DevExtreme (esm/ui/color_box/color_box.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar COLOR_BOX_CLASS = \"dx-colorbox\";\r\nvar COLOR_BOX_INPUT_CLASS = COLOR_BOX_CLASS + \"-input\";\r\nvar COLOR_BOX_INPUT_CONTAINER_CLASS = COLOR_BOX_INPUT_CLASS + \"-container\";\r\nvar COLOR_BOX_COLOR_RESULT_PREVIEW_CLASS = COLOR_BOX_CLASS + \"-color-result-preview\";\r\nvar COLOR_BOX_COLOR_IS_NOT_DEFINED = COLOR_BOX_CLASS + \"-color-is-not-defined\";\r\nvar COLOR_BOX_OVERLAY_CLASS = COLOR_BOX_CLASS + \"-overlay\";\r\nvar COLOR_BOX_CONTAINER_CELL_CLASS = \"dx-colorview-container-cell\";\r\nvar COLOR_BOX_BUTTON_CELL_CLASS = \"dx-colorview-button-cell\";\r\nvar COLOR_BOX_BUTTONS_CONTAINER_CLASS = \"dx-colorview-buttons-container\";\r\nvar COLOR_BOX_APPLY_BUTTON_CLASS = \"dx-colorview-apply-button\";\r\nvar COLOR_BOX_CANCEL_BUTTON_CLASS = \"dx-colorview-cancel-button\";\r\nvar colorEditorPrototype = _color_view__WEBPACK_IMPORTED_MODULE_3__[\"default\"].prototype;\r\nvar colorUtils = {\r\n    makeTransparentBackground: colorEditorPrototype._makeTransparentBackground.bind(colorEditorPrototype),\r\n    makeRgba: colorEditorPrototype._makeRgba.bind(colorEditorPrototype)\r\n};\r\nvar ColorBox = _drop_down_editor_ui_drop_down_editor__WEBPACK_IMPORTED_MODULE_6__[\"default\"].inherit({\r\n    _supportedKeys: function() {\r\n        var arrowHandler = function(e) {\r\n            e.stopPropagation();\r\n            if (this.option(\"opened\")) {\r\n                e.preventDefault();\r\n                return true\r\n            }\r\n        };\r\n        return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])(this.callBase(), {\r\n            tab: function(e) {\r\n                if (this.option(\"opened\")) {\r\n                    e.preventDefault();\r\n                    this._colorView._rgbInputs[0].focus()\r\n                }\r\n            },\r\n            enter: this._enterKeyHandler,\r\n            leftArrow: arrowHandler,\r\n            rightArrow: arrowHandler,\r\n            upArrow: function(e) {\r\n                if (!this.option(\"opened\")) {\r\n                    e.preventDefault();\r\n                    return false\r\n                }\r\n                if (e.altKey) {\r\n                    this.close();\r\n                    return false\r\n                }\r\n                return true\r\n            },\r\n            downArrow: function(e) {\r\n                if (!this.option(\"opened\") && !e.altKey) {\r\n                    e.preventDefault();\r\n                    return false\r\n                }\r\n                if (!this.option(\"opened\") && e.altKey) {\r\n                    this._validatedOpening();\r\n                    return false\r\n                }\r\n                return true\r\n            }\r\n        })\r\n    },\r\n    _getDefaultOptions: function() {\r\n        return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])(this.callBase(), {\r\n            editAlphaChannel: false,\r\n            applyValueMode: \"useButtons\",\r\n            keyStep: 1,\r\n            fieldTemplate: null,\r\n            buttonsLocation: \"bottom after\"\r\n        })\r\n    },\r\n    _popupHidingHandler: function() {\r\n        this.callBase();\r\n        if (\"useButtons\" === this.option(\"applyValueMode\")) {\r\n            this._updateColorViewValue(this.option(\"value\"))\r\n        }\r\n    },\r\n    _popupConfig: function() {\r\n        return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])(this.callBase(), {\r\n            width: \"\"\r\n        })\r\n    },\r\n    _contentReadyHandler: function() {\r\n        this._createColorView();\r\n        this._addPopupBottomClasses()\r\n    },\r\n    _addPopupBottomClasses: function() {\r\n        var $popupBottom = this._popup.bottomToolbar();\r\n        if ($popupBottom) {\r\n            $popupBottom.addClass(COLOR_BOX_CONTAINER_CELL_CLASS).addClass(COLOR_BOX_BUTTON_CELL_CLASS).find(\".dx-toolbar-items-container\").addClass(COLOR_BOX_BUTTONS_CONTAINER_CLASS);\r\n            $popupBottom.find(\".dx-popup-done\").addClass(COLOR_BOX_APPLY_BUTTON_CLASS);\r\n            $popupBottom.find(\".dx-popup-cancel\").addClass(COLOR_BOX_CANCEL_BUTTON_CLASS)\r\n        }\r\n    },\r\n    _createColorView: function() {\r\n        this._popup.$overlayContent().addClass(COLOR_BOX_OVERLAY_CLASS);\r\n        var $colorView = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\").appendTo(this._popup.$content());\r\n        this._colorView = this._createComponent($colorView, _color_view__WEBPACK_IMPORTED_MODULE_3__[\"default\"], this._colorViewConfig());\r\n        this._colorView.registerKeyHandler(\"escape\", this._escapeHandler.bind(this));\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_1__[\"default\"].on($colorView, \"focus\", function() {\r\n            this.focus()\r\n        }.bind(this))\r\n    },\r\n    _escapeHandler: function() {\r\n        this.close();\r\n        this.focus()\r\n    },\r\n    _applyNewColor: function(value) {\r\n        this.option(\"value\", value);\r\n        if (value) {\r\n            colorUtils.makeTransparentBackground(this._$colorResultPreview, value)\r\n        }\r\n        if (this._colorViewEnterKeyPressed) {\r\n            this.close();\r\n            this._colorViewEnterKeyPressed = false\r\n        }\r\n    },\r\n    _colorViewConfig: function() {\r\n        var that = this;\r\n        return {\r\n            value: that.option(\"value\"),\r\n            matchValue: that.option(\"value\"),\r\n            editAlphaChannel: that.option(\"editAlphaChannel\"),\r\n            applyValueMode: that.option(\"applyValueMode\"),\r\n            focusStateEnabled: that.option(\"focusStateEnabled\"),\r\n            stylingMode: this.option(\"stylingMode\"),\r\n            onEnterKeyPressed: function(_ref) {\r\n                var {\r\n                    event: event\r\n                } = _ref;\r\n                that._colorViewEnterKeyPressed = true;\r\n                if (that._colorView.option(\"value\") !== that.option(\"value\")) {\r\n                    that._saveValueChangeEvent(event);\r\n                    that._applyNewColor(that._colorView.option(\"value\"));\r\n                    that.close()\r\n                }\r\n            },\r\n            onValueChanged: function(_ref2) {\r\n                var {\r\n                    event: event,\r\n                    value: value,\r\n                    previousValue: previousValue\r\n                } = _ref2;\r\n                var instantlyMode = \"instantly\" === that.option(\"applyValueMode\");\r\n                var isOldValue = colorUtils.makeRgba(value) === previousValue;\r\n                var changesApplied = instantlyMode || that._colorViewEnterKeyPressed;\r\n                var valueCleared = that._shouldSaveEmptyValue;\r\n                if (isOldValue || !changesApplied || valueCleared) {\r\n                    return\r\n                }\r\n                if (event) {\r\n                    that._saveValueChangeEvent(event)\r\n                }\r\n                that._applyNewColor(value)\r\n            }\r\n        }\r\n    },\r\n    _enterKeyHandler: function(e) {\r\n        var newValue = this._input().val();\r\n        var value = this.option(\"value\");\r\n        var oldValue = this.option(\"editAlphaChannel\") ? colorUtils.makeRgba(value) : value;\r\n        if (!newValue) {\r\n            return false\r\n        }\r\n        var color = new _color__WEBPACK_IMPORTED_MODULE_2__[\"default\"](newValue);\r\n        if (color.colorIsInvalid) {\r\n            this._input().val(oldValue);\r\n            return\r\n        }\r\n        if (newValue !== oldValue) {\r\n            this._applyColorFromInput(newValue);\r\n            this._saveValueChangeEvent(e);\r\n            this.option(\"value\", this.option(\"editAlphaChannel\") ? colorUtils.makeRgba(newValue) : newValue)\r\n        }\r\n        if (this._colorView) {\r\n            var colorViewValue = this._colorView.option(\"value\");\r\n            if (value !== colorViewValue) {\r\n                this._saveValueChangeEvent(e);\r\n                this.option(\"value\", colorViewValue)\r\n            }\r\n        }\r\n        this.close();\r\n        return false\r\n    },\r\n    _applyButtonHandler: function(e) {\r\n        this._saveValueChangeEvent(e.event);\r\n        this._applyNewColor(this._colorView.option(\"value\"));\r\n        this.callBase()\r\n    },\r\n    _cancelButtonHandler: function() {\r\n        this._resetInputValue();\r\n        this.callBase()\r\n    },\r\n    _getKeyboardListeners() {\r\n        return this.callBase().concat([this._colorView])\r\n    },\r\n    _init: function() {\r\n        this.callBase()\r\n    },\r\n    _initMarkup: function() {\r\n        this.$element().addClass(COLOR_BOX_CLASS);\r\n        this.callBase()\r\n    },\r\n    _renderInput: function() {\r\n        this.callBase();\r\n        this._input().addClass(COLOR_BOX_INPUT_CLASS);\r\n        this._renderColorPreview()\r\n    },\r\n    _renderColorPreview: function() {\r\n        this.$element().wrapInner(Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\").addClass(COLOR_BOX_INPUT_CONTAINER_CLASS));\r\n        this._$colorBoxInputContainer = this.$element().children().eq(0);\r\n        this._$colorResultPreview = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\").addClass(COLOR_BOX_COLOR_RESULT_PREVIEW_CLASS).appendTo(this._$textEditorInputContainer);\r\n        if (!this.option(\"value\")) {\r\n            this._$colorBoxInputContainer.addClass(COLOR_BOX_COLOR_IS_NOT_DEFINED)\r\n        } else {\r\n            colorUtils.makeTransparentBackground(this._$colorResultPreview, this.option(\"value\"))\r\n        }\r\n    },\r\n    _renderValue: function() {\r\n        var value = this.option(\"value\");\r\n        var convertToColor = null !== value && this.option(\"editAlphaChannel\");\r\n        var text = convertToColor ? colorUtils.makeRgba(value) : value;\r\n        this.option(\"text\", text);\r\n        return this.callBase()\r\n    },\r\n    _resetInputValue: function() {\r\n        var $input = this._input();\r\n        var value = this.option(\"value\");\r\n        $input.val(value);\r\n        this._updateColorViewValue(value)\r\n    },\r\n    _updateColorViewValue: function(value) {\r\n        if (this._colorView) {\r\n            this._colorView.option({\r\n                value: value,\r\n                matchValue: value\r\n            })\r\n        }\r\n    },\r\n    _valueChangeEventHandler: function(e) {\r\n        var value = this._input().val();\r\n        if (value) {\r\n            value = this._applyColorFromInput(value);\r\n            this._updateColorViewValue(value)\r\n        }\r\n        this.callBase(e, value)\r\n    },\r\n    _applyColorFromInput: function(value) {\r\n        var newColor = new _color__WEBPACK_IMPORTED_MODULE_2__[\"default\"](value);\r\n        if (newColor.colorIsInvalid) {\r\n            this._resetInputValue();\r\n            value = this.option(\"value\")\r\n        }\r\n        return value\r\n    },\r\n    _clean: function() {\r\n        this.callBase();\r\n        delete this._shouldSaveEmptyValue\r\n    },\r\n    _optionChanged: function(args) {\r\n        var value = args.value;\r\n        var name = args.name;\r\n        switch (name) {\r\n            case \"value\":\r\n                this._$colorBoxInputContainer.toggleClass(COLOR_BOX_COLOR_IS_NOT_DEFINED, !value);\r\n                if (value) {\r\n                    colorUtils.makeTransparentBackground(this._$colorResultPreview, value)\r\n                } else {\r\n                    this._$colorResultPreview.removeAttr(\"style\")\r\n                }\r\n                if (null === value) {\r\n                    this._shouldSaveEmptyValue = true\r\n                }\r\n                this._updateColorViewValue(value);\r\n                this._shouldSaveEmptyValue = false;\r\n                this.callBase(args);\r\n                break;\r\n            case \"applyButtonText\":\r\n            case \"cancelButtonText\":\r\n                this.callBase(args);\r\n                this._popup && this._addPopupBottomClasses();\r\n                break;\r\n            case \"editAlphaChannel\":\r\n            case \"keyStep\":\r\n                if (this._colorView) {\r\n                    this._colorView.option(name, value)\r\n                }\r\n                break;\r\n            default:\r\n                this.callBase(args)\r\n        }\r\n    }\r\n});\r\nObject(_core_component_registrator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\"dxColorBox\", ColorBox);\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ColorBox);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvY29sb3JfYm94L2NvbG9yX2JveC5qcz8zZmNhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29DO0FBQ3VCO0FBQzNCO0FBQ0s7QUFHSjtBQUNnQztBQUNJO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZFQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxlQUFlLGlFQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlLGlFQUFNO0FBQ3JCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5Qiw4REFBQztBQUMxQiw0REFBNEQsbURBQVM7QUFDckU7QUFDQSxRQUFRLGtFQUFZO0FBQ3BCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsOERBQUM7QUFDbkM7QUFDQSxvQ0FBb0MsOERBQUM7QUFDckM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsOENBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMkVBQWlCO0FBQ0YsdUVBQVEsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9jb2xvcl9ib3gvY29sb3JfYm94LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS91aS9jb2xvcl9ib3gvY29sb3JfYm94LmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQgJCBmcm9tIFwiLi4vLi4vY29yZS9yZW5kZXJlclwiO1xyXG5pbXBvcnQgZXZlbnRzRW5naW5lIGZyb20gXCIuLi8uLi9ldmVudHMvY29yZS9ldmVudHNfZW5naW5lXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vY29sb3JcIjtcclxuaW1wb3J0IENvbG9yVmlldyBmcm9tIFwiLi9jb2xvcl92aWV3XCI7XHJcbmltcG9ydCB7XHJcbiAgICBleHRlbmRcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9leHRlbmRcIjtcclxuaW1wb3J0IHJlZ2lzdGVyQ29tcG9uZW50IGZyb20gXCIuLi8uLi9jb3JlL2NvbXBvbmVudF9yZWdpc3RyYXRvclwiO1xyXG5pbXBvcnQgRHJvcERvd25FZGl0b3IgZnJvbSBcIi4uL2Ryb3BfZG93bl9lZGl0b3IvdWkuZHJvcF9kb3duX2VkaXRvclwiO1xyXG52YXIgQ09MT1JfQk9YX0NMQVNTID0gXCJkeC1jb2xvcmJveFwiO1xyXG52YXIgQ09MT1JfQk9YX0lOUFVUX0NMQVNTID0gQ09MT1JfQk9YX0NMQVNTICsgXCItaW5wdXRcIjtcclxudmFyIENPTE9SX0JPWF9JTlBVVF9DT05UQUlORVJfQ0xBU1MgPSBDT0xPUl9CT1hfSU5QVVRfQ0xBU1MgKyBcIi1jb250YWluZXJcIjtcclxudmFyIENPTE9SX0JPWF9DT0xPUl9SRVNVTFRfUFJFVklFV19DTEFTUyA9IENPTE9SX0JPWF9DTEFTUyArIFwiLWNvbG9yLXJlc3VsdC1wcmV2aWV3XCI7XHJcbnZhciBDT0xPUl9CT1hfQ09MT1JfSVNfTk9UX0RFRklORUQgPSBDT0xPUl9CT1hfQ0xBU1MgKyBcIi1jb2xvci1pcy1ub3QtZGVmaW5lZFwiO1xyXG52YXIgQ09MT1JfQk9YX09WRVJMQVlfQ0xBU1MgPSBDT0xPUl9CT1hfQ0xBU1MgKyBcIi1vdmVybGF5XCI7XHJcbnZhciBDT0xPUl9CT1hfQ09OVEFJTkVSX0NFTExfQ0xBU1MgPSBcImR4LWNvbG9ydmlldy1jb250YWluZXItY2VsbFwiO1xyXG52YXIgQ09MT1JfQk9YX0JVVFRPTl9DRUxMX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctYnV0dG9uLWNlbGxcIjtcclxudmFyIENPTE9SX0JPWF9CVVRUT05TX0NPTlRBSU5FUl9DTEFTUyA9IFwiZHgtY29sb3J2aWV3LWJ1dHRvbnMtY29udGFpbmVyXCI7XHJcbnZhciBDT0xPUl9CT1hfQVBQTFlfQlVUVE9OX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctYXBwbHktYnV0dG9uXCI7XHJcbnZhciBDT0xPUl9CT1hfQ0FOQ0VMX0JVVFRPTl9DTEFTUyA9IFwiZHgtY29sb3J2aWV3LWNhbmNlbC1idXR0b25cIjtcclxudmFyIGNvbG9yRWRpdG9yUHJvdG90eXBlID0gQ29sb3JWaWV3LnByb3RvdHlwZTtcclxudmFyIGNvbG9yVXRpbHMgPSB7XHJcbiAgICBtYWtlVHJhbnNwYXJlbnRCYWNrZ3JvdW5kOiBjb2xvckVkaXRvclByb3RvdHlwZS5fbWFrZVRyYW5zcGFyZW50QmFja2dyb3VuZC5iaW5kKGNvbG9yRWRpdG9yUHJvdG90eXBlKSxcclxuICAgIG1ha2VSZ2JhOiBjb2xvckVkaXRvclByb3RvdHlwZS5fbWFrZVJnYmEuYmluZChjb2xvckVkaXRvclByb3RvdHlwZSlcclxufTtcclxudmFyIENvbG9yQm94ID0gRHJvcERvd25FZGl0b3IuaW5oZXJpdCh7XHJcbiAgICBfc3VwcG9ydGVkS2V5czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGFycm93SGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uKFwib3BlbmVkXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbEJhc2UoKSwge1xyXG4gICAgICAgICAgICB0YWI6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbihcIm9wZW5lZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xvclZpZXcuX3JnYklucHV0c1swXS5mb2N1cygpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudGVyOiB0aGlzLl9lbnRlcktleUhhbmRsZXIsXHJcbiAgICAgICAgICAgIGxlZnRBcnJvdzogYXJyb3dIYW5kbGVyLFxyXG4gICAgICAgICAgICByaWdodEFycm93OiBhcnJvd0hhbmRsZXIsXHJcbiAgICAgICAgICAgIHVwQXJyb3c6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb24oXCJvcGVuZWRcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5hbHRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkb3duQXJyb3c6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb24oXCJvcGVuZWRcIikgJiYgIWUuYWx0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbihcIm9wZW5lZFwiKSAmJiBlLmFsdEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlZE9wZW5pbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuICAgIF9nZXREZWZhdWx0T3B0aW9uczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxCYXNlKCksIHtcclxuICAgICAgICAgICAgZWRpdEFscGhhQ2hhbm5lbDogZmFsc2UsXHJcbiAgICAgICAgICAgIGFwcGx5VmFsdWVNb2RlOiBcInVzZUJ1dHRvbnNcIixcclxuICAgICAgICAgICAga2V5U3RlcDogMSxcclxuICAgICAgICAgICAgZmllbGRUZW1wbGF0ZTogbnVsbCxcclxuICAgICAgICAgICAgYnV0dG9uc0xvY2F0aW9uOiBcImJvdHRvbSBhZnRlclwiXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBfcG9wdXBIaWRpbmdIYW5kbGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNhbGxCYXNlKCk7XHJcbiAgICAgICAgaWYgKFwidXNlQnV0dG9uc1wiID09PSB0aGlzLm9wdGlvbihcImFwcGx5VmFsdWVNb2RlXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yVmlld1ZhbHVlKHRoaXMub3B0aW9uKFwidmFsdWVcIikpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9wb3B1cENvbmZpZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxCYXNlKCksIHtcclxuICAgICAgICAgICAgd2lkdGg6IFwiXCJcclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuICAgIF9jb250ZW50UmVhZHlIYW5kbGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9jcmVhdGVDb2xvclZpZXcoKTtcclxuICAgICAgICB0aGlzLl9hZGRQb3B1cEJvdHRvbUNsYXNzZXMoKVxyXG4gICAgfSxcclxuICAgIF9hZGRQb3B1cEJvdHRvbUNsYXNzZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciAkcG9wdXBCb3R0b20gPSB0aGlzLl9wb3B1cC5ib3R0b21Ub29sYmFyKCk7XHJcbiAgICAgICAgaWYgKCRwb3B1cEJvdHRvbSkge1xyXG4gICAgICAgICAgICAkcG9wdXBCb3R0b20uYWRkQ2xhc3MoQ09MT1JfQk9YX0NPTlRBSU5FUl9DRUxMX0NMQVNTKS5hZGRDbGFzcyhDT0xPUl9CT1hfQlVUVE9OX0NFTExfQ0xBU1MpLmZpbmQoXCIuZHgtdG9vbGJhci1pdGVtcy1jb250YWluZXJcIikuYWRkQ2xhc3MoQ09MT1JfQk9YX0JVVFRPTlNfQ09OVEFJTkVSX0NMQVNTKTtcclxuICAgICAgICAgICAgJHBvcHVwQm90dG9tLmZpbmQoXCIuZHgtcG9wdXAtZG9uZVwiKS5hZGRDbGFzcyhDT0xPUl9CT1hfQVBQTFlfQlVUVE9OX0NMQVNTKTtcclxuICAgICAgICAgICAgJHBvcHVwQm90dG9tLmZpbmQoXCIuZHgtcG9wdXAtY2FuY2VsXCIpLmFkZENsYXNzKENPTE9SX0JPWF9DQU5DRUxfQlVUVE9OX0NMQVNTKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfY3JlYXRlQ29sb3JWaWV3OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9wb3B1cC4kb3ZlcmxheUNvbnRlbnQoKS5hZGRDbGFzcyhDT0xPUl9CT1hfT1ZFUkxBWV9DTEFTUyk7XHJcbiAgICAgICAgdmFyICRjb2xvclZpZXcgPSAkKFwiPGRpdj5cIikuYXBwZW5kVG8odGhpcy5fcG9wdXAuJGNvbnRlbnQoKSk7XHJcbiAgICAgICAgdGhpcy5fY29sb3JWaWV3ID0gdGhpcy5fY3JlYXRlQ29tcG9uZW50KCRjb2xvclZpZXcsIENvbG9yVmlldywgdGhpcy5fY29sb3JWaWV3Q29uZmlnKCkpO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yVmlldy5yZWdpc3RlcktleUhhbmRsZXIoXCJlc2NhcGVcIiwgdGhpcy5fZXNjYXBlSGFuZGxlci5iaW5kKHRoaXMpKTtcclxuICAgICAgICBldmVudHNFbmdpbmUub24oJGNvbG9yVmlldywgXCJmb2N1c1wiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5mb2N1cygpXHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgfSxcclxuICAgIF9lc2NhcGVIYW5kbGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgdGhpcy5mb2N1cygpXHJcbiAgICB9LFxyXG4gICAgX2FwcGx5TmV3Q29sb3I6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb24oXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbG9yVXRpbHMubWFrZVRyYW5zcGFyZW50QmFja2dyb3VuZCh0aGlzLl8kY29sb3JSZXN1bHRQcmV2aWV3LCB2YWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yVmlld0VudGVyS2V5UHJlc3NlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yVmlld0VudGVyS2V5UHJlc3NlZCA9IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9jb2xvclZpZXdDb25maWc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2YWx1ZTogdGhhdC5vcHRpb24oXCJ2YWx1ZVwiKSxcclxuICAgICAgICAgICAgbWF0Y2hWYWx1ZTogdGhhdC5vcHRpb24oXCJ2YWx1ZVwiKSxcclxuICAgICAgICAgICAgZWRpdEFscGhhQ2hhbm5lbDogdGhhdC5vcHRpb24oXCJlZGl0QWxwaGFDaGFubmVsXCIpLFxyXG4gICAgICAgICAgICBhcHBseVZhbHVlTW9kZTogdGhhdC5vcHRpb24oXCJhcHBseVZhbHVlTW9kZVwiKSxcclxuICAgICAgICAgICAgZm9jdXNTdGF0ZUVuYWJsZWQ6IHRoYXQub3B0aW9uKFwiZm9jdXNTdGF0ZUVuYWJsZWRcIiksXHJcbiAgICAgICAgICAgIHN0eWxpbmdNb2RlOiB0aGlzLm9wdGlvbihcInN0eWxpbmdNb2RlXCIpLFxyXG4gICAgICAgICAgICBvbkVudGVyS2V5UHJlc3NlZDogZnVuY3Rpb24oX3JlZikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcclxuICAgICAgICAgICAgICAgIH0gPSBfcmVmO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fY29sb3JWaWV3RW50ZXJLZXlQcmVzc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9jb2xvclZpZXcub3B0aW9uKFwidmFsdWVcIikgIT09IHRoYXQub3B0aW9uKFwidmFsdWVcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zYXZlVmFsdWVDaGFuZ2VFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fYXBwbHlOZXdDb2xvcih0aGF0Ll9jb2xvclZpZXcub3B0aW9uKFwidmFsdWVcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY2xvc2UoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblZhbHVlQ2hhbmdlZDogZnVuY3Rpb24oX3JlZjIpIHtcclxuICAgICAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiBwcmV2aW91c1ZhbHVlXHJcbiAgICAgICAgICAgICAgICB9ID0gX3JlZjI7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFudGx5TW9kZSA9IFwiaW5zdGFudGx5XCIgPT09IHRoYXQub3B0aW9uKFwiYXBwbHlWYWx1ZU1vZGVcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNPbGRWYWx1ZSA9IGNvbG9yVXRpbHMubWFrZVJnYmEodmFsdWUpID09PSBwcmV2aW91c1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZXNBcHBsaWVkID0gaW5zdGFudGx5TW9kZSB8fCB0aGF0Ll9jb2xvclZpZXdFbnRlcktleVByZXNzZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVDbGVhcmVkID0gdGhhdC5fc2hvdWxkU2F2ZUVtcHR5VmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPbGRWYWx1ZSB8fCAhY2hhbmdlc0FwcGxpZWQgfHwgdmFsdWVDbGVhcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zYXZlVmFsdWVDaGFuZ2VFdmVudChldmVudClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoYXQuX2FwcGx5TmV3Q29sb3IodmFsdWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2VudGVyS2V5SGFuZGxlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuX2lucHV0KCkudmFsKCk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5vcHRpb24oXCJ2YWx1ZVwiKTtcclxuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm9wdGlvbihcImVkaXRBbHBoYUNoYW5uZWxcIikgPyBjb2xvclV0aWxzLm1ha2VSZ2JhKHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgICAgIGlmICghbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb2xvciA9IG5ldyBDb2xvcihuZXdWYWx1ZSk7XHJcbiAgICAgICAgaWYgKGNvbG9yLmNvbG9ySXNJbnZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lucHV0KCkudmFsKG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlDb2xvckZyb21JbnB1dChuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NhdmVWYWx1ZUNoYW5nZUV2ZW50KGUpO1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbihcInZhbHVlXCIsIHRoaXMub3B0aW9uKFwiZWRpdEFscGhhQ2hhbm5lbFwiKSA/IGNvbG9yVXRpbHMubWFrZVJnYmEobmV3VmFsdWUpIDogbmV3VmFsdWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9jb2xvclZpZXcpIHtcclxuICAgICAgICAgICAgdmFyIGNvbG9yVmlld1ZhbHVlID0gdGhpcy5fY29sb3JWaWV3Lm9wdGlvbihcInZhbHVlXCIpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IGNvbG9yVmlld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zYXZlVmFsdWVDaGFuZ2VFdmVudChlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uKFwidmFsdWVcIiwgY29sb3JWaWV3VmFsdWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfSxcclxuICAgIF9hcHBseUJ1dHRvbkhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICB0aGlzLl9zYXZlVmFsdWVDaGFuZ2VFdmVudChlLmV2ZW50KTtcclxuICAgICAgICB0aGlzLl9hcHBseU5ld0NvbG9yKHRoaXMuX2NvbG9yVmlldy5vcHRpb24oXCJ2YWx1ZVwiKSk7XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZSgpXHJcbiAgICB9LFxyXG4gICAgX2NhbmNlbEJ1dHRvbkhhbmRsZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc2V0SW5wdXRWYWx1ZSgpO1xyXG4gICAgICAgIHRoaXMuY2FsbEJhc2UoKVxyXG4gICAgfSxcclxuICAgIF9nZXRLZXlib2FyZExpc3RlbmVycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsQmFzZSgpLmNvbmNhdChbdGhpcy5fY29sb3JWaWV3XSlcclxuICAgIH0sXHJcbiAgICBfaW5pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZSgpXHJcbiAgICB9LFxyXG4gICAgX2luaXRNYXJrdXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuJGVsZW1lbnQoKS5hZGRDbGFzcyhDT0xPUl9CT1hfQ0xBU1MpO1xyXG4gICAgICAgIHRoaXMuY2FsbEJhc2UoKVxyXG4gICAgfSxcclxuICAgIF9yZW5kZXJJbnB1dDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZSgpO1xyXG4gICAgICAgIHRoaXMuX2lucHV0KCkuYWRkQ2xhc3MoQ09MT1JfQk9YX0lOUFVUX0NMQVNTKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJDb2xvclByZXZpZXcoKVxyXG4gICAgfSxcclxuICAgIF9yZW5kZXJDb2xvclByZXZpZXc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuJGVsZW1lbnQoKS53cmFwSW5uZXIoJChcIjxkaXY+XCIpLmFkZENsYXNzKENPTE9SX0JPWF9JTlBVVF9DT05UQUlORVJfQ0xBU1MpKTtcclxuICAgICAgICB0aGlzLl8kY29sb3JCb3hJbnB1dENvbnRhaW5lciA9IHRoaXMuJGVsZW1lbnQoKS5jaGlsZHJlbigpLmVxKDApO1xyXG4gICAgICAgIHRoaXMuXyRjb2xvclJlc3VsdFByZXZpZXcgPSAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoQ09MT1JfQk9YX0NPTE9SX1JFU1VMVF9QUkVWSUVXX0NMQVNTKS5hcHBlbmRUbyh0aGlzLl8kdGV4dEVkaXRvcklucHV0Q29udGFpbmVyKTtcclxuICAgICAgICBpZiAoIXRoaXMub3B0aW9uKFwidmFsdWVcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fJGNvbG9yQm94SW5wdXRDb250YWluZXIuYWRkQ2xhc3MoQ09MT1JfQk9YX0NPTE9SX0lTX05PVF9ERUZJTkVEKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbG9yVXRpbHMubWFrZVRyYW5zcGFyZW50QmFja2dyb3VuZCh0aGlzLl8kY29sb3JSZXN1bHRQcmV2aWV3LCB0aGlzLm9wdGlvbihcInZhbHVlXCIpKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfcmVuZGVyVmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMub3B0aW9uKFwidmFsdWVcIik7XHJcbiAgICAgICAgdmFyIGNvbnZlcnRUb0NvbG9yID0gbnVsbCAhPT0gdmFsdWUgJiYgdGhpcy5vcHRpb24oXCJlZGl0QWxwaGFDaGFubmVsXCIpO1xyXG4gICAgICAgIHZhciB0ZXh0ID0gY29udmVydFRvQ29sb3IgPyBjb2xvclV0aWxzLm1ha2VSZ2JhKHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgICAgIHRoaXMub3B0aW9uKFwidGV4dFwiLCB0ZXh0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsQmFzZSgpXHJcbiAgICB9LFxyXG4gICAgX3Jlc2V0SW5wdXRWYWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyICRpbnB1dCA9IHRoaXMuX2lucHV0KCk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5vcHRpb24oXCJ2YWx1ZVwiKTtcclxuICAgICAgICAkaW5wdXQudmFsKHZhbHVlKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVDb2xvclZpZXdWYWx1ZSh2YWx1ZSlcclxuICAgIH0sXHJcbiAgICBfdXBkYXRlQ29sb3JWaWV3VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yVmlldykge1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xvclZpZXcub3B0aW9uKHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIG1hdGNoVmFsdWU6IHZhbHVlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF92YWx1ZUNoYW5nZUV2ZW50SGFuZGxlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2lucHV0KCkudmFsKCk7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fYXBwbHlDb2xvckZyb21JbnB1dCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yVmlld1ZhbHVlKHZhbHVlKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxCYXNlKGUsIHZhbHVlKVxyXG4gICAgfSxcclxuICAgIF9hcHBseUNvbG9yRnJvbUlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHZhciBuZXdDb2xvciA9IG5ldyBDb2xvcih2YWx1ZSk7XHJcbiAgICAgICAgaWYgKG5ld0NvbG9yLmNvbG9ySXNJbnZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0SW5wdXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMub3B0aW9uKFwidmFsdWVcIilcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICB9LFxyXG4gICAgX2NsZWFuOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNhbGxCYXNlKCk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Nob3VsZFNhdmVFbXB0eVZhbHVlXHJcbiAgICB9LFxyXG4gICAgX29wdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKGFyZ3MpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBhcmdzLnZhbHVlO1xyXG4gICAgICAgIHZhciBuYW1lID0gYXJncy5uYW1lO1xyXG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuXyRjb2xvckJveElucHV0Q29udGFpbmVyLnRvZ2dsZUNsYXNzKENPTE9SX0JPWF9DT0xPUl9JU19OT1RfREVGSU5FRCwgIXZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yVXRpbHMubWFrZVRyYW5zcGFyZW50QmFja2dyb3VuZCh0aGlzLl8kY29sb3JSZXN1bHRQcmV2aWV3LCB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fJGNvbG9yUmVzdWx0UHJldmlldy5yZW1vdmVBdHRyKFwic3R5bGVcIilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3VsZFNhdmVFbXB0eVZhbHVlID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29sb3JWaWV3VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvdWxkU2F2ZUVtcHR5VmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEJhc2UoYXJncyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImFwcGx5QnV0dG9uVGV4dFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiY2FuY2VsQnV0dG9uVGV4dFwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQmFzZShhcmdzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVwICYmIHRoaXMuX2FkZFBvcHVwQm90dG9tQ2xhc3NlcygpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJlZGl0QWxwaGFDaGFubmVsXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJrZXlTdGVwXCI6XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29sb3JWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29sb3JWaWV3Lm9wdGlvbihuYW1lLCB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQmFzZShhcmdzKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbnJlZ2lzdGVyQ29tcG9uZW50KFwiZHhDb2xvckJveFwiLCBDb2xvckJveCk7XHJcbmV4cG9ydCBkZWZhdWx0IENvbG9yQm94O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/color_box/color_box.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/color_box/color_view.js":
/*!****************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/color_box/color_view.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_utils_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/utils/size */ \"./node_modules/devextreme/esm/core/utils/size.js\");\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/* harmony import */ var _events_core_events_engine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../events/core/events_engine */ \"./node_modules/devextreme/esm/events/core/events_engine.js\");\n/* harmony import */ var _animation_translator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../animation/translator */ \"./node_modules/devextreme/esm/animation/translator.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../color */ \"./node_modules/devextreme/esm/color.js\");\n/* harmony import */ var _localization_message__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../localization/message */ \"./node_modules/devextreme/esm/localization/message.js\");\n/* harmony import */ var _core_devices__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/devices */ \"./node_modules/devextreme/esm/core/devices.js\");\n/* harmony import */ var _core_component_registrator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/component_registrator */ \"./node_modules/devextreme/esm/core/component_registrator.js\");\n/* harmony import */ var _editor_editor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../editor/editor */ \"./node_modules/devextreme/esm/ui/editor/editor.js\");\n/* harmony import */ var _number_box__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../number_box */ \"./node_modules/devextreme/esm/ui/number_box.js\");\n/* harmony import */ var _text_box__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../text_box */ \"./node_modules/devextreme/esm/ui/text_box.js\");\n/* harmony import */ var _draggable__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../draggable */ \"./node_modules/devextreme/esm/ui/draggable.js\");\n/* harmony import */ var _events_utils_index__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../events/utils/index */ \"./node_modules/devextreme/esm/events/utils/index.js\");\n/* harmony import */ var _events_click__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../events/click */ \"./node_modules/devextreme/esm/events/click.js\");\n/**\r\n * DevExtreme (esm/ui/color_box/color_view.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar COLOR_VIEW_CLASS = \"dx-colorview\";\r\nvar COLOR_VIEW_CONTAINER_CLASS = \"dx-colorview-container\";\r\nvar COLOR_VIEW_ROW_CLASS = \"dx-colorview-container-row\";\r\nvar COLOR_VIEW_CELL_CLASS = \"dx-colorview-container-cell\";\r\nvar COLOR_VIEW_PALETTE_CLASS = \"dx-colorview-palette\";\r\nvar COLOR_VIEW_PALETTE_CELL_CLASS = \"dx-colorview-palette-cell\";\r\nvar COLOR_VIEW_PALETTE_HANDLE_CLASS = \"dx-colorview-palette-handle\";\r\nvar COLOR_VIEW_PALETTE_GRADIENT_CLASS = \"dx-colorview-palette-gradient\";\r\nvar COLOR_VIEW_PALETTE_GRADIENT_WHITE_CLASS = \"dx-colorview-palette-gradient-white\";\r\nvar COLOR_VIEW_PALETTE_GRADIENT_BLACK_CLASS = \"dx-colorview-palette-gradient-black\";\r\nvar COLOR_VIEW_HUE_SCALE_CLASS = \"dx-colorview-hue-scale\";\r\nvar COLOR_VIEW_HUE_SCALE_CELL_CLASS = \"dx-colorview-hue-scale-cell\";\r\nvar COLOR_VIEW_HUE_SCALE_HANDLE_CLASS = \"dx-colorview-hue-scale-handle\";\r\nvar COLOR_VIEW_HUE_SCALE_WRAPPER_CLASS = \"dx-colorview-hue-scale-wrapper\";\r\nvar COLOR_VIEW_CONTROLS_CONTAINER_CLASS = \"dx-colorview-controls-container\";\r\nvar COLOR_VIEW_RED_LABEL_CLASS = \"dx-colorview-label-red\";\r\nvar COLOR_VIEW_GREEN_LABEL_CLASS = \"dx-colorview-label-green\";\r\nvar COLOR_VIEW_BLUE_LABEL_CLASS = \"dx-colorview-label-blue\";\r\nvar COLOR_VIEW_HEX_LABEL_CLASS = \"dx-colorview-label-hex\";\r\nvar COLOR_VIEW_ALPHA_CHANNEL_SCALE_CLASS = \"dx-colorview-alpha-channel-scale\";\r\nvar COLOR_VIEW_APLHA_CHANNEL_ROW_CLASS = \"dx-colorview-alpha-channel-row\";\r\nvar COLOR_VIEW_ALPHA_CHANNEL_SCALE_WRAPPER_CLASS = \"dx-colorview-alpha-channel-wrapper\";\r\nvar COLOR_VIEW_ALPHA_CHANNEL_LABEL_CLASS = \"dx-colorview-alpha-channel-label\";\r\nvar COLOR_VIEW_ALPHA_CHANNEL_HANDLE_CLASS = \"dx-colorview-alpha-channel-handle\";\r\nvar COLOR_VIEW_ALPHA_CHANNEL_CELL_CLASS = \"dx-colorview-alpha-channel-cell\";\r\nvar COLOR_VIEW_ALPHA_CHANNEL_BORDER_CLASS = \"dx-colorview-alpha-channel-border\";\r\nvar COLOR_VIEW_COLOR_PREVIEW = \"dx-colorview-color-preview\";\r\nvar COLOR_VIEW_COLOR_PREVIEW_CONTAINER_CLASS = \"dx-colorview-color-preview-container\";\r\nvar COLOR_VIEW_COLOR_PREVIEW_CONTAINER_INNER_CLASS = \"dx-colorview-color-preview-container-inner\";\r\nvar COLOR_VIEW_COLOR_PREVIEW_COLOR_CURRENT = \"dx-colorview-color-preview-color-current\";\r\nvar COLOR_VIEW_COLOR_PREVIEW_COLOR_NEW = \"dx-colorview-color-preview-color-new\";\r\nvar ColorView = _editor_editor__WEBPACK_IMPORTED_MODULE_9__[\"default\"].inherit({\r\n    _supportedKeys: function() {\r\n        var isRTL = this.option(\"rtlEnabled\");\r\n        var that = this;\r\n        var getHorizontalPaletteStep = function(e) {\r\n            var step = 100 / that._paletteWidth;\r\n            if (e.shiftKey) {\r\n                step *= that.option(\"keyStep\")\r\n            }\r\n            step = step > 1 ? step : 1;\r\n            return Math.round(step)\r\n        };\r\n        var updateHorizontalPaletteValue = function(step) {\r\n            var value = that._currentColor.hsv.s + step;\r\n            if (value > 100) {\r\n                value = 100\r\n            } else if (value < 0) {\r\n                value = 0\r\n            }\r\n            that._currentColor.hsv.s = value;\r\n            updatePaletteValue()\r\n        };\r\n        var getVerticalPaletteStep = function(e) {\r\n            var step = 100 / that._paletteHeight;\r\n            if (e.shiftKey) {\r\n                step *= that.option(\"keyStep\")\r\n            }\r\n            step = step > 1 ? step : 1;\r\n            return Math.round(step)\r\n        };\r\n        var updateVerticalPaletteValue = function(step) {\r\n            var value = that._currentColor.hsv.v + step;\r\n            if (value > 100) {\r\n                value = 100\r\n            } else if (value < 0) {\r\n                value = 0\r\n            }\r\n            that._currentColor.hsv.v = value;\r\n            updatePaletteValue()\r\n        };\r\n\r\n        function updatePaletteValue() {\r\n            that._placePaletteHandle();\r\n            that._updateColorFromHsv(that._currentColor.hsv.h, that._currentColor.hsv.s, that._currentColor.hsv.v)\r\n        }\r\n        var getHueScaleStep = function(e) {\r\n            var step = 360 / (that._hueScaleWrapperHeight - that._hueScaleHandleHeight);\r\n            if (e.shiftKey) {\r\n                step *= that.option(\"keyStep\")\r\n            }\r\n            step = step > 1 ? step : 1;\r\n            return step\r\n        };\r\n        var updateHueScaleValue = function(step) {\r\n            that._currentColor.hsv.h += step;\r\n            that._placeHueScaleHandle();\r\n            var handleLocation = Object(_animation_translator__WEBPACK_IMPORTED_MODULE_3__[\"locate\"])(that._$hueScaleHandle);\r\n            that._updateColorHue(handleLocation.top + that._hueScaleHandleHeight / 2)\r\n        };\r\n        var getAlphaScaleStep = function(e) {\r\n            var step = 1 / that._alphaChannelScaleWorkWidth;\r\n            if (e.shiftKey) {\r\n                step *= that.option(\"keyStep\")\r\n            }\r\n            step = step > .01 ? step : .01;\r\n            step = isRTL ? -step : step;\r\n            return step\r\n        };\r\n        var updateAlphaScaleValue = function(step) {\r\n            that._currentColor.a += step;\r\n            that._placeAlphaChannelHandle();\r\n            var handleLocation = Object(_animation_translator__WEBPACK_IMPORTED_MODULE_3__[\"locate\"])(that._$alphaChannelHandle);\r\n            that._calculateColorTransparencyByScaleWidth(handleLocation.left + that._alphaChannelHandleWidth / 2)\r\n        };\r\n        return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])(this.callBase(), {\r\n            upArrow: function(e) {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n                if (Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_13__[\"isCommandKeyPressed\"])(e)) {\r\n                    if (this._currentColor.hsv.h <= 360 && !this._isTopColorHue) {\r\n                        this._saveValueChangeEvent(e);\r\n                        updateHueScaleValue(getHueScaleStep(e))\r\n                    }\r\n                } else if (this._currentColor.hsv.v < 100) {\r\n                    this._saveValueChangeEvent(e);\r\n                    updateVerticalPaletteValue(getVerticalPaletteStep(e))\r\n                }\r\n            },\r\n            downArrow: function(e) {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n                if (Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_13__[\"isCommandKeyPressed\"])(e)) {\r\n                    if (this._currentColor.hsv.h >= 0) {\r\n                        if (this._isTopColorHue) {\r\n                            this._currentColor.hsv.h = 360\r\n                        }\r\n                        this._saveValueChangeEvent(e);\r\n                        updateHueScaleValue(-getHueScaleStep(e))\r\n                    }\r\n                } else if (this._currentColor.hsv.v > 0) {\r\n                    this._saveValueChangeEvent(e);\r\n                    updateVerticalPaletteValue(-getVerticalPaletteStep(e))\r\n                }\r\n            },\r\n            rightArrow: function(e) {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n                if (Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_13__[\"isCommandKeyPressed\"])(e)) {\r\n                    if (isRTL ? this._currentColor.a < 1 : this._currentColor.a > 0 && this.option(\"editAlphaChannel\")) {\r\n                        this._saveValueChangeEvent(e);\r\n                        updateAlphaScaleValue(-getAlphaScaleStep(e))\r\n                    }\r\n                } else if (this._currentColor.hsv.s < 100) {\r\n                    this._saveValueChangeEvent(e);\r\n                    updateHorizontalPaletteValue(getHorizontalPaletteStep(e))\r\n                }\r\n            },\r\n            leftArrow: function(e) {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n                if (Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_13__[\"isCommandKeyPressed\"])(e)) {\r\n                    if (isRTL ? this._currentColor.a > 0 : this._currentColor.a < 1 && this.option(\"editAlphaChannel\")) {\r\n                        this._saveValueChangeEvent(e);\r\n                        updateAlphaScaleValue(getAlphaScaleStep(e))\r\n                    }\r\n                } else if (this._currentColor.hsv.s > 0) {\r\n                    this._saveValueChangeEvent(e);\r\n                    updateHorizontalPaletteValue(-getHorizontalPaletteStep(e))\r\n                }\r\n            },\r\n            enter: function(e) {\r\n                this._fireEnterKeyPressed(e)\r\n            }\r\n        })\r\n    },\r\n    _getDefaultOptions: function() {\r\n        return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])(this.callBase(), {\r\n            value: null,\r\n            matchValue: null,\r\n            onEnterKeyPressed: void 0,\r\n            editAlphaChannel: false,\r\n            keyStep: 1,\r\n            stylingMode: void 0\r\n        })\r\n    },\r\n    _defaultOptionsRules: function() {\r\n        return this.callBase().concat([{\r\n            device: function() {\r\n                return \"desktop\" === _core_devices__WEBPACK_IMPORTED_MODULE_7__[\"default\"].real().deviceType && !_core_devices__WEBPACK_IMPORTED_MODULE_7__[\"default\"].isSimulator()\r\n            },\r\n            options: {\r\n                focusStateEnabled: true\r\n            }\r\n        }])\r\n    },\r\n    _init: function() {\r\n        this.callBase();\r\n        this._initColorAndOpacity();\r\n        this._initEnterKeyPressedAction()\r\n    },\r\n    _initEnterKeyPressedAction: function() {\r\n        this._onEnterKeyPressedAction = this._createActionByOption(\"onEnterKeyPressed\")\r\n    },\r\n    _fireEnterKeyPressed: function(e) {\r\n        if (!this._onEnterKeyPressedAction) {\r\n            return\r\n        }\r\n        this._onEnterKeyPressedAction({\r\n            event: e\r\n        })\r\n    },\r\n    _initColorAndOpacity: function() {\r\n        this._setCurrentColor(this.option(\"value\"))\r\n    },\r\n    _setCurrentColor: function(value) {\r\n        value = value || \"#000000\";\r\n        var newColor = new _color__WEBPACK_IMPORTED_MODULE_5__[\"default\"](value);\r\n        if (!newColor.colorIsInvalid) {\r\n            if (!this._currentColor || this._makeRgba(this._currentColor) !== this._makeRgba(newColor)) {\r\n                this._currentColor = newColor;\r\n                if (this._$currentColor) {\r\n                    this._makeTransparentBackground(this._$currentColor, newColor)\r\n                }\r\n            }\r\n        } else {\r\n            this.option(\"value\", this._currentColor.baseColor)\r\n        }\r\n    },\r\n    _setBaseColor: function(value) {\r\n        var color = value || \"#000000\";\r\n        var newColor = new _color__WEBPACK_IMPORTED_MODULE_5__[\"default\"](color);\r\n        if (!newColor.colorIsInvalid) {\r\n            var isBaseColorChanged = this._makeRgba(this.option(\"matchValue\") !== this._makeRgba(newColor));\r\n            if (isBaseColorChanged) {\r\n                if (this._$baseColor) {\r\n                    this._makeTransparentBackground(this._$baseColor, newColor)\r\n                }\r\n            }\r\n        }\r\n    },\r\n    _initMarkup: function() {\r\n        this.callBase();\r\n        this.$element().addClass(COLOR_VIEW_CLASS);\r\n        this._renderColorPickerContainer()\r\n    },\r\n    _render: function() {\r\n        this.callBase();\r\n        this._renderPalette();\r\n        this._renderHueScale();\r\n        this._renderControlsContainer();\r\n        this._renderControls();\r\n        this._renderAlphaChannelElements()\r\n    },\r\n    _makeTransparentBackground: function($el, color) {\r\n        if (!(color instanceof _color__WEBPACK_IMPORTED_MODULE_5__[\"default\"])) {\r\n            color = new _color__WEBPACK_IMPORTED_MODULE_5__[\"default\"](color)\r\n        }\r\n        $el.css(\"backgroundColor\", this._makeRgba(color))\r\n    },\r\n    _makeRgba: function(color) {\r\n        if (!(color instanceof _color__WEBPACK_IMPORTED_MODULE_5__[\"default\"])) {\r\n            color = new _color__WEBPACK_IMPORTED_MODULE_5__[\"default\"](color)\r\n        }\r\n        return \"rgba(\" + [color.r, color.g, color.b, color.a].join(\", \") + \")\"\r\n    },\r\n    _renderValue: function() {\r\n        this.callBase(this.option(\"editAlphaChannel\") ? this._makeRgba(this._currentColor) : this.option(\"value\"))\r\n    },\r\n    _renderColorPickerContainer: function() {\r\n        var $parent = this.$element();\r\n        this._$colorPickerContainer = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_CONTAINER_CLASS).appendTo($parent);\r\n        this._renderHtmlRows()\r\n    },\r\n    _renderHtmlRows: function(updatedOption) {\r\n        var $renderedRows = this._$colorPickerContainer.find(\".\" + COLOR_VIEW_ROW_CLASS);\r\n        var renderedRowsCount = $renderedRows.length;\r\n        var rowCount = this.option(\"editAlphaChannel\") ? 2 : 1;\r\n        var delta = renderedRowsCount - rowCount;\r\n        if (delta > 0) {\r\n            $renderedRows.eq(-1).remove()\r\n        }\r\n        if (delta < 0) {\r\n            delta = Math.abs(delta);\r\n            var rows = [];\r\n            var i;\r\n            for (i = 0; i < delta; i++) {\r\n                rows.push(Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_ROW_CLASS))\r\n            }\r\n            if (renderedRowsCount) {\r\n                for (i = 0; i < rows.length; i++) {\r\n                    $renderedRows.eq(0).after(rows[i])\r\n                }\r\n            } else {\r\n                this._$colorPickerContainer.append(rows)\r\n            }\r\n        }\r\n    },\r\n    _renderHtmlCellInsideRow: function(index, $rowParent, additionalClass) {\r\n        return Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_CELL_CLASS).addClass(additionalClass).appendTo($rowParent.find(\".\" + COLOR_VIEW_ROW_CLASS).eq(index))\r\n    },\r\n    _renderPalette: function() {\r\n        var $paletteCell = this._renderHtmlCellInsideRow(0, this._$colorPickerContainer, COLOR_VIEW_PALETTE_CELL_CLASS);\r\n        var $paletteGradientWhite = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass([COLOR_VIEW_PALETTE_GRADIENT_CLASS, COLOR_VIEW_PALETTE_GRADIENT_WHITE_CLASS].join(\" \"));\r\n        var $paletteGradientBlack = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass([COLOR_VIEW_PALETTE_GRADIENT_CLASS, COLOR_VIEW_PALETTE_GRADIENT_BLACK_CLASS].join(\" \"));\r\n        this._$palette = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_PALETTE_CLASS).css(\"backgroundColor\", this._currentColor.getPureColor().toHex()).appendTo($paletteCell);\r\n        this._paletteHeight = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getHeight\"])(this._$palette);\r\n        this._paletteWidth = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getWidth\"])(this._$palette);\r\n        this._renderPaletteHandle();\r\n        this._$palette.append([$paletteGradientWhite, $paletteGradientBlack])\r\n    },\r\n    _renderPaletteHandle: function() {\r\n        this._$paletteHandle = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_PALETTE_HANDLE_CLASS).appendTo(this._$palette);\r\n        this._createComponent(this._$paletteHandle, _draggable__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\r\n            contentTemplate: null,\r\n            boundary: this._$palette,\r\n            allowMoveByClick: true,\r\n            boundOffset: function() {\r\n                return -this._paletteHandleHeight / 2\r\n            }.bind(this),\r\n            onDragMove: _ref => {\r\n                var {\r\n                    event: event\r\n                } = _ref;\r\n                var paletteHandlePosition = Object(_animation_translator__WEBPACK_IMPORTED_MODULE_3__[\"locate\"])(this._$paletteHandle);\r\n                this._updateByDrag = true;\r\n                this._saveValueChangeEvent(event);\r\n                this._updateColorFromHsv(this._currentColor.hsv.h, this._calculateColorSaturation(paletteHandlePosition), this._calculateColorValue(paletteHandlePosition))\r\n            }\r\n        });\r\n        this._paletteHandleWidth = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getWidth\"])(this._$paletteHandle);\r\n        this._paletteHandleHeight = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getHeight\"])(this._$paletteHandle);\r\n        this._placePaletteHandle()\r\n    },\r\n    _placePaletteHandle: function() {\r\n        Object(_animation_translator__WEBPACK_IMPORTED_MODULE_3__[\"move\"])(this._$paletteHandle, {\r\n            left: Math.round(this._paletteWidth * this._currentColor.hsv.s / 100 - this._paletteHandleWidth / 2),\r\n            top: Math.round(this._paletteHeight - this._paletteHeight * this._currentColor.hsv.v / 100 - this._paletteHandleHeight / 2)\r\n        })\r\n    },\r\n    _calculateColorValue: function(paletteHandlePosition) {\r\n        var value = Math.floor(paletteHandlePosition.top + this._paletteHandleHeight / 2);\r\n        return 100 - Math.round(100 * value / this._paletteHeight)\r\n    },\r\n    _calculateColorSaturation: function(paletteHandlePosition) {\r\n        var saturation = Math.floor(paletteHandlePosition.left + this._paletteHandleWidth / 2);\r\n        return Math.round(100 * saturation / this._paletteWidth)\r\n    },\r\n    _updateColorFromHsv: function(hue, saturation, value) {\r\n        var a = this._currentColor.a;\r\n        this._currentColor = new _color__WEBPACK_IMPORTED_MODULE_5__[\"default\"](\"hsv(\" + [hue, saturation, value].join(\",\") + \")\");\r\n        this._currentColor.a = a;\r\n        this._updateColorParamsAndColorPreview();\r\n        this.applyColor()\r\n    },\r\n    _renderHueScale: function() {\r\n        var $hueScaleCell = this._renderHtmlCellInsideRow(0, this._$colorPickerContainer, COLOR_VIEW_HUE_SCALE_CELL_CLASS);\r\n        this._$hueScaleWrapper = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_HUE_SCALE_WRAPPER_CLASS).appendTo($hueScaleCell);\r\n        this._$hueScale = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_HUE_SCALE_CLASS).appendTo(this._$hueScaleWrapper);\r\n        this._hueScaleHeight = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getHeight\"])(this._$hueScale);\r\n        this._hueScaleWrapperHeight = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterHeight\"])(this._$hueScaleWrapper);\r\n        this._renderHueScaleHandle()\r\n    },\r\n    _renderHueScaleHandle: function() {\r\n        this._$hueScaleHandle = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_HUE_SCALE_HANDLE_CLASS).appendTo(this._$hueScaleWrapper);\r\n        this._createComponent(this._$hueScaleHandle, _draggable__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\r\n            contentTemplate: null,\r\n            boundary: this._$hueScaleWrapper,\r\n            allowMoveByClick: true,\r\n            dragDirection: \"vertical\",\r\n            onDragMove: _ref2 => {\r\n                var {\r\n                    event: event\r\n                } = _ref2;\r\n                this._updateByDrag = true;\r\n                this._saveValueChangeEvent(event);\r\n                this._updateColorHue(Object(_animation_translator__WEBPACK_IMPORTED_MODULE_3__[\"locate\"])(this._$hueScaleHandle).top + this._hueScaleHandleHeight / 2)\r\n            }\r\n        });\r\n        this._hueScaleHandleHeight = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getHeight\"])(this._$hueScaleHandle);\r\n        this._placeHueScaleHandle()\r\n    },\r\n    _placeHueScaleHandle: function() {\r\n        var hueScaleHeight = this._hueScaleWrapperHeight;\r\n        var handleHeight = this._hueScaleHandleHeight;\r\n        var top = (hueScaleHeight - handleHeight) * (360 - this._currentColor.hsv.h) / 360;\r\n        if (hueScaleHeight < top + handleHeight) {\r\n            top = hueScaleHeight - handleHeight\r\n        }\r\n        if (top < 0) {\r\n            top = 0\r\n        }\r\n        Object(_animation_translator__WEBPACK_IMPORTED_MODULE_3__[\"move\"])(this._$hueScaleHandle, {\r\n            top: Math.round(top)\r\n        })\r\n    },\r\n    _updateColorHue: function(handlePosition) {\r\n        var hue = 360 - Math.round(360 * (handlePosition - this._hueScaleHandleHeight / 2) / (this._hueScaleWrapperHeight - this._hueScaleHandleHeight));\r\n        var saturation = this._currentColor.hsv.s;\r\n        var value = this._currentColor.hsv.v;\r\n        this._isTopColorHue = false;\r\n        hue = hue < 0 ? 0 : hue;\r\n        if (hue >= 360) {\r\n            this._isTopColorHue = true;\r\n            hue = 0\r\n        }\r\n        this._updateColorFromHsv(hue, saturation, value);\r\n        this._$palette.css(\"backgroundColor\", this._currentColor.getPureColor().toHex())\r\n    },\r\n    _renderControlsContainer: function() {\r\n        var $controlsContainerCell = this._renderHtmlCellInsideRow(0, this._$colorPickerContainer);\r\n        this._$controlsContainer = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_CONTROLS_CONTAINER_CLASS).appendTo($controlsContainerCell)\r\n    },\r\n    _renderControls: function() {\r\n        this._renderColorsPreview();\r\n        this._renderRgbInputs();\r\n        this._renderHexInput()\r\n    },\r\n    _renderColorsPreview: function() {\r\n        var $colorsPreviewContainer = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_COLOR_PREVIEW_CONTAINER_CLASS).appendTo(this._$controlsContainer);\r\n        var $colorsPreviewContainerInner = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_COLOR_PREVIEW_CONTAINER_INNER_CLASS).appendTo($colorsPreviewContainer);\r\n        this._$currentColor = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass([COLOR_VIEW_COLOR_PREVIEW, COLOR_VIEW_COLOR_PREVIEW_COLOR_NEW].join(\" \"));\r\n        this._$baseColor = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass([COLOR_VIEW_COLOR_PREVIEW, COLOR_VIEW_COLOR_PREVIEW_COLOR_CURRENT].join(\" \"));\r\n        this._makeTransparentBackground(this._$baseColor, this.option(\"matchValue\"));\r\n        this._makeTransparentBackground(this._$currentColor, this._currentColor);\r\n        $colorsPreviewContainerInner.append([this._$baseColor, this._$currentColor])\r\n    },\r\n    _renderAlphaChannelElements: function() {\r\n        if (this.option(\"editAlphaChannel\")) {\r\n            this._$colorPickerContainer.find(\".\" + COLOR_VIEW_ROW_CLASS).eq(1).addClass(COLOR_VIEW_APLHA_CHANNEL_ROW_CLASS);\r\n            this._renderAlphaChannelScale();\r\n            this._renderAlphaChannelInput()\r\n        }\r\n    },\r\n    _renderRgbInputs: function() {\r\n        this._rgbInputsWithLabels = [this._renderEditorWithLabel({\r\n            editorType: _number_box__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\r\n            value: this._currentColor.r,\r\n            onValueChanged: this._updateColor.bind(this, false),\r\n            labelText: \"R\",\r\n            labelAriaText: _localization_message__WEBPACK_IMPORTED_MODULE_6__[\"default\"].format(\"dxColorView-ariaRed\"),\r\n            labelClass: COLOR_VIEW_RED_LABEL_CLASS\r\n        }), this._renderEditorWithLabel({\r\n            editorType: _number_box__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\r\n            value: this._currentColor.g,\r\n            onValueChanged: this._updateColor.bind(this, false),\r\n            labelText: \"G\",\r\n            labelAriaText: _localization_message__WEBPACK_IMPORTED_MODULE_6__[\"default\"].format(\"dxColorView-ariaGreen\"),\r\n            labelClass: COLOR_VIEW_GREEN_LABEL_CLASS\r\n        }), this._renderEditorWithLabel({\r\n            editorType: _number_box__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\r\n            value: this._currentColor.b,\r\n            onValueChanged: this._updateColor.bind(this, false),\r\n            labelText: \"B\",\r\n            labelAriaText: _localization_message__WEBPACK_IMPORTED_MODULE_6__[\"default\"].format(\"dxColorView-ariaBlue\"),\r\n            labelClass: COLOR_VIEW_BLUE_LABEL_CLASS\r\n        })];\r\n        this._$controlsContainer.append(this._rgbInputsWithLabels);\r\n        this._rgbInputs = [this._rgbInputsWithLabels[0].find(\".dx-numberbox\").dxNumberBox(\"instance\"), this._rgbInputsWithLabels[1].find(\".dx-numberbox\").dxNumberBox(\"instance\"), this._rgbInputsWithLabels[2].find(\".dx-numberbox\").dxNumberBox(\"instance\")]\r\n    },\r\n    _renderEditorWithLabel: function(options) {\r\n        var $editor = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\");\r\n        var $label = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<label>\").addClass(options.labelClass).text(options.labelText + \":\").append($editor);\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_2__[\"default\"].off($label, _events_click__WEBPACK_IMPORTED_MODULE_14__[\"name\"]);\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_2__[\"default\"].on($label, _events_click__WEBPACK_IMPORTED_MODULE_14__[\"name\"], (function(e) {\r\n            e.preventDefault()\r\n        }));\r\n        var editorType = options.editorType;\r\n        var editorOptions = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])({\r\n            value: options.value,\r\n            onValueChanged: options.onValueChanged,\r\n            onKeyboardHandled: opts => this._keyboardHandler(opts)\r\n        }, {\r\n            stylingMode: this.option(\"stylingMode\")\r\n        });\r\n        if (editorType === _number_box__WEBPACK_IMPORTED_MODULE_10__[\"default\"]) {\r\n            editorOptions.min = options.min || 0;\r\n            editorOptions.max = options.max || 255;\r\n            editorOptions.step = options.step || 1\r\n        }\r\n        var editor = new editorType($editor, editorOptions);\r\n        editor.registerKeyHandler(\"enter\", function(e) {\r\n            this._fireEnterKeyPressed(e)\r\n        }.bind(this));\r\n        this.setAria(\"label\", options.labelAriaText, $editor);\r\n        return $label\r\n    },\r\n    hexInputOptions: function() {\r\n        return {\r\n            editorType: _text_box__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\r\n            value: this._currentColor.toHex().replace(\"#\", \"\"),\r\n            onValueChanged: this._updateColor.bind(this, true),\r\n            labelClass: COLOR_VIEW_HEX_LABEL_CLASS,\r\n            labelText: \"#\",\r\n            labelAriaText: _localization_message__WEBPACK_IMPORTED_MODULE_6__[\"default\"].format(\"dxColorView-ariaHex\")\r\n        }\r\n    },\r\n    _renderHexInput: function() {\r\n        this._hexInput = _text_box__WEBPACK_IMPORTED_MODULE_11__[\"default\"].getInstance(this._renderEditorWithLabel(this.hexInputOptions()).appendTo(this._$controlsContainer).find(\".dx-textbox\"))\r\n    },\r\n    _renderAlphaChannelScale: function() {\r\n        var $alphaChannelScaleCell = this._renderHtmlCellInsideRow(1, this._$colorPickerContainer, COLOR_VIEW_ALPHA_CHANNEL_CELL_CLASS);\r\n        var $alphaChannelBorder = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_ALPHA_CHANNEL_BORDER_CLASS).appendTo($alphaChannelScaleCell);\r\n        var $alphaChannelScaleWrapper = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_ALPHA_CHANNEL_SCALE_WRAPPER_CLASS).appendTo($alphaChannelBorder);\r\n        this._$alphaChannelScale = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_ALPHA_CHANNEL_SCALE_CLASS).appendTo($alphaChannelScaleWrapper);\r\n        this._makeCSSLinearGradient(this._$alphaChannelScale);\r\n        this._renderAlphaChannelHandle($alphaChannelScaleCell)\r\n    },\r\n    _makeCSSLinearGradient: function($el) {\r\n        var color = this._currentColor;\r\n        var colorAsRgb = [color.r, color.g, color.b].join(\",\");\r\n        var colorAsHex = color.toHex().replace(\"#\", \"\");\r\n        $el.attr(\"style\", function(colorAsRgb, colorAsHex) {\r\n            var rtlEnabled = this.option(\"rtlEnabled\");\r\n            var startColor = \"rgba(\" + colorAsRgb + \", \" + (rtlEnabled ? \"1\" : \"0\") + \")\";\r\n            var finishColor = \"rgba(\" + colorAsRgb + \", \" + (rtlEnabled ? \"0\" : \"1\") + \")\";\r\n            return [\"background-image: -webkit-linear-gradient(180deg, \" + startColor + \", \" + finishColor + \")\", \"background-image: -moz-linear-gradient(-90deg, \" + startColor + \", \" + finishColor + \")\", \"background-image: -o-linear-gradient(-90deg, \" + startColor + \", \" + finishColor + \")\", \"background-image: linear-gradient(-90deg, \" + startColor + \", \" + finishColor + \")\"].join(\";\")\r\n        }.call(this, colorAsRgb, colorAsHex))\r\n    },\r\n    _renderAlphaChannelInput: function() {\r\n        var that = this;\r\n        var $alphaChannelInputCell = this._renderHtmlCellInsideRow(1, this._$colorPickerContainer);\r\n        that._alphaChannelInput = this._renderEditorWithLabel({\r\n            editorType: _number_box__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\r\n            value: this._currentColor.a,\r\n            max: 1,\r\n            step: .1,\r\n            onValueChanged: function(args) {\r\n                var value = args.value;\r\n                value = that._currentColor.isValidAlpha(value) ? value : that._currentColor.a;\r\n                args.event && that._saveValueChangeEvent(args.event);\r\n                that._updateColorTransparency(value);\r\n                that._placeAlphaChannelHandle()\r\n            },\r\n            labelClass: COLOR_VIEW_ALPHA_CHANNEL_LABEL_CLASS,\r\n            labelText: \"Alpha\",\r\n            labelAriaText: _localization_message__WEBPACK_IMPORTED_MODULE_6__[\"default\"].format(\"dxColorView-ariaAlpha\")\r\n        }).appendTo($alphaChannelInputCell).find(\".dx-numberbox\").dxNumberBox(\"instance\")\r\n    },\r\n    _updateColorTransparency: function(transparency) {\r\n        this._currentColor.a = transparency;\r\n        this.applyColor()\r\n    },\r\n    _renderAlphaChannelHandle: function($parent) {\r\n        this._$alphaChannelHandle = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(COLOR_VIEW_ALPHA_CHANNEL_HANDLE_CLASS).appendTo($parent);\r\n        this._createComponent(this._$alphaChannelHandle, _draggable__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\r\n            contentTemplate: null,\r\n            boundary: $parent,\r\n            allowMoveByClick: true,\r\n            dragDirection: \"horizontal\",\r\n            onDragMove: _ref3 => {\r\n                var {\r\n                    event: event\r\n                } = _ref3;\r\n                this._updateByDrag = true;\r\n                var $alphaChannelHandle = this._$alphaChannelHandle;\r\n                var alphaChannelHandlePosition = Object(_animation_translator__WEBPACK_IMPORTED_MODULE_3__[\"locate\"])($alphaChannelHandle).left + this._alphaChannelHandleWidth / 2;\r\n                this._saveValueChangeEvent(event);\r\n                this._calculateColorTransparencyByScaleWidth(alphaChannelHandlePosition)\r\n            }\r\n        });\r\n        this._alphaChannelHandleWidth = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getWidth\"])(this._$alphaChannelHandle);\r\n        this._alphaChannelScaleWorkWidth = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getWidth\"])($parent) - this._alphaChannelHandleWidth;\r\n        this._placeAlphaChannelHandle()\r\n    },\r\n    _calculateColorTransparencyByScaleWidth: function(handlePosition) {\r\n        var transparency = (handlePosition - this._alphaChannelHandleWidth / 2) / this._alphaChannelScaleWorkWidth;\r\n        var rtlEnabled = this.option(\"rtlEnabled\");\r\n        transparency = rtlEnabled ? transparency : 1 - transparency;\r\n        if (handlePosition >= this._alphaChannelScaleWorkWidth + this._alphaChannelHandleWidth / 2) {\r\n            transparency = rtlEnabled ? 1 : 0\r\n        } else if (transparency < 1) {\r\n            transparency = transparency.toFixed(2)\r\n        }\r\n        transparency = Math.max(transparency, 0);\r\n        transparency = Math.min(transparency, 1);\r\n        this._alphaChannelInput.option(\"value\", transparency)\r\n    },\r\n    _placeAlphaChannelHandle: function() {\r\n        var left = this._alphaChannelScaleWorkWidth * (1 - this._currentColor.a);\r\n        if (left < 0) {\r\n            left = 0\r\n        }\r\n        if (this._alphaChannelScaleWorkWidth < left) {\r\n            left = this._alphaChannelScaleWorkWidth\r\n        }\r\n        Object(_animation_translator__WEBPACK_IMPORTED_MODULE_3__[\"move\"])(this._$alphaChannelHandle, {\r\n            left: this.option(\"rtlEnabled\") ? this._alphaChannelScaleWorkWidth - left : left\r\n        })\r\n    },\r\n    applyColor: function() {\r\n        var colorValue = this.option(\"editAlphaChannel\") ? this._makeRgba(this._currentColor) : this._currentColor.toHex();\r\n        this._makeTransparentBackground(this._$currentColor, this._currentColor);\r\n        this.option(\"value\", colorValue)\r\n    },\r\n    cancelColor: function() {\r\n        this._initColorAndOpacity();\r\n        this._refreshMarkup()\r\n    },\r\n    _updateColor: function(isHex, args) {\r\n        var rgba;\r\n        var newColor;\r\n        if (isHex) {\r\n            newColor = this._validateHex(\"#\" + this._hexInput.option(\"value\"))\r\n        } else {\r\n            rgba = this._validateRgb();\r\n            if (this._alphaChannelInput) {\r\n                rgba.push(this._alphaChannelInput.option(\"value\"));\r\n                newColor = \"rgba(\" + rgba.join(\", \") + \")\"\r\n            } else {\r\n                newColor = \"rgb(\" + rgba.join(\", \") + \")\"\r\n            }\r\n        }\r\n        if (!this._suppressEditorsValueUpdating) {\r\n            this._currentColor = new _color__WEBPACK_IMPORTED_MODULE_5__[\"default\"](newColor);\r\n            this._saveValueChangeEvent(args.event);\r\n            this.applyColor();\r\n            this._refreshMarkup()\r\n        }\r\n    },\r\n    _validateHex: function(hex) {\r\n        return this._currentColor.isValidHex(hex) ? hex : this._currentColor.toHex()\r\n    },\r\n    _validateRgb: function() {\r\n        var r = this._rgbInputs[0].option(\"value\");\r\n        var g = this._rgbInputs[1].option(\"value\");\r\n        var b = this._rgbInputs[2].option(\"value\");\r\n        if (!this._currentColor.isValidRGB(r, g, b)) {\r\n            r = this._currentColor.r;\r\n            g = this._currentColor.g;\r\n            b = this._currentColor.b\r\n        }\r\n        return [r, g, b]\r\n    },\r\n    _refreshMarkup: function() {\r\n        this._placeHueScaleHandle();\r\n        this._placePaletteHandle();\r\n        this._updateColorParamsAndColorPreview();\r\n        this._$palette.css(\"backgroundColor\", this._currentColor.getPureColor().toHex());\r\n        if (this._$alphaChannelHandle) {\r\n            this._updateColorTransparency(this._currentColor.a);\r\n            this._placeAlphaChannelHandle()\r\n        }\r\n    },\r\n    _updateColorParamsAndColorPreview: function() {\r\n        this._suppressEditorsValueUpdating = true;\r\n        this._hexInput.option(\"value\", this._currentColor.toHex().replace(\"#\", \"\"));\r\n        this._rgbInputs[0].option(\"value\", this._currentColor.r);\r\n        this._rgbInputs[1].option(\"value\", this._currentColor.g);\r\n        this._rgbInputs[2].option(\"value\", this._currentColor.b);\r\n        this._suppressEditorsValueUpdating = false;\r\n        if (this.option(\"editAlphaChannel\")) {\r\n            this._makeCSSLinearGradient.call(this, this._$alphaChannelScale);\r\n            this._alphaChannelInput.option(\"value\", this._currentColor.a)\r\n        }\r\n    },\r\n    _optionChanged: function(args) {\r\n        var value = args.value;\r\n        switch (args.name) {\r\n            case \"value\":\r\n                this._setCurrentColor(value);\r\n                if (!this._updateByDrag) {\r\n                    this._refreshMarkup()\r\n                }\r\n                this._updateByDrag = false;\r\n                this.callBase(args);\r\n                break;\r\n            case \"matchValue\":\r\n                this._setBaseColor(value);\r\n                break;\r\n            case \"onEnterKeyPressed\":\r\n                this._initEnterKeyPressedAction();\r\n                break;\r\n            case \"editAlphaChannel\":\r\n                if (this._$colorPickerContainer) {\r\n                    this._renderHtmlRows(\"editAlphaChannel\");\r\n                    this._renderAlphaChannelElements()\r\n                }\r\n                break;\r\n            case \"keyStep\":\r\n                break;\r\n            case \"stylingMode\":\r\n                this._renderControls();\r\n                break;\r\n            default:\r\n                this.callBase(args)\r\n        }\r\n    }\r\n});\r\nObject(_core_component_registrator__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(\"dxColorView\", ColorView);\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ColorView);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvY29sb3JfYm94L2NvbG9yX3ZpZXcuanM/NjYwOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLK0I7QUFDSztBQUN1QjtBQUl2QjtBQUdIO0FBQ0Q7QUFDNkI7QUFDcEI7QUFDd0I7QUFDM0I7QUFDQTtBQUNKO0FBQ0c7QUFHSDtBQUdOO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9FQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0VBQU07QUFDdkM7QUFDQTtB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LGlFQUFRO0FBQ2hELDJDQUEyQyxpRUFBUTtBQUNuRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBSTtBQUNaO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4Q0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMkVBQWlCO0FBQ0Ysd0VBQVMsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9jb2xvcl9ib3gvY29sb3Jfdmlldy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdWkvY29sb3JfYm94L2NvbG9yX3ZpZXcuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCB7XHJcbiAgICBnZXRIZWlnaHQsXHJcbiAgICBnZXRXaWR0aCxcclxuICAgIGdldE91dGVySGVpZ2h0XHJcbn0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvc2l6ZVwiO1xyXG5pbXBvcnQgJCBmcm9tIFwiLi4vLi4vY29yZS9yZW5kZXJlclwiO1xyXG5pbXBvcnQgZXZlbnRzRW5naW5lIGZyb20gXCIuLi8uLi9ldmVudHMvY29yZS9ldmVudHNfZW5naW5lXCI7XHJcbmltcG9ydCB7XHJcbiAgICBsb2NhdGUsXHJcbiAgICBtb3ZlXHJcbn0gZnJvbSBcIi4uLy4uL2FuaW1hdGlvbi90cmFuc2xhdG9yXCI7XHJcbmltcG9ydCB7XHJcbiAgICBleHRlbmRcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9leHRlbmRcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9jb2xvclwiO1xyXG5pbXBvcnQgbWVzc2FnZUxvY2FsaXphdGlvbiBmcm9tIFwiLi4vLi4vbG9jYWxpemF0aW9uL21lc3NhZ2VcIjtcclxuaW1wb3J0IGRldmljZXMgZnJvbSBcIi4uLy4uL2NvcmUvZGV2aWNlc1wiO1xyXG5pbXBvcnQgcmVnaXN0ZXJDb21wb25lbnQgZnJvbSBcIi4uLy4uL2NvcmUvY29tcG9uZW50X3JlZ2lzdHJhdG9yXCI7XHJcbmltcG9ydCBFZGl0b3IgZnJvbSBcIi4uL2VkaXRvci9lZGl0b3JcIjtcclxuaW1wb3J0IE51bWJlckJveCBmcm9tIFwiLi4vbnVtYmVyX2JveFwiO1xyXG5pbXBvcnQgVGV4dEJveCBmcm9tIFwiLi4vdGV4dF9ib3hcIjtcclxuaW1wb3J0IERyYWdnYWJsZSBmcm9tIFwiLi4vZHJhZ2dhYmxlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBpc0NvbW1hbmRLZXlQcmVzc2VkXHJcbn0gZnJvbSBcIi4uLy4uL2V2ZW50cy91dGlscy9pbmRleFwiO1xyXG5pbXBvcnQge1xyXG4gICAgbmFtZSBhcyBjbGlja0V2ZW50TmFtZVxyXG59IGZyb20gXCIuLi8uLi9ldmVudHMvY2xpY2tcIjtcclxudmFyIENPTE9SX1ZJRVdfQ0xBU1MgPSBcImR4LWNvbG9ydmlld1wiO1xyXG52YXIgQ09MT1JfVklFV19DT05UQUlORVJfQ0xBU1MgPSBcImR4LWNvbG9ydmlldy1jb250YWluZXJcIjtcclxudmFyIENPTE9SX1ZJRVdfUk9XX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctY29udGFpbmVyLXJvd1wiO1xyXG52YXIgQ09MT1JfVklFV19DRUxMX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctY29udGFpbmVyLWNlbGxcIjtcclxudmFyIENPTE9SX1ZJRVdfUEFMRVRURV9DTEFTUyA9IFwiZHgtY29sb3J2aWV3LXBhbGV0dGVcIjtcclxudmFyIENPTE9SX1ZJRVdfUEFMRVRURV9DRUxMX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctcGFsZXR0ZS1jZWxsXCI7XHJcbnZhciBDT0xPUl9WSUVXX1BBTEVUVEVfSEFORExFX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctcGFsZXR0ZS1oYW5kbGVcIjtcclxudmFyIENPTE9SX1ZJRVdfUEFMRVRURV9HUkFESUVOVF9DTEFTUyA9IFwiZHgtY29sb3J2aWV3LXBhbGV0dGUtZ3JhZGllbnRcIjtcclxudmFyIENPTE9SX1ZJRVdfUEFMRVRURV9HUkFESUVOVF9XSElURV9DTEFTUyA9IFwiZHgtY29sb3J2aWV3LXBhbGV0dGUtZ3JhZGllbnQtd2hpdGVcIjtcclxudmFyIENPTE9SX1ZJRVdfUEFMRVRURV9HUkFESUVOVF9CTEFDS19DTEFTUyA9IFwiZHgtY29sb3J2aWV3LXBhbGV0dGUtZ3JhZGllbnQtYmxhY2tcIjtcclxudmFyIENPTE9SX1ZJRVdfSFVFX1NDQUxFX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctaHVlLXNjYWxlXCI7XHJcbnZhciBDT0xPUl9WSUVXX0hVRV9TQ0FMRV9DRUxMX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctaHVlLXNjYWxlLWNlbGxcIjtcclxudmFyIENPTE9SX1ZJRVdfSFVFX1NDQUxFX0hBTkRMRV9DTEFTUyA9IFwiZHgtY29sb3J2aWV3LWh1ZS1zY2FsZS1oYW5kbGVcIjtcclxudmFyIENPTE9SX1ZJRVdfSFVFX1NDQUxFX1dSQVBQRVJfQ0xBU1MgPSBcImR4LWNvbG9ydmlldy1odWUtc2NhbGUtd3JhcHBlclwiO1xyXG52YXIgQ09MT1JfVklFV19DT05UUk9MU19DT05UQUlORVJfQ0xBU1MgPSBcImR4LWNvbG9ydmlldy1jb250cm9scy1jb250YWluZXJcIjtcclxudmFyIENPTE9SX1ZJRVdfUkVEX0xBQkVMX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctbGFiZWwtcmVkXCI7XHJcbnZhciBDT0xPUl9WSUVXX0dSRUVOX0xBQkVMX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctbGFiZWwtZ3JlZW5cIjtcclxudmFyIENPTE9SX1ZJRVdfQkxVRV9MQUJFTF9DTEFTUyA9IFwiZHgtY29sb3J2aWV3LWxhYmVsLWJsdWVcIjtcclxudmFyIENPTE9SX1ZJRVdfSEVYX0xBQkVMX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctbGFiZWwtaGV4XCI7XHJcbnZhciBDT0xPUl9WSUVXX0FMUEhBX0NIQU5ORUxfU0NBTEVfQ0xBU1MgPSBcImR4LWNvbG9ydmlldy1hbHBoYS1jaGFubmVsLXNjYWxlXCI7XHJcbnZhciBDT0xPUl9WSUVXX0FQTEhBX0NIQU5ORUxfUk9XX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctYWxwaGEtY2hhbm5lbC1yb3dcIjtcclxudmFyIENPTE9SX1ZJRVdfQUxQSEFfQ0hBTk5FTF9TQ0FMRV9XUkFQUEVSX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctYWxwaGEtY2hhbm5lbC13cmFwcGVyXCI7XHJcbnZhciBDT0xPUl9WSUVXX0FMUEhBX0NIQU5ORUxfTEFCRUxfQ0xBU1MgPSBcImR4LWNvbG9ydmlldy1hbHBoYS1jaGFubmVsLWxhYmVsXCI7XHJcbnZhciBDT0xPUl9WSUVXX0FMUEhBX0NIQU5ORUxfSEFORExFX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctYWxwaGEtY2hhbm5lbC1oYW5kbGVcIjtcclxudmFyIENPTE9SX1ZJRVdfQUxQSEFfQ0hBTk5FTF9DRUxMX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctYWxwaGEtY2hhbm5lbC1jZWxsXCI7XHJcbnZhciBDT0xPUl9WSUVXX0FMUEhBX0NIQU5ORUxfQk9SREVSX0NMQVNTID0gXCJkeC1jb2xvcnZpZXctYWxwaGEtY2hhbm5lbC1ib3JkZXJcIjtcclxudmFyIENPTE9SX1ZJRVdfQ09MT1JfUFJFVklFVyA9IFwiZHgtY29sb3J2aWV3LWNvbG9yLXByZXZpZXdcIjtcclxudmFyIENPTE9SX1ZJRVdfQ09MT1JfUFJFVklFV19DT05UQUlORVJfQ0xBU1MgPSBcImR4LWNvbG9ydmlldy1jb2xvci1wcmV2aWV3LWNvbnRhaW5lclwiO1xyXG52YXIgQ09MT1JfVklFV19DT0xPUl9QUkVWSUVXX0NPTlRBSU5FUl9JTk5FUl9DTEFTUyA9IFwiZHgtY29sb3J2aWV3LWNvbG9yLXByZXZpZXctY29udGFpbmVyLWlubmVyXCI7XHJcbnZhciBDT0xPUl9WSUVXX0NPTE9SX1BSRVZJRVdfQ09MT1JfQ1VSUkVOVCA9IFwiZHgtY29sb3J2aWV3LWNvbG9yLXByZXZpZXctY29sb3ItY3VycmVudFwiO1xyXG52YXIgQ09MT1JfVklFV19DT0xPUl9QUkVWSUVXX0NPTE9SX05FVyA9IFwiZHgtY29sb3J2aWV3LWNvbG9yLXByZXZpZXctY29sb3ItbmV3XCI7XHJcbnZhciBDb2xvclZpZXcgPSBFZGl0b3IuaW5oZXJpdCh7XHJcbiAgICBfc3VwcG9ydGVkS2V5czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGlzUlRMID0gdGhpcy5vcHRpb24oXCJydGxFbmFibGVkXCIpO1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgZ2V0SG9yaXpvbnRhbFBhbGV0dGVTdGVwID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgc3RlcCA9IDEwMCAvIHRoYXQuX3BhbGV0dGVXaWR0aDtcclxuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgICAgIHN0ZXAgKj0gdGhhdC5vcHRpb24oXCJrZXlTdGVwXCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RlcCA9IHN0ZXAgPiAxID8gc3RlcCA6IDE7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHN0ZXApXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdXBkYXRlSG9yaXpvbnRhbFBhbGV0dGVWYWx1ZSA9IGZ1bmN0aW9uKHN0ZXApIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhhdC5fY3VycmVudENvbG9yLmhzdi5zICsgc3RlcDtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID4gMTAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDEwMFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhhdC5fY3VycmVudENvbG9yLmhzdi5zID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHVwZGF0ZVBhbGV0dGVWYWx1ZSgpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgZ2V0VmVydGljYWxQYWxldHRlU3RlcCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIHN0ZXAgPSAxMDAgLyB0aGF0Ll9wYWxldHRlSGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xyXG4gICAgICAgICAgICAgICAgc3RlcCAqPSB0aGF0Lm9wdGlvbihcImtleVN0ZXBcIilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdGVwID0gc3RlcCA+IDEgPyBzdGVwIDogMTtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoc3RlcClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB1cGRhdGVWZXJ0aWNhbFBhbGV0dGVWYWx1ZSA9IGZ1bmN0aW9uKHN0ZXApIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhhdC5fY3VycmVudENvbG9yLmhzdi52ICsgc3RlcDtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID4gMTAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDEwMFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhhdC5fY3VycmVudENvbG9yLmhzdi52ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHVwZGF0ZVBhbGV0dGVWYWx1ZSgpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlUGFsZXR0ZVZhbHVlKCkge1xyXG4gICAgICAgICAgICB0aGF0Ll9wbGFjZVBhbGV0dGVIYW5kbGUoKTtcclxuICAgICAgICAgICAgdGhhdC5fdXBkYXRlQ29sb3JGcm9tSHN2KHRoYXQuX2N1cnJlbnRDb2xvci5oc3YuaCwgdGhhdC5fY3VycmVudENvbG9yLmhzdi5zLCB0aGF0Ll9jdXJyZW50Q29sb3IuaHN2LnYpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBnZXRIdWVTY2FsZVN0ZXAgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGVwID0gMzYwIC8gKHRoYXQuX2h1ZVNjYWxlV3JhcHBlckhlaWdodCAtIHRoYXQuX2h1ZVNjYWxlSGFuZGxlSGVpZ2h0KTtcclxuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgICAgIHN0ZXAgKj0gdGhhdC5vcHRpb24oXCJrZXlTdGVwXCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RlcCA9IHN0ZXAgPiAxID8gc3RlcCA6IDE7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGVwXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdXBkYXRlSHVlU2NhbGVWYWx1ZSA9IGZ1bmN0aW9uKHN0ZXApIHtcclxuICAgICAgICAgICAgdGhhdC5fY3VycmVudENvbG9yLmhzdi5oICs9IHN0ZXA7XHJcbiAgICAgICAgICAgIHRoYXQuX3BsYWNlSHVlU2NhbGVIYW5kbGUoKTtcclxuICAgICAgICAgICAgdmFyIGhhbmRsZUxvY2F0aW9uID0gbG9jYXRlKHRoYXQuXyRodWVTY2FsZUhhbmRsZSk7XHJcbiAgICAgICAgICAgIHRoYXQuX3VwZGF0ZUNvbG9ySHVlKGhhbmRsZUxvY2F0aW9uLnRvcCArIHRoYXQuX2h1ZVNjYWxlSGFuZGxlSGVpZ2h0IC8gMilcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBnZXRBbHBoYVNjYWxlU3RlcCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIHN0ZXAgPSAxIC8gdGhhdC5fYWxwaGFDaGFubmVsU2NhbGVXb3JrV2lkdGg7XHJcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwICo9IHRoYXQub3B0aW9uKFwia2V5U3RlcFwiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0ZXAgPSBzdGVwID4gLjAxID8gc3RlcCA6IC4wMTtcclxuICAgICAgICAgICAgc3RlcCA9IGlzUlRMID8gLXN0ZXAgOiBzdGVwO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RlcFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHVwZGF0ZUFscGhhU2NhbGVWYWx1ZSA9IGZ1bmN0aW9uKHN0ZXApIHtcclxuICAgICAgICAgICAgdGhhdC5fY3VycmVudENvbG9yLmEgKz0gc3RlcDtcclxuICAgICAgICAgICAgdGhhdC5fcGxhY2VBbHBoYUNoYW5uZWxIYW5kbGUoKTtcclxuICAgICAgICAgICAgdmFyIGhhbmRsZUxvY2F0aW9uID0gbG9jYXRlKHRoYXQuXyRhbHBoYUNoYW5uZWxIYW5kbGUpO1xyXG4gICAgICAgICAgICB0aGF0Ll9jYWxjdWxhdGVDb2xvclRyYW5zcGFyZW5jeUJ5U2NhbGVXaWR0aChoYW5kbGVMb2NhdGlvbi5sZWZ0ICsgdGhhdC5fYWxwaGFDaGFubmVsSGFuZGxlV2lkdGggLyAyKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxCYXNlKCksIHtcclxuICAgICAgICAgICAgdXBBcnJvdzogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0NvbW1hbmRLZXlQcmVzc2VkKGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRDb2xvci5oc3YuaCA8PSAzNjAgJiYgIXRoaXMuX2lzVG9wQ29sb3JIdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2F2ZVZhbHVlQ2hhbmdlRXZlbnQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUh1ZVNjYWxlVmFsdWUoZ2V0SHVlU2NhbGVTdGVwKGUpKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY3VycmVudENvbG9yLmhzdi52IDwgMTAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2F2ZVZhbHVlQ2hhbmdlRXZlbnQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmVydGljYWxQYWxldHRlVmFsdWUoZ2V0VmVydGljYWxQYWxldHRlU3RlcChlKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZG93bkFycm93OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tbWFuZEtleVByZXNzZWQoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudENvbG9yLmhzdi5oID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVG9wQ29sb3JIdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvci5oc3YuaCA9IDM2MFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVWYWx1ZUNoYW5nZUV2ZW50KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVIdWVTY2FsZVZhbHVlKC1nZXRIdWVTY2FsZVN0ZXAoZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jdXJyZW50Q29sb3IuaHN2LnYgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2F2ZVZhbHVlQ2hhbmdlRXZlbnQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmVydGljYWxQYWxldHRlVmFsdWUoLWdldFZlcnRpY2FsUGFsZXR0ZVN0ZXAoZSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJpZ2h0QXJyb3c6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDb21tYW5kS2V5UHJlc3NlZChlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JUTCA/IHRoaXMuX2N1cnJlbnRDb2xvci5hIDwgMSA6IHRoaXMuX2N1cnJlbnRDb2xvci5hID4gMCAmJiB0aGlzLm9wdGlvbihcImVkaXRBbHBoYUNoYW5uZWxcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2F2ZVZhbHVlQ2hhbmdlRXZlbnQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUFscGhhU2NhbGVWYWx1ZSgtZ2V0QWxwaGFTY2FsZVN0ZXAoZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jdXJyZW50Q29sb3IuaHN2LnMgPCAxMDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zYXZlVmFsdWVDaGFuZ2VFdmVudChlKTtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVIb3Jpem9udGFsUGFsZXR0ZVZhbHVlKGdldEhvcml6b250YWxQYWxldHRlU3RlcChlKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGVmdEFycm93OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tbWFuZEtleVByZXNzZWQoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSVEwgPyB0aGlzLl9jdXJyZW50Q29sb3IuYSA+IDAgOiB0aGlzLl9jdXJyZW50Q29sb3IuYSA8IDEgJiYgdGhpcy5vcHRpb24oXCJlZGl0QWxwaGFDaGFubmVsXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVWYWx1ZUNoYW5nZUV2ZW50KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVBbHBoYVNjYWxlVmFsdWUoZ2V0QWxwaGFTY2FsZVN0ZXAoZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jdXJyZW50Q29sb3IuaHN2LnMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2F2ZVZhbHVlQ2hhbmdlRXZlbnQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSG9yaXpvbnRhbFBhbGV0dGVWYWx1ZSgtZ2V0SG9yaXpvbnRhbFBhbGV0dGVTdGVwKGUpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZUVudGVyS2V5UHJlc3NlZChlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBfZ2V0RGVmYXVsdE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsQmFzZSgpLCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBudWxsLFxyXG4gICAgICAgICAgICBtYXRjaFZhbHVlOiBudWxsLFxyXG4gICAgICAgICAgICBvbkVudGVyS2V5UHJlc3NlZDogdm9pZCAwLFxyXG4gICAgICAgICAgICBlZGl0QWxwaGFDaGFubmVsOiBmYWxzZSxcclxuICAgICAgICAgICAga2V5U3RlcDogMSxcclxuICAgICAgICAgICAgc3R5bGluZ01vZGU6IHZvaWQgMFxyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgX2RlZmF1bHRPcHRpb25zUnVsZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxCYXNlKCkuY29uY2F0KFt7XHJcbiAgICAgICAgICAgIGRldmljZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJkZXNrdG9wXCIgPT09IGRldmljZXMucmVhbCgpLmRldmljZVR5cGUgJiYgIWRldmljZXMuaXNTaW11bGF0b3IoKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBmb2N1c1N0YXRlRW5hYmxlZDogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfV0pXHJcbiAgICB9LFxyXG4gICAgX2luaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbEJhc2UoKTtcclxuICAgICAgICB0aGlzLl9pbml0Q29sb3JBbmRPcGFjaXR5KCk7XHJcbiAgICAgICAgdGhpcy5faW5pdEVudGVyS2V5UHJlc3NlZEFjdGlvbigpXHJcbiAgICB9LFxyXG4gICAgX2luaXRFbnRlcktleVByZXNzZWRBY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX29uRW50ZXJLZXlQcmVzc2VkQWN0aW9uID0gdGhpcy5fY3JlYXRlQWN0aW9uQnlPcHRpb24oXCJvbkVudGVyS2V5UHJlc3NlZFwiKVxyXG4gICAgfSxcclxuICAgIF9maXJlRW50ZXJLZXlQcmVzc2VkOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9vbkVudGVyS2V5UHJlc3NlZEFjdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb25FbnRlcktleVByZXNzZWRBY3Rpb24oe1xyXG4gICAgICAgICAgICBldmVudDogZVxyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgX2luaXRDb2xvckFuZE9wYWNpdHk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3NldEN1cnJlbnRDb2xvcih0aGlzLm9wdGlvbihcInZhbHVlXCIpKVxyXG4gICAgfSxcclxuICAgIF9zZXRDdXJyZW50Q29sb3I6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCBcIiMwMDAwMDBcIjtcclxuICAgICAgICB2YXIgbmV3Q29sb3IgPSBuZXcgQ29sb3IodmFsdWUpO1xyXG4gICAgICAgIGlmICghbmV3Q29sb3IuY29sb3JJc0ludmFsaWQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW50Q29sb3IgfHwgdGhpcy5fbWFrZVJnYmEodGhpcy5fY3VycmVudENvbG9yKSAhPT0gdGhpcy5fbWFrZVJnYmEobmV3Q29sb3IpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSBuZXdDb2xvcjtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl8kY3VycmVudENvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZVRyYW5zcGFyZW50QmFja2dyb3VuZCh0aGlzLl8kY3VycmVudENvbG9yLCBuZXdDb2xvcilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uKFwidmFsdWVcIiwgdGhpcy5fY3VycmVudENvbG9yLmJhc2VDb2xvcilcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3NldEJhc2VDb2xvcjogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB2YXIgY29sb3IgPSB2YWx1ZSB8fCBcIiMwMDAwMDBcIjtcclxuICAgICAgICB2YXIgbmV3Q29sb3IgPSBuZXcgQ29sb3IoY29sb3IpO1xyXG4gICAgICAgIGlmICghbmV3Q29sb3IuY29sb3JJc0ludmFsaWQpIHtcclxuICAgICAgICAgICAgdmFyIGlzQmFzZUNvbG9yQ2hhbmdlZCA9IHRoaXMuX21ha2VSZ2JhKHRoaXMub3B0aW9uKFwibWF0Y2hWYWx1ZVwiKSAhPT0gdGhpcy5fbWFrZVJnYmEobmV3Q29sb3IpKTtcclxuICAgICAgICAgICAgaWYgKGlzQmFzZUNvbG9yQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuXyRiYXNlQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlVHJhbnNwYXJlbnRCYWNrZ3JvdW5kKHRoaXMuXyRiYXNlQ29sb3IsIG5ld0NvbG9yKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9pbml0TWFya3VwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNhbGxCYXNlKCk7XHJcbiAgICAgICAgdGhpcy4kZWxlbWVudCgpLmFkZENsYXNzKENPTE9SX1ZJRVdfQ0xBU1MpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckNvbG9yUGlja2VyQ29udGFpbmVyKClcclxuICAgIH0sXHJcbiAgICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNhbGxCYXNlKCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyUGFsZXR0ZSgpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckh1ZVNjYWxlKCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyQ29udHJvbHNDb250YWluZXIoKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJDb250cm9scygpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckFscGhhQ2hhbm5lbEVsZW1lbnRzKClcclxuICAgIH0sXHJcbiAgICBfbWFrZVRyYW5zcGFyZW50QmFja2dyb3VuZDogZnVuY3Rpb24oJGVsLCBjb2xvcikge1xyXG4gICAgICAgIGlmICghKGNvbG9yIGluc3RhbmNlb2YgQ29sb3IpKSB7XHJcbiAgICAgICAgICAgIGNvbG9yID0gbmV3IENvbG9yKGNvbG9yKVxyXG4gICAgICAgIH1cclxuICAgICAgICAkZWwuY3NzKFwiYmFja2dyb3VuZENvbG9yXCIsIHRoaXMuX21ha2VSZ2JhKGNvbG9yKSlcclxuICAgIH0sXHJcbiAgICBfbWFrZVJnYmE6IGZ1bmN0aW9uKGNvbG9yKSB7XHJcbiAgICAgICAgaWYgKCEoY29sb3IgaW5zdGFuY2VvZiBDb2xvcikpIHtcclxuICAgICAgICAgICAgY29sb3IgPSBuZXcgQ29sb3IoY29sb3IpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcInJnYmEoXCIgKyBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYV0uam9pbihcIiwgXCIpICsgXCIpXCJcclxuICAgIH0sXHJcbiAgICBfcmVuZGVyVmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbEJhc2UodGhpcy5vcHRpb24oXCJlZGl0QWxwaGFDaGFubmVsXCIpID8gdGhpcy5fbWFrZVJnYmEodGhpcy5fY3VycmVudENvbG9yKSA6IHRoaXMub3B0aW9uKFwidmFsdWVcIikpXHJcbiAgICB9LFxyXG4gICAgX3JlbmRlckNvbG9yUGlja2VyQ29udGFpbmVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgJHBhcmVudCA9IHRoaXMuJGVsZW1lbnQoKTtcclxuICAgICAgICB0aGlzLl8kY29sb3JQaWNrZXJDb250YWluZXIgPSAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoQ09MT1JfVklFV19DT05UQUlORVJfQ0xBU1MpLmFwcGVuZFRvKCRwYXJlbnQpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckh0bWxSb3dzKClcclxuICAgIH0sXHJcbiAgICBfcmVuZGVySHRtbFJvd3M6IGZ1bmN0aW9uKHVwZGF0ZWRPcHRpb24pIHtcclxuICAgICAgICB2YXIgJHJlbmRlcmVkUm93cyA9IHRoaXMuXyRjb2xvclBpY2tlckNvbnRhaW5lci5maW5kKFwiLlwiICsgQ09MT1JfVklFV19ST1dfQ0xBU1MpO1xyXG4gICAgICAgIHZhciByZW5kZXJlZFJvd3NDb3VudCA9ICRyZW5kZXJlZFJvd3MubGVuZ3RoO1xyXG4gICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMub3B0aW9uKFwiZWRpdEFscGhhQ2hhbm5lbFwiKSA/IDIgOiAxO1xyXG4gICAgICAgIHZhciBkZWx0YSA9IHJlbmRlcmVkUm93c0NvdW50IC0gcm93Q291bnQ7XHJcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xyXG4gICAgICAgICAgICAkcmVuZGVyZWRSb3dzLmVxKC0xKS5yZW1vdmUoKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XHJcbiAgICAgICAgICAgIGRlbHRhID0gTWF0aC5hYnMoZGVsdGEpO1xyXG4gICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlbHRhOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJvd3MucHVzaCgkKFwiPGRpdj5cIikuYWRkQ2xhc3MoQ09MT1JfVklFV19ST1dfQ0xBU1MpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZFJvd3NDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAkcmVuZGVyZWRSb3dzLmVxKDApLmFmdGVyKHJvd3NbaV0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl8kY29sb3JQaWNrZXJDb250YWluZXIuYXBwZW5kKHJvd3MpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3JlbmRlckh0bWxDZWxsSW5zaWRlUm93OiBmdW5jdGlvbihpbmRleCwgJHJvd1BhcmVudCwgYWRkaXRpb25hbENsYXNzKSB7XHJcbiAgICAgICAgcmV0dXJuICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhDT0xPUl9WSUVXX0NFTExfQ0xBU1MpLmFkZENsYXNzKGFkZGl0aW9uYWxDbGFzcykuYXBwZW5kVG8oJHJvd1BhcmVudC5maW5kKFwiLlwiICsgQ09MT1JfVklFV19ST1dfQ0xBU1MpLmVxKGluZGV4KSlcclxuICAgIH0sXHJcbiAgICBfcmVuZGVyUGFsZXR0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyICRwYWxldHRlQ2VsbCA9IHRoaXMuX3JlbmRlckh0bWxDZWxsSW5zaWRlUm93KDAsIHRoaXMuXyRjb2xvclBpY2tlckNvbnRhaW5lciwgQ09MT1JfVklFV19QQUxFVFRFX0NFTExfQ0xBU1MpO1xyXG4gICAgICAgIHZhciAkcGFsZXR0ZUdyYWRpZW50V2hpdGUgPSAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoW0NPTE9SX1ZJRVdfUEFMRVRURV9HUkFESUVOVF9DTEFTUywgQ09MT1JfVklFV19QQUxFVFRFX0dSQURJRU5UX1dISVRFX0NMQVNTXS5qb2luKFwiIFwiKSk7XHJcbiAgICAgICAgdmFyICRwYWxldHRlR3JhZGllbnRCbGFjayA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhbQ09MT1JfVklFV19QQUxFVFRFX0dSQURJRU5UX0NMQVNTLCBDT0xPUl9WSUVXX1BBTEVUVEVfR1JBRElFTlRfQkxBQ0tfQ0xBU1NdLmpvaW4oXCIgXCIpKTtcclxuICAgICAgICB0aGlzLl8kcGFsZXR0ZSA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhDT0xPUl9WSUVXX1BBTEVUVEVfQ0xBU1MpLmNzcyhcImJhY2tncm91bmRDb2xvclwiLCB0aGlzLl9jdXJyZW50Q29sb3IuZ2V0UHVyZUNvbG9yKCkudG9IZXgoKSkuYXBwZW5kVG8oJHBhbGV0dGVDZWxsKTtcclxuICAgICAgICB0aGlzLl9wYWxldHRlSGVpZ2h0ID0gZ2V0SGVpZ2h0KHRoaXMuXyRwYWxldHRlKTtcclxuICAgICAgICB0aGlzLl9wYWxldHRlV2lkdGggPSBnZXRXaWR0aCh0aGlzLl8kcGFsZXR0ZSk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyUGFsZXR0ZUhhbmRsZSgpO1xyXG4gICAgICAgIHRoaXMuXyRwYWxldHRlLmFwcGVuZChbJHBhbGV0dGVHcmFkaWVudFdoaXRlLCAkcGFsZXR0ZUdyYWRpZW50QmxhY2tdKVxyXG4gICAgfSxcclxuICAgIF9yZW5kZXJQYWxldHRlSGFuZGxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl8kcGFsZXR0ZUhhbmRsZSA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhDT0xPUl9WSUVXX1BBTEVUVEVfSEFORExFX0NMQVNTKS5hcHBlbmRUbyh0aGlzLl8kcGFsZXR0ZSk7XHJcbiAgICAgICAgdGhpcy5fY3JlYXRlQ29tcG9uZW50KHRoaXMuXyRwYWxldHRlSGFuZGxlLCBEcmFnZ2FibGUsIHtcclxuICAgICAgICAgICAgY29udGVudFRlbXBsYXRlOiBudWxsLFxyXG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fJHBhbGV0dGUsXHJcbiAgICAgICAgICAgIGFsbG93TW92ZUJ5Q2xpY2s6IHRydWUsXHJcbiAgICAgICAgICAgIGJvdW5kT2Zmc2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtdGhpcy5fcGFsZXR0ZUhhbmRsZUhlaWdodCAvIDJcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICBvbkRyYWdNb3ZlOiBfcmVmID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XHJcbiAgICAgICAgICAgICAgICB9ID0gX3JlZjtcclxuICAgICAgICAgICAgICAgIHZhciBwYWxldHRlSGFuZGxlUG9zaXRpb24gPSBsb2NhdGUodGhpcy5fJHBhbGV0dGVIYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQnlEcmFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVWYWx1ZUNoYW5nZUV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yRnJvbUhzdih0aGlzLl9jdXJyZW50Q29sb3IuaHN2LmgsIHRoaXMuX2NhbGN1bGF0ZUNvbG9yU2F0dXJhdGlvbihwYWxldHRlSGFuZGxlUG9zaXRpb24pLCB0aGlzLl9jYWxjdWxhdGVDb2xvclZhbHVlKHBhbGV0dGVIYW5kbGVQb3NpdGlvbikpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9wYWxldHRlSGFuZGxlV2lkdGggPSBnZXRXaWR0aCh0aGlzLl8kcGFsZXR0ZUhhbmRsZSk7XHJcbiAgICAgICAgdGhpcy5fcGFsZXR0ZUhhbmRsZUhlaWdodCA9IGdldEhlaWdodCh0aGlzLl8kcGFsZXR0ZUhhbmRsZSk7XHJcbiAgICAgICAgdGhpcy5fcGxhY2VQYWxldHRlSGFuZGxlKClcclxuICAgIH0sXHJcbiAgICBfcGxhY2VQYWxldHRlSGFuZGxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBtb3ZlKHRoaXMuXyRwYWxldHRlSGFuZGxlLCB7XHJcbiAgICAgICAgICAgIGxlZnQ6IE1hdGgucm91bmQodGhpcy5fcGFsZXR0ZVdpZHRoICogdGhpcy5fY3VycmVudENvbG9yLmhzdi5zIC8gMTAwIC0gdGhpcy5fcGFsZXR0ZUhhbmRsZVdpZHRoIC8gMiksXHJcbiAgICAgICAgICAgIHRvcDogTWF0aC5yb3VuZCh0aGlzLl9wYWxldHRlSGVpZ2h0IC0gdGhpcy5fcGFsZXR0ZUhlaWdodCAqIHRoaXMuX2N1cnJlbnRDb2xvci5oc3YudiAvIDEwMCAtIHRoaXMuX3BhbGV0dGVIYW5kbGVIZWlnaHQgLyAyKVxyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgX2NhbGN1bGF0ZUNvbG9yVmFsdWU6IGZ1bmN0aW9uKHBhbGV0dGVIYW5kbGVQb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IE1hdGguZmxvb3IocGFsZXR0ZUhhbmRsZVBvc2l0aW9uLnRvcCArIHRoaXMuX3BhbGV0dGVIYW5kbGVIZWlnaHQgLyAyKTtcclxuICAgICAgICByZXR1cm4gMTAwIC0gTWF0aC5yb3VuZCgxMDAgKiB2YWx1ZSAvIHRoaXMuX3BhbGV0dGVIZWlnaHQpXHJcbiAgICB9LFxyXG4gICAgX2NhbGN1bGF0ZUNvbG9yU2F0dXJhdGlvbjogZnVuY3Rpb24ocGFsZXR0ZUhhbmRsZVBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIHNhdHVyYXRpb24gPSBNYXRoLmZsb29yKHBhbGV0dGVIYW5kbGVQb3NpdGlvbi5sZWZ0ICsgdGhpcy5fcGFsZXR0ZUhhbmRsZVdpZHRoIC8gMik7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoMTAwICogc2F0dXJhdGlvbiAvIHRoaXMuX3BhbGV0dGVXaWR0aClcclxuICAgIH0sXHJcbiAgICBfdXBkYXRlQ29sb3JGcm9tSHN2OiBmdW5jdGlvbihodWUsIHNhdHVyYXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLl9jdXJyZW50Q29sb3IuYTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSBuZXcgQ29sb3IoXCJoc3YoXCIgKyBbaHVlLCBzYXR1cmF0aW9uLCB2YWx1ZV0uam9pbihcIixcIikgKyBcIilcIik7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLmEgPSBhO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yUGFyYW1zQW5kQ29sb3JQcmV2aWV3KCk7XHJcbiAgICAgICAgdGhpcy5hcHBseUNvbG9yKClcclxuICAgIH0sXHJcbiAgICBfcmVuZGVySHVlU2NhbGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciAkaHVlU2NhbGVDZWxsID0gdGhpcy5fcmVuZGVySHRtbENlbGxJbnNpZGVSb3coMCwgdGhpcy5fJGNvbG9yUGlja2VyQ29udGFpbmVyLCBDT0xPUl9WSUVXX0hVRV9TQ0FMRV9DRUxMX0NMQVNTKTtcclxuICAgICAgICB0aGlzLl8kaHVlU2NhbGVXcmFwcGVyID0gJChcIjxkaXY+XCIpLmFkZENsYXNzKENPTE9SX1ZJRVdfSFVFX1NDQUxFX1dSQVBQRVJfQ0xBU1MpLmFwcGVuZFRvKCRodWVTY2FsZUNlbGwpO1xyXG4gICAgICAgIHRoaXMuXyRodWVTY2FsZSA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhDT0xPUl9WSUVXX0hVRV9TQ0FMRV9DTEFTUykuYXBwZW5kVG8odGhpcy5fJGh1ZVNjYWxlV3JhcHBlcik7XHJcbiAgICAgICAgdGhpcy5faHVlU2NhbGVIZWlnaHQgPSBnZXRIZWlnaHQodGhpcy5fJGh1ZVNjYWxlKTtcclxuICAgICAgICB0aGlzLl9odWVTY2FsZVdyYXBwZXJIZWlnaHQgPSBnZXRPdXRlckhlaWdodCh0aGlzLl8kaHVlU2NhbGVXcmFwcGVyKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJIdWVTY2FsZUhhbmRsZSgpXHJcbiAgICB9LFxyXG4gICAgX3JlbmRlckh1ZVNjYWxlSGFuZGxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl8kaHVlU2NhbGVIYW5kbGUgPSAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoQ09MT1JfVklFV19IVUVfU0NBTEVfSEFORExFX0NMQVNTKS5hcHBlbmRUbyh0aGlzLl8kaHVlU2NhbGVXcmFwcGVyKTtcclxuICAgICAgICB0aGlzLl9jcmVhdGVDb21wb25lbnQodGhpcy5fJGh1ZVNjYWxlSGFuZGxlLCBEcmFnZ2FibGUsIHtcclxuICAgICAgICAgICAgY29udGVudFRlbXBsYXRlOiBudWxsLFxyXG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fJGh1ZVNjYWxlV3JhcHBlcixcclxuICAgICAgICAgICAgYWxsb3dNb3ZlQnlDbGljazogdHJ1ZSxcclxuICAgICAgICAgICAgZHJhZ0RpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiLFxyXG4gICAgICAgICAgICBvbkRyYWdNb3ZlOiBfcmVmMiA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxyXG4gICAgICAgICAgICAgICAgfSA9IF9yZWYyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQnlEcmFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVWYWx1ZUNoYW5nZUV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9ySHVlKGxvY2F0ZSh0aGlzLl8kaHVlU2NhbGVIYW5kbGUpLnRvcCArIHRoaXMuX2h1ZVNjYWxlSGFuZGxlSGVpZ2h0IC8gMilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2h1ZVNjYWxlSGFuZGxlSGVpZ2h0ID0gZ2V0SGVpZ2h0KHRoaXMuXyRodWVTY2FsZUhhbmRsZSk7XHJcbiAgICAgICAgdGhpcy5fcGxhY2VIdWVTY2FsZUhhbmRsZSgpXHJcbiAgICB9LFxyXG4gICAgX3BsYWNlSHVlU2NhbGVIYW5kbGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBodWVTY2FsZUhlaWdodCA9IHRoaXMuX2h1ZVNjYWxlV3JhcHBlckhlaWdodDtcclxuICAgICAgICB2YXIgaGFuZGxlSGVpZ2h0ID0gdGhpcy5faHVlU2NhbGVIYW5kbGVIZWlnaHQ7XHJcbiAgICAgICAgdmFyIHRvcCA9IChodWVTY2FsZUhlaWdodCAtIGhhbmRsZUhlaWdodCkgKiAoMzYwIC0gdGhpcy5fY3VycmVudENvbG9yLmhzdi5oKSAvIDM2MDtcclxuICAgICAgICBpZiAoaHVlU2NhbGVIZWlnaHQgPCB0b3AgKyBoYW5kbGVIZWlnaHQpIHtcclxuICAgICAgICAgICAgdG9wID0gaHVlU2NhbGVIZWlnaHQgLSBoYW5kbGVIZWlnaHRcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvcCA8IDApIHtcclxuICAgICAgICAgICAgdG9wID0gMFxyXG4gICAgICAgIH1cclxuICAgICAgICBtb3ZlKHRoaXMuXyRodWVTY2FsZUhhbmRsZSwge1xyXG4gICAgICAgICAgICB0b3A6IE1hdGgucm91bmQodG9wKVxyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgX3VwZGF0ZUNvbG9ySHVlOiBmdW5jdGlvbihoYW5kbGVQb3NpdGlvbikge1xyXG4gICAgICAgIHZhciBodWUgPSAzNjAgLSBNYXRoLnJvdW5kKDM2MCAqIChoYW5kbGVQb3NpdGlvbiAtIHRoaXMuX2h1ZVNjYWxlSGFuZGxlSGVpZ2h0IC8gMikgLyAodGhpcy5faHVlU2NhbGVXcmFwcGVySGVpZ2h0IC0gdGhpcy5faHVlU2NhbGVIYW5kbGVIZWlnaHQpKTtcclxuICAgICAgICB2YXIgc2F0dXJhdGlvbiA9IHRoaXMuX2N1cnJlbnRDb2xvci5oc3YucztcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9jdXJyZW50Q29sb3IuaHN2LnY7XHJcbiAgICAgICAgdGhpcy5faXNUb3BDb2xvckh1ZSA9IGZhbHNlO1xyXG4gICAgICAgIGh1ZSA9IGh1ZSA8IDAgPyAwIDogaHVlO1xyXG4gICAgICAgIGlmIChodWUgPj0gMzYwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzVG9wQ29sb3JIdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICBodWUgPSAwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yRnJvbUhzdihodWUsIHNhdHVyYXRpb24sIHZhbHVlKTtcclxuICAgICAgICB0aGlzLl8kcGFsZXR0ZS5jc3MoXCJiYWNrZ3JvdW5kQ29sb3JcIiwgdGhpcy5fY3VycmVudENvbG9yLmdldFB1cmVDb2xvcigpLnRvSGV4KCkpXHJcbiAgICB9LFxyXG4gICAgX3JlbmRlckNvbnRyb2xzQ29udGFpbmVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgJGNvbnRyb2xzQ29udGFpbmVyQ2VsbCA9IHRoaXMuX3JlbmRlckh0bWxDZWxsSW5zaWRlUm93KDAsIHRoaXMuXyRjb2xvclBpY2tlckNvbnRhaW5lcik7XHJcbiAgICAgICAgdGhpcy5fJGNvbnRyb2xzQ29udGFpbmVyID0gJChcIjxkaXY+XCIpLmFkZENsYXNzKENPTE9SX1ZJRVdfQ09OVFJPTFNfQ09OVEFJTkVSX0NMQVNTKS5hcHBlbmRUbygkY29udHJvbHNDb250YWluZXJDZWxsKVxyXG4gICAgfSxcclxuICAgIF9yZW5kZXJDb250cm9sczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyQ29sb3JzUHJldmlldygpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlclJnYklucHV0cygpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckhleElucHV0KClcclxuICAgIH0sXHJcbiAgICBfcmVuZGVyQ29sb3JzUHJldmlldzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyICRjb2xvcnNQcmV2aWV3Q29udGFpbmVyID0gJChcIjxkaXY+XCIpLmFkZENsYXNzKENPTE9SX1ZJRVdfQ09MT1JfUFJFVklFV19DT05UQUlORVJfQ0xBU1MpLmFwcGVuZFRvKHRoaXMuXyRjb250cm9sc0NvbnRhaW5lcik7XHJcbiAgICAgICAgdmFyICRjb2xvcnNQcmV2aWV3Q29udGFpbmVySW5uZXIgPSAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoQ09MT1JfVklFV19DT0xPUl9QUkVWSUVXX0NPTlRBSU5FUl9JTk5FUl9DTEFTUykuYXBwZW5kVG8oJGNvbG9yc1ByZXZpZXdDb250YWluZXIpO1xyXG4gICAgICAgIHRoaXMuXyRjdXJyZW50Q29sb3IgPSAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoW0NPTE9SX1ZJRVdfQ09MT1JfUFJFVklFVywgQ09MT1JfVklFV19DT0xPUl9QUkVWSUVXX0NPTE9SX05FV10uam9pbihcIiBcIikpO1xyXG4gICAgICAgIHRoaXMuXyRiYXNlQ29sb3IgPSAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoW0NPTE9SX1ZJRVdfQ09MT1JfUFJFVklFVywgQ09MT1JfVklFV19DT0xPUl9QUkVWSUVXX0NPTE9SX0NVUlJFTlRdLmpvaW4oXCIgXCIpKTtcclxuICAgICAgICB0aGlzLl9tYWtlVHJhbnNwYXJlbnRCYWNrZ3JvdW5kKHRoaXMuXyRiYXNlQ29sb3IsIHRoaXMub3B0aW9uKFwibWF0Y2hWYWx1ZVwiKSk7XHJcbiAgICAgICAgdGhpcy5fbWFrZVRyYW5zcGFyZW50QmFja2dyb3VuZCh0aGlzLl8kY3VycmVudENvbG9yLCB0aGlzLl9jdXJyZW50Q29sb3IpO1xyXG4gICAgICAgICRjb2xvcnNQcmV2aWV3Q29udGFpbmVySW5uZXIuYXBwZW5kKFt0aGlzLl8kYmFzZUNvbG9yLCB0aGlzLl8kY3VycmVudENvbG9yXSlcclxuICAgIH0sXHJcbiAgICBfcmVuZGVyQWxwaGFDaGFubmVsRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbihcImVkaXRBbHBoYUNoYW5uZWxcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5fJGNvbG9yUGlja2VyQ29udGFpbmVyLmZpbmQoXCIuXCIgKyBDT0xPUl9WSUVXX1JPV19DTEFTUykuZXEoMSkuYWRkQ2xhc3MoQ09MT1JfVklFV19BUExIQV9DSEFOTkVMX1JPV19DTEFTUyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckFscGhhQ2hhbm5lbFNjYWxlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckFscGhhQ2hhbm5lbElucHV0KClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3JlbmRlclJnYklucHV0czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fcmdiSW5wdXRzV2l0aExhYmVscyA9IFt0aGlzLl9yZW5kZXJFZGl0b3JXaXRoTGFiZWwoe1xyXG4gICAgICAgICAgICBlZGl0b3JUeXBlOiBOdW1iZXJCb3gsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9jdXJyZW50Q29sb3IucixcclxuICAgICAgICAgICAgb25WYWx1ZUNoYW5nZWQ6IHRoaXMuX3VwZGF0ZUNvbG9yLmJpbmQodGhpcywgZmFsc2UpLFxyXG4gICAgICAgICAgICBsYWJlbFRleHQ6IFwiUlwiLFxyXG4gICAgICAgICAgICBsYWJlbEFyaWFUZXh0OiBtZXNzYWdlTG9jYWxpemF0aW9uLmZvcm1hdChcImR4Q29sb3JWaWV3LWFyaWFSZWRcIiksXHJcbiAgICAgICAgICAgIGxhYmVsQ2xhc3M6IENPTE9SX1ZJRVdfUkVEX0xBQkVMX0NMQVNTXHJcbiAgICAgICAgfSksIHRoaXMuX3JlbmRlckVkaXRvcldpdGhMYWJlbCh7XHJcbiAgICAgICAgICAgIGVkaXRvclR5cGU6IE51bWJlckJveCxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuX2N1cnJlbnRDb2xvci5nLFxyXG4gICAgICAgICAgICBvblZhbHVlQ2hhbmdlZDogdGhpcy5fdXBkYXRlQ29sb3IuYmluZCh0aGlzLCBmYWxzZSksXHJcbiAgICAgICAgICAgIGxhYmVsVGV4dDogXCJHXCIsXHJcbiAgICAgICAgICAgIGxhYmVsQXJpYVRleHQ6IG1lc3NhZ2VMb2NhbGl6YXRpb24uZm9ybWF0KFwiZHhDb2xvclZpZXctYXJpYUdyZWVuXCIpLFxyXG4gICAgICAgICAgICBsYWJlbENsYXNzOiBDT0xPUl9WSUVXX0dSRUVOX0xBQkVMX0NMQVNTXHJcbiAgICAgICAgfSksIHRoaXMuX3JlbmRlckVkaXRvcldpdGhMYWJlbCh7XHJcbiAgICAgICAgICAgIGVkaXRvclR5cGU6IE51bWJlckJveCxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuX2N1cnJlbnRDb2xvci5iLFxyXG4gICAgICAgICAgICBvblZhbHVlQ2hhbmdlZDogdGhpcy5fdXBkYXRlQ29sb3IuYmluZCh0aGlzLCBmYWxzZSksXHJcbiAgICAgICAgICAgIGxhYmVsVGV4dDogXCJCXCIsXHJcbiAgICAgICAgICAgIGxhYmVsQXJpYVRleHQ6IG1lc3NhZ2VMb2NhbGl6YXRpb24uZm9ybWF0KFwiZHhDb2xvclZpZXctYXJpYUJsdWVcIiksXHJcbiAgICAgICAgICAgIGxhYmVsQ2xhc3M6IENPTE9SX1ZJRVdfQkxVRV9MQUJFTF9DTEFTU1xyXG4gICAgICAgIH0pXTtcclxuICAgICAgICB0aGlzLl8kY29udHJvbHNDb250YWluZXIuYXBwZW5kKHRoaXMuX3JnYklucHV0c1dpdGhMYWJlbHMpO1xyXG4gICAgICAgIHRoaXMuX3JnYklucHV0cyA9IFt0aGlzLl9yZ2JJbnB1dHNXaXRoTGFiZWxzWzBdLmZpbmQoXCIuZHgtbnVtYmVyYm94XCIpLmR4TnVtYmVyQm94KFwiaW5zdGFuY2VcIiksIHRoaXMuX3JnYklucHV0c1dpdGhMYWJlbHNbMV0uZmluZChcIi5keC1udW1iZXJib3hcIikuZHhOdW1iZXJCb3goXCJpbnN0YW5jZVwiKSwgdGhpcy5fcmdiSW5wdXRzV2l0aExhYmVsc1syXS5maW5kKFwiLmR4LW51bWJlcmJveFwiKS5keE51bWJlckJveChcImluc3RhbmNlXCIpXVxyXG4gICAgfSxcclxuICAgIF9yZW5kZXJFZGl0b3JXaXRoTGFiZWw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgJGVkaXRvciA9ICQoXCI8ZGl2PlwiKTtcclxuICAgICAgICB2YXIgJGxhYmVsID0gJChcIjxsYWJlbD5cIikuYWRkQ2xhc3Mob3B0aW9ucy5sYWJlbENsYXNzKS50ZXh0KG9wdGlvbnMubGFiZWxUZXh0ICsgXCI6XCIpLmFwcGVuZCgkZWRpdG9yKTtcclxuICAgICAgICBldmVudHNFbmdpbmUub2ZmKCRsYWJlbCwgY2xpY2tFdmVudE5hbWUpO1xyXG4gICAgICAgIGV2ZW50c0VuZ2luZS5vbigkbGFiZWwsIGNsaWNrRXZlbnROYW1lLCAoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdmFyIGVkaXRvclR5cGUgPSBvcHRpb25zLmVkaXRvclR5cGU7XHJcbiAgICAgICAgdmFyIGVkaXRvck9wdGlvbnMgPSBleHRlbmQoe1xyXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcclxuICAgICAgICAgICAgb25WYWx1ZUNoYW5nZWQ6IG9wdGlvbnMub25WYWx1ZUNoYW5nZWQsXHJcbiAgICAgICAgICAgIG9uS2V5Ym9hcmRIYW5kbGVkOiBvcHRzID0+IHRoaXMuX2tleWJvYXJkSGFuZGxlcihvcHRzKVxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgICAgc3R5bGluZ01vZGU6IHRoaXMub3B0aW9uKFwic3R5bGluZ01vZGVcIilcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZWRpdG9yVHlwZSA9PT0gTnVtYmVyQm94KSB7XHJcbiAgICAgICAgICAgIGVkaXRvck9wdGlvbnMubWluID0gb3B0aW9ucy5taW4gfHwgMDtcclxuICAgICAgICAgICAgZWRpdG9yT3B0aW9ucy5tYXggPSBvcHRpb25zLm1heCB8fCAyNTU7XHJcbiAgICAgICAgICAgIGVkaXRvck9wdGlvbnMuc3RlcCA9IG9wdGlvbnMuc3RlcCB8fCAxXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlZGl0b3IgPSBuZXcgZWRpdG9yVHlwZSgkZWRpdG9yLCBlZGl0b3JPcHRpb25zKTtcclxuICAgICAgICBlZGl0b3IucmVnaXN0ZXJLZXlIYW5kbGVyKFwiZW50ZXJcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9maXJlRW50ZXJLZXlQcmVzc2VkKGUpXHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnNldEFyaWEoXCJsYWJlbFwiLCBvcHRpb25zLmxhYmVsQXJpYVRleHQsICRlZGl0b3IpO1xyXG4gICAgICAgIHJldHVybiAkbGFiZWxcclxuICAgIH0sXHJcbiAgICBoZXhJbnB1dE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGVkaXRvclR5cGU6IFRleHRCb3gsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9jdXJyZW50Q29sb3IudG9IZXgoKS5yZXBsYWNlKFwiI1wiLCBcIlwiKSxcclxuICAgICAgICAgICAgb25WYWx1ZUNoYW5nZWQ6IHRoaXMuX3VwZGF0ZUNvbG9yLmJpbmQodGhpcywgdHJ1ZSksXHJcbiAgICAgICAgICAgIGxhYmVsQ2xhc3M6IENPTE9SX1ZJRVdfSEVYX0xBQkVMX0NMQVNTLFxyXG4gICAgICAgICAgICBsYWJlbFRleHQ6IFwiI1wiLFxyXG4gICAgICAgICAgICBsYWJlbEFyaWFUZXh0OiBtZXNzYWdlTG9jYWxpemF0aW9uLmZvcm1hdChcImR4Q29sb3JWaWV3LWFyaWFIZXhcIilcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3JlbmRlckhleElucHV0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9oZXhJbnB1dCA9IFRleHRCb3guZ2V0SW5zdGFuY2UodGhpcy5fcmVuZGVyRWRpdG9yV2l0aExhYmVsKHRoaXMuaGV4SW5wdXRPcHRpb25zKCkpLmFwcGVuZFRvKHRoaXMuXyRjb250cm9sc0NvbnRhaW5lcikuZmluZChcIi5keC10ZXh0Ym94XCIpKVxyXG4gICAgfSxcclxuICAgIF9yZW5kZXJBbHBoYUNoYW5uZWxTY2FsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyICRhbHBoYUNoYW5uZWxTY2FsZUNlbGwgPSB0aGlzLl9yZW5kZXJIdG1sQ2VsbEluc2lkZVJvdygxLCB0aGlzLl8kY29sb3JQaWNrZXJDb250YWluZXIsIENPTE9SX1ZJRVdfQUxQSEFfQ0hBTk5FTF9DRUxMX0NMQVNTKTtcclxuICAgICAgICB2YXIgJGFscGhhQ2hhbm5lbEJvcmRlciA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhDT0xPUl9WSUVXX0FMUEhBX0NIQU5ORUxfQk9SREVSX0NMQVNTKS5hcHBlbmRUbygkYWxwaGFDaGFubmVsU2NhbGVDZWxsKTtcclxuICAgICAgICB2YXIgJGFscGhhQ2hhbm5lbFNjYWxlV3JhcHBlciA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhDT0xPUl9WSUVXX0FMUEhBX0NIQU5ORUxfU0NBTEVfV1JBUFBFUl9DTEFTUykuYXBwZW5kVG8oJGFscGhhQ2hhbm5lbEJvcmRlcik7XHJcbiAgICAgICAgdGhpcy5fJGFscGhhQ2hhbm5lbFNjYWxlID0gJChcIjxkaXY+XCIpLmFkZENsYXNzKENPTE9SX1ZJRVdfQUxQSEFfQ0hBTk5FTF9TQ0FMRV9DTEFTUykuYXBwZW5kVG8oJGFscGhhQ2hhbm5lbFNjYWxlV3JhcHBlcik7XHJcbiAgICAgICAgdGhpcy5fbWFrZUNTU0xpbmVhckdyYWRpZW50KHRoaXMuXyRhbHBoYUNoYW5uZWxTY2FsZSk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyQWxwaGFDaGFubmVsSGFuZGxlKCRhbHBoYUNoYW5uZWxTY2FsZUNlbGwpXHJcbiAgICB9LFxyXG4gICAgX21ha2VDU1NMaW5lYXJHcmFkaWVudDogZnVuY3Rpb24oJGVsKSB7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5fY3VycmVudENvbG9yO1xyXG4gICAgICAgIHZhciBjb2xvckFzUmdiID0gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmJdLmpvaW4oXCIsXCIpO1xyXG4gICAgICAgIHZhciBjb2xvckFzSGV4ID0gY29sb3IudG9IZXgoKS5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcclxuICAgICAgICAkZWwuYXR0cihcInN0eWxlXCIsIGZ1bmN0aW9uKGNvbG9yQXNSZ2IsIGNvbG9yQXNIZXgpIHtcclxuICAgICAgICAgICAgdmFyIHJ0bEVuYWJsZWQgPSB0aGlzLm9wdGlvbihcInJ0bEVuYWJsZWRcIik7XHJcbiAgICAgICAgICAgIHZhciBzdGFydENvbG9yID0gXCJyZ2JhKFwiICsgY29sb3JBc1JnYiArIFwiLCBcIiArIChydGxFbmFibGVkID8gXCIxXCIgOiBcIjBcIikgKyBcIilcIjtcclxuICAgICAgICAgICAgdmFyIGZpbmlzaENvbG9yID0gXCJyZ2JhKFwiICsgY29sb3JBc1JnYiArIFwiLCBcIiArIChydGxFbmFibGVkID8gXCIwXCIgOiBcIjFcIikgKyBcIilcIjtcclxuICAgICAgICAgICAgcmV0dXJuIFtcImJhY2tncm91bmQtaW1hZ2U6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KDE4MGRlZywgXCIgKyBzdGFydENvbG9yICsgXCIsIFwiICsgZmluaXNoQ29sb3IgKyBcIilcIiwgXCJiYWNrZ3JvdW5kLWltYWdlOiAtbW96LWxpbmVhci1ncmFkaWVudCgtOTBkZWcsIFwiICsgc3RhcnRDb2xvciArIFwiLCBcIiArIGZpbmlzaENvbG9yICsgXCIpXCIsIFwiYmFja2dyb3VuZC1pbWFnZTogLW8tbGluZWFyLWdyYWRpZW50KC05MGRlZywgXCIgKyBzdGFydENvbG9yICsgXCIsIFwiICsgZmluaXNoQ29sb3IgKyBcIilcIiwgXCJiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQoLTkwZGVnLCBcIiArIHN0YXJ0Q29sb3IgKyBcIiwgXCIgKyBmaW5pc2hDb2xvciArIFwiKVwiXS5qb2luKFwiO1wiKVxyXG4gICAgICAgIH0uY2FsbCh0aGlzLCBjb2xvckFzUmdiLCBjb2xvckFzSGV4KSlcclxuICAgIH0sXHJcbiAgICBfcmVuZGVyQWxwaGFDaGFubmVsSW5wdXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgJGFscGhhQ2hhbm5lbElucHV0Q2VsbCA9IHRoaXMuX3JlbmRlckh0bWxDZWxsSW5zaWRlUm93KDEsIHRoaXMuXyRjb2xvclBpY2tlckNvbnRhaW5lcik7XHJcbiAgICAgICAgdGhhdC5fYWxwaGFDaGFubmVsSW5wdXQgPSB0aGlzLl9yZW5kZXJFZGl0b3JXaXRoTGFiZWwoe1xyXG4gICAgICAgICAgICBlZGl0b3JUeXBlOiBOdW1iZXJCb3gsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9jdXJyZW50Q29sb3IuYSxcclxuICAgICAgICAgICAgbWF4OiAxLFxyXG4gICAgICAgICAgICBzdGVwOiAuMSxcclxuICAgICAgICAgICAgb25WYWx1ZUNoYW5nZWQ6IGZ1bmN0aW9uKGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFyZ3MudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoYXQuX2N1cnJlbnRDb2xvci5pc1ZhbGlkQWxwaGEodmFsdWUpID8gdmFsdWUgOiB0aGF0Ll9jdXJyZW50Q29sb3IuYTtcclxuICAgICAgICAgICAgICAgIGFyZ3MuZXZlbnQgJiYgdGhhdC5fc2F2ZVZhbHVlQ2hhbmdlRXZlbnQoYXJncy5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll91cGRhdGVDb2xvclRyYW5zcGFyZW5jeSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9wbGFjZUFscGhhQ2hhbm5lbEhhbmRsZSgpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxhYmVsQ2xhc3M6IENPTE9SX1ZJRVdfQUxQSEFfQ0hBTk5FTF9MQUJFTF9DTEFTUyxcclxuICAgICAgICAgICAgbGFiZWxUZXh0OiBcIkFscGhhXCIsXHJcbiAgICAgICAgICAgIGxhYmVsQXJpYVRleHQ6IG1lc3NhZ2VMb2NhbGl6YXRpb24uZm9ybWF0KFwiZHhDb2xvclZpZXctYXJpYUFscGhhXCIpXHJcbiAgICAgICAgfSkuYXBwZW5kVG8oJGFscGhhQ2hhbm5lbElucHV0Q2VsbCkuZmluZChcIi5keC1udW1iZXJib3hcIikuZHhOdW1iZXJCb3goXCJpbnN0YW5jZVwiKVxyXG4gICAgfSxcclxuICAgIF91cGRhdGVDb2xvclRyYW5zcGFyZW5jeTogZnVuY3Rpb24odHJhbnNwYXJlbmN5KSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLmEgPSB0cmFuc3BhcmVuY3k7XHJcbiAgICAgICAgdGhpcy5hcHBseUNvbG9yKClcclxuICAgIH0sXHJcbiAgICBfcmVuZGVyQWxwaGFDaGFubmVsSGFuZGxlOiBmdW5jdGlvbigkcGFyZW50KSB7XHJcbiAgICAgICAgdGhpcy5fJGFscGhhQ2hhbm5lbEhhbmRsZSA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhDT0xPUl9WSUVXX0FMUEhBX0NIQU5ORUxfSEFORExFX0NMQVNTKS5hcHBlbmRUbygkcGFyZW50KTtcclxuICAgICAgICB0aGlzLl9jcmVhdGVDb21wb25lbnQodGhpcy5fJGFscGhhQ2hhbm5lbEhhbmRsZSwgRHJhZ2dhYmxlLCB7XHJcbiAgICAgICAgICAgIGNvbnRlbnRUZW1wbGF0ZTogbnVsbCxcclxuICAgICAgICAgICAgYm91bmRhcnk6ICRwYXJlbnQsXHJcbiAgICAgICAgICAgIGFsbG93TW92ZUJ5Q2xpY2s6IHRydWUsXHJcbiAgICAgICAgICAgIGRyYWdEaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgICAgICAgICBvbkRyYWdNb3ZlOiBfcmVmMyA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxyXG4gICAgICAgICAgICAgICAgfSA9IF9yZWYzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQnlEcmFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciAkYWxwaGFDaGFubmVsSGFuZGxlID0gdGhpcy5fJGFscGhhQ2hhbm5lbEhhbmRsZTtcclxuICAgICAgICAgICAgICAgIHZhciBhbHBoYUNoYW5uZWxIYW5kbGVQb3NpdGlvbiA9IGxvY2F0ZSgkYWxwaGFDaGFubmVsSGFuZGxlKS5sZWZ0ICsgdGhpcy5fYWxwaGFDaGFubmVsSGFuZGxlV2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2F2ZVZhbHVlQ2hhbmdlRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlQ29sb3JUcmFuc3BhcmVuY3lCeVNjYWxlV2lkdGgoYWxwaGFDaGFubmVsSGFuZGxlUG9zaXRpb24pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9hbHBoYUNoYW5uZWxIYW5kbGVXaWR0aCA9IGdldFdpZHRoKHRoaXMuXyRhbHBoYUNoYW5uZWxIYW5kbGUpO1xyXG4gICAgICAgIHRoaXMuX2FscGhhQ2hhbm5lbFNjYWxlV29ya1dpZHRoID0gZ2V0V2lkdGgoJHBhcmVudCkgLSB0aGlzLl9hbHBoYUNoYW5uZWxIYW5kbGVXaWR0aDtcclxuICAgICAgICB0aGlzLl9wbGFjZUFscGhhQ2hhbm5lbEhhbmRsZSgpXHJcbiAgICB9LFxyXG4gICAgX2NhbGN1bGF0ZUNvbG9yVHJhbnNwYXJlbmN5QnlTY2FsZVdpZHRoOiBmdW5jdGlvbihoYW5kbGVQb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB0cmFuc3BhcmVuY3kgPSAoaGFuZGxlUG9zaXRpb24gLSB0aGlzLl9hbHBoYUNoYW5uZWxIYW5kbGVXaWR0aCAvIDIpIC8gdGhpcy5fYWxwaGFDaGFubmVsU2NhbGVXb3JrV2lkdGg7XHJcbiAgICAgICAgdmFyIHJ0bEVuYWJsZWQgPSB0aGlzLm9wdGlvbihcInJ0bEVuYWJsZWRcIik7XHJcbiAgICAgICAgdHJhbnNwYXJlbmN5ID0gcnRsRW5hYmxlZCA/IHRyYW5zcGFyZW5jeSA6IDEgLSB0cmFuc3BhcmVuY3k7XHJcbiAgICAgICAgaWYgKGhhbmRsZVBvc2l0aW9uID49IHRoaXMuX2FscGhhQ2hhbm5lbFNjYWxlV29ya1dpZHRoICsgdGhpcy5fYWxwaGFDaGFubmVsSGFuZGxlV2lkdGggLyAyKSB7XHJcbiAgICAgICAgICAgIHRyYW5zcGFyZW5jeSA9IHJ0bEVuYWJsZWQgPyAxIDogMFxyXG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNwYXJlbmN5IDwgMSkge1xyXG4gICAgICAgICAgICB0cmFuc3BhcmVuY3kgPSB0cmFuc3BhcmVuY3kudG9GaXhlZCgyKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFuc3BhcmVuY3kgPSBNYXRoLm1heCh0cmFuc3BhcmVuY3ksIDApO1xyXG4gICAgICAgIHRyYW5zcGFyZW5jeSA9IE1hdGgubWluKHRyYW5zcGFyZW5jeSwgMSk7XHJcbiAgICAgICAgdGhpcy5fYWxwaGFDaGFubmVsSW5wdXQub3B0aW9uKFwidmFsdWVcIiwgdHJhbnNwYXJlbmN5KVxyXG4gICAgfSxcclxuICAgIF9wbGFjZUFscGhhQ2hhbm5lbEhhbmRsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLl9hbHBoYUNoYW5uZWxTY2FsZVdvcmtXaWR0aCAqICgxIC0gdGhpcy5fY3VycmVudENvbG9yLmEpO1xyXG4gICAgICAgIGlmIChsZWZ0IDwgMCkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gMFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fYWxwaGFDaGFubmVsU2NhbGVXb3JrV2lkdGggPCBsZWZ0KSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSB0aGlzLl9hbHBoYUNoYW5uZWxTY2FsZVdvcmtXaWR0aFxyXG4gICAgICAgIH1cclxuICAgICAgICBtb3ZlKHRoaXMuXyRhbHBoYUNoYW5uZWxIYW5kbGUsIHtcclxuICAgICAgICAgICAgbGVmdDogdGhpcy5vcHRpb24oXCJydGxFbmFibGVkXCIpID8gdGhpcy5fYWxwaGFDaGFubmVsU2NhbGVXb3JrV2lkdGggLSBsZWZ0IDogbGVmdFxyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgYXBwbHlDb2xvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGNvbG9yVmFsdWUgPSB0aGlzLm9wdGlvbihcImVkaXRBbHBoYUNoYW5uZWxcIikgPyB0aGlzLl9tYWtlUmdiYSh0aGlzLl9jdXJyZW50Q29sb3IpIDogdGhpcy5fY3VycmVudENvbG9yLnRvSGV4KCk7XHJcbiAgICAgICAgdGhpcy5fbWFrZVRyYW5zcGFyZW50QmFja2dyb3VuZCh0aGlzLl8kY3VycmVudENvbG9yLCB0aGlzLl9jdXJyZW50Q29sb3IpO1xyXG4gICAgICAgIHRoaXMub3B0aW9uKFwidmFsdWVcIiwgY29sb3JWYWx1ZSlcclxuICAgIH0sXHJcbiAgICBjYW5jZWxDb2xvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdENvbG9yQW5kT3BhY2l0eSgpO1xyXG4gICAgICAgIHRoaXMuX3JlZnJlc2hNYXJrdXAoKVxyXG4gICAgfSxcclxuICAgIF91cGRhdGVDb2xvcjogZnVuY3Rpb24oaXNIZXgsIGFyZ3MpIHtcclxuICAgICAgICB2YXIgcmdiYTtcclxuICAgICAgICB2YXIgbmV3Q29sb3I7XHJcbiAgICAgICAgaWYgKGlzSGV4KSB7XHJcbiAgICAgICAgICAgIG5ld0NvbG9yID0gdGhpcy5fdmFsaWRhdGVIZXgoXCIjXCIgKyB0aGlzLl9oZXhJbnB1dC5vcHRpb24oXCJ2YWx1ZVwiKSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZ2JhID0gdGhpcy5fdmFsaWRhdGVSZ2IoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2FscGhhQ2hhbm5lbElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICByZ2JhLnB1c2godGhpcy5fYWxwaGFDaGFubmVsSW5wdXQub3B0aW9uKFwidmFsdWVcIikpO1xyXG4gICAgICAgICAgICAgICAgbmV3Q29sb3IgPSBcInJnYmEoXCIgKyByZ2JhLmpvaW4oXCIsIFwiKSArIFwiKVwiXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDb2xvciA9IFwicmdiKFwiICsgcmdiYS5qb2luKFwiLCBcIikgKyBcIilcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fc3VwcHJlc3NFZGl0b3JzVmFsdWVVcGRhdGluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSBuZXcgQ29sb3IobmV3Q29sb3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9zYXZlVmFsdWVDaGFuZ2VFdmVudChhcmdzLmV2ZW50KTtcclxuICAgICAgICAgICAgdGhpcy5hcHBseUNvbG9yKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hNYXJrdXAoKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfdmFsaWRhdGVIZXg6IGZ1bmN0aW9uKGhleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50Q29sb3IuaXNWYWxpZEhleChoZXgpID8gaGV4IDogdGhpcy5fY3VycmVudENvbG9yLnRvSGV4KClcclxuICAgIH0sXHJcbiAgICBfdmFsaWRhdGVSZ2I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciByID0gdGhpcy5fcmdiSW5wdXRzWzBdLm9wdGlvbihcInZhbHVlXCIpO1xyXG4gICAgICAgIHZhciBnID0gdGhpcy5fcmdiSW5wdXRzWzFdLm9wdGlvbihcInZhbHVlXCIpO1xyXG4gICAgICAgIHZhciBiID0gdGhpcy5fcmdiSW5wdXRzWzJdLm9wdGlvbihcInZhbHVlXCIpO1xyXG4gICAgICAgIGlmICghdGhpcy5fY3VycmVudENvbG9yLmlzVmFsaWRSR0IociwgZywgYikpIHtcclxuICAgICAgICAgICAgciA9IHRoaXMuX2N1cnJlbnRDb2xvci5yO1xyXG4gICAgICAgICAgICBnID0gdGhpcy5fY3VycmVudENvbG9yLmc7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLl9jdXJyZW50Q29sb3IuYlxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3IsIGcsIGJdXHJcbiAgICB9LFxyXG4gICAgX3JlZnJlc2hNYXJrdXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3BsYWNlSHVlU2NhbGVIYW5kbGUoKTtcclxuICAgICAgICB0aGlzLl9wbGFjZVBhbGV0dGVIYW5kbGUoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVDb2xvclBhcmFtc0FuZENvbG9yUHJldmlldygpO1xyXG4gICAgICAgIHRoaXMuXyRwYWxldHRlLmNzcyhcImJhY2tncm91bmRDb2xvclwiLCB0aGlzLl9jdXJyZW50Q29sb3IuZ2V0UHVyZUNvbG9yKCkudG9IZXgoKSk7XHJcbiAgICAgICAgaWYgKHRoaXMuXyRhbHBoYUNoYW5uZWxIYW5kbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29sb3JUcmFuc3BhcmVuY3kodGhpcy5fY3VycmVudENvbG9yLmEpO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGFjZUFscGhhQ2hhbm5lbEhhbmRsZSgpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF91cGRhdGVDb2xvclBhcmFtc0FuZENvbG9yUHJldmlldzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fc3VwcHJlc3NFZGl0b3JzVmFsdWVVcGRhdGluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5faGV4SW5wdXQub3B0aW9uKFwidmFsdWVcIiwgdGhpcy5fY3VycmVudENvbG9yLnRvSGV4KCkucmVwbGFjZShcIiNcIiwgXCJcIikpO1xyXG4gICAgICAgIHRoaXMuX3JnYklucHV0c1swXS5vcHRpb24oXCJ2YWx1ZVwiLCB0aGlzLl9jdXJyZW50Q29sb3Iucik7XHJcbiAgICAgICAgdGhpcy5fcmdiSW5wdXRzWzFdLm9wdGlvbihcInZhbHVlXCIsIHRoaXMuX2N1cnJlbnRDb2xvci5nKTtcclxuICAgICAgICB0aGlzLl9yZ2JJbnB1dHNbMl0ub3B0aW9uKFwidmFsdWVcIiwgdGhpcy5fY3VycmVudENvbG9yLmIpO1xyXG4gICAgICAgIHRoaXMuX3N1cHByZXNzRWRpdG9yc1ZhbHVlVXBkYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb24oXCJlZGl0QWxwaGFDaGFubmVsXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21ha2VDU1NMaW5lYXJHcmFkaWVudC5jYWxsKHRoaXMsIHRoaXMuXyRhbHBoYUNoYW5uZWxTY2FsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FscGhhQ2hhbm5lbElucHV0Lm9wdGlvbihcInZhbHVlXCIsIHRoaXMuX2N1cnJlbnRDb2xvci5hKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfb3B0aW9uQ2hhbmdlZDogZnVuY3Rpb24oYXJncykge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3MudmFsdWU7XHJcbiAgICAgICAgc3dpdGNoIChhcmdzLm5hbWUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDdXJyZW50Q29sb3IodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl91cGRhdGVCeURyYWcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoTWFya3VwKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJ5RHJhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQmFzZShhcmdzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibWF0Y2hWYWx1ZVwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0QmFzZUNvbG9yKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwib25FbnRlcktleVByZXNzZWRcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRFbnRlcktleVByZXNzZWRBY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZWRpdEFscGhhQ2hhbm5lbFwiOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuXyRjb2xvclBpY2tlckNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckh0bWxSb3dzKFwiZWRpdEFscGhhQ2hhbm5lbFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJBbHBoYUNoYW5uZWxFbGVtZW50cygpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImtleVN0ZXBcIjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic3R5bGluZ01vZGVcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckNvbnRyb2xzKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEJhc2UoYXJncylcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5yZWdpc3RlckNvbXBvbmVudChcImR4Q29sb3JWaWV3XCIsIENvbG9yVmlldyk7XHJcbmV4cG9ydCBkZWZhdWx0IENvbG9yVmlldztcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/color_box/color_view.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor.js":
/*!*******************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _html_editor_ui_html_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./html_editor/ui.html_editor */ \"./node_modules/devextreme/esm/ui/html_editor/ui.html_editor.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (_html_editor_ui_html_editor__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IuanM/ODUwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzRDtBQUN2QyxrSUFBVSxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3VpL2h0bWxfZWRpdG9yLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS91aS9odG1sX2VkaXRvci5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IEh0bWxFZGl0b3IgZnJvbSBcIi4vaHRtbF9lZGl0b3IvdWkuaHRtbF9lZGl0b3JcIjtcclxuZXhwb3J0IGRlZmF1bHQgSHRtbEVkaXRvcjtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/converterController.js":
/*!***************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/converterController.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * DevExtreme (esm/ui/html_editor/converterController.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nclass ConverterController {\r\n    constructor() {\r\n        this._converters = {}\r\n    }\r\n    addConverter(name, converter) {\r\n        this._converters[name] = converter\r\n    }\r\n    getConverter(name) {\r\n        return this._converters[name]\r\n    }\r\n}\r\nvar controller = new ConverterController;\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (controller);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvY29udmVydGVyQ29udHJvbGxlci5qcz8zNmFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLHlFQUFVLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvY29udmVydGVyQ29udHJvbGxlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdWkvaHRtbF9lZGl0b3IvY29udmVydGVyQ29udHJvbGxlci5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuY2xhc3MgQ29udmVydGVyQ29udHJvbGxlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9jb252ZXJ0ZXJzID0ge31cclxuICAgIH1cclxuICAgIGFkZENvbnZlcnRlcihuYW1lLCBjb252ZXJ0ZXIpIHtcclxuICAgICAgICB0aGlzLl9jb252ZXJ0ZXJzW25hbWVdID0gY29udmVydGVyXHJcbiAgICB9XHJcbiAgICBnZXRDb252ZXJ0ZXIobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0ZXJzW25hbWVdXHJcbiAgICB9XHJcbn1cclxudmFyIGNvbnRyb2xsZXIgPSBuZXcgQ29udmVydGVyQ29udHJvbGxlcjtcclxuZXhwb3J0IGRlZmF1bHQgY29udHJvbGxlcjtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/converterController.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/converters/delta.js":
/*!************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/converters/delta.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _converterController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../converterController */ \"./node_modules/devextreme/esm/ui/html_editor/converterController.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/converters/delta.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\nclass DeltaConverter {\r\n    setQuillInstance(quillInstance) {\r\n        this.quillInstance = quillInstance\r\n    }\r\n    toHtml() {\r\n        if (!this.quillInstance) {\r\n            return\r\n        }\r\n        return this._isQuillEmpty() ? \"\" : this.quillInstance.getSemanticHTML(0, this.quillInstance.getLength() + 1)\r\n    }\r\n    _isQuillEmpty() {\r\n        var delta = this.quillInstance.getContents();\r\n        return 1 === delta.length() && this._isDeltaEmpty(delta)\r\n    }\r\n    _isDeltaEmpty(delta) {\r\n        return delta.reduce((__, _ref) => {\r\n            var {\r\n                insert: insert\r\n            } = _ref;\r\n            return -1 !== insert.indexOf(\"\\n\")\r\n        })\r\n    }\r\n}\r\n_converterController__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addConverter(\"delta\", DeltaConverter);\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (DeltaConverter);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvY29udmVydGVycy9kZWx0YS5qcz82MDgwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNERBQW1CO0FBQ0osNkVBQWMsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9odG1sX2VkaXRvci9jb252ZXJ0ZXJzL2RlbHRhLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS91aS9odG1sX2VkaXRvci9jb252ZXJ0ZXJzL2RlbHRhLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQgQ29udmVydGVyQ29udHJvbGxlciBmcm9tIFwiLi4vY29udmVydGVyQ29udHJvbGxlclwiO1xyXG5jbGFzcyBEZWx0YUNvbnZlcnRlciB7XHJcbiAgICBzZXRRdWlsbEluc3RhbmNlKHF1aWxsSW5zdGFuY2UpIHtcclxuICAgICAgICB0aGlzLnF1aWxsSW5zdGFuY2UgPSBxdWlsbEluc3RhbmNlXHJcbiAgICB9XHJcbiAgICB0b0h0bWwoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnF1aWxsSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1F1aWxsRW1wdHkoKSA/IFwiXCIgOiB0aGlzLnF1aWxsSW5zdGFuY2UuZ2V0U2VtYW50aWNIVE1MKDAsIHRoaXMucXVpbGxJbnN0YW5jZS5nZXRMZW5ndGgoKSArIDEpXHJcbiAgICB9XHJcbiAgICBfaXNRdWlsbEVtcHR5KCkge1xyXG4gICAgICAgIHZhciBkZWx0YSA9IHRoaXMucXVpbGxJbnN0YW5jZS5nZXRDb250ZW50cygpO1xyXG4gICAgICAgIHJldHVybiAxID09PSBkZWx0YS5sZW5ndGgoKSAmJiB0aGlzLl9pc0RlbHRhRW1wdHkoZGVsdGEpXHJcbiAgICB9XHJcbiAgICBfaXNEZWx0YUVtcHR5KGRlbHRhKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlbHRhLnJlZHVjZSgoX18sIF9yZWYpID0+IHtcclxuICAgICAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgICAgIGluc2VydDogaW5zZXJ0XHJcbiAgICAgICAgICAgIH0gPSBfcmVmO1xyXG4gICAgICAgICAgICByZXR1cm4gLTEgIT09IGluc2VydC5pbmRleE9mKFwiXFxuXCIpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufVxyXG5Db252ZXJ0ZXJDb250cm9sbGVyLmFkZENvbnZlcnRlcihcImRlbHRhXCIsIERlbHRhQ29udmVydGVyKTtcclxuZXhwb3J0IGRlZmF1bHQgRGVsdGFDb252ZXJ0ZXI7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/converters/delta.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/formats/align.js":
/*!*********************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/formats/align.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_0__);\n/**\r\n * DevExtreme (esm/ui/html_editor/formats/align.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\nvar AlignStyle = {};\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a) {\r\n    AlignStyle = devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a.import(\"attributors/style/align\");\r\n    AlignStyle.whitelist.push(\"left\")\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (AlignStyle);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvZm9ybWF0cy9hbGlnbi5qcz9lZDc2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUM7QUFDckM7QUFDQSxJQUFJLHVEQUFLO0FBQ1QsaUJBQWlCLHVEQUFLO0FBQ3RCO0FBQ0E7QUFDZSx5RUFBVSxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3VpL2h0bWxfZWRpdG9yL2Zvcm1hdHMvYWxpZ24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3VpL2h0bWxfZWRpdG9yL2Zvcm1hdHMvYWxpZ24uanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCBRdWlsbCBmcm9tIFwiZGV2ZXh0cmVtZS1xdWlsbFwiO1xyXG52YXIgQWxpZ25TdHlsZSA9IHt9O1xyXG5pZiAoUXVpbGwpIHtcclxuICAgIEFsaWduU3R5bGUgPSBRdWlsbC5pbXBvcnQoXCJhdHRyaWJ1dG9ycy9zdHlsZS9hbGlnblwiKTtcclxuICAgIEFsaWduU3R5bGUud2hpdGVsaXN0LnB1c2goXCJsZWZ0XCIpXHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgQWxpZ25TdHlsZTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/formats/align.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/formats/font.js":
/*!********************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/formats/font.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_0__);\n/**\r\n * DevExtreme (esm/ui/html_editor/formats/font.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\nvar FontStyle = {};\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a) {\r\n    FontStyle = devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a.import(\"attributors/style/font\");\r\n    FontStyle.whitelist = null\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (FontStyle);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvZm9ybWF0cy9mb250LmpzP2JhYWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUNyQztBQUNBLElBQUksdURBQUs7QUFDVCxnQkFBZ0IsdURBQUs7QUFDckI7QUFDQTtBQUNlLHdFQUFTLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvZm9ybWF0cy9mb250LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS91aS9odG1sX2VkaXRvci9mb3JtYXRzL2ZvbnQuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCBRdWlsbCBmcm9tIFwiZGV2ZXh0cmVtZS1xdWlsbFwiO1xyXG52YXIgRm9udFN0eWxlID0ge307XHJcbmlmIChRdWlsbCkge1xyXG4gICAgRm9udFN0eWxlID0gUXVpbGwuaW1wb3J0KFwiYXR0cmlidXRvcnMvc3R5bGUvZm9udFwiKTtcclxuICAgIEZvbnRTdHlsZS53aGl0ZWxpc3QgPSBudWxsXHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgRm9udFN0eWxlO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/formats/font.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/formats/image.js":
/*!*********************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/formats/image.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/formats/image.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\nvar ExtImage = {};\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a) {\r\n    var Image = devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a.import(\"formats/image\");\r\n    ExtImage = class extends Image {\r\n        static create(data) {\r\n            var SRC = data && data.src || data;\r\n            var node = super.create(SRC);\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isObject\"])(data)) {\r\n                var setAttribute = (attr, value) => {\r\n                    data[attr] && node.setAttribute(attr, value)\r\n                };\r\n                setAttribute(\"alt\", data.alt);\r\n                setAttribute(\"width\", data.width);\r\n                setAttribute(\"height\", data.height)\r\n            }\r\n            return node\r\n        }\r\n        static formats(domNode) {\r\n            var formats = super.formats(domNode);\r\n            formats.imageSrc = domNode.getAttribute(\"src\");\r\n            return formats\r\n        }\r\n        formats() {\r\n            var formats = super.formats();\r\n            var floatValue = this.domNode.style.float;\r\n            if (floatValue) {\r\n                formats.float = floatValue\r\n            }\r\n            return formats\r\n        }\r\n        format(name, value) {\r\n            if (\"float\" === name) {\r\n                this.domNode.style[name] = value\r\n            } else {\r\n                super.format(name, value)\r\n            }\r\n        }\r\n        static value(domNode) {\r\n            return {\r\n                src: domNode.getAttribute(\"src\"),\r\n                width: domNode.getAttribute(\"width\"),\r\n                height: domNode.getAttribute(\"height\"),\r\n                alt: domNode.getAttribute(\"alt\")\r\n            }\r\n        }\r\n    };\r\n    ExtImage.blotName = \"extendedImage\"\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ExtImage);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvZm9ybWF0cy9pbWFnZS5qcz81ZGI5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUdIO0FBQ2xDO0FBQ0EsSUFBSSx1REFBSztBQUNULGdCQUFnQix1REFBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsdUVBQVEsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9odG1sX2VkaXRvci9mb3JtYXRzL2ltYWdlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS91aS9odG1sX2VkaXRvci9mb3JtYXRzL2ltYWdlLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQgUXVpbGwgZnJvbSBcImRldmV4dHJlbWUtcXVpbGxcIjtcclxuaW1wb3J0IHtcclxuICAgIGlzT2JqZWN0XHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvdHlwZVwiO1xyXG52YXIgRXh0SW1hZ2UgPSB7fTtcclxuaWYgKFF1aWxsKSB7XHJcbiAgICB2YXIgSW1hZ2UgPSBRdWlsbC5pbXBvcnQoXCJmb3JtYXRzL2ltYWdlXCIpO1xyXG4gICAgRXh0SW1hZ2UgPSBjbGFzcyBleHRlbmRzIEltYWdlIHtcclxuICAgICAgICBzdGF0aWMgY3JlYXRlKGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIFNSQyA9IGRhdGEgJiYgZGF0YS5zcmMgfHwgZGF0YTtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdXBlci5jcmVhdGUoU1JDKTtcclxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2V0QXR0cmlidXRlID0gKGF0dHIsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVthdHRyXSAmJiBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGUoXCJhbHRcIiwgZGF0YS5hbHQpO1xyXG4gICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgZGF0YS53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgZGF0YS5oZWlnaHQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGVcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIGZvcm1hdHMoZG9tTm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0cyA9IHN1cGVyLmZvcm1hdHMoZG9tTm9kZSk7XHJcbiAgICAgICAgICAgIGZvcm1hdHMuaW1hZ2VTcmMgPSBkb21Ob2RlLmdldEF0dHJpYnV0ZShcInNyY1wiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHNcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9ybWF0cygpIHtcclxuICAgICAgICAgICAgdmFyIGZvcm1hdHMgPSBzdXBlci5mb3JtYXRzKCk7XHJcbiAgICAgICAgICAgIHZhciBmbG9hdFZhbHVlID0gdGhpcy5kb21Ob2RlLnN0eWxlLmZsb2F0O1xyXG4gICAgICAgICAgICBpZiAoZmxvYXRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0cy5mbG9hdCA9IGZsb2F0VmFsdWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0c1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JtYXQobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKFwiZmxvYXRcIiA9PT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb21Ob2RlLnN0eWxlW25hbWVdID0gdmFsdWVcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN1cGVyLmZvcm1hdChuYW1lLCB2YWx1ZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgdmFsdWUoZG9tTm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3JjOiBkb21Ob2RlLmdldEF0dHJpYnV0ZShcInNyY1wiKSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBkb21Ob2RlLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBkb21Ob2RlLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSxcclxuICAgICAgICAgICAgICAgIGFsdDogZG9tTm9kZS5nZXRBdHRyaWJ1dGUoXCJhbHRcIilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFeHRJbWFnZS5ibG90TmFtZSA9IFwiZXh0ZW5kZWRJbWFnZVwiXHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgRXh0SW1hZ2U7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/formats/image.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/formats/link.js":
/*!********************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/formats/link.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/formats/link.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\nvar ExtLink = {};\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a) {\r\n    var Link = devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a.import(\"formats/link\");\r\n    ExtLink = class ExtLink extends Link {\r\n        static create(data) {\r\n            var HREF = data && data.href || data;\r\n            var node = super.create(HREF);\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isObject\"])(data)) {\r\n                if (data.text) {\r\n                    node.innerText = data.text\r\n                }\r\n                if (!data.target) {\r\n                    node.removeAttribute(\"target\")\r\n                }\r\n            }\r\n            return node\r\n        }\r\n        static formats(domNode) {\r\n            return {\r\n                href: domNode.getAttribute(\"href\"),\r\n                target: domNode.getAttribute(\"target\")\r\n            }\r\n        }\r\n        formats() {\r\n            var formats = super.formats();\r\n            var {\r\n                href: href,\r\n                target: target\r\n            } = ExtLink.formats(this.domNode);\r\n            formats.link = href;\r\n            formats.target = target;\r\n            return formats\r\n        }\r\n        format(name, value) {\r\n            if (\"link\" === name && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isObject\"])(value)) {\r\n                if (value.text) {\r\n                    this.domNode.innerText = value.text\r\n                }\r\n                if (value.target) {\r\n                    this.domNode.setAttribute(\"target\", \"_blank\")\r\n                } else {\r\n                    this.domNode.removeAttribute(\"target\")\r\n                }\r\n                this.domNode.setAttribute(\"href\", value.href)\r\n            } else {\r\n                super.format(name, value)\r\n            }\r\n        }\r\n        static value(domNode) {\r\n            return {\r\n                href: domNode.getAttribute(\"href\"),\r\n                text: domNode.innerText,\r\n                target: !!domNode.getAttribute(\"target\")\r\n            }\r\n        }\r\n    }\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ExtLink);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvZm9ybWF0cy9saW5rLmpzPzg0YjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FDO0FBR0g7QUFDbEM7QUFDQSxJQUFJLHVEQUFLO0FBQ1QsZUFBZSx1REFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUVBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2Usc0VBQU8sRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9odG1sX2VkaXRvci9mb3JtYXRzL2xpbmsuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3VpL2h0bWxfZWRpdG9yL2Zvcm1hdHMvbGluay5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IFF1aWxsIGZyb20gXCJkZXZleHRyZW1lLXF1aWxsXCI7XHJcbmltcG9ydCB7XHJcbiAgICBpc09iamVjdFxyXG59IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWxzL3R5cGVcIjtcclxudmFyIEV4dExpbmsgPSB7fTtcclxuaWYgKFF1aWxsKSB7XHJcbiAgICB2YXIgTGluayA9IFF1aWxsLmltcG9ydChcImZvcm1hdHMvbGlua1wiKTtcclxuICAgIEV4dExpbmsgPSBjbGFzcyBFeHRMaW5rIGV4dGVuZHMgTGluayB7XHJcbiAgICAgICAgc3RhdGljIGNyZWF0ZShkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBIUkVGID0gZGF0YSAmJiBkYXRhLmhyZWYgfHwgZGF0YTtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdXBlci5jcmVhdGUoSFJFRik7XHJcbiAgICAgICAgICAgIGlmIChpc09iamVjdChkYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEudGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaW5uZXJUZXh0ID0gZGF0YS50ZXh0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJ0YXJnZXRcIilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgZm9ybWF0cyhkb21Ob2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBocmVmOiBkb21Ob2RlLmdldEF0dHJpYnV0ZShcImhyZWZcIiksXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGRvbU5vZGUuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9ybWF0cygpIHtcclxuICAgICAgICAgICAgdmFyIGZvcm1hdHMgPSBzdXBlci5mb3JtYXRzKCk7XHJcbiAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICBocmVmOiBocmVmLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRcclxuICAgICAgICAgICAgfSA9IEV4dExpbmsuZm9ybWF0cyh0aGlzLmRvbU5vZGUpO1xyXG4gICAgICAgICAgICBmb3JtYXRzLmxpbmsgPSBocmVmO1xyXG4gICAgICAgICAgICBmb3JtYXRzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHNcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9ybWF0KG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChcImxpbmtcIiA9PT0gbmFtZSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb21Ob2RlLmlubmVyVGV4dCA9IHZhbHVlLnRleHRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbU5vZGUuc2V0QXR0cmlidXRlKFwidGFyZ2V0XCIsIFwiX2JsYW5rXCIpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJ0YXJnZXRcIilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZG9tTm9kZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHZhbHVlLmhyZWYpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdXBlci5mb3JtYXQobmFtZSwgdmFsdWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIHZhbHVlKGRvbU5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGhyZWY6IGRvbU5vZGUuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxcclxuICAgICAgICAgICAgICAgIHRleHQ6IGRvbU5vZGUuaW5uZXJUZXh0LFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiAhIWRvbU5vZGUuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgRXh0TGluaztcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/formats/link.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/formats/mention.js":
/*!***********************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/formats/mention.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/formats/mention.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\nvar Mention = {};\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a) {\r\n    var Embed = devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a.import(\"blots/embed\");\r\n    var MENTION_CLASS = \"dx-mention\";\r\n    Mention = class extends Embed {\r\n        static create(data) {\r\n            var node = super.create();\r\n            node.setAttribute(\"spellcheck\", false);\r\n            node.dataset.marker = data.marker;\r\n            node.dataset.mentionValue = data.value;\r\n            node.dataset.id = data.id;\r\n            this.renderContent(node, data);\r\n            return node\r\n        }\r\n        static value(node) {\r\n            return {\r\n                marker: node.dataset.marker,\r\n                id: node.dataset.id,\r\n                value: node.dataset.mentionValue\r\n            }\r\n        }\r\n        static renderContent(node, data) {\r\n            var template = this._templates.get(data.marker);\r\n            if (template) {\r\n                template.render({\r\n                    model: data,\r\n                    container: node\r\n                })\r\n            } else {\r\n                this.baseContentRender(node, data)\r\n            }\r\n        }\r\n        static baseContentRender(node, data) {\r\n            var $marker = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<span>\").text(data.marker);\r\n            Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node).append($marker).append(data.value)\r\n        }\r\n        static addTemplate(marker, template) {\r\n            this._templates.set(marker, template)\r\n        }\r\n        static removeTemplate(marker) {\r\n            this._templates.delete(marker)\r\n        }\r\n    };\r\n    Mention.blotName = \"mention\";\r\n    Mention.tagName = \"span\";\r\n    Mention.className = MENTION_CLASS;\r\n    Mention._templates = new Map\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Mention);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvZm9ybWF0cy9tZW50aW9uLmpzPzliMjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FDO0FBQ0U7QUFDdkM7QUFDQSxJQUFJLHVEQUFLO0FBQ1QsZ0JBQWdCLHVEQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOERBQUM7QUFDM0IsWUFBWSw4REFBQztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2Usc0VBQU8sRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9odG1sX2VkaXRvci9mb3JtYXRzL21lbnRpb24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3VpL2h0bWxfZWRpdG9yL2Zvcm1hdHMvbWVudGlvbi5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IFF1aWxsIGZyb20gXCJkZXZleHRyZW1lLXF1aWxsXCI7XHJcbmltcG9ydCAkIGZyb20gXCIuLi8uLi8uLi9jb3JlL3JlbmRlcmVyXCI7XHJcbnZhciBNZW50aW9uID0ge307XHJcbmlmIChRdWlsbCkge1xyXG4gICAgdmFyIEVtYmVkID0gUXVpbGwuaW1wb3J0KFwiYmxvdHMvZW1iZWRcIik7XHJcbiAgICB2YXIgTUVOVElPTl9DTEFTUyA9IFwiZHgtbWVudGlvblwiO1xyXG4gICAgTWVudGlvbiA9IGNsYXNzIGV4dGVuZHMgRW1iZWQge1xyXG4gICAgICAgIHN0YXRpYyBjcmVhdGUoZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN1cGVyLmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcInNwZWxsY2hlY2tcIiwgZmFsc2UpO1xyXG4gICAgICAgICAgICBub2RlLmRhdGFzZXQubWFya2VyID0gZGF0YS5tYXJrZXI7XHJcbiAgICAgICAgICAgIG5vZGUuZGF0YXNldC5tZW50aW9uVmFsdWUgPSBkYXRhLnZhbHVlO1xyXG4gICAgICAgICAgICBub2RlLmRhdGFzZXQuaWQgPSBkYXRhLmlkO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNvbnRlbnQobm9kZSwgZGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyB2YWx1ZShub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXI6IG5vZGUuZGF0YXNldC5tYXJrZXIsXHJcbiAgICAgICAgICAgICAgICBpZDogbm9kZS5kYXRhc2V0LmlkLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5vZGUuZGF0YXNldC5tZW50aW9uVmFsdWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0aWMgcmVuZGVyQ29udGVudChub2RlLCBkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMuX3RlbXBsYXRlcy5nZXQoZGF0YS5tYXJrZXIpO1xyXG4gICAgICAgICAgICBpZiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlLnJlbmRlcih7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBub2RlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlQ29udGVudFJlbmRlcihub2RlLCBkYXRhKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBiYXNlQ29udGVudFJlbmRlcihub2RlLCBkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciAkbWFya2VyID0gJChcIjxzcGFuPlwiKS50ZXh0KGRhdGEubWFya2VyKTtcclxuICAgICAgICAgICAgJChub2RlKS5hcHBlbmQoJG1hcmtlcikuYXBwZW5kKGRhdGEudmFsdWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyBhZGRUZW1wbGF0ZShtYXJrZXIsIHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlcy5zZXQobWFya2VyLCB0ZW1wbGF0ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGljIHJlbW92ZVRlbXBsYXRlKG1hcmtlcikge1xyXG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZXMuZGVsZXRlKG1hcmtlcilcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWVudGlvbi5ibG90TmFtZSA9IFwibWVudGlvblwiO1xyXG4gICAgTWVudGlvbi50YWdOYW1lID0gXCJzcGFuXCI7XHJcbiAgICBNZW50aW9uLmNsYXNzTmFtZSA9IE1FTlRJT05fQ0xBU1M7XHJcbiAgICBNZW50aW9uLl90ZW1wbGF0ZXMgPSBuZXcgTWFwXHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgTWVudGlvbjtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/formats/mention.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/formats/size.js":
/*!********************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/formats/size.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_0__);\n/**\r\n * DevExtreme (esm/ui/html_editor/formats/size.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\nvar SizeStyle = {};\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a) {\r\n    SizeStyle = devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a.import(\"attributors/style/size\");\r\n    SizeStyle.whitelist = null\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (SizeStyle);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvZm9ybWF0cy9zaXplLmpzP2E3OTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUNyQztBQUNBLElBQUksdURBQUs7QUFDVCxnQkFBZ0IsdURBQUs7QUFDckI7QUFDQTtBQUNlLHdFQUFTLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvZm9ybWF0cy9zaXplLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS91aS9odG1sX2VkaXRvci9mb3JtYXRzL3NpemUuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCBRdWlsbCBmcm9tIFwiZGV2ZXh0cmVtZS1xdWlsbFwiO1xyXG52YXIgU2l6ZVN0eWxlID0ge307XHJcbmlmIChRdWlsbCkge1xyXG4gICAgU2l6ZVN0eWxlID0gUXVpbGwuaW1wb3J0KFwiYXR0cmlidXRvcnMvc3R5bGUvc2l6ZVwiKTtcclxuICAgIFNpemVTdHlsZS53aGl0ZWxpc3QgPSBudWxsXHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgU2l6ZVN0eWxlO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/formats/size.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/formats/variable.js":
/*!************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/formats/variable.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_utils_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/utils/common */ \"./node_modules/devextreme/esm/core/utils/common.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/formats/variable.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\nvar Variable = {};\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a) {\r\n    var Embed = devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a.import(\"blots/embed\");\r\n    var VARIABLE_CLASS = \"dx-variable\";\r\n    Variable = class extends Embed {\r\n        static create(data) {\r\n            var node = super.create();\r\n            var startEscapeChar;\r\n            var endEscapeChar;\r\n            var text = data.value;\r\n            if (Array.isArray(data.escapeChar)) {\r\n                startEscapeChar = Object(_core_utils_common__WEBPACK_IMPORTED_MODULE_1__[\"ensureDefined\"])(data.escapeChar[0], \"\");\r\n                endEscapeChar = Object(_core_utils_common__WEBPACK_IMPORTED_MODULE_1__[\"ensureDefined\"])(data.escapeChar[1], \"\")\r\n            } else {\r\n                startEscapeChar = endEscapeChar = data.escapeChar\r\n            }\r\n            node.innerText = startEscapeChar + text + endEscapeChar;\r\n            node.dataset.varStartEscChar = startEscapeChar;\r\n            node.dataset.varEndEscChar = endEscapeChar;\r\n            node.dataset.varValue = data.value;\r\n            return node\r\n        }\r\n        static value(node) {\r\n            return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])({}, {\r\n                value: node.dataset.varValue,\r\n                escapeChar: [node.dataset.varStartEscChar || \"\", node.dataset.varEndEscChar || \"\"]\r\n            })\r\n        }\r\n    };\r\n    Variable.blotName = \"variable\";\r\n    Variable.tagName = \"span\";\r\n    Variable.className = VARIABLE_CLASS\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Variable);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvZm9ybWF0cy92YXJpYWJsZS5qcz8yZWRmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FDO0FBR0Q7QUFHQTtBQUNwQztBQUNBLElBQUksdURBQUs7QUFDVCxnQkFBZ0IsdURBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3RUFBYTtBQUMvQyxnQ0FBZ0Msd0VBQWE7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpRUFBTSxHQUFHO0FBQzVCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsdUVBQVEsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9odG1sX2VkaXRvci9mb3JtYXRzL3ZhcmlhYmxlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS91aS9odG1sX2VkaXRvci9mb3JtYXRzL3ZhcmlhYmxlLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQgUXVpbGwgZnJvbSBcImRldmV4dHJlbWUtcXVpbGxcIjtcclxuaW1wb3J0IHtcclxuICAgIGVuc3VyZURlZmluZWRcclxufSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlscy9jb21tb25cIjtcclxuaW1wb3J0IHtcclxuICAgIGV4dGVuZFxyXG59IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWxzL2V4dGVuZFwiO1xyXG52YXIgVmFyaWFibGUgPSB7fTtcclxuaWYgKFF1aWxsKSB7XHJcbiAgICB2YXIgRW1iZWQgPSBRdWlsbC5pbXBvcnQoXCJibG90cy9lbWJlZFwiKTtcclxuICAgIHZhciBWQVJJQUJMRV9DTEFTUyA9IFwiZHgtdmFyaWFibGVcIjtcclxuICAgIFZhcmlhYmxlID0gY2xhc3MgZXh0ZW5kcyBFbWJlZCB7XHJcbiAgICAgICAgc3RhdGljIGNyZWF0ZShkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gc3VwZXIuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIHZhciBzdGFydEVzY2FwZUNoYXI7XHJcbiAgICAgICAgICAgIHZhciBlbmRFc2NhcGVDaGFyO1xyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IGRhdGEudmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEuZXNjYXBlQ2hhcikpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0RXNjYXBlQ2hhciA9IGVuc3VyZURlZmluZWQoZGF0YS5lc2NhcGVDaGFyWzBdLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgIGVuZEVzY2FwZUNoYXIgPSBlbnN1cmVEZWZpbmVkKGRhdGEuZXNjYXBlQ2hhclsxXSwgXCJcIilcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0RXNjYXBlQ2hhciA9IGVuZEVzY2FwZUNoYXIgPSBkYXRhLmVzY2FwZUNoYXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlLmlubmVyVGV4dCA9IHN0YXJ0RXNjYXBlQ2hhciArIHRleHQgKyBlbmRFc2NhcGVDaGFyO1xyXG4gICAgICAgICAgICBub2RlLmRhdGFzZXQudmFyU3RhcnRFc2NDaGFyID0gc3RhcnRFc2NhcGVDaGFyO1xyXG4gICAgICAgICAgICBub2RlLmRhdGFzZXQudmFyRW5kRXNjQ2hhciA9IGVuZEVzY2FwZUNoYXI7XHJcbiAgICAgICAgICAgIG5vZGUuZGF0YXNldC52YXJWYWx1ZSA9IGRhdGEudmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRpYyB2YWx1ZShub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRlbmQoe30sIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBub2RlLmRhdGFzZXQudmFyVmFsdWUsXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVDaGFyOiBbbm9kZS5kYXRhc2V0LnZhclN0YXJ0RXNjQ2hhciB8fCBcIlwiLCBub2RlLmRhdGFzZXQudmFyRW5kRXNjQ2hhciB8fCBcIlwiXVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWYXJpYWJsZS5ibG90TmFtZSA9IFwidmFyaWFibGVcIjtcclxuICAgIFZhcmlhYmxlLnRhZ05hbWUgPSBcInNwYW5cIjtcclxuICAgIFZhcmlhYmxlLmNsYXNzTmFtZSA9IFZBUklBQkxFX0NMQVNTXHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgVmFyaWFibGU7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/formats/variable.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/matchers/wordLists.js":
/*!**************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/matchers/wordLists.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * DevExtreme (esm/ui/html_editor/matchers/wordLists.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nfunction getListType(matches) {\r\n    var prefix = matches[1];\r\n    return prefix.match(/\\S+\\./) ? \"ordered\" : \"bullet\"\r\n}\r\n\r\nfunction getIndent(node) {\r\n    var style = node.getAttribute(\"style\");\r\n    if (style) {\r\n        var level = style.replace(/\\n+/g, \"\").match(/level(\\d+)/);\r\n        return level ? level[1] - 1 : 0\r\n    } else {\r\n        return false\r\n    }\r\n}\r\n\r\nfunction removeNewLineChar(operations) {\r\n    var newLineOperation = operations[operations.length - 1];\r\n    newLineOperation.insert = newLineOperation.insert.trim()\r\n}\r\nvar getMatcher = quill => {\r\n    var Delta = quill.import(\"delta\");\r\n    return (node, delta) => {\r\n        var ops = delta.ops.slice();\r\n        var insertOperation = ops[0];\r\n        insertOperation.insert = insertOperation.insert.replace(/^\\s+/, \"\");\r\n        var listDecoratorMatches = insertOperation.insert.match(/^(\\S+)\\s+/);\r\n        var indent = listDecoratorMatches && getIndent(node);\r\n        if (!listDecoratorMatches || false === indent) {\r\n            return delta\r\n        }\r\n        insertOperation.insert = insertOperation.insert.substring(listDecoratorMatches[0].length, insertOperation.insert.length);\r\n        removeNewLineChar(ops);\r\n        ops.push({\r\n            insert: \"\\n\",\r\n            attributes: {\r\n                list: getListType(listDecoratorMatches),\r\n                indent: indent\r\n            }\r\n        });\r\n        return new Delta(ops)\r\n    }\r\n};\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (getMatcher);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbWF0Y2hlcnMvd29yZExpc3RzLmpzPzhjOTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDZSx5RUFBVSxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3VpL2h0bWxfZWRpdG9yL21hdGNoZXJzL3dvcmRMaXN0cy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdWkvaHRtbF9lZGl0b3IvbWF0Y2hlcnMvd29yZExpc3RzLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRMaXN0VHlwZShtYXRjaGVzKSB7XHJcbiAgICB2YXIgcHJlZml4ID0gbWF0Y2hlc1sxXTtcclxuICAgIHJldHVybiBwcmVmaXgubWF0Y2goL1xcUytcXC4vKSA/IFwib3JkZXJlZFwiIDogXCJidWxsZXRcIlxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRJbmRlbnQobm9kZSkge1xyXG4gICAgdmFyIHN0eWxlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcclxuICAgIGlmIChzdHlsZSkge1xyXG4gICAgICAgIHZhciBsZXZlbCA9IHN0eWxlLnJlcGxhY2UoL1xcbisvZywgXCJcIikubWF0Y2goL2xldmVsKFxcZCspLyk7XHJcbiAgICAgICAgcmV0dXJuIGxldmVsID8gbGV2ZWxbMV0gLSAxIDogMFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlTmV3TGluZUNoYXIob3BlcmF0aW9ucykge1xyXG4gICAgdmFyIG5ld0xpbmVPcGVyYXRpb24gPSBvcGVyYXRpb25zW29wZXJhdGlvbnMubGVuZ3RoIC0gMV07XHJcbiAgICBuZXdMaW5lT3BlcmF0aW9uLmluc2VydCA9IG5ld0xpbmVPcGVyYXRpb24uaW5zZXJ0LnRyaW0oKVxyXG59XHJcbnZhciBnZXRNYXRjaGVyID0gcXVpbGwgPT4ge1xyXG4gICAgdmFyIERlbHRhID0gcXVpbGwuaW1wb3J0KFwiZGVsdGFcIik7XHJcbiAgICByZXR1cm4gKG5vZGUsIGRlbHRhKSA9PiB7XHJcbiAgICAgICAgdmFyIG9wcyA9IGRlbHRhLm9wcy5zbGljZSgpO1xyXG4gICAgICAgIHZhciBpbnNlcnRPcGVyYXRpb24gPSBvcHNbMF07XHJcbiAgICAgICAgaW5zZXJ0T3BlcmF0aW9uLmluc2VydCA9IGluc2VydE9wZXJhdGlvbi5pbnNlcnQucmVwbGFjZSgvXlxccysvLCBcIlwiKTtcclxuICAgICAgICB2YXIgbGlzdERlY29yYXRvck1hdGNoZXMgPSBpbnNlcnRPcGVyYXRpb24uaW5zZXJ0Lm1hdGNoKC9eKFxcUyspXFxzKy8pO1xyXG4gICAgICAgIHZhciBpbmRlbnQgPSBsaXN0RGVjb3JhdG9yTWF0Y2hlcyAmJiBnZXRJbmRlbnQobm9kZSk7XHJcbiAgICAgICAgaWYgKCFsaXN0RGVjb3JhdG9yTWF0Y2hlcyB8fCBmYWxzZSA9PT0gaW5kZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWx0YVxyXG4gICAgICAgIH1cclxuICAgICAgICBpbnNlcnRPcGVyYXRpb24uaW5zZXJ0ID0gaW5zZXJ0T3BlcmF0aW9uLmluc2VydC5zdWJzdHJpbmcobGlzdERlY29yYXRvck1hdGNoZXNbMF0ubGVuZ3RoLCBpbnNlcnRPcGVyYXRpb24uaW5zZXJ0Lmxlbmd0aCk7XHJcbiAgICAgICAgcmVtb3ZlTmV3TGluZUNoYXIob3BzKTtcclxuICAgICAgICBvcHMucHVzaCh7XHJcbiAgICAgICAgICAgIGluc2VydDogXCJcXG5cIixcclxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xyXG4gICAgICAgICAgICAgICAgbGlzdDogZ2V0TGlzdFR5cGUobGlzdERlY29yYXRvck1hdGNoZXMpLFxyXG4gICAgICAgICAgICAgICAgaW5kZW50OiBpbmRlbnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGVsdGEob3BzKVxyXG4gICAgfVxyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBnZXRNYXRjaGVyO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/matchers/wordLists.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/modules/base.js":
/*!********************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/modules/base.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./empty */ \"./node_modules/devextreme/esm/ui/html_editor/modules/empty.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/modules/base.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\nvar BaseModule = _empty__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a) {\r\n    var BaseQuillModule = devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a.import(\"core/module\");\r\n    BaseModule = class extends BaseQuillModule {\r\n        constructor(quill, options) {\r\n            super(quill, options);\r\n            this.editorInstance = options.editorInstance\r\n        }\r\n        saveValueChangeEvent(event) {\r\n            this.editorInstance._saveValueChangeEvent(event)\r\n        }\r\n        addCleanCallback(callback) {\r\n            this.editorInstance.addCleanCallback(callback)\r\n        }\r\n        handleOptionChangeValue(changes) {\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isObject\"])(changes)) {\r\n                Object.entries(changes).forEach(_ref => {\r\n                    var [name, value] = _ref;\r\n                    return this.option(name, value)\r\n                })\r\n            } else if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(changes)) {\r\n                null === this || void 0 === this ? void 0 : this.clean()\r\n            }\r\n        }\r\n    }\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (BaseModule);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy9iYXNlLmpzPzIwZGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUM7QUFDSDtBQUlBO0FBQ2xDLGlCQUFpQiw4Q0FBVztBQUM1QixJQUFJLHVEQUFLO0FBQ1QsMEJBQTBCLHVEQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYSxXQUFXLGtFQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSx5RUFBVSxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3VpL2h0bWxfZWRpdG9yL21vZHVsZXMvYmFzZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy9iYXNlLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQgUXVpbGwgZnJvbSBcImRldmV4dHJlbWUtcXVpbGxcIjtcclxuaW1wb3J0IEVtcHR5TW9kdWxlIGZyb20gXCIuL2VtcHR5XCI7XHJcbmltcG9ydCB7XHJcbiAgICBpc09iamVjdCxcclxuICAgIGlzRGVmaW5lZFxyXG59IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWxzL3R5cGVcIjtcclxudmFyIEJhc2VNb2R1bGUgPSBFbXB0eU1vZHVsZTtcclxuaWYgKFF1aWxsKSB7XHJcbiAgICB2YXIgQmFzZVF1aWxsTW9kdWxlID0gUXVpbGwuaW1wb3J0KFwiY29yZS9tb2R1bGVcIik7XHJcbiAgICBCYXNlTW9kdWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUXVpbGxNb2R1bGUge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHF1aWxsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHF1aWxsLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZSA9IG9wdGlvbnMuZWRpdG9ySW5zdGFuY2VcclxuICAgICAgICB9XHJcbiAgICAgICAgc2F2ZVZhbHVlQ2hhbmdlRXZlbnQoZXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZS5fc2F2ZVZhbHVlQ2hhbmdlRXZlbnQoZXZlbnQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkZENsZWFuQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZS5hZGRDbGVhbkNhbGxiYWNrKGNhbGxiYWNrKVxyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVPcHRpb25DaGFuZ2VWYWx1ZShjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGlmIChpc09iamVjdChjaGFuZ2VzKSkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY2hhbmdlcykuZm9yRWFjaChfcmVmID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgW25hbWUsIHZhbHVlXSA9IF9yZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uKG5hbWUsIHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNEZWZpbmVkKGNoYW5nZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBudWxsID09PSB0aGlzIHx8IHZvaWQgMCA9PT0gdGhpcyA/IHZvaWQgMCA6IHRoaXMuY2xlYW4oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IEJhc2VNb2R1bGU7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/modules/base.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/modules/dropImage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/modules/dropImage.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _events_core_events_engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../events/core/events_engine */ \"./node_modules/devextreme/esm/events/core/events_engine.js\");\n/* harmony import */ var _events_utils_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../events/utils/index */ \"./node_modules/devextreme/esm/events/utils/index.js\");\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/* harmony import */ var _core_utils_browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/utils/browser */ \"./node_modules/devextreme/esm/core/utils/browser.js\");\n/* harmony import */ var _core_utils_window__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/utils/window */ \"./node_modules/devextreme/esm/core/utils/window.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./base */ \"./node_modules/devextreme/esm/ui/html_editor/modules/base.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/modules/dropImage.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar DropImageModule = _base__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a) {\r\n    DropImageModule = class extends _base__WEBPACK_IMPORTED_MODULE_6__[\"default\"] {\r\n        constructor(quill, options) {\r\n            super(quill, options);\r\n            var widgetName = this.editorInstance.NAME;\r\n            _events_core_events_engine__WEBPACK_IMPORTED_MODULE_1__[\"default\"].on(this.quill.root, Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_2__[\"addNamespace\"])(\"drop\", widgetName), this._dropHandler.bind(this));\r\n            _events_core_events_engine__WEBPACK_IMPORTED_MODULE_1__[\"default\"].on(this.quill.root, Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_2__[\"addNamespace\"])(\"paste\", widgetName), this._pasteHandler.bind(this))\r\n        }\r\n        _dropHandler(e) {\r\n            var _dataTransfer$files;\r\n            var dataTransfer = e.originalEvent.dataTransfer;\r\n            var hasFiles = null === dataTransfer || void 0 === dataTransfer ? void 0 : null === (_dataTransfer$files = dataTransfer.files) || void 0 === _dataTransfer$files ? void 0 : _dataTransfer$files.length;\r\n            this.saveValueChangeEvent(e);\r\n            e.preventDefault();\r\n            if (hasFiles) {\r\n                this._getImage(dataTransfer.files, this._addImage.bind(this))\r\n            }\r\n        }\r\n        _pasteHandler(e) {\r\n            var _clipboardData$items;\r\n            var {\r\n                clipboardData: clipboardData\r\n            } = e.originalEvent;\r\n            this.saveValueChangeEvent(e);\r\n            if (!clipboardData) {\r\n                return\r\n            }\r\n            var hasDataItems = null === (_clipboardData$items = clipboardData.items) || void 0 === _clipboardData$items ? void 0 : _clipboardData$items.length;\r\n            var isHtmlData = clipboardData.getData(\"text/html\");\r\n            if (!isHtmlData && hasDataItems) {\r\n                this._getImage(clipboardData.items, imageData => {\r\n                    if (this._isBrowserSupportImagePaste(_core_utils_browser__WEBPACK_IMPORTED_MODULE_4__[\"default\"])) {\r\n                        return\r\n                    }\r\n                    this._addImage(imageData)\r\n                })\r\n            }\r\n        }\r\n        _isBrowserSupportImagePaste(_ref) {\r\n            var {\r\n                mozilla: mozilla,\r\n                chrome: chrome,\r\n                version: version\r\n            } = _ref;\r\n            return mozilla || chrome && version > 82\r\n        }\r\n        _isImage(file) {\r\n            return !!file.type.match(/^image\\/(a?png|bmp|gif|p?jpe?g|svg|vnd\\.microsoft\\.icon|webp)/i)\r\n        }\r\n        _getImage(files, callback) {\r\n            var window = Object(_core_utils_window__WEBPACK_IMPORTED_MODULE_5__[\"getWindow\"])();\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"each\"])(files, (index, file) => {\r\n                if (!this._isImage(file)) {\r\n                    return\r\n                }\r\n                var reader = new window.FileReader;\r\n                reader.onload = _ref2 => {\r\n                    var {\r\n                        target: target\r\n                    } = _ref2;\r\n                    callback(target.result)\r\n                };\r\n                var readableFile = file.getAsFile ? file.getAsFile() : file;\r\n                if (readableFile instanceof window.Blob) {\r\n                    reader.readAsDataURL(readableFile)\r\n                }\r\n            })\r\n        }\r\n        _addImage(data) {\r\n            var selection = this.quill.getSelection();\r\n            var pasteIndex = selection ? selection.index : this.quill.getLength();\r\n            this.quill.insertEmbed(pasteIndex, \"extendedImage\", data, \"user\")\r\n        }\r\n    }\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (DropImageModule);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy9kcm9wSW1hZ2UuanM/ZjZkMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FDO0FBQ3lCO0FBR3pCO0FBR0M7QUFDWTtBQUdkO0FBQ0o7QUFDaEMsc0JBQXNCLDZDQUFVO0FBQ2hDLElBQUksdURBQUs7QUFDVCxvQ0FBb0MsNkNBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBWSxxQkFBcUIsd0VBQVk7QUFDekQsWUFBWSxrRUFBWSxxQkFBcUIsd0VBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsMkRBQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvRUFBUztBQUNsQyxZQUFZLGlFQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsOEVBQWUsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9odG1sX2VkaXRvci9tb2R1bGVzL2Ryb3BJbWFnZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy9kcm9wSW1hZ2UuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCBRdWlsbCBmcm9tIFwiZGV2ZXh0cmVtZS1xdWlsbFwiO1xyXG5pbXBvcnQgZXZlbnRzRW5naW5lIGZyb20gXCIuLi8uLi8uLi9ldmVudHMvY29yZS9ldmVudHNfZW5naW5lXCI7XHJcbmltcG9ydCB7XHJcbiAgICBhZGROYW1lc3BhY2VcclxufSBmcm9tIFwiLi4vLi4vLi4vZXZlbnRzL3V0aWxzL2luZGV4XCI7XHJcbmltcG9ydCB7XHJcbiAgICBlYWNoXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvaXRlcmF0b3JcIjtcclxuaW1wb3J0IGJyb3dzZXIgZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvYnJvd3NlclwiO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0V2luZG93XHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvd2luZG93XCI7XHJcbmltcG9ydCBCYXNlTW9kdWxlIGZyb20gXCIuL2Jhc2VcIjtcclxudmFyIERyb3BJbWFnZU1vZHVsZSA9IEJhc2VNb2R1bGU7XHJcbmlmIChRdWlsbCkge1xyXG4gICAgRHJvcEltYWdlTW9kdWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihxdWlsbCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBzdXBlcihxdWlsbCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHZhciB3aWRnZXROYW1lID0gdGhpcy5lZGl0b3JJbnN0YW5jZS5OQU1FO1xyXG4gICAgICAgICAgICBldmVudHNFbmdpbmUub24odGhpcy5xdWlsbC5yb290LCBhZGROYW1lc3BhY2UoXCJkcm9wXCIsIHdpZGdldE5hbWUpLCB0aGlzLl9kcm9wSGFuZGxlci5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgZXZlbnRzRW5naW5lLm9uKHRoaXMucXVpbGwucm9vdCwgYWRkTmFtZXNwYWNlKFwicGFzdGVcIiwgd2lkZ2V0TmFtZSksIHRoaXMuX3Bhc3RlSGFuZGxlci5iaW5kKHRoaXMpKVxyXG4gICAgICAgIH1cclxuICAgICAgICBfZHJvcEhhbmRsZXIoZSkge1xyXG4gICAgICAgICAgICB2YXIgX2RhdGFUcmFuc2ZlciRmaWxlcztcclxuICAgICAgICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXI7XHJcbiAgICAgICAgICAgIHZhciBoYXNGaWxlcyA9IG51bGwgPT09IGRhdGFUcmFuc2ZlciB8fCB2b2lkIDAgPT09IGRhdGFUcmFuc2ZlciA/IHZvaWQgMCA6IG51bGwgPT09IChfZGF0YVRyYW5zZmVyJGZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzKSB8fCB2b2lkIDAgPT09IF9kYXRhVHJhbnNmZXIkZmlsZXMgPyB2b2lkIDAgOiBfZGF0YVRyYW5zZmVyJGZpbGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5zYXZlVmFsdWVDaGFuZ2VFdmVudChlKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBpZiAoaGFzRmlsZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dldEltYWdlKGRhdGFUcmFuc2Zlci5maWxlcywgdGhpcy5fYWRkSW1hZ2UuYmluZCh0aGlzKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfcGFzdGVIYW5kbGVyKGUpIHtcclxuICAgICAgICAgICAgdmFyIF9jbGlwYm9hcmREYXRhJGl0ZW1zO1xyXG4gICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgY2xpcGJvYXJkRGF0YTogY2xpcGJvYXJkRGF0YVxyXG4gICAgICAgICAgICB9ID0gZS5vcmlnaW5hbEV2ZW50O1xyXG4gICAgICAgICAgICB0aGlzLnNhdmVWYWx1ZUNoYW5nZUV2ZW50KGUpO1xyXG4gICAgICAgICAgICBpZiAoIWNsaXBib2FyZERhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBoYXNEYXRhSXRlbXMgPSBudWxsID09PSAoX2NsaXBib2FyZERhdGEkaXRlbXMgPSBjbGlwYm9hcmREYXRhLml0ZW1zKSB8fCB2b2lkIDAgPT09IF9jbGlwYm9hcmREYXRhJGl0ZW1zID8gdm9pZCAwIDogX2NsaXBib2FyZERhdGEkaXRlbXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgaXNIdG1sRGF0YSA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvaHRtbFwiKTtcclxuICAgICAgICAgICAgaWYgKCFpc0h0bWxEYXRhICYmIGhhc0RhdGFJdGVtcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0SW1hZ2UoY2xpcGJvYXJkRGF0YS5pdGVtcywgaW1hZ2VEYXRhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNCcm93c2VyU3VwcG9ydEltYWdlUGFzdGUoYnJvd3NlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEltYWdlKGltYWdlRGF0YSlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX2lzQnJvd3NlclN1cHBvcnRJbWFnZVBhc3RlKF9yZWYpIHtcclxuICAgICAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgICAgIG1vemlsbGE6IG1vemlsbGEsXHJcbiAgICAgICAgICAgICAgICBjaHJvbWU6IGNocm9tZSxcclxuICAgICAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25cclxuICAgICAgICAgICAgfSA9IF9yZWY7XHJcbiAgICAgICAgICAgIHJldHVybiBtb3ppbGxhIHx8IGNocm9tZSAmJiB2ZXJzaW9uID4gODJcclxuICAgICAgICB9XHJcbiAgICAgICAgX2lzSW1hZ2UoZmlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISFmaWxlLnR5cGUubWF0Y2goL15pbWFnZVxcLyhhP3BuZ3xibXB8Z2lmfHA/anBlP2d8c3ZnfHZuZFxcLm1pY3Jvc29mdFxcLmljb258d2VicCkvaSlcclxuICAgICAgICB9XHJcbiAgICAgICAgX2dldEltYWdlKGZpbGVzLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgd2luZG93ID0gZ2V0V2luZG93KCk7XHJcbiAgICAgICAgICAgIGVhY2goZmlsZXMsIChpbmRleCwgZmlsZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0ltYWdlKGZpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IHdpbmRvdy5GaWxlUmVhZGVyO1xyXG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IF9yZWYyID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldFxyXG4gICAgICAgICAgICAgICAgICAgIH0gPSBfcmVmMjtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0YXJnZXQucmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciByZWFkYWJsZUZpbGUgPSBmaWxlLmdldEFzRmlsZSA/IGZpbGUuZ2V0QXNGaWxlKCkgOiBmaWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlYWRhYmxlRmlsZSBpbnN0YW5jZW9mIHdpbmRvdy5CbG9iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwocmVhZGFibGVGaWxlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICBfYWRkSW1hZ2UoZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgdmFyIHBhc3RlSW5kZXggPSBzZWxlY3Rpb24gPyBzZWxlY3Rpb24uaW5kZXggOiB0aGlzLnF1aWxsLmdldExlbmd0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLnF1aWxsLmluc2VydEVtYmVkKHBhc3RlSW5kZXgsIFwiZXh0ZW5kZWRJbWFnZVwiLCBkYXRhLCBcInVzZXJcIilcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgRHJvcEltYWdlTW9kdWxlO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/modules/dropImage.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/modules/empty.js":
/*!*********************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/modules/empty.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return EmptyModule; });\n/**\r\n * DevExtreme (esm/ui/html_editor/modules/empty.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nclass EmptyModule {}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy9lbXB0eS5qcz9lNDEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy9lbXB0eS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy9lbXB0eS5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW1wdHlNb2R1bGUge31cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/modules/empty.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/modules/mentions.js":
/*!************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/modules/mentions.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _core_utils_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/utils/data */ \"./node_modules/devextreme/esm/core/utils/data.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _core_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/element */ \"./node_modules/devextreme/esm/core/element.js\");\n/* harmony import */ var _events_core_events_engine__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../events/core/events_engine */ \"./node_modules/devextreme/esm/events/core/events_engine.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base */ \"./node_modules/devextreme/esm/ui/html_editor/modules/base.js\");\n/* harmony import */ var _popup__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./popup */ \"./node_modules/devextreme/esm/ui/html_editor/modules/popup.js\");\n/* harmony import */ var _formats_mention__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../formats/mention */ \"./node_modules/devextreme/esm/ui/html_editor/formats/mention.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/modules/mentions.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar MentionModule = _base__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_1___default.a) {\r\n    var USER_ACTION = \"user\";\r\n    var DEFAULT_MARKER = \"@\";\r\n    var KEYS = {\r\n        ARROW_UP: \"upArrow\",\r\n        ARROW_DOWN: \"downArrow\",\r\n        ARROW_LEFT: \"leftArrow\",\r\n        ARROW_RIGHT: \"rightArrow\",\r\n        ENTER: \"enter\",\r\n        ESCAPE: \"escape\",\r\n        SPACE: \"space\",\r\n        PAGE_UP: \"pageUp\",\r\n        PAGE_DOWN: \"pageDown\",\r\n        END: \"end\",\r\n        HOME: \"home\"\r\n    };\r\n    var NAVIGATION_KEYS = [KEYS.ARROW_LEFT, KEYS.ARROW_RIGHT, KEYS.PAGE_UP, KEYS.PAGE_DOWN, KEYS.END, KEYS.HOME];\r\n    var ALLOWED_PREFIX_CHARS = [\" \", \"\\n\"];\r\n    var DISABLED_STATE_CLASS = \"dx-state-disabled\";\r\n    devextreme_quill__WEBPACK_IMPORTED_MODULE_1___default.a.register({\r\n        \"formats/mention\": _formats_mention__WEBPACK_IMPORTED_MODULE_9__[\"default\"]\r\n    }, true);\r\n    MentionModule = class extends _popup__WEBPACK_IMPORTED_MODULE_8__[\"default\"] {\r\n        _getDefaultOptions() {\r\n            var baseConfig = super._getDefaultOptions();\r\n            return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])(baseConfig, {\r\n                itemTemplate: \"item\",\r\n                valueExpr: \"this\",\r\n                displayExpr: \"this\",\r\n                template: null,\r\n                searchExpr: null,\r\n                searchTimeout: 500,\r\n                minSearchLength: 0\r\n            })\r\n        }\r\n        constructor(quill, options) {\r\n            super(quill, options);\r\n            this._mentions = {};\r\n            options.mentions.forEach(item => {\r\n                var marker = item.marker;\r\n                if (!marker) {\r\n                    item.marker = marker = DEFAULT_MARKER\r\n                }\r\n                var template = item.template;\r\n                if (template) {\r\n                    var preparedTemplate = this.editorInstance._getTemplate(template);\r\n                    preparedTemplate && _formats_mention__WEBPACK_IMPORTED_MODULE_9__[\"default\"].addTemplate(marker, preparedTemplate)\r\n                }\r\n                this._mentions[marker] = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])({}, this._getDefaultOptions(), item)\r\n            });\r\n            this._attachKeyboardHandlers();\r\n            this.addCleanCallback(this.clean.bind(this));\r\n            this.quill.on(\"text-change\", this.onTextChange.bind(this))\r\n        }\r\n        _attachKeyboardHandlers() {\r\n            this.quill.keyboard.addBinding({\r\n                key: KEYS.ARROW_UP\r\n            }, this._moveToItem.bind(this, \"prev\"));\r\n            this.quill.keyboard.addBinding({\r\n                key: KEYS.ARROW_DOWN\r\n            }, this._moveToItem.bind(this, \"next\"));\r\n            this.quill.keyboard.addBinding({\r\n                key: [KEYS.ENTER, KEYS.SPACE]\r\n            }, this._selectItemHandler.bind(this));\r\n            var enterBindings = this.quill.keyboard.bindings[KEYS.ENTER];\r\n            enterBindings.unshift(enterBindings.pop());\r\n            this.quill.keyboard.addBinding({\r\n                key: KEYS.ESCAPE\r\n            }, this._escapeKeyHandler.bind(this));\r\n            this.quill.keyboard.addBinding({\r\n                key: [KEYS.ARROW_LEFT, KEYS.ARROW_RIGHT],\r\n                shiftKey: true\r\n            }, this._ignoreKeyHandler.bind(this));\r\n            this.quill.keyboard.addBinding({\r\n                key: NAVIGATION_KEYS\r\n            }, this._ignoreKeyHandler.bind(this))\r\n        }\r\n        _moveToItem(direction) {\r\n            var dataSource = this._list.getDataSource();\r\n            if (this._isMentionActive && !dataSource.isLoading()) {\r\n                var $focusedItem = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this._list.option(\"focusedElement\"));\r\n                var defaultItemPosition = \"next\" === direction ? \"first\" : \"last\";\r\n                var $nextItem = $focusedItem[direction]();\r\n                $nextItem = $nextItem.length ? $nextItem : this._activeListItems[defaultItemPosition]();\r\n                this._list.option(\"focusedElement\", Object(_core_element__WEBPACK_IMPORTED_MODULE_5__[\"getPublicElement\"])($nextItem));\r\n                this._list.scrollToItem($nextItem)\r\n            }\r\n            return !this._isMentionActive\r\n        }\r\n        _ignoreKeyHandler() {\r\n            return !this._isMentionActive\r\n        }\r\n        _fitIntoRange(value, start, end) {\r\n            if (value > end) {\r\n                return start\r\n            }\r\n            if (value < start) {\r\n                return end\r\n            }\r\n            return value\r\n        }\r\n        _selectItemHandler() {\r\n            if (this._isMentionActive) {\r\n                this._list.option(\"items\").length ? this._list.selectItem(this._list.option(\"focusedElement\")) : this._popup.hide()\r\n            }\r\n            return !this._isMentionActive\r\n        }\r\n        _escapeKeyHandler() {\r\n            if (this._isMentionActive) {\r\n                this._popup.hide()\r\n            }\r\n            return !this._isMentionActive\r\n        }\r\n        renderList($container, options) {\r\n            this.compileGetters(this.options);\r\n            super.renderList($container, options)\r\n        }\r\n        compileGetters(_ref) {\r\n            var {\r\n                displayExpr: displayExpr,\r\n                valueExpr: valueExpr\r\n            } = _ref;\r\n            this._valueGetter = Object(_core_utils_data__WEBPACK_IMPORTED_MODULE_2__[\"compileGetter\"])(displayExpr);\r\n            this._idGetter = Object(_core_utils_data__WEBPACK_IMPORTED_MODULE_2__[\"compileGetter\"])(valueExpr)\r\n        }\r\n        _getListConfig(options) {\r\n            var baseConfig = super._getListConfig(options);\r\n            return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])(baseConfig, {\r\n                itemTemplate: this.options.itemTemplate,\r\n                onContentReady: () => {\r\n                    if (this._hasSearch) {\r\n                        this._popup.repaint();\r\n                        this._focusFirstElement();\r\n                        this._hasSearch = false\r\n                    }\r\n                }\r\n            })\r\n        }\r\n        insertEmbedContent() {\r\n            var markerLength = this._activeMentionConfig.marker.length;\r\n            var textLength = markerLength + this._searchValue.length;\r\n            var caretPosition = this.getPosition();\r\n            var selectedItem = this._list.option(\"selectedItem\");\r\n            var value = {\r\n                value: this._valueGetter(selectedItem),\r\n                id: this._idGetter(selectedItem),\r\n                marker: this._activeMentionConfig.marker\r\n            };\r\n            var Delta = devextreme_quill__WEBPACK_IMPORTED_MODULE_1___default.a.import(\"delta\");\r\n            var startIndex = Math.max(0, caretPosition - markerLength);\r\n            var retainCorrection = \"\\n\" === this._getCharByIndex(startIndex) ? 1 : 0;\r\n            startIndex += retainCorrection;\r\n            var newDelta = (new Delta).retain(startIndex).delete(textLength).insert({\r\n                mention: value\r\n            }).insert(\" \");\r\n            this.quill.updateContents(newDelta);\r\n            this.quill.setSelection(startIndex + 2)\r\n        }\r\n        _getLastInsertOperation(ops) {\r\n            var lastOperation = ops[ops.length - 1];\r\n            var isLastOperationInsert = \"insert\" in lastOperation;\r\n            if (isLastOperationInsert) {\r\n                return lastOperation\r\n            }\r\n            var isLastOperationDelete = \"delete\" in lastOperation;\r\n            if (isLastOperationDelete && ops.length >= 2) {\r\n                var penultOperation = ops[ops.length - 2];\r\n                var isPenultOperationInsert = \"insert\" in penultOperation;\r\n                var isSelectionReplacing = isLastOperationDelete && isPenultOperationInsert;\r\n                if (isSelectionReplacing) {\r\n                    return penultOperation\r\n                }\r\n            }\r\n            return null\r\n        }\r\n        onTextChange(newDelta, oldDelta, source) {\r\n            if (source === USER_ACTION) {\r\n                var lastOperation = newDelta.ops[newDelta.ops.length - 1];\r\n                if (this._isMentionActive && this._isPopupVisible) {\r\n                    this._processSearchValue(lastOperation) && this._filterList(this._searchValue)\r\n                } else {\r\n                    var {\r\n                        ops: ops\r\n                    } = newDelta;\r\n                    var lastInsertOperation = this._getLastInsertOperation(ops);\r\n                    if (lastInsertOperation) {\r\n                        this.checkMentionRequest(lastInsertOperation, ops)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        get _isPopupVisible() {\r\n            var _this$_popup;\r\n            return null === (_this$_popup = this._popup) || void 0 === _this$_popup ? void 0 : _this$_popup.option(\"visible\")\r\n        }\r\n        _processSearchValue(operation) {\r\n            var isInsertOperation = \"insert\" in operation;\r\n            if (isInsertOperation) {\r\n                this._searchValue += operation.insert\r\n            } else if (!this._searchValue.length || operation.delete > 1) {\r\n                this._popup.hide();\r\n                return false\r\n            } else {\r\n                this._searchValue = this._searchValue.slice(0, -1)\r\n            }\r\n            return true\r\n        }\r\n        checkMentionRequest(_ref2, ops) {\r\n            var {\r\n                insert: insert\r\n            } = _ref2;\r\n            var caret = this.quill.getSelection();\r\n            if (!insert || !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isString\"])(insert) || !caret || this._isMarkerPartOfText(ops[0].retain)) {\r\n                return\r\n            }\r\n            this._activeMentionConfig = this._mentions[insert];\r\n            if (this._activeMentionConfig) {\r\n                this._updateList(this._activeMentionConfig);\r\n                this.savePosition(caret.index);\r\n                this._popup.option(\"position\", this._popupPosition);\r\n                this._searchValue = \"\";\r\n                this._popup.show()\r\n            }\r\n        }\r\n        _isMarkerPartOfText(retain) {\r\n            if (!retain || -1 !== ALLOWED_PREFIX_CHARS.indexOf(this._getCharByIndex(retain - 1))) {\r\n                return false\r\n            }\r\n            return true\r\n        }\r\n        _getCharByIndex(index) {\r\n            return this.quill.getContents(index, 1).ops[0].insert\r\n        }\r\n        _updateList(_ref3) {\r\n            var {\r\n                dataSource: dataSource,\r\n                displayExpr: displayExpr,\r\n                valueExpr: valueExpr,\r\n                itemTemplate: itemTemplate,\r\n                searchExpr: searchExpr\r\n            } = _ref3;\r\n            this.compileGetters({\r\n                displayExpr: displayExpr,\r\n                valueExpr: valueExpr\r\n            });\r\n            this._list.unselectAll();\r\n            this._list.option({\r\n                dataSource: dataSource,\r\n                displayExpr: displayExpr,\r\n                itemTemplate: itemTemplate,\r\n                searchExpr: searchExpr\r\n            })\r\n        }\r\n        _filterList(searchValue) {\r\n            if (!this._isMinSearchLengthExceeded(searchValue)) {\r\n                this._resetFilter();\r\n                return\r\n            }\r\n            var searchTimeout = this._activeMentionConfig.searchTimeout;\r\n            if (searchTimeout) {\r\n                clearTimeout(this._searchTimer);\r\n                this._searchTimer = setTimeout(() => {\r\n                    this._search(searchValue)\r\n                }, searchTimeout)\r\n            } else {\r\n                this._search(searchValue)\r\n            }\r\n        }\r\n        _isMinSearchLengthExceeded(searchValue) {\r\n            return searchValue.length >= this._activeMentionConfig.minSearchLength\r\n        }\r\n        _resetFilter() {\r\n            clearTimeout(this._searchTimer);\r\n            this._search(null)\r\n        }\r\n        _search(searchValue) {\r\n            this._hasSearch = true;\r\n            this._list.option(\"searchValue\", searchValue)\r\n        }\r\n        _focusFirstElement() {\r\n            if (!this._list) {\r\n                return\r\n            }\r\n            var $firstItem = this._activeListItems.first();\r\n            this._list.option(\"focusedElement\", Object(_core_element__WEBPACK_IMPORTED_MODULE_5__[\"getPublicElement\"])($firstItem));\r\n            this._list.scrollToItem($firstItem)\r\n        }\r\n        get _popupPosition() {\r\n            var position = this.getPosition();\r\n            var {\r\n                left: mentionLeft,\r\n                top: mentionTop,\r\n                height: mentionHeight\r\n            } = this.quill.getBounds(position ? position - 1 : position);\r\n            var {\r\n                left: leftOffset,\r\n                top: topOffset\r\n            } = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.quill.root).offset();\r\n            var positionEvent = _events_core_events_engine__WEBPACK_IMPORTED_MODULE_6__[\"default\"].Event(\"positionEvent\", {\r\n                pageX: leftOffset + mentionLeft,\r\n                pageY: topOffset + mentionTop\r\n            });\r\n            return {\r\n                of: positionEvent,\r\n                offset: {\r\n                    v: mentionHeight\r\n                },\r\n                my: \"top left\",\r\n                at: \"top left\",\r\n                collision: {\r\n                    y: \"flip\",\r\n                    x: \"flipfit\"\r\n                }\r\n            }\r\n        }\r\n        _getPopupConfig() {\r\n            return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])(super._getPopupConfig(), {\r\n                hideOnParentScroll: false,\r\n                onShown: () => {\r\n                    this._isMentionActive = true;\r\n                    this._hasSearch = false;\r\n                    this._focusFirstElement()\r\n                },\r\n                onHidden: () => {\r\n                    this._list.unselectAll();\r\n                    this._list.option(\"focusedElement\", null);\r\n                    this._isMentionActive = false;\r\n                    this._search(null)\r\n                },\r\n                focusStateEnabled: false\r\n            })\r\n        }\r\n        get _activeListItems() {\r\n            return this._list.itemElements().filter(\":not(.\".concat(DISABLED_STATE_CLASS, \")\"))\r\n        }\r\n        clean() {\r\n            Object.keys(this._mentions).forEach(marker => {\r\n                if (this._mentions[marker].template) {\r\n                    _formats_mention__WEBPACK_IMPORTED_MODULE_9__[\"default\"].removeTemplate(marker)\r\n                }\r\n            })\r\n        }\r\n    }\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (MentionModule);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy9tZW50aW9ucy5qcz81NTAxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDdUM7QUFDRjtBQUdIO0FBR0E7QUFHRTtBQUdMO0FBQytCO0FBQzlCO0FBQ0U7QUFDTztBQUN6QyxvQkFBb0IsNkNBQVU7QUFDOUIsSUFBSSx1REFBSztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdURBQUs7QUFDVCwyQkFBMkIsd0RBQU87QUFDbEMsS0FBSztBQUNMLGtDQUFrQyw4Q0FBVztBQUM3QztBQUNBO0FBQ0EsbUJBQW1CLGlFQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3REFBTztBQUMvQztBQUNBLHlDQUF5QyxpRUFBTSxHQUFHO0FBQ2xELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOERBQUM7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHNFQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0NBQWdDLHNFQUFhO0FBQzdDLDZCQUE2QixzRUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUVBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRCQUE0QixpRUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzRUFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUcsOERBQUM7QUFDakIsZ0NBQWdDLGtFQUFZO0FBQzVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlFQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBTztBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDZSw0RUFBYSxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3VpL2h0bWxfZWRpdG9yL21vZHVsZXMvbWVudGlvbnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3VpL2h0bWxfZWRpdG9yL21vZHVsZXMvbWVudGlvbnMuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCAkIGZyb20gXCIuLi8uLi8uLi9jb3JlL3JlbmRlcmVyXCI7XHJcbmltcG9ydCBRdWlsbCBmcm9tIFwiZGV2ZXh0cmVtZS1xdWlsbFwiO1xyXG5pbXBvcnQge1xyXG4gICAgY29tcGlsZUdldHRlclxyXG59IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWxzL2RhdGFcIjtcclxuaW1wb3J0IHtcclxuICAgIGlzU3RyaW5nXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvdHlwZVwiO1xyXG5pbXBvcnQge1xyXG4gICAgZXh0ZW5kXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvZXh0ZW5kXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRQdWJsaWNFbGVtZW50XHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvZWxlbWVudFwiO1xyXG5pbXBvcnQgZXZlbnRzRW5naW5lIGZyb20gXCIuLi8uLi8uLi9ldmVudHMvY29yZS9ldmVudHNfZW5naW5lXCI7XHJcbmltcG9ydCBCYXNlTW9kdWxlIGZyb20gXCIuL2Jhc2VcIjtcclxuaW1wb3J0IFBvcHVwTW9kdWxlIGZyb20gXCIuL3BvcHVwXCI7XHJcbmltcG9ydCBNZW50aW9uIGZyb20gXCIuLi9mb3JtYXRzL21lbnRpb25cIjtcclxudmFyIE1lbnRpb25Nb2R1bGUgPSBCYXNlTW9kdWxlO1xyXG5pZiAoUXVpbGwpIHtcclxuICAgIHZhciBVU0VSX0FDVElPTiA9IFwidXNlclwiO1xyXG4gICAgdmFyIERFRkFVTFRfTUFSS0VSID0gXCJAXCI7XHJcbiAgICB2YXIgS0VZUyA9IHtcclxuICAgICAgICBBUlJPV19VUDogXCJ1cEFycm93XCIsXHJcbiAgICAgICAgQVJST1dfRE9XTjogXCJkb3duQXJyb3dcIixcclxuICAgICAgICBBUlJPV19MRUZUOiBcImxlZnRBcnJvd1wiLFxyXG4gICAgICAgIEFSUk9XX1JJR0hUOiBcInJpZ2h0QXJyb3dcIixcclxuICAgICAgICBFTlRFUjogXCJlbnRlclwiLFxyXG4gICAgICAgIEVTQ0FQRTogXCJlc2NhcGVcIixcclxuICAgICAgICBTUEFDRTogXCJzcGFjZVwiLFxyXG4gICAgICAgIFBBR0VfVVA6IFwicGFnZVVwXCIsXHJcbiAgICAgICAgUEFHRV9ET1dOOiBcInBhZ2VEb3duXCIsXHJcbiAgICAgICAgRU5EOiBcImVuZFwiLFxyXG4gICAgICAgIEhPTUU6IFwiaG9tZVwiXHJcbiAgICB9O1xyXG4gICAgdmFyIE5BVklHQVRJT05fS0VZUyA9IFtLRVlTLkFSUk9XX0xFRlQsIEtFWVMuQVJST1dfUklHSFQsIEtFWVMuUEFHRV9VUCwgS0VZUy5QQUdFX0RPV04sIEtFWVMuRU5ELCBLRVlTLkhPTUVdO1xyXG4gICAgdmFyIEFMTE9XRURfUFJFRklYX0NIQVJTID0gW1wiIFwiLCBcIlxcblwiXTtcclxuICAgIHZhciBESVNBQkxFRF9TVEFURV9DTEFTUyA9IFwiZHgtc3RhdGUtZGlzYWJsZWRcIjtcclxuICAgIFF1aWxsLnJlZ2lzdGVyKHtcclxuICAgICAgICBcImZvcm1hdHMvbWVudGlvblwiOiBNZW50aW9uXHJcbiAgICB9LCB0cnVlKTtcclxuICAgIE1lbnRpb25Nb2R1bGUgPSBjbGFzcyBleHRlbmRzIFBvcHVwTW9kdWxlIHtcclxuICAgICAgICBfZ2V0RGVmYXVsdE9wdGlvbnMoKSB7XHJcbiAgICAgICAgICAgIHZhciBiYXNlQ29uZmlnID0gc3VwZXIuX2dldERlZmF1bHRPcHRpb25zKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRlbmQoYmFzZUNvbmZpZywge1xyXG4gICAgICAgICAgICAgICAgaXRlbVRlbXBsYXRlOiBcIml0ZW1cIixcclxuICAgICAgICAgICAgICAgIHZhbHVlRXhwcjogXCJ0aGlzXCIsXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5RXhwcjogXCJ0aGlzXCIsXHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHNlYXJjaEV4cHI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzZWFyY2hUaW1lb3V0OiA1MDAsXHJcbiAgICAgICAgICAgICAgICBtaW5TZWFyY2hMZW5ndGg6IDBcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3RydWN0b3IocXVpbGwsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgc3VwZXIocXVpbGwsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLl9tZW50aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBvcHRpb25zLm1lbnRpb25zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFya2VyID0gaXRlbS5tYXJrZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ubWFya2VyID0gbWFya2VyID0gREVGQVVMVF9NQVJLRVJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IGl0ZW0udGVtcGxhdGU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlcGFyZWRUZW1wbGF0ZSA9IHRoaXMuZWRpdG9ySW5zdGFuY2UuX2dldFRlbXBsYXRlKHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBwcmVwYXJlZFRlbXBsYXRlICYmIE1lbnRpb24uYWRkVGVtcGxhdGUobWFya2VyLCBwcmVwYXJlZFRlbXBsYXRlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWVudGlvbnNbbWFya2VyXSA9IGV4dGVuZCh7fSwgdGhpcy5fZ2V0RGVmYXVsdE9wdGlvbnMoKSwgaXRlbSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaEtleWJvYXJkSGFuZGxlcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRDbGVhbkNhbGxiYWNrKHRoaXMuY2xlYW4uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMucXVpbGwub24oXCJ0ZXh0LWNoYW5nZVwiLCB0aGlzLm9uVGV4dENoYW5nZS5iaW5kKHRoaXMpKVxyXG4gICAgICAgIH1cclxuICAgICAgICBfYXR0YWNoS2V5Ym9hcmRIYW5kbGVycygpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWlsbC5rZXlib2FyZC5hZGRCaW5kaW5nKHtcclxuICAgICAgICAgICAgICAgIGtleTogS0VZUy5BUlJPV19VUFxyXG4gICAgICAgICAgICB9LCB0aGlzLl9tb3ZlVG9JdGVtLmJpbmQodGhpcywgXCJwcmV2XCIpKTtcclxuICAgICAgICAgICAgdGhpcy5xdWlsbC5rZXlib2FyZC5hZGRCaW5kaW5nKHtcclxuICAgICAgICAgICAgICAgIGtleTogS0VZUy5BUlJPV19ET1dOXHJcbiAgICAgICAgICAgIH0sIHRoaXMuX21vdmVUb0l0ZW0uYmluZCh0aGlzLCBcIm5leHRcIikpO1xyXG4gICAgICAgICAgICB0aGlzLnF1aWxsLmtleWJvYXJkLmFkZEJpbmRpbmcoe1xyXG4gICAgICAgICAgICAgICAga2V5OiBbS0VZUy5FTlRFUiwgS0VZUy5TUEFDRV1cclxuICAgICAgICAgICAgfSwgdGhpcy5fc2VsZWN0SXRlbUhhbmRsZXIuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHZhciBlbnRlckJpbmRpbmdzID0gdGhpcy5xdWlsbC5rZXlib2FyZC5iaW5kaW5nc1tLRVlTLkVOVEVSXTtcclxuICAgICAgICAgICAgZW50ZXJCaW5kaW5ncy51bnNoaWZ0KGVudGVyQmluZGluZ3MucG9wKCkpO1xyXG4gICAgICAgICAgICB0aGlzLnF1aWxsLmtleWJvYXJkLmFkZEJpbmRpbmcoe1xyXG4gICAgICAgICAgICAgICAga2V5OiBLRVlTLkVTQ0FQRVxyXG4gICAgICAgICAgICB9LCB0aGlzLl9lc2NhcGVLZXlIYW5kbGVyLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLnF1aWxsLmtleWJvYXJkLmFkZEJpbmRpbmcoe1xyXG4gICAgICAgICAgICAgICAga2V5OiBbS0VZUy5BUlJPV19MRUZULCBLRVlTLkFSUk9XX1JJR0hUXSxcclxuICAgICAgICAgICAgICAgIHNoaWZ0S2V5OiB0cnVlXHJcbiAgICAgICAgICAgIH0sIHRoaXMuX2lnbm9yZUtleUhhbmRsZXIuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMucXVpbGwua2V5Ym9hcmQuYWRkQmluZGluZyh7XHJcbiAgICAgICAgICAgICAgICBrZXk6IE5BVklHQVRJT05fS0VZU1xyXG4gICAgICAgICAgICB9LCB0aGlzLl9pZ25vcmVLZXlIYW5kbGVyLmJpbmQodGhpcykpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9tb3ZlVG9JdGVtKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgZGF0YVNvdXJjZSA9IHRoaXMuX2xpc3QuZ2V0RGF0YVNvdXJjZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNNZW50aW9uQWN0aXZlICYmICFkYXRhU291cmNlLmlzTG9hZGluZygpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJGZvY3VzZWRJdGVtID0gJCh0aGlzLl9saXN0Lm9wdGlvbihcImZvY3VzZWRFbGVtZW50XCIpKTtcclxuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0SXRlbVBvc2l0aW9uID0gXCJuZXh0XCIgPT09IGRpcmVjdGlvbiA/IFwiZmlyc3RcIiA6IFwibGFzdFwiO1xyXG4gICAgICAgICAgICAgICAgdmFyICRuZXh0SXRlbSA9ICRmb2N1c2VkSXRlbVtkaXJlY3Rpb25dKCk7XHJcbiAgICAgICAgICAgICAgICAkbmV4dEl0ZW0gPSAkbmV4dEl0ZW0ubGVuZ3RoID8gJG5leHRJdGVtIDogdGhpcy5fYWN0aXZlTGlzdEl0ZW1zW2RlZmF1bHRJdGVtUG9zaXRpb25dKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0Lm9wdGlvbihcImZvY3VzZWRFbGVtZW50XCIsIGdldFB1YmxpY0VsZW1lbnQoJG5leHRJdGVtKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0LnNjcm9sbFRvSXRlbSgkbmV4dEl0ZW0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9pc01lbnRpb25BY3RpdmVcclxuICAgICAgICB9XHJcbiAgICAgICAgX2lnbm9yZUtleUhhbmRsZXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5faXNNZW50aW9uQWN0aXZlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9maXRJbnRvUmFuZ2UodmFsdWUsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID4gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPCBzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBfc2VsZWN0SXRlbUhhbmRsZXIoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc01lbnRpb25BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3Qub3B0aW9uKFwiaXRlbXNcIikubGVuZ3RoID8gdGhpcy5fbGlzdC5zZWxlY3RJdGVtKHRoaXMuX2xpc3Qub3B0aW9uKFwiZm9jdXNlZEVsZW1lbnRcIikpIDogdGhpcy5fcG9wdXAuaGlkZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9pc01lbnRpb25BY3RpdmVcclxuICAgICAgICB9XHJcbiAgICAgICAgX2VzY2FwZUtleUhhbmRsZXIoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc01lbnRpb25BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVwLmhpZGUoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5faXNNZW50aW9uQWN0aXZlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlckxpc3QoJGNvbnRhaW5lciwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVHZXR0ZXJzKHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHN1cGVyLnJlbmRlckxpc3QoJGNvbnRhaW5lciwgb3B0aW9ucylcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcGlsZUdldHRlcnMoX3JlZikge1xyXG4gICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheUV4cHI6IGRpc3BsYXlFeHByLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVFeHByOiB2YWx1ZUV4cHJcclxuICAgICAgICAgICAgfSA9IF9yZWY7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlR2V0dGVyID0gY29tcGlsZUdldHRlcihkaXNwbGF5RXhwcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2lkR2V0dGVyID0gY29tcGlsZUdldHRlcih2YWx1ZUV4cHIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9nZXRMaXN0Q29uZmlnKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGJhc2VDb25maWcgPSBzdXBlci5fZ2V0TGlzdENvbmZpZyhvcHRpb25zKTtcclxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZChiYXNlQ29uZmlnLCB7XHJcbiAgICAgICAgICAgICAgICBpdGVtVGVtcGxhdGU6IHRoaXMub3B0aW9ucy5pdGVtVGVtcGxhdGUsXHJcbiAgICAgICAgICAgICAgICBvbkNvbnRlbnRSZWFkeTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYXNTZWFyY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wdXAucmVwYWludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb2N1c0ZpcnN0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNTZWFyY2ggPSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zZXJ0RW1iZWRDb250ZW50KCkge1xyXG4gICAgICAgICAgICB2YXIgbWFya2VyTGVuZ3RoID0gdGhpcy5fYWN0aXZlTWVudGlvbkNvbmZpZy5tYXJrZXIubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgdGV4dExlbmd0aCA9IG1hcmtlckxlbmd0aCArIHRoaXMuX3NlYXJjaFZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEl0ZW0gPSB0aGlzLl9saXN0Lm9wdGlvbihcInNlbGVjdGVkSXRlbVwiKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuX3ZhbHVlR2V0dGVyKHNlbGVjdGVkSXRlbSksXHJcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5faWRHZXR0ZXIoc2VsZWN0ZWRJdGVtKSxcclxuICAgICAgICAgICAgICAgIG1hcmtlcjogdGhpcy5fYWN0aXZlTWVudGlvbkNvbmZpZy5tYXJrZXJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIERlbHRhID0gUXVpbGwuaW1wb3J0KFwiZGVsdGFcIik7XHJcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gTWF0aC5tYXgoMCwgY2FyZXRQb3NpdGlvbiAtIG1hcmtlckxlbmd0aCk7XHJcbiAgICAgICAgICAgIHZhciByZXRhaW5Db3JyZWN0aW9uID0gXCJcXG5cIiA9PT0gdGhpcy5fZ2V0Q2hhckJ5SW5kZXgoc3RhcnRJbmRleCkgPyAxIDogMDtcclxuICAgICAgICAgICAgc3RhcnRJbmRleCArPSByZXRhaW5Db3JyZWN0aW9uO1xyXG4gICAgICAgICAgICB2YXIgbmV3RGVsdGEgPSAobmV3IERlbHRhKS5yZXRhaW4oc3RhcnRJbmRleCkuZGVsZXRlKHRleHRMZW5ndGgpLmluc2VydCh7XHJcbiAgICAgICAgICAgICAgICBtZW50aW9uOiB2YWx1ZVxyXG4gICAgICAgICAgICB9KS5pbnNlcnQoXCIgXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnF1aWxsLnVwZGF0ZUNvbnRlbnRzKG5ld0RlbHRhKTtcclxuICAgICAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oc3RhcnRJbmRleCArIDIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9nZXRMYXN0SW5zZXJ0T3BlcmF0aW9uKG9wcykge1xyXG4gICAgICAgICAgICB2YXIgbGFzdE9wZXJhdGlvbiA9IG9wc1tvcHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIHZhciBpc0xhc3RPcGVyYXRpb25JbnNlcnQgPSBcImluc2VydFwiIGluIGxhc3RPcGVyYXRpb247XHJcbiAgICAgICAgICAgIGlmIChpc0xhc3RPcGVyYXRpb25JbnNlcnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0T3BlcmF0aW9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGlzTGFzdE9wZXJhdGlvbkRlbGV0ZSA9IFwiZGVsZXRlXCIgaW4gbGFzdE9wZXJhdGlvbjtcclxuICAgICAgICAgICAgaWYgKGlzTGFzdE9wZXJhdGlvbkRlbGV0ZSAmJiBvcHMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwZW51bHRPcGVyYXRpb24gPSBvcHNbb3BzLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzUGVudWx0T3BlcmF0aW9uSW5zZXJ0ID0gXCJpbnNlcnRcIiBpbiBwZW51bHRPcGVyYXRpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNTZWxlY3Rpb25SZXBsYWNpbmcgPSBpc0xhc3RPcGVyYXRpb25EZWxldGUgJiYgaXNQZW51bHRPcGVyYXRpb25JbnNlcnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTZWxlY3Rpb25SZXBsYWNpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVudWx0T3BlcmF0aW9uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgb25UZXh0Q2hhbmdlKG5ld0RlbHRhLCBvbGREZWx0YSwgc291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IFVTRVJfQUNUSU9OKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdE9wZXJhdGlvbiA9IG5ld0RlbHRhLm9wc1tuZXdEZWx0YS5vcHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNNZW50aW9uQWN0aXZlICYmIHRoaXMuX2lzUG9wdXBWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1NlYXJjaFZhbHVlKGxhc3RPcGVyYXRpb24pICYmIHRoaXMuX2ZpbHRlckxpc3QodGhpcy5fc2VhcmNoVmFsdWUpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wczogb3BzXHJcbiAgICAgICAgICAgICAgICAgICAgfSA9IG5ld0RlbHRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0SW5zZXJ0T3BlcmF0aW9uID0gdGhpcy5fZ2V0TGFzdEluc2VydE9wZXJhdGlvbihvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0SW5zZXJ0T3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tNZW50aW9uUmVxdWVzdChsYXN0SW5zZXJ0T3BlcmF0aW9uLCBvcHMpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBfaXNQb3B1cFZpc2libGUoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyRfcG9wdXA7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsID09PSAoX3RoaXMkX3BvcHVwID0gdGhpcy5fcG9wdXApIHx8IHZvaWQgMCA9PT0gX3RoaXMkX3BvcHVwID8gdm9pZCAwIDogX3RoaXMkX3BvcHVwLm9wdGlvbihcInZpc2libGVcIilcclxuICAgICAgICB9XHJcbiAgICAgICAgX3Byb2Nlc3NTZWFyY2hWYWx1ZShvcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIGlzSW5zZXJ0T3BlcmF0aW9uID0gXCJpbnNlcnRcIiBpbiBvcGVyYXRpb247XHJcbiAgICAgICAgICAgIGlmIChpc0luc2VydE9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VhcmNoVmFsdWUgKz0gb3BlcmF0aW9uLmluc2VydFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9zZWFyY2hWYWx1ZS5sZW5ndGggfHwgb3BlcmF0aW9uLmRlbGV0ZSA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVwLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VhcmNoVmFsdWUgPSB0aGlzLl9zZWFyY2hWYWx1ZS5zbGljZSgwLCAtMSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBjaGVja01lbnRpb25SZXF1ZXN0KF9yZWYyLCBvcHMpIHtcclxuICAgICAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgICAgIGluc2VydDogaW5zZXJ0XHJcbiAgICAgICAgICAgIH0gPSBfcmVmMjtcclxuICAgICAgICAgICAgdmFyIGNhcmV0ID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgaWYgKCFpbnNlcnQgfHwgIWlzU3RyaW5nKGluc2VydCkgfHwgIWNhcmV0IHx8IHRoaXMuX2lzTWFya2VyUGFydE9mVGV4dChvcHNbMF0ucmV0YWluKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlTWVudGlvbkNvbmZpZyA9IHRoaXMuX21lbnRpb25zW2luc2VydF07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVNZW50aW9uQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMaXN0KHRoaXMuX2FjdGl2ZU1lbnRpb25Db25maWcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlUG9zaXRpb24oY2FyZXQuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wdXAub3B0aW9uKFwicG9zaXRpb25cIiwgdGhpcy5fcG9wdXBQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWFyY2hWYWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3B1cC5zaG93KClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfaXNNYXJrZXJQYXJ0T2ZUZXh0KHJldGFpbikge1xyXG4gICAgICAgICAgICBpZiAoIXJldGFpbiB8fCAtMSAhPT0gQUxMT1dFRF9QUkVGSVhfQ0hBUlMuaW5kZXhPZih0aGlzLl9nZXRDaGFyQnlJbmRleChyZXRhaW4gLSAxKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9nZXRDaGFyQnlJbmRleChpbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWlsbC5nZXRDb250ZW50cyhpbmRleCwgMSkub3BzWzBdLmluc2VydFxyXG4gICAgICAgIH1cclxuICAgICAgICBfdXBkYXRlTGlzdChfcmVmMykge1xyXG4gICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZTogZGF0YVNvdXJjZSxcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlFeHByOiBkaXNwbGF5RXhwcixcclxuICAgICAgICAgICAgICAgIHZhbHVlRXhwcjogdmFsdWVFeHByLFxyXG4gICAgICAgICAgICAgICAgaXRlbVRlbXBsYXRlOiBpdGVtVGVtcGxhdGUsXHJcbiAgICAgICAgICAgICAgICBzZWFyY2hFeHByOiBzZWFyY2hFeHByXHJcbiAgICAgICAgICAgIH0gPSBfcmVmMztcclxuICAgICAgICAgICAgdGhpcy5jb21waWxlR2V0dGVycyh7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5RXhwcjogZGlzcGxheUV4cHIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZUV4cHI6IHZhbHVlRXhwclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fbGlzdC51bnNlbGVjdEFsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0Lm9wdGlvbih7XHJcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlOiBkYXRhU291cmNlLFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheUV4cHI6IGRpc3BsYXlFeHByLFxyXG4gICAgICAgICAgICAgICAgaXRlbVRlbXBsYXRlOiBpdGVtVGVtcGxhdGUsXHJcbiAgICAgICAgICAgICAgICBzZWFyY2hFeHByOiBzZWFyY2hFeHByXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9maWx0ZXJMaXN0KHNlYXJjaFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNNaW5TZWFyY2hMZW5ndGhFeGNlZWRlZChzZWFyY2hWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0RmlsdGVyKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2VhcmNoVGltZW91dCA9IHRoaXMuX2FjdGl2ZU1lbnRpb25Db25maWcuc2VhcmNoVGltZW91dDtcclxuICAgICAgICAgICAgaWYgKHNlYXJjaFRpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zZWFyY2hUaW1lcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWFyY2hUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlYXJjaChzZWFyY2hWYWx1ZSlcclxuICAgICAgICAgICAgICAgIH0sIHNlYXJjaFRpbWVvdXQpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWFyY2goc2VhcmNoVmFsdWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX2lzTWluU2VhcmNoTGVuZ3RoRXhjZWVkZWQoc2VhcmNoVmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlYXJjaFZhbHVlLmxlbmd0aCA+PSB0aGlzLl9hY3RpdmVNZW50aW9uQ29uZmlnLm1pblNlYXJjaExlbmd0aFxyXG4gICAgICAgIH1cclxuICAgICAgICBfcmVzZXRGaWx0ZXIoKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zZWFyY2hUaW1lcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlYXJjaChudWxsKVxyXG4gICAgICAgIH1cclxuICAgICAgICBfc2VhcmNoKHNlYXJjaFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc1NlYXJjaCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3Qub3B0aW9uKFwic2VhcmNoVmFsdWVcIiwgc2VhcmNoVmFsdWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9mb2N1c0ZpcnN0RWxlbWVudCgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9saXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgJGZpcnN0SXRlbSA9IHRoaXMuX2FjdGl2ZUxpc3RJdGVtcy5maXJzdCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0Lm9wdGlvbihcImZvY3VzZWRFbGVtZW50XCIsIGdldFB1YmxpY0VsZW1lbnQoJGZpcnN0SXRlbSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0LnNjcm9sbFRvSXRlbSgkZmlyc3RJdGVtKVxyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgX3BvcHVwUG9zaXRpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgICAgIGxlZnQ6IG1lbnRpb25MZWZ0LFxyXG4gICAgICAgICAgICAgICAgdG9wOiBtZW50aW9uVG9wLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtZW50aW9uSGVpZ2h0XHJcbiAgICAgICAgICAgIH0gPSB0aGlzLnF1aWxsLmdldEJvdW5kcyhwb3NpdGlvbiA/IHBvc2l0aW9uIC0gMSA6IHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnRPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICB0b3A6IHRvcE9mZnNldFxyXG4gICAgICAgICAgICB9ID0gJCh0aGlzLnF1aWxsLnJvb3QpLm9mZnNldCgpO1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25FdmVudCA9IGV2ZW50c0VuZ2luZS5FdmVudChcInBvc2l0aW9uRXZlbnRcIiwge1xyXG4gICAgICAgICAgICAgICAgcGFnZVg6IGxlZnRPZmZzZXQgKyBtZW50aW9uTGVmdCxcclxuICAgICAgICAgICAgICAgIHBhZ2VZOiB0b3BPZmZzZXQgKyBtZW50aW9uVG9wXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgb2Y6IHBvc2l0aW9uRXZlbnQsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB2OiBtZW50aW9uSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbXk6IFwidG9wIGxlZnRcIixcclxuICAgICAgICAgICAgICAgIGF0OiBcInRvcCBsZWZ0XCIsXHJcbiAgICAgICAgICAgICAgICBjb2xsaXNpb246IHtcclxuICAgICAgICAgICAgICAgICAgICB5OiBcImZsaXBcIixcclxuICAgICAgICAgICAgICAgICAgICB4OiBcImZsaXBmaXRcIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9nZXRQb3B1cENvbmZpZygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZChzdXBlci5fZ2V0UG9wdXBDb25maWcoKSwge1xyXG4gICAgICAgICAgICAgICAgaGlkZU9uUGFyZW50U2Nyb2xsOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG9uU2hvd246ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc01lbnRpb25BY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc1NlYXJjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzRmlyc3RFbGVtZW50KClcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkhpZGRlbjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpc3QudW5zZWxlY3RBbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9saXN0Lm9wdGlvbihcImZvY3VzZWRFbGVtZW50XCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzTWVudGlvbkFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlYXJjaChudWxsKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZvY3VzU3RhdGVFbmFibGVkOiBmYWxzZVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgX2FjdGl2ZUxpc3RJdGVtcygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3QuaXRlbUVsZW1lbnRzKCkuZmlsdGVyKFwiOm5vdCguXCIuY29uY2F0KERJU0FCTEVEX1NUQVRFX0NMQVNTLCBcIilcIikpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsZWFuKCkge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9tZW50aW9ucykuZm9yRWFjaChtYXJrZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21lbnRpb25zW21hcmtlcl0udGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBNZW50aW9uLnJlbW92ZVRlbXBsYXRlKG1hcmtlcilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgTWVudGlvbk1vZHVsZTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/modules/mentions.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/modules/popup.js":
/*!*********************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/modules/popup.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_utils_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/utils/size */ \"./node_modules/devextreme/esm/core/utils/size.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _core_utils_window__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/utils/window */ \"./node_modules/devextreme/esm/core/utils/window.js\");\n/* harmony import */ var _events_core_events_engine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../events/core/events_engine */ \"./node_modules/devextreme/esm/events/core/events_engine.js\");\n/* harmony import */ var _events_utils_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../events/utils/index */ \"./node_modules/devextreme/esm/events/utils/index.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base */ \"./node_modules/devextreme/esm/ui/html_editor/modules/base.js\");\n/* harmony import */ var _popup__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../popup */ \"./node_modules/devextreme/esm/ui/popup.js\");\n/* harmony import */ var _list_light__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../list_light */ \"./node_modules/devextreme/esm/ui/list_light.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/modules/popup.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar MODULE_NAMESPACE = \"dxHtmlEditorPopupModule\";\r\nvar ListPopupModule = _base__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_1___default.a) {\r\n    var SUGGESTION_LIST_CLASS = \"dx-suggestion-list\";\r\n    var SUGGESTION_LIST_WRAPPER_CLASS = \"dx-suggestion-list-wrapper\";\r\n    var MIN_HEIGHT = 100;\r\n    ListPopupModule = class extends _base__WEBPACK_IMPORTED_MODULE_7__[\"default\"] {\r\n        _getDefaultOptions() {\r\n            return {\r\n                dataSource: null\r\n            }\r\n        }\r\n        constructor(quill, options) {\r\n            super(quill, options);\r\n            this.options = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_3__[\"extend\"])({}, this._getDefaultOptions(), options);\r\n            this._popup = this.renderPopup();\r\n            this._popup.$wrapper().addClass(SUGGESTION_LIST_WRAPPER_CLASS);\r\n            this._renderPreventFocusOut()\r\n        }\r\n        renderList($container, options) {\r\n            var $list = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"<div>\").addClass(SUGGESTION_LIST_CLASS).appendTo($container);\r\n            this._list = this.options.editorInstance._createComponent($list, _list_light__WEBPACK_IMPORTED_MODULE_9__[\"default\"], options)\r\n        }\r\n        renderPopup() {\r\n            var editorInstance = this.options.editorInstance;\r\n            var $container = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"<div>\").appendTo(editorInstance.$element());\r\n            var popupConfig = this._getPopupConfig();\r\n            return editorInstance._createComponent($container, _popup__WEBPACK_IMPORTED_MODULE_8__[\"default\"], popupConfig)\r\n        }\r\n        _getPopupConfig() {\r\n            return {\r\n                contentTemplate: contentElem => {\r\n                    var listConfig = this._getListConfig(this.options);\r\n                    this.renderList(Object(_core_renderer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(contentElem), listConfig)\r\n                },\r\n                deferRendering: false,\r\n                onShown: () => {\r\n                    this._list.focus()\r\n                },\r\n                onHidden: () => {\r\n                    this._list.unselectAll();\r\n                    this._list.option(\"focusedElement\", null)\r\n                },\r\n                showTitle: false,\r\n                width: \"auto\",\r\n                height: \"auto\",\r\n                shading: false,\r\n                hideOnParentScroll: true,\r\n                closeOnOutsideClick: true,\r\n                animation: {\r\n                    show: {\r\n                        type: \"fade\",\r\n                        duration: 0,\r\n                        from: 0,\r\n                        to: 1\r\n                    },\r\n                    hide: {\r\n                        type: \"fade\",\r\n                        duration: 400,\r\n                        from: 1,\r\n                        to: 0\r\n                    }\r\n                },\r\n                fullScreen: false,\r\n                maxHeight: this.maxHeight\r\n            }\r\n        }\r\n        _getListConfig(options) {\r\n            return {\r\n                dataSource: options.dataSource,\r\n                onSelectionChanged: this.selectionChangedHandler.bind(this),\r\n                selectionMode: \"single\",\r\n                pageLoadMode: \"scrollBottom\"\r\n            }\r\n        }\r\n        get maxHeight() {\r\n            var window = Object(_core_utils_window__WEBPACK_IMPORTED_MODULE_4__[\"getWindow\"])();\r\n            var windowHeight = window && Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getHeight\"])(window) || 0;\r\n            return Math.max(MIN_HEIGHT, .5 * windowHeight)\r\n        }\r\n        selectionChangedHandler(e) {\r\n            if (this._popup.option(\"visible\")) {\r\n                this._popup.hide();\r\n                this.insertEmbedContent(e)\r\n            }\r\n        }\r\n        _renderPreventFocusOut() {\r\n            var eventName = Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_6__[\"addNamespace\"])(\"mousedown\", MODULE_NAMESPACE);\r\n            _events_core_events_engine__WEBPACK_IMPORTED_MODULE_5__[\"default\"].on(this._popup.$wrapper(), eventName, e => {\r\n                e.preventDefault()\r\n            })\r\n        }\r\n        insertEmbedContent(selectionChangedEvent) {}\r\n        showPopup() {\r\n            this._popup && this._popup.show()\r\n        }\r\n        savePosition(position) {\r\n            this.caretPosition = position\r\n        }\r\n        getPosition() {\r\n            return this.caretPosition\r\n        }\r\n    }\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ListPopupModule);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy9wb3B1cC5qcz85MWU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHa0M7QUFDRztBQUNFO0FBR0g7QUFHQTtBQUMwQjtBQUd6QjtBQUNMO0FBQ0E7QUFDSTtBQUNwQztBQUNBLHNCQUFzQiw2Q0FBVTtBQUNoQyxJQUFJLHVEQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZDQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFNLEdBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4REFBQztBQUN6Qiw2RUFBNkUsbURBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhEQUFDO0FBQzlCO0FBQ0EsK0RBQStELDhDQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOERBQUM7QUFDckMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvRUFBUztBQUNsQyx5Q0FBeUMsa0VBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdFQUFZO0FBQ3hDLFlBQVksa0VBQVk7QUFDeEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSw4RUFBZSxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3VpL2h0bWxfZWRpdG9yL21vZHVsZXMvcG9wdXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3VpL2h0bWxfZWRpdG9yL21vZHVsZXMvcG9wdXAuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCB7XHJcbiAgICBnZXRIZWlnaHRcclxufSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlscy9zaXplXCI7XHJcbmltcG9ydCBRdWlsbCBmcm9tIFwiZGV2ZXh0cmVtZS1xdWlsbFwiO1xyXG5pbXBvcnQgJCBmcm9tIFwiLi4vLi4vLi4vY29yZS9yZW5kZXJlclwiO1xyXG5pbXBvcnQge1xyXG4gICAgZXh0ZW5kXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvZXh0ZW5kXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRXaW5kb3dcclxufSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlscy93aW5kb3dcIjtcclxuaW1wb3J0IGV2ZW50c0VuZ2luZSBmcm9tIFwiLi4vLi4vLi4vZXZlbnRzL2NvcmUvZXZlbnRzX2VuZ2luZVwiO1xyXG5pbXBvcnQge1xyXG4gICAgYWRkTmFtZXNwYWNlXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2V2ZW50cy91dGlscy9pbmRleFwiO1xyXG5pbXBvcnQgQmFzZU1vZHVsZSBmcm9tIFwiLi9iYXNlXCI7XHJcbmltcG9ydCBQb3B1cCBmcm9tIFwiLi4vLi4vcG9wdXBcIjtcclxuaW1wb3J0IExpc3QgZnJvbSBcIi4uLy4uL2xpc3RfbGlnaHRcIjtcclxudmFyIE1PRFVMRV9OQU1FU1BBQ0UgPSBcImR4SHRtbEVkaXRvclBvcHVwTW9kdWxlXCI7XHJcbnZhciBMaXN0UG9wdXBNb2R1bGUgPSBCYXNlTW9kdWxlO1xyXG5pZiAoUXVpbGwpIHtcclxuICAgIHZhciBTVUdHRVNUSU9OX0xJU1RfQ0xBU1MgPSBcImR4LXN1Z2dlc3Rpb24tbGlzdFwiO1xyXG4gICAgdmFyIFNVR0dFU1RJT05fTElTVF9XUkFQUEVSX0NMQVNTID0gXCJkeC1zdWdnZXN0aW9uLWxpc3Qtd3JhcHBlclwiO1xyXG4gICAgdmFyIE1JTl9IRUlHSFQgPSAxMDA7XHJcbiAgICBMaXN0UG9wdXBNb2R1bGUgPSBjbGFzcyBleHRlbmRzIEJhc2VNb2R1bGUge1xyXG4gICAgICAgIF9nZXREZWZhdWx0T3B0aW9ucygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2U6IG51bGxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdHJ1Y3RvcihxdWlsbCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBzdXBlcihxdWlsbCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgdGhpcy5fZ2V0RGVmYXVsdE9wdGlvbnMoKSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwID0gdGhpcy5yZW5kZXJQb3B1cCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9wb3B1cC4kd3JhcHBlcigpLmFkZENsYXNzKFNVR0dFU1RJT05fTElTVF9XUkFQUEVSX0NMQVNTKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyUHJldmVudEZvY3VzT3V0KClcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyTGlzdCgkY29udGFpbmVyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciAkbGlzdCA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhTVUdHRVNUSU9OX0xJU1RfQ0xBU1MpLmFwcGVuZFRvKCRjb250YWluZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0ID0gdGhpcy5vcHRpb25zLmVkaXRvckluc3RhbmNlLl9jcmVhdGVDb21wb25lbnQoJGxpc3QsIExpc3QsIG9wdGlvbnMpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlclBvcHVwKCkge1xyXG4gICAgICAgICAgICB2YXIgZWRpdG9ySW5zdGFuY2UgPSB0aGlzLm9wdGlvbnMuZWRpdG9ySW5zdGFuY2U7XHJcbiAgICAgICAgICAgIHZhciAkY29udGFpbmVyID0gJChcIjxkaXY+XCIpLmFwcGVuZFRvKGVkaXRvckluc3RhbmNlLiRlbGVtZW50KCkpO1xyXG4gICAgICAgICAgICB2YXIgcG9wdXBDb25maWcgPSB0aGlzLl9nZXRQb3B1cENvbmZpZygpO1xyXG4gICAgICAgICAgICByZXR1cm4gZWRpdG9ySW5zdGFuY2UuX2NyZWF0ZUNvbXBvbmVudCgkY29udGFpbmVyLCBQb3B1cCwgcG9wdXBDb25maWcpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9nZXRQb3B1cENvbmZpZygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUZW1wbGF0ZTogY29udGVudEVsZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0Q29uZmlnID0gdGhpcy5fZ2V0TGlzdENvbmZpZyh0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGlzdCgkKGNvbnRlbnRFbGVtKSwgbGlzdENvbmZpZylcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkZWZlclJlbmRlcmluZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBvblNob3duOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGlzdC5mb2N1cygpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25IaWRkZW46ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9saXN0LnVuc2VsZWN0QWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGlzdC5vcHRpb24oXCJmb2N1c2VkRWxlbWVudFwiLCBudWxsKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNob3dUaXRsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgc2hhZGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBoaWRlT25QYXJlbnRTY3JvbGw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjbG9zZU9uT3V0c2lkZUNsaWNrOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZhZGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAxXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBoaWRlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmFkZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogNDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogMFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdWxsU2NyZWVuOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogdGhpcy5tYXhIZWlnaHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfZ2V0TGlzdENvbmZpZyhvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlOiBvcHRpb25zLmRhdGFTb3VyY2UsXHJcbiAgICAgICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZWQ6IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZEhhbmRsZXIuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IFwic2luZ2xlXCIsXHJcbiAgICAgICAgICAgICAgICBwYWdlTG9hZE1vZGU6IFwic2Nyb2xsQm90dG9tXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgbWF4SGVpZ2h0KCkge1xyXG4gICAgICAgICAgICB2YXIgd2luZG93ID0gZ2V0V2luZG93KCk7XHJcbiAgICAgICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cgJiYgZ2V0SGVpZ2h0KHdpbmRvdykgfHwgMDtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1JTl9IRUlHSFQsIC41ICogd2luZG93SGVpZ2h0KVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxlY3Rpb25DaGFuZ2VkSGFuZGxlcihlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wb3B1cC5vcHRpb24oXCJ2aXNpYmxlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3B1cC5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydEVtYmVkQ29udGVudChlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yZW5kZXJQcmV2ZW50Rm9jdXNPdXQoKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBhZGROYW1lc3BhY2UoXCJtb3VzZWRvd25cIiwgTU9EVUxFX05BTUVTUEFDRSk7XHJcbiAgICAgICAgICAgIGV2ZW50c0VuZ2luZS5vbih0aGlzLl9wb3B1cC4kd3JhcHBlcigpLCBldmVudE5hbWUsIGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc2VydEVtYmVkQ29udGVudChzZWxlY3Rpb25DaGFuZ2VkRXZlbnQpIHt9XHJcbiAgICAgICAgc2hvd1BvcHVwKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5zaG93KClcclxuICAgICAgICB9XHJcbiAgICAgICAgc2F2ZVBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FyZXRQb3NpdGlvbiA9IHBvc2l0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldFBvc2l0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYXJldFBvc2l0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IExpc3RQb3B1cE1vZHVsZTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/modules/popup.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/modules/resizing.js":
/*!************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/modules/resizing.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ResizingModule; });\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/* harmony import */ var _events_core_events_engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../events/core/events_engine */ \"./node_modules/devextreme/esm/events/core/events_engine.js\");\n/* harmony import */ var _events_click__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../events/click */ \"./node_modules/devextreme/esm/events/click.js\");\n/* harmony import */ var _events_utils_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../events/utils/index */ \"./node_modules/devextreme/esm/events/utils/index.js\");\n/* harmony import */ var _animation_translator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../animation/translator */ \"./node_modules/devextreme/esm/animation/translator.js\");\n/* harmony import */ var _core_devices__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/devices */ \"./node_modules/devextreme/esm/core/devices.js\");\n/* harmony import */ var _resizable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../resizable */ \"./node_modules/devextreme/esm/ui/resizable.js\");\n/* harmony import */ var _core_utils_position__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/utils/position */ \"./node_modules/devextreme/esm/core/utils/position.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./base */ \"./node_modules/devextreme/esm/ui/html_editor/modules/base.js\");\n/* harmony import */ var _core_utils_size__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../core/utils/size */ \"./node_modules/devextreme/esm/core/utils/size.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/modules/resizing.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar DX_RESIZE_FRAME_CLASS = \"dx-resize-frame\";\r\nvar DX_TOUCH_DEVICE_CLASS = \"dx-touch-device\";\r\nvar MODULE_NAMESPACE = \"dxHtmlResizingModule\";\r\nvar KEYDOWN_EVENT = Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_3__[\"addNamespace\"])(\"keydown\", MODULE_NAMESPACE);\r\nvar SCROLL_EVENT = Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_3__[\"addNamespace\"])(\"scroll\", MODULE_NAMESPACE);\r\nvar MOUSEDOWN_EVENT = Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_3__[\"addNamespace\"])(\"mousedown\", MODULE_NAMESPACE);\r\nvar FRAME_PADDING = 1;\r\nclass ResizingModule extends _base__WEBPACK_IMPORTED_MODULE_9__[\"default\"] {\r\n    constructor(quill, options) {\r\n        super(quill, options);\r\n        this.allowedTargets = options.allowedTargets || [\"image\"];\r\n        this.enabled = !!options.enabled;\r\n        this._hideFrameWithContext = this.hideFrame.bind(this);\r\n        this._framePositionChangedHandler = this._prepareFramePositionChangedHandler();\r\n        if (this.enabled) {\r\n            this._attachEvents();\r\n            this._createResizeFrame()\r\n        }\r\n    }\r\n    _attachEvents() {\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_1__[\"default\"].on(this.quill.root, Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_3__[\"addNamespace\"])(_events_click__WEBPACK_IMPORTED_MODULE_2__[\"name\"], MODULE_NAMESPACE), this._clickHandler.bind(this));\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_1__[\"default\"].on(this.quill.root, SCROLL_EVENT, this._framePositionChangedHandler);\r\n        this.editorInstance.on(\"focusOut\", this._hideFrameWithContext);\r\n        this.quill.on(\"text-change\", this._framePositionChangedHandler)\r\n    }\r\n    _detachEvents() {\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_1__[\"default\"].off(this.quill.root, MODULE_NAMESPACE);\r\n        this.editorInstance.off(\"focusOut\", this._hideFrameWithContext);\r\n        this.quill.off(\"text-change\", this._framePositionChangedHandler)\r\n    }\r\n    _clickHandler(e) {\r\n        if (this._isAllowedTarget(e.target)) {\r\n            if (this._$target === e.target) {\r\n                return\r\n            }\r\n            this._$target = e.target;\r\n            var $target = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this._$target);\r\n            var minWidth = Math.max(Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_10__[\"getOuterWidth\"])($target) - Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_10__[\"getWidth\"])($target), this.resizable.option(\"minWidth\"));\r\n            var minHeight = Math.max(Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_10__[\"getOuterHeight\"])($target) - Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_10__[\"getHeight\"])($target), this.resizable.option(\"minHeight\"));\r\n            this.resizable.option({\r\n                minWidth: minWidth,\r\n                minHeight: minHeight\r\n            });\r\n            this.updateFramePosition();\r\n            this.showFrame();\r\n            this._adjustSelection()\r\n        } else if (this._$target) {\r\n            this.hideFrame()\r\n        }\r\n    }\r\n    _prepareFramePositionChangedHandler(e) {\r\n        return () => {\r\n            if (this._$target) {\r\n                this.updateFramePosition()\r\n            }\r\n        }\r\n    }\r\n    _adjustSelection() {\r\n        if (!this.quill.getSelection()) {\r\n            this.quill.setSelection(0, 0)\r\n        }\r\n    }\r\n    _isAllowedTarget(targetElement) {\r\n        return this._isImage(targetElement)\r\n    }\r\n    _isImage(targetElement) {\r\n        return -1 !== this.allowedTargets.indexOf(\"image\") && \"IMG\" === targetElement.tagName.toUpperCase()\r\n    }\r\n    showFrame() {\r\n        this._$resizeFrame.show();\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_1__[\"default\"].on(this.quill.root, KEYDOWN_EVENT, this._handleFrameKeyDown.bind(this))\r\n    }\r\n    _handleFrameKeyDown(e) {\r\n        var keyName = Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_3__[\"normalizeKeyName\"])(e);\r\n        if (\"del\" === keyName || \"backspace\" === keyName) {\r\n            this._deleteImage()\r\n        }\r\n        this.hideFrame()\r\n    }\r\n    hideFrame() {\r\n        this._$target = null;\r\n        this._$resizeFrame.hide();\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_1__[\"default\"].off(this.quill.root, KEYDOWN_EVENT)\r\n    }\r\n    updateFramePosition() {\r\n        var {\r\n            height: height,\r\n            width: width,\r\n            top: targetTop,\r\n            left: targetLeft\r\n        } = Object(_core_utils_position__WEBPACK_IMPORTED_MODULE_7__[\"getBoundingRect\"])(this._$target);\r\n        var {\r\n            top: containerTop,\r\n            left: containerLeft\r\n        } = Object(_core_utils_position__WEBPACK_IMPORTED_MODULE_7__[\"getBoundingRect\"])(this.quill.root);\r\n        var borderWidth = this._getBorderWidth();\r\n        this._$resizeFrame.css({\r\n            height: height,\r\n            width: width,\r\n            padding: FRAME_PADDING,\r\n            top: targetTop - containerTop - borderWidth - FRAME_PADDING,\r\n            left: targetLeft - containerLeft - borderWidth - FRAME_PADDING\r\n        });\r\n        Object(_animation_translator__WEBPACK_IMPORTED_MODULE_4__[\"move\"])(this._$resizeFrame, {\r\n            left: 0,\r\n            top: 0\r\n        })\r\n    }\r\n    _getBorderWidth() {\r\n        return parseInt(this._$resizeFrame.css(\"borderTopWidth\"))\r\n    }\r\n    _createResizeFrame() {\r\n        if (this._$resizeFrame) {\r\n            return\r\n        }\r\n        var {\r\n            deviceType: deviceType\r\n        } = _core_devices__WEBPACK_IMPORTED_MODULE_5__[\"default\"].current();\r\n        this._$resizeFrame = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\").addClass(DX_RESIZE_FRAME_CLASS).toggleClass(DX_TOUCH_DEVICE_CLASS, \"desktop\" !== deviceType).appendTo(this.editorInstance._getQuillContainer()).hide();\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_1__[\"default\"].on(this._$resizeFrame, MOUSEDOWN_EVENT, e => {\r\n            e.preventDefault()\r\n        });\r\n        this.resizable = this.editorInstance._createComponent(this._$resizeFrame, _resizable__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\r\n            _keepAspectRatio: true,\r\n            onResize: e => {\r\n                if (!this._$target) {\r\n                    return\r\n                }\r\n                Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this._$target).attr({\r\n                    height: e.height,\r\n                    width: e.width\r\n                });\r\n                this.updateFramePosition()\r\n            }\r\n        })\r\n    }\r\n    _deleteImage() {\r\n        if (this._isAllowedTarget(this._$target)) {\r\n            var _Quill$find;\r\n            null === (_Quill$find = devextreme_quill__WEBPACK_IMPORTED_MODULE_8___default.a.find(this._$target)) || void 0 === _Quill$find ? void 0 : _Quill$find.deleteAt(0)\r\n        }\r\n    }\r\n    option(option, value) {\r\n        if (\"mediaResizing\" === option) {\r\n            this.handleOptionChangeValue(value);\r\n            return\r\n        }\r\n        if (\"enabled\" === option) {\r\n            this.enabled = value;\r\n            value ? this._attachEvents() : this._detachEvents()\r\n        } else if (\"allowedTargets\" === option && Array.isArray(value)) {\r\n            this.allowedTargets = value\r\n        }\r\n    }\r\n    clean() {\r\n        this._detachEvents();\r\n        this._$resizeFrame.remove();\r\n        this._$resizeFrame = void 0\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy9yZXNpemluZy5qcz9mNTViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VDO0FBQ3VCO0FBRy9CO0FBSU07QUFHRTtBQUNLO0FBQ0o7QUFHRjtBQUNEO0FBQ0w7QUFNRTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0VBQVk7QUFDaEMsbUJBQW1CLHdFQUFZO0FBQy9CLHNCQUFzQix3RUFBWTtBQUNsQztBQUNlLDZCQUE2Qiw2Q0FBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFZLHFCQUFxQix3RUFBWSxDQUFDLGtEQUFVO0FBQ2hFLFFBQVEsa0VBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4REFBQztBQUMzQixvQ0FBb0MsdUVBQWEsWUFBWSxrRUFBUTtBQUNyRSxxQ0FBcUMsd0VBQWMsWUFBWSxtRUFBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFZO0FBQ3BCO0FBQ0E7QUFDQSxzQkFBc0IsNEVBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLDRFQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyw0RUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRLGtFQUFJO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyxxREFBTztBQUNuQiw2QkFBNkIsOERBQUM7QUFDOUIsUUFBUSxrRUFBWTtBQUNwQjtBQUNBLFNBQVM7QUFDVCxrRkFBa0Ysa0RBQVM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBQztBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdURBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3VpL2h0bWxfZWRpdG9yL21vZHVsZXMvcmVzaXppbmcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3VpL2h0bWxfZWRpdG9yL21vZHVsZXMvcmVzaXppbmcuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCAkIGZyb20gXCIuLi8uLi8uLi9jb3JlL3JlbmRlcmVyXCI7XHJcbmltcG9ydCBldmVudHNFbmdpbmUgZnJvbSBcIi4uLy4uLy4uL2V2ZW50cy9jb3JlL2V2ZW50c19lbmdpbmVcIjtcclxuaW1wb3J0IHtcclxuICAgIG5hbWUgYXMgQ2xpY2tFdmVudFxyXG59IGZyb20gXCIuLi8uLi8uLi9ldmVudHMvY2xpY2tcIjtcclxuaW1wb3J0IHtcclxuICAgIGFkZE5hbWVzcGFjZSxcclxuICAgIG5vcm1hbGl6ZUtleU5hbWVcclxufSBmcm9tIFwiLi4vLi4vLi4vZXZlbnRzL3V0aWxzL2luZGV4XCI7XHJcbmltcG9ydCB7XHJcbiAgICBtb3ZlXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2FuaW1hdGlvbi90cmFuc2xhdG9yXCI7XHJcbmltcG9ydCBkZXZpY2VzIGZyb20gXCIuLi8uLi8uLi9jb3JlL2RldmljZXNcIjtcclxuaW1wb3J0IFJlc2l6YWJsZSBmcm9tIFwiLi4vLi4vcmVzaXphYmxlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRCb3VuZGluZ1JlY3RcclxufSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlscy9wb3NpdGlvblwiO1xyXG5pbXBvcnQgUXVpbGwgZnJvbSBcImRldmV4dHJlbWUtcXVpbGxcIjtcclxuaW1wb3J0IEJhc2VNb2R1bGUgZnJvbSBcIi4vYmFzZVwiO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0SGVpZ2h0LFxyXG4gICAgZ2V0T3V0ZXJIZWlnaHQsXHJcbiAgICBnZXRPdXRlcldpZHRoLFxyXG4gICAgZ2V0V2lkdGhcclxufSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlscy9zaXplXCI7XHJcbnZhciBEWF9SRVNJWkVfRlJBTUVfQ0xBU1MgPSBcImR4LXJlc2l6ZS1mcmFtZVwiO1xyXG52YXIgRFhfVE9VQ0hfREVWSUNFX0NMQVNTID0gXCJkeC10b3VjaC1kZXZpY2VcIjtcclxudmFyIE1PRFVMRV9OQU1FU1BBQ0UgPSBcImR4SHRtbFJlc2l6aW5nTW9kdWxlXCI7XHJcbnZhciBLRVlET1dOX0VWRU5UID0gYWRkTmFtZXNwYWNlKFwia2V5ZG93blwiLCBNT0RVTEVfTkFNRVNQQUNFKTtcclxudmFyIFNDUk9MTF9FVkVOVCA9IGFkZE5hbWVzcGFjZShcInNjcm9sbFwiLCBNT0RVTEVfTkFNRVNQQUNFKTtcclxudmFyIE1PVVNFRE9XTl9FVkVOVCA9IGFkZE5hbWVzcGFjZShcIm1vdXNlZG93blwiLCBNT0RVTEVfTkFNRVNQQUNFKTtcclxudmFyIEZSQU1FX1BBRERJTkcgPSAxO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNpemluZ01vZHVsZSBleHRlbmRzIEJhc2VNb2R1bGUge1xyXG4gICAgY29uc3RydWN0b3IocXVpbGwsIG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihxdWlsbCwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5hbGxvd2VkVGFyZ2V0cyA9IG9wdGlvbnMuYWxsb3dlZFRhcmdldHMgfHwgW1wiaW1hZ2VcIl07XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gISFvcHRpb25zLmVuYWJsZWQ7XHJcbiAgICAgICAgdGhpcy5faGlkZUZyYW1lV2l0aENvbnRleHQgPSB0aGlzLmhpZGVGcmFtZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2ZyYW1lUG9zaXRpb25DaGFuZ2VkSGFuZGxlciA9IHRoaXMuX3ByZXBhcmVGcmFtZVBvc2l0aW9uQ2hhbmdlZEhhbmRsZXIoKTtcclxuICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaEV2ZW50cygpO1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVSZXNpemVGcmFtZSgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2F0dGFjaEV2ZW50cygpIHtcclxuICAgICAgICBldmVudHNFbmdpbmUub24odGhpcy5xdWlsbC5yb290LCBhZGROYW1lc3BhY2UoQ2xpY2tFdmVudCwgTU9EVUxFX05BTUVTUEFDRSksIHRoaXMuX2NsaWNrSGFuZGxlci5iaW5kKHRoaXMpKTtcclxuICAgICAgICBldmVudHNFbmdpbmUub24odGhpcy5xdWlsbC5yb290LCBTQ1JPTExfRVZFTlQsIHRoaXMuX2ZyYW1lUG9zaXRpb25DaGFuZ2VkSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZS5vbihcImZvY3VzT3V0XCIsIHRoaXMuX2hpZGVGcmFtZVdpdGhDb250ZXh0KTtcclxuICAgICAgICB0aGlzLnF1aWxsLm9uKFwidGV4dC1jaGFuZ2VcIiwgdGhpcy5fZnJhbWVQb3NpdGlvbkNoYW5nZWRIYW5kbGVyKVxyXG4gICAgfVxyXG4gICAgX2RldGFjaEV2ZW50cygpIHtcclxuICAgICAgICBldmVudHNFbmdpbmUub2ZmKHRoaXMucXVpbGwucm9vdCwgTU9EVUxFX05BTUVTUEFDRSk7XHJcbiAgICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZS5vZmYoXCJmb2N1c091dFwiLCB0aGlzLl9oaWRlRnJhbWVXaXRoQ29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5xdWlsbC5vZmYoXCJ0ZXh0LWNoYW5nZVwiLCB0aGlzLl9mcmFtZVBvc2l0aW9uQ2hhbmdlZEhhbmRsZXIpXHJcbiAgICB9XHJcbiAgICBfY2xpY2tIYW5kbGVyKGUpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNBbGxvd2VkVGFyZ2V0KGUudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fJHRhcmdldCA9PT0gZS50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuXyR0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgdmFyICR0YXJnZXQgPSAkKHRoaXMuXyR0YXJnZXQpO1xyXG4gICAgICAgICAgICB2YXIgbWluV2lkdGggPSBNYXRoLm1heChnZXRPdXRlcldpZHRoKCR0YXJnZXQpIC0gZ2V0V2lkdGgoJHRhcmdldCksIHRoaXMucmVzaXphYmxlLm9wdGlvbihcIm1pbldpZHRoXCIpKTtcclxuICAgICAgICAgICAgdmFyIG1pbkhlaWdodCA9IE1hdGgubWF4KGdldE91dGVySGVpZ2h0KCR0YXJnZXQpIC0gZ2V0SGVpZ2h0KCR0YXJnZXQpLCB0aGlzLnJlc2l6YWJsZS5vcHRpb24oXCJtaW5IZWlnaHRcIikpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6YWJsZS5vcHRpb24oe1xyXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IG1pbldpZHRoLFxyXG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0OiBtaW5IZWlnaHRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRnJhbWVQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLnNob3dGcmFtZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9hZGp1c3RTZWxlY3Rpb24oKVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fJHRhcmdldCkge1xyXG4gICAgICAgICAgICB0aGlzLmhpZGVGcmFtZSgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVGcmFtZVBvc2l0aW9uQ2hhbmdlZEhhbmRsZXIoZSkge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl8kdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZyYW1lUG9zaXRpb24oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FkanVzdFNlbGVjdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMucXVpbGwuZ2V0U2VsZWN0aW9uKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oMCwgMClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaXNBbGxvd2VkVGFyZ2V0KHRhcmdldEVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNJbWFnZSh0YXJnZXRFbGVtZW50KVxyXG4gICAgfVxyXG4gICAgX2lzSW1hZ2UodGFyZ2V0RWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiAtMSAhPT0gdGhpcy5hbGxvd2VkVGFyZ2V0cy5pbmRleE9mKFwiaW1hZ2VcIikgJiYgXCJJTUdcIiA9PT0gdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKClcclxuICAgIH1cclxuICAgIHNob3dGcmFtZSgpIHtcclxuICAgICAgICB0aGlzLl8kcmVzaXplRnJhbWUuc2hvdygpO1xyXG4gICAgICAgIGV2ZW50c0VuZ2luZS5vbih0aGlzLnF1aWxsLnJvb3QsIEtFWURPV05fRVZFTlQsIHRoaXMuX2hhbmRsZUZyYW1lS2V5RG93bi5iaW5kKHRoaXMpKVxyXG4gICAgfVxyXG4gICAgX2hhbmRsZUZyYW1lS2V5RG93bihlKSB7XHJcbiAgICAgICAgdmFyIGtleU5hbWUgPSBub3JtYWxpemVLZXlOYW1lKGUpO1xyXG4gICAgICAgIGlmIChcImRlbFwiID09PSBrZXlOYW1lIHx8IFwiYmFja3NwYWNlXCIgPT09IGtleU5hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVsZXRlSW1hZ2UoKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhpZGVGcmFtZSgpXHJcbiAgICB9XHJcbiAgICBoaWRlRnJhbWUoKSB7XHJcbiAgICAgICAgdGhpcy5fJHRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fJHJlc2l6ZUZyYW1lLmhpZGUoKTtcclxuICAgICAgICBldmVudHNFbmdpbmUub2ZmKHRoaXMucXVpbGwucm9vdCwgS0VZRE9XTl9FVkVOVClcclxuICAgIH1cclxuICAgIHVwZGF0ZUZyYW1lUG9zaXRpb24oKSB7XHJcbiAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgdG9wOiB0YXJnZXRUb3AsXHJcbiAgICAgICAgICAgIGxlZnQ6IHRhcmdldExlZnRcclxuICAgICAgICB9ID0gZ2V0Qm91bmRpbmdSZWN0KHRoaXMuXyR0YXJnZXQpO1xyXG4gICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgIHRvcDogY29udGFpbmVyVG9wLFxyXG4gICAgICAgICAgICBsZWZ0OiBjb250YWluZXJMZWZ0XHJcbiAgICAgICAgfSA9IGdldEJvdW5kaW5nUmVjdCh0aGlzLnF1aWxsLnJvb3QpO1xyXG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IHRoaXMuX2dldEJvcmRlcldpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5fJHJlc2l6ZUZyYW1lLmNzcyh7XHJcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IEZSQU1FX1BBRERJTkcsXHJcbiAgICAgICAgICAgIHRvcDogdGFyZ2V0VG9wIC0gY29udGFpbmVyVG9wIC0gYm9yZGVyV2lkdGggLSBGUkFNRV9QQURESU5HLFxyXG4gICAgICAgICAgICBsZWZ0OiB0YXJnZXRMZWZ0IC0gY29udGFpbmVyTGVmdCAtIGJvcmRlcldpZHRoIC0gRlJBTUVfUEFERElOR1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1vdmUodGhpcy5fJHJlc2l6ZUZyYW1lLCB7XHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHRvcDogMFxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBfZ2V0Qm9yZGVyV2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuXyRyZXNpemVGcmFtZS5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSlcclxuICAgIH1cclxuICAgIF9jcmVhdGVSZXNpemVGcmFtZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fJHJlc2l6ZUZyYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICBkZXZpY2VUeXBlOiBkZXZpY2VUeXBlXHJcbiAgICAgICAgfSA9IGRldmljZXMuY3VycmVudCgpO1xyXG4gICAgICAgIHRoaXMuXyRyZXNpemVGcmFtZSA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhEWF9SRVNJWkVfRlJBTUVfQ0xBU1MpLnRvZ2dsZUNsYXNzKERYX1RPVUNIX0RFVklDRV9DTEFTUywgXCJkZXNrdG9wXCIgIT09IGRldmljZVR5cGUpLmFwcGVuZFRvKHRoaXMuZWRpdG9ySW5zdGFuY2UuX2dldFF1aWxsQ29udGFpbmVyKCkpLmhpZGUoKTtcclxuICAgICAgICBldmVudHNFbmdpbmUub24odGhpcy5fJHJlc2l6ZUZyYW1lLCBNT1VTRURPV05fRVZFTlQsIGUgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlc2l6YWJsZSA9IHRoaXMuZWRpdG9ySW5zdGFuY2UuX2NyZWF0ZUNvbXBvbmVudCh0aGlzLl8kcmVzaXplRnJhbWUsIFJlc2l6YWJsZSwge1xyXG4gICAgICAgICAgICBfa2VlcEFzcGVjdFJhdGlvOiB0cnVlLFxyXG4gICAgICAgICAgICBvblJlc2l6ZTogZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuXyR0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICQodGhpcy5fJHRhcmdldCkuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBlLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogZS53aWR0aFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZyYW1lUG9zaXRpb24oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuICAgIF9kZWxldGVJbWFnZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNBbGxvd2VkVGFyZ2V0KHRoaXMuXyR0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHZhciBfUXVpbGwkZmluZDtcclxuICAgICAgICAgICAgbnVsbCA9PT0gKF9RdWlsbCRmaW5kID0gUXVpbGwuZmluZCh0aGlzLl8kdGFyZ2V0KSkgfHwgdm9pZCAwID09PSBfUXVpbGwkZmluZCA/IHZvaWQgMCA6IF9RdWlsbCRmaW5kLmRlbGV0ZUF0KDApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb3B0aW9uKG9wdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoXCJtZWRpYVJlc2l6aW5nXCIgPT09IG9wdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZU9wdGlvbkNoYW5nZVZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChcImVuYWJsZWRcIiA9PT0gb3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB2YWx1ZSA/IHRoaXMuX2F0dGFjaEV2ZW50cygpIDogdGhpcy5fZGV0YWNoRXZlbnRzKClcclxuICAgICAgICB9IGVsc2UgaWYgKFwiYWxsb3dlZFRhcmdldHNcIiA9PT0gb3B0aW9uICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWxsb3dlZFRhcmdldHMgPSB2YWx1ZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFuKCkge1xyXG4gICAgICAgIHRoaXMuX2RldGFjaEV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMuXyRyZXNpemVGcmFtZS5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLl8kcmVzaXplRnJhbWUgPSB2b2lkIDBcclxuICAgIH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/modules/resizing.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/modules/tableContextMenu.js":
/*!********************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/modules/tableContextMenu.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ \"./node_modules/devextreme/esm/ui/html_editor/modules/base.js\");\n/* harmony import */ var _events_core_events_engine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../events/core/events_engine */ \"./node_modules/devextreme/esm/events/core/events_engine.js\");\n/* harmony import */ var _events_utils_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../events/utils/index */ \"./node_modules/devextreme/esm/events/utils/index.js\");\n/* harmony import */ var _context_menu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../context_menu */ \"./node_modules/devextreme/esm/ui/context_menu.js\");\n/* harmony import */ var _localization_message__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../localization/message */ \"./node_modules/devextreme/esm/localization/message.js\");\n/* harmony import */ var _utils_table_helper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/table_helper */ \"./node_modules/devextreme/esm/ui/html_editor/utils/table_helper.js\");\n/* harmony import */ var _utils_toolbar_helper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/toolbar_helper */ \"./node_modules/devextreme/esm/ui/html_editor/utils/toolbar_helper.js\");\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_inflector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../core/utils/inflector */ \"./node_modules/devextreme/esm/core/utils/inflector.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/modules/tableContextMenu.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar MODULE_NAMESPACE = \"dxHtmlEditorTableContextMenu\";\r\nvar CONTEXT_MENU_EVENT = Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_4__[\"addNamespace\"])(\"dxcontextmenu\", MODULE_NAMESPACE);\r\nvar TableContextMenuModule = _base__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\r\nvar localize = name => _localization_message__WEBPACK_IMPORTED_MODULE_6__[\"default\"].format(\"dxHtmlEditor-\".concat(Object(_core_utils_inflector__WEBPACK_IMPORTED_MODULE_11__[\"camelize\"])(name)));\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a) {\r\n    TableContextMenuModule = class extends _base__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\r\n        constructor(quill, options) {\r\n            super(quill, options);\r\n            this.enabled = !!options.enabled;\r\n            this._quillContainer = this.editorInstance._getQuillContainer();\r\n            this.addCleanCallback(this.prepareCleanCallback());\r\n            this._formatHandlers = Object(_utils_toolbar_helper__WEBPACK_IMPORTED_MODULE_8__[\"getFormatHandlers\"])(this);\r\n            this._tableFormats = Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_7__[\"getTableFormats\"])(quill);\r\n            if (this.enabled) {\r\n                this._enableContextMenu(options.items)\r\n            }\r\n        }\r\n        _enableContextMenu(items) {\r\n            var _this$_contextMenu;\r\n            null === (_this$_contextMenu = this._contextMenu) || void 0 === _this$_contextMenu ? void 0 : _this$_contextMenu.dispose();\r\n            this._contextMenu = this._createContextMenu(items);\r\n            this._attachEvents()\r\n        }\r\n        _attachEvents() {\r\n            _events_core_events_engine__WEBPACK_IMPORTED_MODULE_3__[\"default\"].on(this.editorInstance._getContent(), CONTEXT_MENU_EVENT, this._prepareContextMenuHandler())\r\n        }\r\n        _detachEvents() {\r\n            _events_core_events_engine__WEBPACK_IMPORTED_MODULE_3__[\"default\"].off(this.editorInstance._getContent(), CONTEXT_MENU_EVENT)\r\n        }\r\n        _createContextMenu(items) {\r\n            var $container = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").appendTo(this.editorInstance.$element());\r\n            var menuConfig = this._getMenuConfig(items);\r\n            return this.editorInstance._createComponent($container, _context_menu__WEBPACK_IMPORTED_MODULE_5__[\"default\"], menuConfig)\r\n        }\r\n        showPropertiesForm() {\r\n            var type = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : \"cell\";\r\n            var $element = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this._targetElement).closest(\"cell\" === type ? \"th, td\" : \"table\");\r\n            this._contextMenu.hide();\r\n            this._formatHandlers[\"\".concat(type, \"Properties\")]($element);\r\n            this._targetElement = null\r\n        }\r\n        _isAcceptableItem(widget, acceptableWidgetName) {\r\n            return !widget || widget === acceptableWidgetName\r\n        }\r\n        _handleObjectItem(item) {\r\n            if (item.name && this._isAcceptableItem(item.widget, \"dxButton\")) {\r\n                var defaultButtonItemConfig = this._prepareMenuItemConfig(item.name);\r\n                var buttonItemConfig = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_12__[\"extend\"])(true, defaultButtonItemConfig, item);\r\n                return buttonItemConfig\r\n            } else if (item.items) {\r\n                item.items = this._prepareMenuItems(item.items);\r\n                return item\r\n            } else {\r\n                return item\r\n            }\r\n        }\r\n        _prepareMenuItemConfig(name) {\r\n            var _ICON_MAP$name, _this$_formatHandlers;\r\n            var iconName = null !== (_ICON_MAP$name = _utils_toolbar_helper__WEBPACK_IMPORTED_MODULE_8__[\"ICON_MAP\"][name]) && void 0 !== _ICON_MAP$name ? _ICON_MAP$name : name;\r\n            var buttonText = Object(_core_utils_inflector__WEBPACK_IMPORTED_MODULE_11__[\"titleize\"])(name);\r\n            return {\r\n                text: localize(buttonText),\r\n                icon: iconName.toLowerCase(),\r\n                onClick: null !== (_this$_formatHandlers = this._formatHandlers[name]) && void 0 !== _this$_formatHandlers ? _this$_formatHandlers : Object(_utils_toolbar_helper__WEBPACK_IMPORTED_MODULE_8__[\"getDefaultClickHandler\"])(this, name)\r\n            }\r\n        }\r\n        _prepareMenuItems(items) {\r\n            var resultItems = [];\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_9__[\"each\"])(items, (_, item) => {\r\n                var newItem;\r\n                if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_10__[\"isObject\"])(item)) {\r\n                    newItem = this._handleObjectItem(item)\r\n                } else if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_10__[\"isString\"])(item)) {\r\n                    newItem = this._prepareMenuItemConfig(item)\r\n                }\r\n                if (newItem) {\r\n                    resultItems.push(newItem)\r\n                }\r\n            });\r\n            return resultItems\r\n        }\r\n        _getMenuConfig(items) {\r\n            var defaultItems = [{\r\n                text: localize(\"insert\"),\r\n                items: [\"insertHeaderRow\", \"insertRowAbove\", \"insertRowBelow\", Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_12__[\"extend\"])(this._prepareMenuItemConfig(\"insertColumnLeft\"), {\r\n                    beginGroup: true\r\n                }), \"insertColumnRight\"]\r\n            }, {\r\n                text: localize(\"delete\"),\r\n                items: [\"deleteColumn\", \"deleteRow\", \"deleteTable\"]\r\n            }, Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_12__[\"extend\"])(this._prepareMenuItemConfig(\"cellProperties\"), {\r\n                onClick: e => {\r\n                    this.showPropertiesForm(\"cell\")\r\n                }\r\n            }), Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_12__[\"extend\"])(this._prepareMenuItemConfig(\"tableProperties\"), {\r\n                onClick: e => {\r\n                    this.showPropertiesForm(\"table\")\r\n                }\r\n            })];\r\n            var customItems = this._prepareMenuItems(null !== items && void 0 !== items && items.length ? items : defaultItems);\r\n            return {\r\n                target: this._quillContainer,\r\n                showEvent: null,\r\n                hideOnParentScroll: false,\r\n                items: customItems\r\n            }\r\n        }\r\n        _prepareContextMenuHandler() {\r\n            return event => {\r\n                if (this._isTableTarget(event.target)) {\r\n                    this._targetElement = event.target;\r\n                    this._setContextMenuPosition(event);\r\n                    this._contextMenu.show();\r\n                    event.preventDefault()\r\n                }\r\n            }\r\n        }\r\n        _setContextMenuPosition(event) {\r\n            var startPosition = this._quillContainer.get(0).getBoundingClientRect();\r\n            this._contextMenu.option({\r\n                position: {\r\n                    my: \"left top\",\r\n                    at: \"left top\",\r\n                    collision: \"fit fit\",\r\n                    offset: {\r\n                        x: event.clientX - startPosition.left,\r\n                        y: event.clientY - startPosition.top\r\n                    }\r\n                }\r\n            })\r\n        }\r\n        _isTableTarget(targetElement) {\r\n            return !!Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(targetElement).closest(\".dx-htmleditor-content td, .dx-htmleditor-content th\").length\r\n        }\r\n        clean() {\r\n            this._detachEvents()\r\n        }\r\n        option(option, value) {\r\n            if (\"tableContextMenu\" === option) {\r\n                this.handleOptionChangeValue(value);\r\n                return\r\n            }\r\n            if (\"enabled\" === option) {\r\n                this.enabled = value;\r\n                value ? this._enableContextMenu() : this.clean()\r\n            } else if (\"items\" === option) {\r\n                var _this$_contextMenu2;\r\n                null === (_this$_contextMenu2 = this._contextMenu) || void 0 === _this$_contextMenu2 ? void 0 : _this$_contextMenu2.dispose();\r\n                this._contextMenu = this._createContextMenu(value)\r\n            }\r\n        }\r\n        prepareCleanCallback() {\r\n            return () => {\r\n                this.clean()\r\n            }\r\n        }\r\n    }\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (TableContextMenuModule);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy90YWJsZUNvbnRleHRNZW51LmpzPzhhNjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUNFO0FBQ1A7QUFDOEI7QUFHekI7QUFDUTtBQUNtQjtBQUdqQztBQUtFO0FBR0s7QUFJSjtBQUlLO0FBR0g7QUFDcEM7QUFDQSx5QkFBeUIsd0VBQVk7QUFDckMsNkJBQTZCLDZDQUFVO0FBQ3ZDLHVCQUF1Qiw2REFBbUIsK0JBQStCLHVFQUFRO0FBQ2pGLElBQUksdURBQUs7QUFDVCwyQ0FBMkMsNkNBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrRUFBaUI7QUFDcEQsaUNBQWlDLDJFQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUFZO0FBQ3hCO0FBQ0E7QUFDQSxZQUFZLGtFQUFZO0FBQ3hCO0FBQ0E7QUFDQSw2QkFBNkIsOERBQUM7QUFDOUI7QUFDQSxvRUFBb0UscURBQVc7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhEQUFDO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtFQUFNO0FBQzdDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw4REFBUTtBQUM5RCw2QkFBNkIsdUVBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0EscUpBQXFKLG9GQUFzQjtBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUVBQUk7QUFDaEI7QUFDQSxvQkFBb0Isa0VBQVE7QUFDNUI7QUFDQSxpQkFBaUIsVUFBVSxrRUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usa0VBQU07QUFDckY7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhLEVBQUUsa0VBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHLGtFQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQiw4REFBQztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UscUZBQXNCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy90YWJsZUNvbnRleHRNZW51LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS91aS9odG1sX2VkaXRvci9tb2R1bGVzL3RhYmxlQ29udGV4dE1lbnUuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCBRdWlsbCBmcm9tIFwiZGV2ZXh0cmVtZS1xdWlsbFwiO1xyXG5pbXBvcnQgJCBmcm9tIFwiLi4vLi4vLi4vY29yZS9yZW5kZXJlclwiO1xyXG5pbXBvcnQgQmFzZU1vZHVsZSBmcm9tIFwiLi9iYXNlXCI7XHJcbmltcG9ydCBldmVudHNFbmdpbmUgZnJvbSBcIi4uLy4uLy4uL2V2ZW50cy9jb3JlL2V2ZW50c19lbmdpbmVcIjtcclxuaW1wb3J0IHtcclxuICAgIGFkZE5hbWVzcGFjZVxyXG59IGZyb20gXCIuLi8uLi8uLi9ldmVudHMvdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IENvbnRleHRNZW51IGZyb20gXCIuLi8uLi9jb250ZXh0X21lbnVcIjtcclxuaW1wb3J0IGxvY2FsaXphdGlvbk1lc3NhZ2UgZnJvbSBcIi4uLy4uLy4uL2xvY2FsaXphdGlvbi9tZXNzYWdlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRUYWJsZUZvcm1hdHNcclxufSBmcm9tIFwiLi4vdXRpbHMvdGFibGVfaGVscGVyXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRGb3JtYXRIYW5kbGVycyxcclxuICAgIGdldERlZmF1bHRDbGlja0hhbmRsZXIsXHJcbiAgICBJQ09OX01BUFxyXG59IGZyb20gXCIuLi91dGlscy90b29sYmFyX2hlbHBlclwiO1xyXG5pbXBvcnQge1xyXG4gICAgZWFjaFxyXG59IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWxzL2l0ZXJhdG9yXCI7XHJcbmltcG9ydCB7XHJcbiAgICBpc1N0cmluZyxcclxuICAgIGlzT2JqZWN0XHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvdHlwZVwiO1xyXG5pbXBvcnQge1xyXG4gICAgdGl0bGVpemUsXHJcbiAgICBjYW1lbGl6ZVxyXG59IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWxzL2luZmxlY3RvclwiO1xyXG5pbXBvcnQge1xyXG4gICAgZXh0ZW5kXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvZXh0ZW5kXCI7XHJcbnZhciBNT0RVTEVfTkFNRVNQQUNFID0gXCJkeEh0bWxFZGl0b3JUYWJsZUNvbnRleHRNZW51XCI7XHJcbnZhciBDT05URVhUX01FTlVfRVZFTlQgPSBhZGROYW1lc3BhY2UoXCJkeGNvbnRleHRtZW51XCIsIE1PRFVMRV9OQU1FU1BBQ0UpO1xyXG52YXIgVGFibGVDb250ZXh0TWVudU1vZHVsZSA9IEJhc2VNb2R1bGU7XHJcbnZhciBsb2NhbGl6ZSA9IG5hbWUgPT4gbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItXCIuY29uY2F0KGNhbWVsaXplKG5hbWUpKSk7XHJcbmlmIChRdWlsbCkge1xyXG4gICAgVGFibGVDb250ZXh0TWVudU1vZHVsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IocXVpbGwsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgc3VwZXIocXVpbGwsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSAhIW9wdGlvbnMuZW5hYmxlZDtcclxuICAgICAgICAgICAgdGhpcy5fcXVpbGxDb250YWluZXIgPSB0aGlzLmVkaXRvckluc3RhbmNlLl9nZXRRdWlsbENvbnRhaW5lcigpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZENsZWFuQ2FsbGJhY2sodGhpcy5wcmVwYXJlQ2xlYW5DYWxsYmFjaygpKTtcclxuICAgICAgICAgICAgdGhpcy5fZm9ybWF0SGFuZGxlcnMgPSBnZXRGb3JtYXRIYW5kbGVycyh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fdGFibGVGb3JtYXRzID0gZ2V0VGFibGVGb3JtYXRzKHF1aWxsKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlQ29udGV4dE1lbnUob3B0aW9ucy5pdGVtcylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfZW5hYmxlQ29udGV4dE1lbnUoaXRlbXMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzJF9jb250ZXh0TWVudTtcclxuICAgICAgICAgICAgbnVsbCA9PT0gKF90aGlzJF9jb250ZXh0TWVudSA9IHRoaXMuX2NvbnRleHRNZW51KSB8fCB2b2lkIDAgPT09IF90aGlzJF9jb250ZXh0TWVudSA/IHZvaWQgMCA6IF90aGlzJF9jb250ZXh0TWVudS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHRNZW51ID0gdGhpcy5fY3JlYXRlQ29udGV4dE1lbnUoaXRlbXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hFdmVudHMoKVxyXG4gICAgICAgIH1cclxuICAgICAgICBfYXR0YWNoRXZlbnRzKCkge1xyXG4gICAgICAgICAgICBldmVudHNFbmdpbmUub24odGhpcy5lZGl0b3JJbnN0YW5jZS5fZ2V0Q29udGVudCgpLCBDT05URVhUX01FTlVfRVZFTlQsIHRoaXMuX3ByZXBhcmVDb250ZXh0TWVudUhhbmRsZXIoKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgX2RldGFjaEV2ZW50cygpIHtcclxuICAgICAgICAgICAgZXZlbnRzRW5naW5lLm9mZih0aGlzLmVkaXRvckluc3RhbmNlLl9nZXRDb250ZW50KCksIENPTlRFWFRfTUVOVV9FVkVOVClcclxuICAgICAgICB9XHJcbiAgICAgICAgX2NyZWF0ZUNvbnRleHRNZW51KGl0ZW1zKSB7XHJcbiAgICAgICAgICAgIHZhciAkY29udGFpbmVyID0gJChcIjxkaXY+XCIpLmFwcGVuZFRvKHRoaXMuZWRpdG9ySW5zdGFuY2UuJGVsZW1lbnQoKSk7XHJcbiAgICAgICAgICAgIHZhciBtZW51Q29uZmlnID0gdGhpcy5fZ2V0TWVudUNvbmZpZyhpdGVtcyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvckluc3RhbmNlLl9jcmVhdGVDb21wb25lbnQoJGNvbnRhaW5lciwgQ29udGV4dE1lbnUsIG1lbnVDb25maWcpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNob3dQcm9wZXJ0aWVzRm9ybSgpIHtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IFwiY2VsbFwiO1xyXG4gICAgICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKHRoaXMuX3RhcmdldEVsZW1lbnQpLmNsb3Nlc3QoXCJjZWxsXCIgPT09IHR5cGUgPyBcInRoLCB0ZFwiIDogXCJ0YWJsZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dE1lbnUuaGlkZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9mb3JtYXRIYW5kbGVyc1tcIlwiLmNvbmNhdCh0eXBlLCBcIlByb3BlcnRpZXNcIildKCRlbGVtZW50KTtcclxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWxlbWVudCA9IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgX2lzQWNjZXB0YWJsZUl0ZW0od2lkZ2V0LCBhY2NlcHRhYmxlV2lkZ2V0TmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gIXdpZGdldCB8fCB3aWRnZXQgPT09IGFjY2VwdGFibGVXaWRnZXROYW1lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9oYW5kbGVPYmplY3RJdGVtKGl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZSAmJiB0aGlzLl9pc0FjY2VwdGFibGVJdGVtKGl0ZW0ud2lkZ2V0LCBcImR4QnV0dG9uXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdEJ1dHRvbkl0ZW1Db25maWcgPSB0aGlzLl9wcmVwYXJlTWVudUl0ZW1Db25maWcoaXRlbS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHZhciBidXR0b25JdGVtQ29uZmlnID0gZXh0ZW5kKHRydWUsIGRlZmF1bHRCdXR0b25JdGVtQ29uZmlnLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidXR0b25JdGVtQ29uZmlnXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5pdGVtcykge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5pdGVtcyA9IHRoaXMuX3ByZXBhcmVNZW51SXRlbXMoaXRlbS5pdGVtcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfcHJlcGFyZU1lbnVJdGVtQ29uZmlnKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIF9JQ09OX01BUCRuYW1lLCBfdGhpcyRfZm9ybWF0SGFuZGxlcnM7XHJcbiAgICAgICAgICAgIHZhciBpY29uTmFtZSA9IG51bGwgIT09IChfSUNPTl9NQVAkbmFtZSA9IElDT05fTUFQW25hbWVdKSAmJiB2b2lkIDAgIT09IF9JQ09OX01BUCRuYW1lID8gX0lDT05fTUFQJG5hbWUgOiBuYW1lO1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9uVGV4dCA9IHRpdGxlaXplKG5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogbG9jYWxpemUoYnV0dG9uVGV4dCksXHJcbiAgICAgICAgICAgICAgICBpY29uOiBpY29uTmFtZS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgICAgICAgICAgb25DbGljazogbnVsbCAhPT0gKF90aGlzJF9mb3JtYXRIYW5kbGVycyA9IHRoaXMuX2Zvcm1hdEhhbmRsZXJzW25hbWVdKSAmJiB2b2lkIDAgIT09IF90aGlzJF9mb3JtYXRIYW5kbGVycyA/IF90aGlzJF9mb3JtYXRIYW5kbGVycyA6IGdldERlZmF1bHRDbGlja0hhbmRsZXIodGhpcywgbmFtZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfcHJlcGFyZU1lbnVJdGVtcyhpdGVtcykge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0SXRlbXMgPSBbXTtcclxuICAgICAgICAgICAgZWFjaChpdGVtcywgKF8sIGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdJdGVtO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SXRlbSA9IHRoaXMuX2hhbmRsZU9iamVjdEl0ZW0oaXRlbSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoaXRlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJdGVtID0gdGhpcy5fcHJlcGFyZU1lbnVJdGVtQ29uZmlnKGl0ZW0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3SXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEl0ZW1zLnB1c2gobmV3SXRlbSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRJdGVtc1xyXG4gICAgICAgIH1cclxuICAgICAgICBfZ2V0TWVudUNvbmZpZyhpdGVtcykge1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdEl0ZW1zID0gW3tcclxuICAgICAgICAgICAgICAgIHRleHQ6IGxvY2FsaXplKFwiaW5zZXJ0XCIpLFxyXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtcImluc2VydEhlYWRlclJvd1wiLCBcImluc2VydFJvd0Fib3ZlXCIsIFwiaW5zZXJ0Um93QmVsb3dcIiwgZXh0ZW5kKHRoaXMuX3ByZXBhcmVNZW51SXRlbUNvbmZpZyhcImluc2VydENvbHVtbkxlZnRcIiksIHtcclxuICAgICAgICAgICAgICAgICAgICBiZWdpbkdyb3VwOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KSwgXCJpbnNlcnRDb2x1bW5SaWdodFwiXVxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBsb2NhbGl6ZShcImRlbGV0ZVwiKSxcclxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbXCJkZWxldGVDb2x1bW5cIiwgXCJkZWxldGVSb3dcIiwgXCJkZWxldGVUYWJsZVwiXVxyXG4gICAgICAgICAgICB9LCBleHRlbmQodGhpcy5fcHJlcGFyZU1lbnVJdGVtQ29uZmlnKFwiY2VsbFByb3BlcnRpZXNcIiksIHtcclxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Byb3BlcnRpZXNGb3JtKFwiY2VsbFwiKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSwgZXh0ZW5kKHRoaXMuX3ByZXBhcmVNZW51SXRlbUNvbmZpZyhcInRhYmxlUHJvcGVydGllc1wiKSwge1xyXG4gICAgICAgICAgICAgICAgb25DbGljazogZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93UHJvcGVydGllc0Zvcm0oXCJ0YWJsZVwiKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgIHZhciBjdXN0b21JdGVtcyA9IHRoaXMuX3ByZXBhcmVNZW51SXRlbXMobnVsbCAhPT0gaXRlbXMgJiYgdm9pZCAwICE9PSBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPyBpdGVtcyA6IGRlZmF1bHRJdGVtcyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuX3F1aWxsQ29udGFpbmVyLFxyXG4gICAgICAgICAgICAgICAgc2hvd0V2ZW50OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgaGlkZU9uUGFyZW50U2Nyb2xsOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGl0ZW1zOiBjdXN0b21JdGVtc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9wcmVwYXJlQ29udGV4dE1lbnVIYW5kbGVyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGFibGVUYXJnZXQoZXZlbnQudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsZW1lbnQgPSBldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29udGV4dE1lbnVQb3NpdGlvbihldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dE1lbnUuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfc2V0Q29udGV4dE1lbnVQb3NpdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHRoaXMuX3F1aWxsQ29udGFpbmVyLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dE1lbnUub3B0aW9uKHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXk6IFwibGVmdCB0b3BcIixcclxuICAgICAgICAgICAgICAgICAgICBhdDogXCJsZWZ0IHRvcFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbjogXCJmaXQgZml0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFggLSBzdGFydFBvc2l0aW9uLmxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSBzdGFydFBvc2l0aW9uLnRvcFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgX2lzVGFibGVUYXJnZXQodGFyZ2V0RWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISEkKHRhcmdldEVsZW1lbnQpLmNsb3Nlc3QoXCIuZHgtaHRtbGVkaXRvci1jb250ZW50IHRkLCAuZHgtaHRtbGVkaXRvci1jb250ZW50IHRoXCIpLmxlbmd0aFxyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhbigpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGV0YWNoRXZlbnRzKClcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0aW9uKG9wdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKFwidGFibGVDb250ZXh0TWVudVwiID09PSBvcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlT3B0aW9uQ2hhbmdlVmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFwiZW5hYmxlZFwiID09PSBvcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPyB0aGlzLl9lbmFibGVDb250ZXh0TWVudSgpIDogdGhpcy5jbGVhbigpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJpdGVtc1wiID09PSBvcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfY29udGV4dE1lbnUyO1xyXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gKF90aGlzJF9jb250ZXh0TWVudTIgPSB0aGlzLl9jb250ZXh0TWVudSkgfHwgdm9pZCAwID09PSBfdGhpcyRfY29udGV4dE1lbnUyID8gdm9pZCAwIDogX3RoaXMkX2NvbnRleHRNZW51Mi5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0TWVudSA9IHRoaXMuX2NyZWF0ZUNvbnRleHRNZW51KHZhbHVlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXBhcmVDbGVhbkNhbGxiYWNrKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbigpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgVGFibGVDb250ZXh0TWVudU1vZHVsZTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/modules/tableContextMenu.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/modules/tableResizing.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/modules/tableResizing.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TableResizingModule; });\n/* harmony import */ var _core_utils_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/utils/size */ \"./node_modules/devextreme/esm/core/utils/size.js\");\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/* harmony import */ var _events_core_events_engine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../events/core/events_engine */ \"./node_modules/devextreme/esm/events/core/events_engine.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _events_utils_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../events/utils/index */ \"./node_modules/devextreme/esm/events/utils/index.js\");\n/* harmony import */ var _core_utils_resize_callbacks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/utils/resize_callbacks */ \"./node_modules/devextreme/esm/core/utils/resize_callbacks.js\");\n/* harmony import */ var _animation_translator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../animation/translator */ \"./node_modules/devextreme/esm/animation/translator.js\");\n/* harmony import */ var _core_utils_position__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/utils/position */ \"./node_modules/devextreme/esm/core/utils/position.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./base */ \"./node_modules/devextreme/esm/ui/html_editor/modules/base.js\");\n/* harmony import */ var _draggable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../draggable */ \"./node_modules/devextreme/esm/ui/draggable.js\");\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/* harmony import */ var _core_utils_window__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../core/utils/window */ \"./node_modules/devextreme/esm/core/utils/window.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _utils_table_helper__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/table_helper */ \"./node_modules/devextreme/esm/ui/html_editor/utils/table_helper.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/modules/tableResizing.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar DX_COLUMN_RESIZE_FRAME_CLASS = \"dx-table-resize-frame\";\r\nvar DX_COLUMN_RESIZER_CLASS = \"dx-htmleditor-column-resizer\";\r\nvar DX_ROW_RESIZER_CLASS = \"dx-htmleditor-row-resizer\";\r\nvar DEFAULTS = {\r\n    minColumnWidth: 40,\r\n    minRowHeight: 24\r\n};\r\nvar DRAGGABLE_ELEMENT_OFFSET = 2;\r\nvar ROUGH_OFFSET = 3;\r\nvar MODULE_NAMESPACE = \"dxHtmlTableResizingModule\";\r\nvar POINTERDOWN_EVENT = Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_4__[\"addNamespace\"])(\"dxpointerdown\", MODULE_NAMESPACE);\r\nvar SCROLL_EVENT = Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_4__[\"addNamespace\"])(\"scroll\", MODULE_NAMESPACE);\r\nclass TableResizingModule extends _base__WEBPACK_IMPORTED_MODULE_8__[\"default\"] {\r\n    constructor(quill, options) {\r\n        super(quill, options);\r\n        this.enabled = !!options.enabled;\r\n        this._tableResizeFrames = [];\r\n        this._minColumnWidth = this._minSizeLimit(\"minColumnWidth\", options.minColumnWidth);\r\n        this._minRowHeight = this._minSizeLimit(\"minRowHeight\", options.minRowHeight);\r\n        this._quillContainer = this.editorInstance._getQuillContainer();\r\n        this._tableData = [];\r\n        if (this.enabled) {\r\n            this._applyResizing()\r\n        }\r\n    }\r\n    _applyResizing(forcedStart) {\r\n        if (forcedStart) {\r\n            this._applyResizingImpl()\r\n        } else {\r\n            this.editorInstance.addContentInitializedCallback(this._applyResizingImpl.bind(this))\r\n        }\r\n        this.addCleanCallback(this.clean.bind(this));\r\n        this._resizeHandlerWithContext = _core_utils_resize_callbacks__WEBPACK_IMPORTED_MODULE_5__[\"default\"].add(this._resizeHandler.bind(this))\r\n    }\r\n    _minSizeLimit(propertyName, newValue) {\r\n        return Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(newValue) ? Math.max(newValue, 0) : DEFAULTS[propertyName]\r\n    }\r\n    _applyResizingImpl() {\r\n        var $tables = this._findTables();\r\n        if ($tables.length) {\r\n            this._fixTablesWidths($tables);\r\n            this._createResizeFrames($tables);\r\n            this._updateFramesPositions();\r\n            this._updateFramesSeparators()\r\n        }\r\n        this._attachEvents()\r\n    }\r\n    _attachEvents() {\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_2__[\"default\"].on(this.editorInstance._getContent(), SCROLL_EVENT, this._updateFramesPositions.bind(this));\r\n        this.quill.on(\"text-change\", this._getQuillTextChangeHandler())\r\n    }\r\n    _detachEvents() {\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_2__[\"default\"].off(this.editorInstance._getContent(), MODULE_NAMESPACE);\r\n        this.quill.off(\"text-change\", this._quillTextChangeHandler)\r\n    }\r\n    _getQuillTextChangeHandler(delta, oldContent, source) {\r\n        return (delta, oldContent, source) => {\r\n            if (this._isTableChanging()) {\r\n                var $tables = this._findTables();\r\n                this._removeResizeFrames();\r\n                if (\"api\" === source) {\r\n                    this._fixTablesWidths($tables)\r\n                }\r\n                this._updateTablesColumnsWidth($tables);\r\n                this._createResizeFrames($tables);\r\n                this._updateFramesPositions();\r\n                this._updateFramesSeparators()\r\n            } else {\r\n                this._updateFramesPositions();\r\n                if (!this._isDragging) {\r\n                    this._updateFramesSeparators()\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _getFrameForTable($table) {\r\n        var _this$_framesForTable;\r\n        return null === (_this$_framesForTable = this._framesForTables) || void 0 === _this$_framesForTable ? void 0 : _this$_framesForTable.get($table.get(0))\r\n    }\r\n    _resizeHandler() {\r\n        this._windowResizeTimeout = setTimeout(() => {\r\n            var $tables = this._findTables();\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_10__[\"each\"])($tables, (index, table) => {\r\n                var $table = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(table);\r\n                var frame = this._tableResizeFrames[index];\r\n                var actualTableWidth = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterWidth\"])($table);\r\n                var lastTableWidth = this._tableLastWidth(frame);\r\n                if (Math.abs(actualTableWidth - lastTableWidth) > 1) {\r\n                    this._tableLastWidth(frame, actualTableWidth);\r\n                    this._updateColumnsWidth($table, index)\r\n                }\r\n            });\r\n            this._updateFramesPositions();\r\n            this._updateFramesSeparators()\r\n        })\r\n    }\r\n    _findTables() {\r\n        return Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this._quillContainer).find(\"table\")\r\n    }\r\n    _getWidthStyleValue($element) {\r\n        var styleValue = $element[0].style.width;\r\n        return \"\" !== styleValue ? parseInt(styleValue) : void 0\r\n    }\r\n    _tableLastWidth(frame, newValue) {\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(newValue)) {\r\n            frame.lastWidth = newValue\r\n        } else {\r\n            return null === frame || void 0 === frame ? void 0 : frame.lastWidth\r\n        }\r\n    }\r\n    _fixTablesWidths($tables) {\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_10__[\"each\"])($tables, (index, table) => {\r\n            var $table = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(table);\r\n            var $columnElements = this._getTableDeterminantElements($table, \"horizontal\");\r\n            if (!this._tableResizeFrames[index]) {\r\n                this._tableResizeFrames[index] = {\r\n                    lastWidth: void 0\r\n                }\r\n            }\r\n            var frame = this._getFrameForTable($table);\r\n            if (!frame) {\r\n                this._tableResizeFrames.push({\r\n                    $table: $table\r\n                })\r\n            }\r\n            if (0 === Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"getAutoSizedElements\"])($table).length) {\r\n                var _this$_tableLastWidth;\r\n                var {\r\n                    columnsSum: columnsSum\r\n                } = this._getColumnElementsSum($columnElements);\r\n                Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"unfixTableWidth\"])($table, {\r\n                    quill: this.quill\r\n                });\r\n                var tableWidth = null !== (_this$_tableLastWidth = this._tableLastWidth(frame)) && void 0 !== _this$_tableLastWidth ? _this$_tableLastWidth : Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterWidth\"])($table);\r\n                if (frame) {\r\n                    this._tableLastWidth(frame, Math.max(columnsSum, tableWidth))\r\n                }\r\n            }\r\n        })\r\n    }\r\n    _createResizeFrames($tables) {\r\n        this._framesForTables = new Map;\r\n        $tables.each((index, table) => {\r\n            var _this$_tableResizeFra;\r\n            var $table = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(table);\r\n            var $lastTable = null === (_this$_tableResizeFra = this._tableResizeFrames[index]) || void 0 === _this$_tableResizeFra ? void 0 : _this$_tableResizeFra.$table;\r\n            var $tableLastWidth = this._tableResizeFrames[index].lastWidth;\r\n            this._tableResizeFrames[index] = {\r\n                $frame: this._createTableResizeFrame(table),\r\n                $table: $table,\r\n                index: index,\r\n                lastWidth: $lastTable && table === $lastTable.get(0) ? $tableLastWidth : void 0,\r\n                columnsCount: this._getTableDeterminantElements($table, \"horizontal\").length,\r\n                rowsCount: this._getTableDeterminantElements($table, \"vertical\").length\r\n            };\r\n            this._framesForTables.set(table, this._tableResizeFrames[index])\r\n        });\r\n        this._tableResizeFrames.length = $tables.length\r\n    }\r\n    _isTableChanging() {\r\n        var $tables = this._findTables();\r\n        var result = false;\r\n        if ($tables.length !== this._tableResizeFrames.length) {\r\n            result = true\r\n        } else {\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_10__[\"each\"])($tables, (index, table) => {\r\n                var $table = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(table);\r\n                var frame = this._tableResizeFrames[index];\r\n                var isColumnsCountChanged = (null === frame || void 0 === frame ? void 0 : frame.columnsCount) !== this._getTableDeterminantElements($table, \"horizontal\").length;\r\n                var isRowCountChanged = (null === frame || void 0 === frame ? void 0 : frame.rowsCount) !== this._getTableDeterminantElements($table, \"vertical\").length;\r\n                if (isColumnsCountChanged || isRowCountChanged) {\r\n                    result = true;\r\n                    return false\r\n                }\r\n            })\r\n        }\r\n        return result\r\n    }\r\n    _removeResizeFrames(clearArray) {\r\n        var _this$_framesForTable2;\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_10__[\"each\"])(this._tableResizeFrames, (index, resizeFrame) => {\r\n            if (resizeFrame.$frame) {\r\n                var _resizeFrame$$frame;\r\n                var resizerElementsSelector = \".\".concat(DX_COLUMN_RESIZER_CLASS, \", .\").concat(DX_ROW_RESIZER_CLASS);\r\n                this._detachSeparatorEvents(null === (_resizeFrame$$frame = resizeFrame.$frame) || void 0 === _resizeFrame$$frame ? void 0 : _resizeFrame$$frame.find(resizerElementsSelector));\r\n                resizeFrame.$frame.remove()\r\n            }\r\n        });\r\n        null === (_this$_framesForTable2 = this._framesForTables) || void 0 === _this$_framesForTable2 ? void 0 : _this$_framesForTable2.clear();\r\n        if (clearArray) {\r\n            this._tableResizeFrames = []\r\n        }\r\n    }\r\n    _detachSeparatorEvents($lineSeparators) {\r\n        $lineSeparators.each((i, $lineSeparator) => {\r\n            _events_core_events_engine__WEBPACK_IMPORTED_MODULE_2__[\"default\"].off($lineSeparator, POINTERDOWN_EVENT)\r\n        })\r\n    }\r\n    _createTableResizeFrame() {\r\n        return Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(DX_COLUMN_RESIZE_FRAME_CLASS).appendTo(this._quillContainer)\r\n    }\r\n    _updateFramesPositions() {\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_10__[\"each\"])(this._tableResizeFrames, (index, tableResizeFrame) => {\r\n            this._updateFramePosition(tableResizeFrame.$table, tableResizeFrame.$frame)\r\n        })\r\n    }\r\n    _updateFramePosition($table, $frame) {\r\n        var {\r\n            height: height,\r\n            width: width,\r\n            top: targetTop,\r\n            left: targetLeft\r\n        } = Object(_core_utils_position__WEBPACK_IMPORTED_MODULE_7__[\"getBoundingRect\"])($table.get(0));\r\n        var {\r\n            top: containerTop,\r\n            left: containerLeft\r\n        } = Object(_core_utils_position__WEBPACK_IMPORTED_MODULE_7__[\"getBoundingRect\"])(this.quill.root);\r\n        $frame.css({\r\n            height: height,\r\n            width: width,\r\n            top: targetTop - containerTop,\r\n            left: targetLeft - containerLeft\r\n        });\r\n        Object(_animation_translator__WEBPACK_IMPORTED_MODULE_6__[\"move\"])($frame, {\r\n            left: 0,\r\n            top: 0\r\n        })\r\n    }\r\n    _updateFramesSeparators(direction) {\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_10__[\"each\"])(this._tableResizeFrames, (index, frame) => {\r\n            if (direction) {\r\n                this._updateFrameSeparators(frame, direction)\r\n            } else {\r\n                this._updateFrameSeparators(frame, \"vertical\");\r\n                this._updateFrameSeparators(frame, \"horizontal\")\r\n            }\r\n        })\r\n    }\r\n    _isDraggable($element) {\r\n        return $element.hasClass(\"dx-draggable\") && $element.is(\":visible\")\r\n    }\r\n    _removeDraggable($currentLineSeparator, lineResizerClass) {\r\n        if (this._isDraggable($currentLineSeparator)) {\r\n            var draggable = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])($currentLineSeparator).dxDraggable(\"instance\");\r\n            draggable.dispose();\r\n            Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])($currentLineSeparator).addClass(lineResizerClass)\r\n        }\r\n    }\r\n    _getDirectionInfo(direction) {\r\n        if (\"vertical\" === direction) {\r\n            return {\r\n                lineResizerClass: DX_ROW_RESIZER_CLASS,\r\n                sizeFunction: x => Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterHeight\"])(x),\r\n                positionCoordinate: \"top\",\r\n                positionStyleProperty: \"height\",\r\n                positionCoordinateName: \"y\"\r\n            }\r\n        } else {\r\n            return {\r\n                lineResizerClass: DX_COLUMN_RESIZER_CLASS,\r\n                sizeFunction: x => Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterWidth\"])(x),\r\n                positionCoordinate: this.editorInstance.option(\"rtlEnabled\") ? \"right\" : \"left\",\r\n                positionStyleProperty: \"width\",\r\n                positionCoordinateName: \"x\"\r\n            }\r\n        }\r\n    }\r\n    _getSize($element, directionInfo) {\r\n        return directionInfo.sizeFunction($element)\r\n    }\r\n    _updateFrameSeparators(frame, direction) {\r\n        var $determinantElements = this._getTableDeterminantElements(frame.$table, direction);\r\n        var determinantElementsCount = $determinantElements.length;\r\n        var determinantElementsSeparatorsCount = determinantElementsCount - 1;\r\n        var directionInfo = this._getDirectionInfo(direction);\r\n        var lineSeparators = frame.$frame.find(\".\".concat(directionInfo.lineResizerClass));\r\n        var styleOptions = {\r\n            transform: \"none\"\r\n        };\r\n        var currentPosition = 0;\r\n        for (var i = 0; i <= determinantElementsSeparatorsCount; i++) {\r\n            currentPosition += this._getSize($determinantElements.eq(i), directionInfo);\r\n            if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(lineSeparators[i])) {\r\n                lineSeparators[i] = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(directionInfo.lineResizerClass).appendTo(frame.$frame).get(0)\r\n            }\r\n            var $currentLineSeparator = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(lineSeparators[i]);\r\n            this._removeDraggable($currentLineSeparator, directionInfo.lineResizerClass);\r\n            styleOptions[directionInfo.positionCoordinate] = currentPosition - DRAGGABLE_ELEMENT_OFFSET;\r\n            Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])($currentLineSeparator).css(styleOptions);\r\n            var attachSeparatorData = {\r\n                lineSeparator: lineSeparators[i],\r\n                index: i,\r\n                $determinantElements: $determinantElements,\r\n                frame: frame,\r\n                direction: direction\r\n            };\r\n            this._attachColumnSeparatorEvents(attachSeparatorData)\r\n        }\r\n    }\r\n    _getTableDeterminantElements($table, direction) {\r\n        if (\"vertical\" === direction) {\r\n            return $table.find(\"th:first-child, td:first-child\")\r\n        } else {\r\n            return Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"getColumnElements\"])($table)\r\n        }\r\n    }\r\n    _attachColumnSeparatorEvents(options) {\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_2__[\"default\"].on(options.lineSeparator, POINTERDOWN_EVENT, () => {\r\n            this._createDraggableElement(options)\r\n        })\r\n    }\r\n    _dragStartHandler(_ref) {\r\n        var {\r\n            $determinantElements: $determinantElements,\r\n            index: index,\r\n            frame: frame,\r\n            direction: direction,\r\n            lineSeparator: lineSeparator\r\n        } = _ref;\r\n        var directionInfo = this._getDirectionInfo(direction);\r\n        this._isDragging = true;\r\n        this._fixColumnsWidth(frame.$table);\r\n        this._startLineSize = parseInt(this._getSize(Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])($determinantElements[index]), directionInfo));\r\n        this._startTableWidth = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterWidth\"])(frame.$table);\r\n        this._startLineSeparatorPosition = parseInt(Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(lineSeparator).css(directionInfo.positionCoordinate));\r\n        this._nextLineSize = 0;\r\n        if ($determinantElements[index + 1]) {\r\n            this._nextLineSize = parseInt(this._getSize(Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])($determinantElements[index + 1]), directionInfo))\r\n        } else if (\"horizontal\" === direction) {\r\n            Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"unfixTableWidth\"])(frame.$table, {\r\n                quill: this.quill\r\n            })\r\n        }\r\n    }\r\n    _shouldRevertOffset(direction) {\r\n        return \"horizontal\" === direction && this.editorInstance.option(\"rtlEnabled\")\r\n    }\r\n    _isNextColumnWidthEnough(nextColumnNewSize, $nextColumnElement, eventOffset) {\r\n        if (!this._nextLineSize) {\r\n            return true\r\n        } else if (nextColumnNewSize >= this._minColumnWidth) {\r\n            var isWidthIncreased = this._nextColumnOffsetLimit ? eventOffset < this._nextColumnOffsetLimit : eventOffset < 0;\r\n            var isWidthLimited = Math.abs(this._getWidthStyleValue($nextColumnElement) - Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterWidth\"])($nextColumnElement)) > ROUGH_OFFSET;\r\n            return isWidthIncreased || !isWidthLimited\r\n        }\r\n        return false\r\n    }\r\n    _shouldSetNextColumnWidth(nextColumnNewSize) {\r\n        return this._nextLineSize && nextColumnNewSize > 0\r\n    }\r\n    _horizontalDragHandler(_ref2) {\r\n        var {\r\n            currentLineNewSize: currentLineNewSize,\r\n            directionInfo: directionInfo,\r\n            eventOffset: eventOffset,\r\n            $determinantElements: $determinantElements,\r\n            index: index,\r\n            frame: frame\r\n        } = _ref2;\r\n        var nextColumnNewSize = this._nextLineSize && this._nextLineSize - eventOffset;\r\n        var isCurrentColumnWidthEnough = currentLineNewSize >= this._minColumnWidth;\r\n        var $lineElements = Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"getLineElements\"])(frame.$table, index);\r\n        var $nextLineElements = Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"getLineElements\"])(frame.$table, index + 1);\r\n        var realWidthDiff = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterWidth\"])($lineElements.eq(0)) - currentLineNewSize;\r\n        if (isCurrentColumnWidthEnough) {\r\n            if (this._isNextColumnWidthEnough(nextColumnNewSize, $determinantElements.eq(index + 1), eventOffset)) {\r\n                Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"setLineElementsFormat\"])(this, {\r\n                    elements: $lineElements,\r\n                    property: directionInfo.positionStyleProperty,\r\n                    value: currentLineNewSize\r\n                });\r\n                if (this._shouldSetNextColumnWidth(nextColumnNewSize)) {\r\n                    Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"setLineElementsFormat\"])(this, {\r\n                        elements: $nextLineElements,\r\n                        property: directionInfo.positionStyleProperty,\r\n                        value: nextColumnNewSize\r\n                    })\r\n                }\r\n                var isTableWidthChanged = Math.abs(this._startTableWidth - Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterWidth\"])(frame.$table)) < ROUGH_OFFSET;\r\n                var shouldRevertNewValue = Math.abs(realWidthDiff) > ROUGH_OFFSET || !this._nextLineSize && isTableWidthChanged;\r\n                if (shouldRevertNewValue) {\r\n                    Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"setLineElementsFormat\"])(this, {\r\n                        elements: $lineElements,\r\n                        property: directionInfo.positionStyleProperty,\r\n                        value: Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterWidth\"])($lineElements.eq(0))\r\n                    });\r\n                    nextColumnNewSize += currentLineNewSize - Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterWidth\"])($lineElements.eq(0));\r\n                    if (this._shouldSetNextColumnWidth(nextColumnNewSize)) {\r\n                        Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"setLineElementsFormat\"])(this, {\r\n                            elements: $nextLineElements,\r\n                            property: directionInfo.positionStyleProperty,\r\n                            value: nextColumnNewSize\r\n                        })\r\n                    }\r\n                }\r\n            } else {\r\n                this._nextColumnOffsetLimit = this._nextColumnOffsetLimit || eventOffset\r\n            }\r\n        }\r\n        this._$highlightedElement.css(directionInfo.positionCoordinate, this._startLineSeparatorPosition + eventOffset + realWidthDiff + \"px\")\r\n    }\r\n    _verticalDragHandler(_ref3) {\r\n        var {\r\n            currentLineNewSize: currentLineNewSize,\r\n            directionInfo: directionInfo,\r\n            eventOffset: eventOffset,\r\n            $determinantElements: $determinantElements,\r\n            index: index,\r\n            frame: frame\r\n        } = _ref3;\r\n        var newHeight = Math.max(currentLineNewSize, this._minRowHeight);\r\n        var $lineElements = Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"getLineElements\"])(frame.$table, index, \"vertical\");\r\n        Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"setLineElementsFormat\"])(this, {\r\n            elements: $lineElements,\r\n            property: directionInfo.positionStyleProperty,\r\n            value: newHeight\r\n        });\r\n        var rowHeightDiff = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterHeight\"])($determinantElements.eq(index)) - currentLineNewSize;\r\n        this._$highlightedElement.css(directionInfo.positionCoordinate, this._startLineSeparatorPosition + eventOffset + rowHeightDiff + \"px\")\r\n    }\r\n    _dragMoveHandler(event, _ref4) {\r\n        var {\r\n            $determinantElements: $determinantElements,\r\n            index: index,\r\n            frame: frame,\r\n            direction: direction\r\n        } = _ref4;\r\n        var directionInfo = this._getDirectionInfo(direction);\r\n        var eventOffset = event.offset[directionInfo.positionCoordinateName];\r\n        this.editorInstance._saveValueChangeEvent(event);\r\n        if (this._shouldRevertOffset(direction)) {\r\n            eventOffset = -eventOffset\r\n        }\r\n        var currentLineNewSize = this._startLineSize + eventOffset;\r\n        if (\"horizontal\" === direction) {\r\n            this._horizontalDragHandler({\r\n                currentLineNewSize: currentLineNewSize,\r\n                directionInfo: directionInfo,\r\n                eventOffset: eventOffset,\r\n                $determinantElements: $determinantElements,\r\n                index: index,\r\n                frame: frame\r\n            })\r\n        } else {\r\n            this._verticalDragHandler({\r\n                currentLineNewSize: currentLineNewSize,\r\n                directionInfo: directionInfo,\r\n                eventOffset: eventOffset,\r\n                $determinantElements: $determinantElements,\r\n                index: index,\r\n                frame: frame\r\n            })\r\n        }\r\n        this._updateFramePosition(frame.$table, frame.$frame)\r\n    }\r\n    _dragEndHandler(options) {\r\n        var _this$_$highlightedEl;\r\n        null === (_this$_$highlightedEl = this._$highlightedElement) || void 0 === _this$_$highlightedEl ? void 0 : _this$_$highlightedEl.remove();\r\n        this._isDragging = void 0;\r\n        this._nextColumnOffsetLimit = void 0;\r\n        this._tableLastWidth(options.frame, Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterWidth\"])(options.frame.$table));\r\n        this._updateFramesPositions();\r\n        this._updateFramesSeparators()\r\n    }\r\n    _isLastColumnResizing(_ref5) {\r\n        var {\r\n            $determinantElements: $determinantElements,\r\n            index: index\r\n        } = _ref5;\r\n        return !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])($determinantElements[index + 1])\r\n    }\r\n    _getBoundaryConfig(options) {\r\n        var result = {};\r\n        if (\"vertical\" === options.direction) {\r\n            result.boundary = options.frame.$table;\r\n            result.boundOffset = {\r\n                bottom: Object(_core_utils_window__WEBPACK_IMPORTED_MODULE_11__[\"hasWindow\"])() ? -Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getHeight\"])(Object(_core_utils_window__WEBPACK_IMPORTED_MODULE_11__[\"getWindow\"])()) : -Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterHeight\"])(this._quillContainer),\r\n                top: 0,\r\n                left: 0,\r\n                right: 0\r\n            }\r\n        } else if (!this._isLastColumnResizing(options)) {\r\n            result.boundary = options.frame.$table\r\n        } else {\r\n            var $content = this.editorInstance._getContent();\r\n            result.boundary = $content;\r\n            result.boundOffset = {\r\n                bottom: 0,\r\n                top: 0,\r\n                left: $content.css(\"paddingLeft\"),\r\n                right: $content.css(\"paddingRight\")\r\n            }\r\n        }\r\n        return result\r\n    }\r\n    _createDraggableElement(options) {\r\n        var _this$_$highlightedEl2;\r\n        var boundaryConfig = this._getBoundaryConfig(options);\r\n        var directionClass = \"vertical\" === options.direction ? \"dx-htmleditor-highlighted-row\" : \"dx-htmleditor-highlighted-column\";\r\n        null === (_this$_$highlightedEl2 = this._$highlightedElement) || void 0 === _this$_$highlightedEl2 ? void 0 : _this$_$highlightedEl2.remove();\r\n        this._$highlightedElement = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(\"\".concat(directionClass)).insertAfter(Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(options.lineSeparator));\r\n        var config = {\r\n            contentTemplate: null,\r\n            allowMoveByClick: false,\r\n            dragDirection: options.direction,\r\n            onDragMove: _ref6 => {\r\n                var {\r\n                    component: component,\r\n                    event: event\r\n                } = _ref6;\r\n                this._dragMoveHandler(event, options)\r\n            },\r\n            onDragStart: () => {\r\n                this._dragStartHandler(options)\r\n            },\r\n            onDragEnd: () => {\r\n                this._dragEndHandler(options)\r\n            }\r\n        };\r\n        Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_12__[\"extend\"])(config, boundaryConfig);\r\n        this._currentDraggableElement = this.editorInstance._createComponent(options.lineSeparator, _draggable__WEBPACK_IMPORTED_MODULE_9__[\"default\"], config)\r\n    }\r\n    _fixColumnsWidth($table) {\r\n        var determinantElements = this._getTableDeterminantElements($table);\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_10__[\"each\"])(determinantElements, (index, element) => {\r\n            var columnWidth = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterWidth\"])(element);\r\n            var $lineElements = Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"getLineElements\"])($table, index);\r\n            Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"setLineElementsFormat\"])(this, {\r\n                elements: $lineElements,\r\n                property: \"width\",\r\n                value: Math.max(columnWidth, this._minColumnWidth)\r\n            })\r\n        })\r\n    }\r\n    _getColumnElementsSum(columnElements) {\r\n        var columnsWidths = [];\r\n        var columnsSum = 0;\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_10__[\"each\"])(columnElements, (index, element) => {\r\n            var $element = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element);\r\n            var columnWidth = this._getWidthStyleValue($element) || Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterWidth\"])($element);\r\n            columnsWidths[index] = Math.max(columnWidth, this._minColumnWidth);\r\n            columnsSum += columnsWidths[index]\r\n        });\r\n        return {\r\n            columnsWidths: columnsWidths,\r\n            columnsSum: columnsSum\r\n        }\r\n    }\r\n    _setColumnsRatioWidth(columnElements, ratio, columnsWidths, $table) {\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_10__[\"each\"])(columnElements, index => {\r\n            var $lineElements = Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"getLineElements\"])($table, index);\r\n            var resultWidth;\r\n            if (ratio > 0) {\r\n                resultWidth = this._minColumnWidth + Math.round((columnsWidths[index] - this._minColumnWidth) * ratio)\r\n            } else {\r\n                resultWidth = this._minColumnWidth\r\n            }\r\n            Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_13__[\"setLineElementsFormat\"])(this, {\r\n                elements: $lineElements,\r\n                property: \"width\",\r\n                value: resultWidth\r\n            })\r\n        })\r\n    }\r\n    _updateColumnsWidth($table, frameIndex) {\r\n        var determinantElements = this._getTableDeterminantElements($table);\r\n        var frame = this._tableResizeFrames[frameIndex];\r\n        if (!frame) {\r\n            this._tableResizeFrames[frameIndex] = {}\r\n        }\r\n        frame = this._tableResizeFrames[frameIndex];\r\n        var tableWidth = this._tableLastWidth(frame) || Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getOuterWidth\"])($table);\r\n        var ratio;\r\n        var {\r\n            columnsWidths: columnsWidths,\r\n            columnsSum: columnsSum\r\n        } = this._getColumnElementsSum(determinantElements);\r\n        var minWidthForColumns = determinantElements.length * this._minColumnWidth;\r\n        if (columnsSum > minWidthForColumns) {\r\n            ratio = (tableWidth - minWidthForColumns) / (columnsSum - minWidthForColumns)\r\n        } else {\r\n            ratio = -1\r\n        }\r\n        this._tableLastWidth(frame, ratio > 0 ? tableWidth : minWidthForColumns);\r\n        this._setColumnsRatioWidth(determinantElements, ratio, columnsWidths, $table)\r\n    }\r\n    _updateTablesColumnsWidth($tables) {\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_10__[\"each\"])($tables, (index, table) => {\r\n            this._updateColumnsWidth(Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(table), index)\r\n        })\r\n    }\r\n    option(option, value) {\r\n        if (\"tableResizing\" === option) {\r\n            this.handleOptionChangeValue(value);\r\n            return\r\n        }\r\n        if (\"enabled\" === option) {\r\n            this.enabled = value;\r\n            value ? this._applyResizing(true) : this.clean()\r\n        } else if ([\"minColumnWidth\", \"minRowHeight\"].includes(option)) {\r\n            this[\"_\".concat(option)] = this._minSizeLimit(option, value)\r\n        }\r\n    }\r\n    clean() {\r\n        this._removeResizeFrames(true);\r\n        this._detachEvents();\r\n        _core_utils_resize_callbacks__WEBPACK_IMPORTED_MODULE_5__[\"default\"].remove(this._resizeHandlerWithContext);\r\n        clearTimeout(this._windowResizeTimeout);\r\n        this._resizeHandlerWithContext = void 0;\r\n        this._isDragging = void 0;\r\n        this._startTableWidth = void 0;\r\n        clearTimeout(this._attachResizerTimeout)\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy90YWJsZVJlc2l6aW5nLmpzPzQ5MGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS2tDO0FBQ0s7QUFDdUI7QUFHNUI7QUFHRztBQUNxQztBQUduQztBQUdEO0FBQ047QUFDUTtBQUdGO0FBSUY7QUFHQTtBQU9MO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdFQUFZO0FBQ3BDLG1CQUFtQix3RUFBWTtBQUNoQixrQ0FBa0MsNkNBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvRUFBc0I7QUFDL0Q7QUFDQTtBQUNBLGVBQWUsa0VBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0VBQUk7QUFDaEIsNkJBQTZCLDhEQUFDO0FBQzlCO0FBQ0EsdUNBQXVDLHNF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QUNBLHdEQUF3RCxzRUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBSTtBQUNaLHFDQUFxQyw4REFBQztBQUN0QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0VBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3VpL2h0bWxfZWRpdG9yL21vZHVsZXMvdGFibGVSZXNpemluZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy90YWJsZVJlc2l6aW5nLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0T3V0ZXJXaWR0aCxcclxuICAgIGdldE91dGVySGVpZ2h0LFxyXG4gICAgZ2V0SGVpZ2h0XHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvc2l6ZVwiO1xyXG5pbXBvcnQgJCBmcm9tIFwiLi4vLi4vLi4vY29yZS9yZW5kZXJlclwiO1xyXG5pbXBvcnQgZXZlbnRzRW5naW5lIGZyb20gXCIuLi8uLi8uLi9ldmVudHMvY29yZS9ldmVudHNfZW5naW5lXCI7XHJcbmltcG9ydCB7XHJcbiAgICBpc0RlZmluZWRcclxufSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlscy90eXBlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBhZGROYW1lc3BhY2VcclxufSBmcm9tIFwiLi4vLi4vLi4vZXZlbnRzL3V0aWxzL2luZGV4XCI7XHJcbmltcG9ydCBfd2luZG93UmVzaXplQ2FsbGJhY2tzIGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWxzL3Jlc2l6ZV9jYWxsYmFja3NcIjtcclxuaW1wb3J0IHtcclxuICAgIG1vdmVcclxufSBmcm9tIFwiLi4vLi4vLi4vYW5pbWF0aW9uL3RyYW5zbGF0b3JcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldEJvdW5kaW5nUmVjdFxyXG59IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWxzL3Bvc2l0aW9uXCI7XHJcbmltcG9ydCBCYXNlTW9kdWxlIGZyb20gXCIuL2Jhc2VcIjtcclxuaW1wb3J0IERyYWdnYWJsZSBmcm9tIFwiLi4vLi4vZHJhZ2dhYmxlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBlYWNoXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvaXRlcmF0b3JcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldFdpbmRvdyxcclxuICAgIGhhc1dpbmRvd1xyXG59IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWxzL3dpbmRvd1wiO1xyXG5pbXBvcnQge1xyXG4gICAgZXh0ZW5kXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvZXh0ZW5kXCI7XHJcbmltcG9ydCB7XHJcbiAgICBzZXRMaW5lRWxlbWVudHNGb3JtYXQsXHJcbiAgICBnZXRMaW5lRWxlbWVudHMsXHJcbiAgICBnZXRBdXRvU2l6ZWRFbGVtZW50cyxcclxuICAgIGdldENvbHVtbkVsZW1lbnRzLFxyXG4gICAgdW5maXhUYWJsZVdpZHRoXHJcbn0gZnJvbSBcIi4uL3V0aWxzL3RhYmxlX2hlbHBlclwiO1xyXG52YXIgRFhfQ09MVU1OX1JFU0laRV9GUkFNRV9DTEFTUyA9IFwiZHgtdGFibGUtcmVzaXplLWZyYW1lXCI7XHJcbnZhciBEWF9DT0xVTU5fUkVTSVpFUl9DTEFTUyA9IFwiZHgtaHRtbGVkaXRvci1jb2x1bW4tcmVzaXplclwiO1xyXG52YXIgRFhfUk9XX1JFU0laRVJfQ0xBU1MgPSBcImR4LWh0bWxlZGl0b3Itcm93LXJlc2l6ZXJcIjtcclxudmFyIERFRkFVTFRTID0ge1xyXG4gICAgbWluQ29sdW1uV2lkdGg6IDQwLFxyXG4gICAgbWluUm93SGVpZ2h0OiAyNFxyXG59O1xyXG52YXIgRFJBR0dBQkxFX0VMRU1FTlRfT0ZGU0VUID0gMjtcclxudmFyIFJPVUdIX09GRlNFVCA9IDM7XHJcbnZhciBNT0RVTEVfTkFNRVNQQUNFID0gXCJkeEh0bWxUYWJsZVJlc2l6aW5nTW9kdWxlXCI7XHJcbnZhciBQT0lOVEVSRE9XTl9FVkVOVCA9IGFkZE5hbWVzcGFjZShcImR4cG9pbnRlcmRvd25cIiwgTU9EVUxFX05BTUVTUEFDRSk7XHJcbnZhciBTQ1JPTExfRVZFTlQgPSBhZGROYW1lc3BhY2UoXCJzY3JvbGxcIiwgTU9EVUxFX05BTUVTUEFDRSk7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYmxlUmVzaXppbmdNb2R1bGUgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcclxuICAgIGNvbnN0cnVjdG9yKHF1aWxsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIocXVpbGwsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9ICEhb3B0aW9ucy5lbmFibGVkO1xyXG4gICAgICAgIHRoaXMuX3RhYmxlUmVzaXplRnJhbWVzID0gW107XHJcbiAgICAgICAgdGhpcy5fbWluQ29sdW1uV2lkdGggPSB0aGlzLl9taW5TaXplTGltaXQoXCJtaW5Db2x1bW5XaWR0aFwiLCBvcHRpb25zLm1pbkNvbHVtbldpZHRoKTtcclxuICAgICAgICB0aGlzLl9taW5Sb3dIZWlnaHQgPSB0aGlzLl9taW5TaXplTGltaXQoXCJtaW5Sb3dIZWlnaHRcIiwgb3B0aW9ucy5taW5Sb3dIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX3F1aWxsQ29udGFpbmVyID0gdGhpcy5lZGl0b3JJbnN0YW5jZS5fZ2V0UXVpbGxDb250YWluZXIoKTtcclxuICAgICAgICB0aGlzLl90YWJsZURhdGEgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5UmVzaXppbmcoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9hcHBseVJlc2l6aW5nKGZvcmNlZFN0YXJ0KSB7XHJcbiAgICAgICAgaWYgKGZvcmNlZFN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5UmVzaXppbmdJbXBsKClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmVkaXRvckluc3RhbmNlLmFkZENvbnRlbnRJbml0aWFsaXplZENhbGxiYWNrKHRoaXMuX2FwcGx5UmVzaXppbmdJbXBsLmJpbmQodGhpcykpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkQ2xlYW5DYWxsYmFjayh0aGlzLmNsZWFuLmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXJXaXRoQ29udGV4dCA9IF93aW5kb3dSZXNpemVDYWxsYmFja3MuYWRkKHRoaXMuX3Jlc2l6ZUhhbmRsZXIuYmluZCh0aGlzKSlcclxuICAgIH1cclxuICAgIF9taW5TaXplTGltaXQocHJvcGVydHlOYW1lLCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBpc0RlZmluZWQobmV3VmFsdWUpID8gTWF0aC5tYXgobmV3VmFsdWUsIDApIDogREVGQVVMVFNbcHJvcGVydHlOYW1lXVxyXG4gICAgfVxyXG4gICAgX2FwcGx5UmVzaXppbmdJbXBsKCkge1xyXG4gICAgICAgIHZhciAkdGFibGVzID0gdGhpcy5fZmluZFRhYmxlcygpO1xyXG4gICAgICAgIGlmICgkdGFibGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl9maXhUYWJsZXNXaWR0aHMoJHRhYmxlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlc2l6ZUZyYW1lcygkdGFibGVzKTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRnJhbWVzUG9zaXRpb25zKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZyYW1lc1NlcGFyYXRvcnMoKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9hdHRhY2hFdmVudHMoKVxyXG4gICAgfVxyXG4gICAgX2F0dGFjaEV2ZW50cygpIHtcclxuICAgICAgICBldmVudHNFbmdpbmUub24odGhpcy5lZGl0b3JJbnN0YW5jZS5fZ2V0Q29udGVudCgpLCBTQ1JPTExfRVZFTlQsIHRoaXMuX3VwZGF0ZUZyYW1lc1Bvc2l0aW9ucy5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnF1aWxsLm9uKFwidGV4dC1jaGFuZ2VcIiwgdGhpcy5fZ2V0UXVpbGxUZXh0Q2hhbmdlSGFuZGxlcigpKVxyXG4gICAgfVxyXG4gICAgX2RldGFjaEV2ZW50cygpIHtcclxuICAgICAgICBldmVudHNFbmdpbmUub2ZmKHRoaXMuZWRpdG9ySW5zdGFuY2UuX2dldENvbnRlbnQoKSwgTU9EVUxFX05BTUVTUEFDRSk7XHJcbiAgICAgICAgdGhpcy5xdWlsbC5vZmYoXCJ0ZXh0LWNoYW5nZVwiLCB0aGlzLl9xdWlsbFRleHRDaGFuZ2VIYW5kbGVyKVxyXG4gICAgfVxyXG4gICAgX2dldFF1aWxsVGV4dENoYW5nZUhhbmRsZXIoZGVsdGEsIG9sZENvbnRlbnQsIHNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiAoZGVsdGEsIG9sZENvbnRlbnQsIHNvdXJjZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNUYWJsZUNoYW5naW5nKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciAkdGFibGVzID0gdGhpcy5fZmluZFRhYmxlcygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlUmVzaXplRnJhbWVzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJhcGlcIiA9PT0gc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZml4VGFibGVzV2lkdGhzKCR0YWJsZXMpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVUYWJsZXNDb2x1bW5zV2lkdGgoJHRhYmxlcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVSZXNpemVGcmFtZXMoJHRhYmxlcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVGcmFtZXNQb3NpdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZyYW1lc1NlcGFyYXRvcnMoKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRnJhbWVzUG9zaXRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVGcmFtZXNTZXBhcmF0b3JzKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRGcmFtZUZvclRhYmxlKCR0YWJsZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyRfZnJhbWVzRm9yVGFibGU7XHJcbiAgICAgICAgcmV0dXJuIG51bGwgPT09IChfdGhpcyRfZnJhbWVzRm9yVGFibGUgPSB0aGlzLl9mcmFtZXNGb3JUYWJsZXMpIHx8IHZvaWQgMCA9PT0gX3RoaXMkX2ZyYW1lc0ZvclRhYmxlID8gdm9pZCAwIDogX3RoaXMkX2ZyYW1lc0ZvclRhYmxlLmdldCgkdGFibGUuZ2V0KDApKVxyXG4gICAgfVxyXG4gICAgX3Jlc2l6ZUhhbmRsZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fd2luZG93UmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgJHRhYmxlcyA9IHRoaXMuX2ZpbmRUYWJsZXMoKTtcclxuICAgICAgICAgICAgZWFjaCgkdGFibGVzLCAoaW5kZXgsIHRhYmxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJHRhYmxlID0gJCh0YWJsZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLl90YWJsZVJlc2l6ZUZyYW1lc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0dWFsVGFibGVXaWR0aCA9IGdldE91dGVyV2lkdGgoJHRhYmxlKTtcclxuICAgICAgICAgICAgICAgIHZhciBsYXN0VGFibGVXaWR0aCA9IHRoaXMuX3RhYmxlTGFzdFdpZHRoKGZyYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhhY3R1YWxUYWJsZVdpZHRoIC0gbGFzdFRhYmxlV2lkdGgpID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RhYmxlTGFzdFdpZHRoKGZyYW1lLCBhY3R1YWxUYWJsZVdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVDb2x1bW5zV2lkdGgoJHRhYmxlLCBpbmRleClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZyYW1lc1Bvc2l0aW9ucygpO1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVGcmFtZXNTZXBhcmF0b3JzKClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgX2ZpbmRUYWJsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuICQodGhpcy5fcXVpbGxDb250YWluZXIpLmZpbmQoXCJ0YWJsZVwiKVxyXG4gICAgfVxyXG4gICAgX2dldFdpZHRoU3R5bGVWYWx1ZSgkZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBzdHlsZVZhbHVlID0gJGVsZW1lbnRbMF0uc3R5bGUud2lkdGg7XHJcbiAgICAgICAgcmV0dXJuIFwiXCIgIT09IHN0eWxlVmFsdWUgPyBwYXJzZUludChzdHlsZVZhbHVlKSA6IHZvaWQgMFxyXG4gICAgfVxyXG4gICAgX3RhYmxlTGFzdFdpZHRoKGZyYW1lLCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIGlmIChpc0RlZmluZWQobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGZyYW1lLmxhc3RXaWR0aCA9IG5ld1ZhbHVlXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT09IGZyYW1lIHx8IHZvaWQgMCA9PT0gZnJhbWUgPyB2b2lkIDAgOiBmcmFtZS5sYXN0V2lkdGhcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZml4VGFibGVzV2lkdGhzKCR0YWJsZXMpIHtcclxuICAgICAgICBlYWNoKCR0YWJsZXMsIChpbmRleCwgdGFibGUpID0+IHtcclxuICAgICAgICAgICAgdmFyICR0YWJsZSA9ICQodGFibGUpO1xyXG4gICAgICAgICAgICB2YXIgJGNvbHVtbkVsZW1lbnRzID0gdGhpcy5fZ2V0VGFibGVEZXRlcm1pbmFudEVsZW1lbnRzKCR0YWJsZSwgXCJob3Jpem9udGFsXCIpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RhYmxlUmVzaXplRnJhbWVzW2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFibGVSZXNpemVGcmFtZXNbaW5kZXhdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RXaWR0aDogdm9pZCAwXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5fZ2V0RnJhbWVGb3JUYWJsZSgkdGFibGUpO1xyXG4gICAgICAgICAgICBpZiAoIWZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YWJsZVJlc2l6ZUZyYW1lcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAkdGFibGU6ICR0YWJsZVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoMCA9PT0gZ2V0QXV0b1NpemVkRWxlbWVudHMoJHRhYmxlKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfdGFibGVMYXN0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnNTdW06IGNvbHVtbnNTdW1cclxuICAgICAgICAgICAgICAgIH0gPSB0aGlzLl9nZXRDb2x1bW5FbGVtZW50c1N1bSgkY29sdW1uRWxlbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgdW5maXhUYWJsZVdpZHRoKCR0YWJsZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1aWxsOiB0aGlzLnF1aWxsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciB0YWJsZVdpZHRoID0gbnVsbCAhPT0gKF90aGlzJF90YWJsZUxhc3RXaWR0aCA9IHRoaXMuX3RhYmxlTGFzdFdpZHRoKGZyYW1lKSkgJiYgdm9pZCAwICE9PSBfdGhpcyRfdGFibGVMYXN0V2lkdGggPyBfdGhpcyRfdGFibGVMYXN0V2lkdGggOiBnZXRPdXRlcldpZHRoKCR0YWJsZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90YWJsZUxhc3RXaWR0aChmcmFtZSwgTWF0aC5tYXgoY29sdW1uc1N1bSwgdGFibGVXaWR0aCkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgX2NyZWF0ZVJlc2l6ZUZyYW1lcygkdGFibGVzKSB7XHJcbiAgICAgICAgdGhpcy5fZnJhbWVzRm9yVGFibGVzID0gbmV3IE1hcDtcclxuICAgICAgICAkdGFibGVzLmVhY2goKGluZGV4LCB0YWJsZSkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMkX3RhYmxlUmVzaXplRnJhO1xyXG4gICAgICAgICAgICB2YXIgJHRhYmxlID0gJCh0YWJsZSk7XHJcbiAgICAgICAgICAgIHZhciAkbGFzdFRhYmxlID0gbnVsbCA9PT0gKF90aGlzJF90YWJsZVJlc2l6ZUZyYSA9IHRoaXMuX3RhYmxlUmVzaXplRnJhbWVzW2luZGV4XSkgfHwgdm9pZCAwID09PSBfdGhpcyRfdGFibGVSZXNpemVGcmEgPyB2b2lkIDAgOiBfdGhpcyRfdGFibGVSZXNpemVGcmEuJHRhYmxlO1xyXG4gICAgICAgICAgICB2YXIgJHRhYmxlTGFzdFdpZHRoID0gdGhpcy5fdGFibGVSZXNpemVGcmFtZXNbaW5kZXhdLmxhc3RXaWR0aDtcclxuICAgICAgICAgICAgdGhpcy5fdGFibGVSZXNpemVGcmFtZXNbaW5kZXhdID0ge1xyXG4gICAgICAgICAgICAgICAgJGZyYW1lOiB0aGlzLl9jcmVhdGVUYWJsZVJlc2l6ZUZyYW1lKHRhYmxlKSxcclxuICAgICAgICAgICAgICAgICR0YWJsZTogJHRhYmxlLFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICAgICAgbGFzdFdpZHRoOiAkbGFzdFRhYmxlICYmIHRhYmxlID09PSAkbGFzdFRhYmxlLmdldCgwKSA/ICR0YWJsZUxhc3RXaWR0aCA6IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgIGNvbHVtbnNDb3VudDogdGhpcy5fZ2V0VGFibGVEZXRlcm1pbmFudEVsZW1lbnRzKCR0YWJsZSwgXCJob3Jpem9udGFsXCIpLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHJvd3NDb3VudDogdGhpcy5fZ2V0VGFibGVEZXRlcm1pbmFudEVsZW1lbnRzKCR0YWJsZSwgXCJ2ZXJ0aWNhbFwiKS5sZW5ndGhcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fZnJhbWVzRm9yVGFibGVzLnNldCh0YWJsZSwgdGhpcy5fdGFibGVSZXNpemVGcmFtZXNbaW5kZXhdKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3RhYmxlUmVzaXplRnJhbWVzLmxlbmd0aCA9ICR0YWJsZXMubGVuZ3RoXHJcbiAgICB9XHJcbiAgICBfaXNUYWJsZUNoYW5naW5nKCkge1xyXG4gICAgICAgIHZhciAkdGFibGVzID0gdGhpcy5fZmluZFRhYmxlcygpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICBpZiAoJHRhYmxlcy5sZW5ndGggIT09IHRoaXMuX3RhYmxlUmVzaXplRnJhbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZWFjaCgkdGFibGVzLCAoaW5kZXgsIHRhYmxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJHRhYmxlID0gJCh0YWJsZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLl90YWJsZVJlc2l6ZUZyYW1lc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNDb2x1bW5zQ291bnRDaGFuZ2VkID0gKG51bGwgPT09IGZyYW1lIHx8IHZvaWQgMCA9PT0gZnJhbWUgPyB2b2lkIDAgOiBmcmFtZS5jb2x1bW5zQ291bnQpICE9PSB0aGlzLl9nZXRUYWJsZURldGVybWluYW50RWxlbWVudHMoJHRhYmxlLCBcImhvcml6b250YWxcIikubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzUm93Q291bnRDaGFuZ2VkID0gKG51bGwgPT09IGZyYW1lIHx8IHZvaWQgMCA9PT0gZnJhbWUgPyB2b2lkIDAgOiBmcmFtZS5yb3dzQ291bnQpICE9PSB0aGlzLl9nZXRUYWJsZURldGVybWluYW50RWxlbWVudHMoJHRhYmxlLCBcInZlcnRpY2FsXCIpLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChpc0NvbHVtbnNDb3VudENoYW5nZWQgfHwgaXNSb3dDb3VudENoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICB9XHJcbiAgICBfcmVtb3ZlUmVzaXplRnJhbWVzKGNsZWFyQXJyYXkpIHtcclxuICAgICAgICB2YXIgX3RoaXMkX2ZyYW1lc0ZvclRhYmxlMjtcclxuICAgICAgICBlYWNoKHRoaXMuX3RhYmxlUmVzaXplRnJhbWVzLCAoaW5kZXgsIHJlc2l6ZUZyYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXNpemVGcmFtZS4kZnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfcmVzaXplRnJhbWUkJGZyYW1lO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc2l6ZXJFbGVtZW50c1NlbGVjdG9yID0gXCIuXCIuY29uY2F0KERYX0NPTFVNTl9SRVNJWkVSX0NMQVNTLCBcIiwgLlwiKS5jb25jYXQoRFhfUk9XX1JFU0laRVJfQ0xBU1MpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGV0YWNoU2VwYXJhdG9yRXZlbnRzKG51bGwgPT09IChfcmVzaXplRnJhbWUkJGZyYW1lID0gcmVzaXplRnJhbWUuJGZyYW1lKSB8fCB2b2lkIDAgPT09IF9yZXNpemVGcmFtZSQkZnJhbWUgPyB2b2lkIDAgOiBfcmVzaXplRnJhbWUkJGZyYW1lLmZpbmQocmVzaXplckVsZW1lbnRzU2VsZWN0b3IpKTtcclxuICAgICAgICAgICAgICAgIHJlc2l6ZUZyYW1lLiRmcmFtZS5yZW1vdmUoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbnVsbCA9PT0gKF90aGlzJF9mcmFtZXNGb3JUYWJsZTIgPSB0aGlzLl9mcmFtZXNGb3JUYWJsZXMpIHx8IHZvaWQgMCA9PT0gX3RoaXMkX2ZyYW1lc0ZvclRhYmxlMiA/IHZvaWQgMCA6IF90aGlzJF9mcmFtZXNGb3JUYWJsZTIuY2xlYXIoKTtcclxuICAgICAgICBpZiAoY2xlYXJBcnJheSkge1xyXG4gICAgICAgICAgICB0aGlzLl90YWJsZVJlc2l6ZUZyYW1lcyA9IFtdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2RldGFjaFNlcGFyYXRvckV2ZW50cygkbGluZVNlcGFyYXRvcnMpIHtcclxuICAgICAgICAkbGluZVNlcGFyYXRvcnMuZWFjaCgoaSwgJGxpbmVTZXBhcmF0b3IpID0+IHtcclxuICAgICAgICAgICAgZXZlbnRzRW5naW5lLm9mZigkbGluZVNlcGFyYXRvciwgUE9JTlRFUkRPV05fRVZFTlQpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuICAgIF9jcmVhdGVUYWJsZVJlc2l6ZUZyYW1lKCkge1xyXG4gICAgICAgIHJldHVybiAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoRFhfQ09MVU1OX1JFU0laRV9GUkFNRV9DTEFTUykuYXBwZW5kVG8odGhpcy5fcXVpbGxDb250YWluZXIpXHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRnJhbWVzUG9zaXRpb25zKCkge1xyXG4gICAgICAgIGVhY2godGhpcy5fdGFibGVSZXNpemVGcmFtZXMsIChpbmRleCwgdGFibGVSZXNpemVGcmFtZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVGcmFtZVBvc2l0aW9uKHRhYmxlUmVzaXplRnJhbWUuJHRhYmxlLCB0YWJsZVJlc2l6ZUZyYW1lLiRmcmFtZSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUZyYW1lUG9zaXRpb24oJHRhYmxlLCAkZnJhbWUpIHtcclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICB0b3A6IHRhcmdldFRvcCxcclxuICAgICAgICAgICAgbGVmdDogdGFyZ2V0TGVmdFxyXG4gICAgICAgIH0gPSBnZXRCb3VuZGluZ1JlY3QoJHRhYmxlLmdldCgwKSk7XHJcbiAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgdG9wOiBjb250YWluZXJUb3AsXHJcbiAgICAgICAgICAgIGxlZnQ6IGNvbnRhaW5lckxlZnRcclxuICAgICAgICB9ID0gZ2V0Qm91bmRpbmdSZWN0KHRoaXMucXVpbGwucm9vdCk7XHJcbiAgICAgICAgJGZyYW1lLmNzcyh7XHJcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgIHRvcDogdGFyZ2V0VG9wIC0gY29udGFpbmVyVG9wLFxyXG4gICAgICAgICAgICBsZWZ0OiB0YXJnZXRMZWZ0IC0gY29udGFpbmVyTGVmdFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1vdmUoJGZyYW1lLCB7XHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHRvcDogMFxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRnJhbWVzU2VwYXJhdG9ycyhkaXJlY3Rpb24pIHtcclxuICAgICAgICBlYWNoKHRoaXMuX3RhYmxlUmVzaXplRnJhbWVzLCAoaW5kZXgsIGZyYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZyYW1lU2VwYXJhdG9ycyhmcmFtZSwgZGlyZWN0aW9uKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRnJhbWVTZXBhcmF0b3JzKGZyYW1lLCBcInZlcnRpY2FsXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRnJhbWVTZXBhcmF0b3JzKGZyYW1lLCBcImhvcml6b250YWxcIilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBfaXNEcmFnZ2FibGUoJGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gJGVsZW1lbnQuaGFzQ2xhc3MoXCJkeC1kcmFnZ2FibGVcIikgJiYgJGVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKVxyXG4gICAgfVxyXG4gICAgX3JlbW92ZURyYWdnYWJsZSgkY3VycmVudExpbmVTZXBhcmF0b3IsIGxpbmVSZXNpemVyQ2xhc3MpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNEcmFnZ2FibGUoJGN1cnJlbnRMaW5lU2VwYXJhdG9yKSkge1xyXG4gICAgICAgICAgICB2YXIgZHJhZ2dhYmxlID0gJCgkY3VycmVudExpbmVTZXBhcmF0b3IpLmR4RHJhZ2dhYmxlKFwiaW5zdGFuY2VcIik7XHJcbiAgICAgICAgICAgIGRyYWdnYWJsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICQoJGN1cnJlbnRMaW5lU2VwYXJhdG9yKS5hZGRDbGFzcyhsaW5lUmVzaXplckNsYXNzKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXREaXJlY3Rpb25JbmZvKGRpcmVjdGlvbikge1xyXG4gICAgICAgIGlmIChcInZlcnRpY2FsXCIgPT09IGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbGluZVJlc2l6ZXJDbGFzczogRFhfUk9XX1JFU0laRVJfQ0xBU1MsXHJcbiAgICAgICAgICAgICAgICBzaXplRnVuY3Rpb246IHggPT4gZ2V0T3V0ZXJIZWlnaHQoeCksXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNvb3JkaW5hdGU6IFwidG9wXCIsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvblN0eWxlUHJvcGVydHk6IFwiaGVpZ2h0XCIsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNvb3JkaW5hdGVOYW1lOiBcInlcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGxpbmVSZXNpemVyQ2xhc3M6IERYX0NPTFVNTl9SRVNJWkVSX0NMQVNTLFxyXG4gICAgICAgICAgICAgICAgc2l6ZUZ1bmN0aW9uOiB4ID0+IGdldE91dGVyV2lkdGgoeCksXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNvb3JkaW5hdGU6IHRoaXMuZWRpdG9ySW5zdGFuY2Uub3B0aW9uKFwicnRsRW5hYmxlZFwiKSA/IFwicmlnaHRcIiA6IFwibGVmdFwiLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25TdHlsZVByb3BlcnR5OiBcIndpZHRoXCIsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNvb3JkaW5hdGVOYW1lOiBcInhcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldFNpemUoJGVsZW1lbnQsIGRpcmVjdGlvbkluZm8pIHtcclxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uSW5mby5zaXplRnVuY3Rpb24oJGVsZW1lbnQpXHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRnJhbWVTZXBhcmF0b3JzKGZyYW1lLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICB2YXIgJGRldGVybWluYW50RWxlbWVudHMgPSB0aGlzLl9nZXRUYWJsZURldGVybWluYW50RWxlbWVudHMoZnJhbWUuJHRhYmxlLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgIHZhciBkZXRlcm1pbmFudEVsZW1lbnRzQ291bnQgPSAkZGV0ZXJtaW5hbnRFbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGRldGVybWluYW50RWxlbWVudHNTZXBhcmF0b3JzQ291bnQgPSBkZXRlcm1pbmFudEVsZW1lbnRzQ291bnQgLSAxO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb25JbmZvID0gdGhpcy5fZ2V0RGlyZWN0aW9uSW5mbyhkaXJlY3Rpb24pO1xyXG4gICAgICAgIHZhciBsaW5lU2VwYXJhdG9ycyA9IGZyYW1lLiRmcmFtZS5maW5kKFwiLlwiLmNvbmNhdChkaXJlY3Rpb25JbmZvLmxpbmVSZXNpemVyQ2xhc3MpKTtcclxuICAgICAgICB2YXIgc3R5bGVPcHRpb25zID0ge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwibm9uZVwiXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBkZXRlcm1pbmFudEVsZW1lbnRzU2VwYXJhdG9yc0NvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uICs9IHRoaXMuX2dldFNpemUoJGRldGVybWluYW50RWxlbWVudHMuZXEoaSksIGRpcmVjdGlvbkluZm8pO1xyXG4gICAgICAgICAgICBpZiAoIWlzRGVmaW5lZChsaW5lU2VwYXJhdG9yc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVTZXBhcmF0b3JzW2ldID0gJChcIjxkaXY+XCIpLmFkZENsYXNzKGRpcmVjdGlvbkluZm8ubGluZVJlc2l6ZXJDbGFzcykuYXBwZW5kVG8oZnJhbWUuJGZyYW1lKS5nZXQoMClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgJGN1cnJlbnRMaW5lU2VwYXJhdG9yID0gJChsaW5lU2VwYXJhdG9yc1tpXSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZURyYWdnYWJsZSgkY3VycmVudExpbmVTZXBhcmF0b3IsIGRpcmVjdGlvbkluZm8ubGluZVJlc2l6ZXJDbGFzcyk7XHJcbiAgICAgICAgICAgIHN0eWxlT3B0aW9uc1tkaXJlY3Rpb25JbmZvLnBvc2l0aW9uQ29vcmRpbmF0ZV0gPSBjdXJyZW50UG9zaXRpb24gLSBEUkFHR0FCTEVfRUxFTUVOVF9PRkZTRVQ7XHJcbiAgICAgICAgICAgICQoJGN1cnJlbnRMaW5lU2VwYXJhdG9yKS5jc3Moc3R5bGVPcHRpb25zKTtcclxuICAgICAgICAgICAgdmFyIGF0dGFjaFNlcGFyYXRvckRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lU2VwYXJhdG9yOiBsaW5lU2VwYXJhdG9yc1tpXSxcclxuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxyXG4gICAgICAgICAgICAgICAgJGRldGVybWluYW50RWxlbWVudHM6ICRkZXRlcm1pbmFudEVsZW1lbnRzLFxyXG4gICAgICAgICAgICAgICAgZnJhbWU6IGZyYW1lLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fYXR0YWNoQ29sdW1uU2VwYXJhdG9yRXZlbnRzKGF0dGFjaFNlcGFyYXRvckRhdGEpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldFRhYmxlRGV0ZXJtaW5hbnRFbGVtZW50cygkdGFibGUsIGRpcmVjdGlvbikge1xyXG4gICAgICAgIGlmIChcInZlcnRpY2FsXCIgPT09IGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gJHRhYmxlLmZpbmQoXCJ0aDpmaXJzdC1jaGlsZCwgdGQ6Zmlyc3QtY2hpbGRcIilcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29sdW1uRWxlbWVudHMoJHRhYmxlKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9hdHRhY2hDb2x1bW5TZXBhcmF0b3JFdmVudHMob3B0aW9ucykge1xyXG4gICAgICAgIGV2ZW50c0VuZ2luZS5vbihvcHRpb25zLmxpbmVTZXBhcmF0b3IsIFBPSU5URVJET1dOX0VWRU5ULCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZURyYWdnYWJsZUVsZW1lbnQob3B0aW9ucylcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgX2RyYWdTdGFydEhhbmRsZXIoX3JlZikge1xyXG4gICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICRkZXRlcm1pbmFudEVsZW1lbnRzOiAkZGV0ZXJtaW5hbnRFbGVtZW50cyxcclxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICBmcmFtZTogZnJhbWUsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICBsaW5lU2VwYXJhdG9yOiBsaW5lU2VwYXJhdG9yXHJcbiAgICAgICAgfSA9IF9yZWY7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbkluZm8gPSB0aGlzLl9nZXREaXJlY3Rpb25JbmZvKGRpcmVjdGlvbik7XHJcbiAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fZml4Q29sdW1uc1dpZHRoKGZyYW1lLiR0YWJsZSk7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRMaW5lU2l6ZSA9IHBhcnNlSW50KHRoaXMuX2dldFNpemUoJCgkZGV0ZXJtaW5hbnRFbGVtZW50c1tpbmRleF0pLCBkaXJlY3Rpb25JbmZvKSk7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRUYWJsZVdpZHRoID0gZ2V0T3V0ZXJXaWR0aChmcmFtZS4kdGFibGUpO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0TGluZVNlcGFyYXRvclBvc2l0aW9uID0gcGFyc2VJbnQoJChsaW5lU2VwYXJhdG9yKS5jc3MoZGlyZWN0aW9uSW5mby5wb3NpdGlvbkNvb3JkaW5hdGUpKTtcclxuICAgICAgICB0aGlzLl9uZXh0TGluZVNpemUgPSAwO1xyXG4gICAgICAgIGlmICgkZGV0ZXJtaW5hbnRFbGVtZW50c1tpbmRleCArIDFdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25leHRMaW5lU2l6ZSA9IHBhcnNlSW50KHRoaXMuX2dldFNpemUoJCgkZGV0ZXJtaW5hbnRFbGVtZW50c1tpbmRleCArIDFdKSwgZGlyZWN0aW9uSW5mbykpXHJcbiAgICAgICAgfSBlbHNlIGlmIChcImhvcml6b250YWxcIiA9PT0gZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHVuZml4VGFibGVXaWR0aChmcmFtZS4kdGFibGUsIHtcclxuICAgICAgICAgICAgICAgIHF1aWxsOiB0aGlzLnF1aWxsXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3Nob3VsZFJldmVydE9mZnNldChkaXJlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gXCJob3Jpem9udGFsXCIgPT09IGRpcmVjdGlvbiAmJiB0aGlzLmVkaXRvckluc3RhbmNlLm9wdGlvbihcInJ0bEVuYWJsZWRcIilcclxuICAgIH1cclxuICAgIF9pc05leHRDb2x1bW5XaWR0aEVub3VnaChuZXh0Q29sdW1uTmV3U2l6ZSwgJG5leHRDb2x1bW5FbGVtZW50LCBldmVudE9mZnNldCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbmV4dExpbmVTaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0Q29sdW1uTmV3U2l6ZSA+PSB0aGlzLl9taW5Db2x1bW5XaWR0aCkge1xyXG4gICAgICAgICAgICB2YXIgaXNXaWR0aEluY3JlYXNlZCA9IHRoaXMuX25leHRDb2x1bW5PZmZzZXRMaW1pdCA/IGV2ZW50T2Zmc2V0IDwgdGhpcy5fbmV4dENvbHVtbk9mZnNldExpbWl0IDogZXZlbnRPZmZzZXQgPCAwO1xyXG4gICAgICAgICAgICB2YXIgaXNXaWR0aExpbWl0ZWQgPSBNYXRoLmFicyh0aGlzLl9nZXRXaWR0aFN0eWxlVmFsdWUoJG5leHRDb2x1bW5FbGVtZW50KSAtIGdldE91dGVyV2lkdGgoJG5leHRDb2x1bW5FbGVtZW50KSkgPiBST1VHSF9PRkZTRVQ7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1dpZHRoSW5jcmVhc2VkIHx8ICFpc1dpZHRoTGltaXRlZFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICAgIF9zaG91bGRTZXROZXh0Q29sdW1uV2lkdGgobmV4dENvbHVtbk5ld1NpemUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmV4dExpbmVTaXplICYmIG5leHRDb2x1bW5OZXdTaXplID4gMFxyXG4gICAgfVxyXG4gICAgX2hvcml6b250YWxEcmFnSGFuZGxlcihfcmVmMikge1xyXG4gICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lTmV3U2l6ZTogY3VycmVudExpbmVOZXdTaXplLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb25JbmZvOiBkaXJlY3Rpb25JbmZvLFxyXG4gICAgICAgICAgICBldmVudE9mZnNldDogZXZlbnRPZmZzZXQsXHJcbiAgICAgICAgICAgICRkZXRlcm1pbmFudEVsZW1lbnRzOiAkZGV0ZXJtaW5hbnRFbGVtZW50cyxcclxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICBmcmFtZTogZnJhbWVcclxuICAgICAgICB9ID0gX3JlZjI7XHJcbiAgICAgICAgdmFyIG5leHRDb2x1bW5OZXdTaXplID0gdGhpcy5fbmV4dExpbmVTaXplICYmIHRoaXMuX25leHRMaW5lU2l6ZSAtIGV2ZW50T2Zmc2V0O1xyXG4gICAgICAgIHZhciBpc0N1cnJlbnRDb2x1bW5XaWR0aEVub3VnaCA9IGN1cnJlbnRMaW5lTmV3U2l6ZSA+PSB0aGlzLl9taW5Db2x1bW5XaWR0aDtcclxuICAgICAgICB2YXIgJGxpbmVFbGVtZW50cyA9IGdldExpbmVFbGVtZW50cyhmcmFtZS4kdGFibGUsIGluZGV4KTtcclxuICAgICAgICB2YXIgJG5leHRMaW5lRWxlbWVudHMgPSBnZXRMaW5lRWxlbWVudHMoZnJhbWUuJHRhYmxlLCBpbmRleCArIDEpO1xyXG4gICAgICAgIHZhciByZWFsV2lkdGhEaWZmID0gZ2V0T3V0ZXJXaWR0aCgkbGluZUVsZW1lbnRzLmVxKDApKSAtIGN1cnJlbnRMaW5lTmV3U2l6ZTtcclxuICAgICAgICBpZiAoaXNDdXJyZW50Q29sdW1uV2lkdGhFbm91Z2gpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTmV4dENvbHVtbldpZHRoRW5vdWdoKG5leHRDb2x1bW5OZXdTaXplLCAkZGV0ZXJtaW5hbnRFbGVtZW50cy5lcShpbmRleCArIDEpLCBldmVudE9mZnNldCkpIHtcclxuICAgICAgICAgICAgICAgIHNldExpbmVFbGVtZW50c0Zvcm1hdCh0aGlzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6ICRsaW5lRWxlbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGRpcmVjdGlvbkluZm8ucG9zaXRpb25TdHlsZVByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50TGluZU5ld1NpemVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFNldE5leHRDb2x1bW5XaWR0aChuZXh0Q29sdW1uTmV3U2l6ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRMaW5lRWxlbWVudHNGb3JtYXQodGhpcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogJG5leHRMaW5lRWxlbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBkaXJlY3Rpb25JbmZvLnBvc2l0aW9uU3R5bGVQcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5leHRDb2x1bW5OZXdTaXplXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBpc1RhYmxlV2lkdGhDaGFuZ2VkID0gTWF0aC5hYnModGhpcy5fc3RhcnRUYWJsZVdpZHRoIC0gZ2V0T3V0ZXJXaWR0aChmcmFtZS4kdGFibGUpKSA8IFJPVUdIX09GRlNFVDtcclxuICAgICAgICAgICAgICAgIHZhciBzaG91bGRSZXZlcnROZXdWYWx1ZSA9IE1hdGguYWJzKHJlYWxXaWR0aERpZmYpID4gUk9VR0hfT0ZGU0VUIHx8ICF0aGlzLl9uZXh0TGluZVNpemUgJiYgaXNUYWJsZVdpZHRoQ2hhbmdlZDtcclxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZXZlcnROZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldExpbmVFbGVtZW50c0Zvcm1hdCh0aGlzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiAkbGluZUVsZW1lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogZGlyZWN0aW9uSW5mby5wb3NpdGlvblN0eWxlUHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRPdXRlcldpZHRoKCRsaW5lRWxlbWVudHMuZXEoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbHVtbk5ld1NpemUgKz0gY3VycmVudExpbmVOZXdTaXplIC0gZ2V0T3V0ZXJXaWR0aCgkbGluZUVsZW1lbnRzLmVxKDApKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkU2V0TmV4dENvbHVtbldpZHRoKG5leHRDb2x1bW5OZXdTaXplKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRMaW5lRWxlbWVudHNGb3JtYXQodGhpcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6ICRuZXh0TGluZUVsZW1lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGRpcmVjdGlvbkluZm8ucG9zaXRpb25TdHlsZVByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5leHRDb2x1bW5OZXdTaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dENvbHVtbk9mZnNldExpbWl0ID0gdGhpcy5fbmV4dENvbHVtbk9mZnNldExpbWl0IHx8IGV2ZW50T2Zmc2V0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fJGhpZ2hsaWdodGVkRWxlbWVudC5jc3MoZGlyZWN0aW9uSW5mby5wb3NpdGlvbkNvb3JkaW5hdGUsIHRoaXMuX3N0YXJ0TGluZVNlcGFyYXRvclBvc2l0aW9uICsgZXZlbnRPZmZzZXQgKyByZWFsV2lkdGhEaWZmICsgXCJweFwiKVxyXG4gICAgfVxyXG4gICAgX3ZlcnRpY2FsRHJhZ0hhbmRsZXIoX3JlZjMpIHtcclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICBjdXJyZW50TGluZU5ld1NpemU6IGN1cnJlbnRMaW5lTmV3U2l6ZSxcclxuICAgICAgICAgICAgZGlyZWN0aW9uSW5mbzogZGlyZWN0aW9uSW5mbyxcclxuICAgICAgICAgICAgZXZlbnRPZmZzZXQ6IGV2ZW50T2Zmc2V0LFxyXG4gICAgICAgICAgICAkZGV0ZXJtaW5hbnRFbGVtZW50czogJGRldGVybWluYW50RWxlbWVudHMsXHJcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgICAgICAgZnJhbWU6IGZyYW1lXHJcbiAgICAgICAgfSA9IF9yZWYzO1xyXG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSBNYXRoLm1heChjdXJyZW50TGluZU5ld1NpemUsIHRoaXMuX21pblJvd0hlaWdodCk7XHJcbiAgICAgICAgdmFyICRsaW5lRWxlbWVudHMgPSBnZXRMaW5lRWxlbWVudHMoZnJhbWUuJHRhYmxlLCBpbmRleCwgXCJ2ZXJ0aWNhbFwiKTtcclxuICAgICAgICBzZXRMaW5lRWxlbWVudHNGb3JtYXQodGhpcywge1xyXG4gICAgICAgICAgICBlbGVtZW50czogJGxpbmVFbGVtZW50cyxcclxuICAgICAgICAgICAgcHJvcGVydHk6IGRpcmVjdGlvbkluZm8ucG9zaXRpb25TdHlsZVByb3BlcnR5LFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3SGVpZ2h0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHJvd0hlaWdodERpZmYgPSBnZXRPdXRlckhlaWdodCgkZGV0ZXJtaW5hbnRFbGVtZW50cy5lcShpbmRleCkpIC0gY3VycmVudExpbmVOZXdTaXplO1xyXG4gICAgICAgIHRoaXMuXyRoaWdobGlnaHRlZEVsZW1lbnQuY3NzKGRpcmVjdGlvbkluZm8ucG9zaXRpb25Db29yZGluYXRlLCB0aGlzLl9zdGFydExpbmVTZXBhcmF0b3JQb3NpdGlvbiArIGV2ZW50T2Zmc2V0ICsgcm93SGVpZ2h0RGlmZiArIFwicHhcIilcclxuICAgIH1cclxuICAgIF9kcmFnTW92ZUhhbmRsZXIoZXZlbnQsIF9yZWY0KSB7XHJcbiAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgJGRldGVybWluYW50RWxlbWVudHM6ICRkZXRlcm1pbmFudEVsZW1lbnRzLFxyXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgIGZyYW1lOiBmcmFtZSxcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cclxuICAgICAgICB9ID0gX3JlZjQ7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbkluZm8gPSB0aGlzLl9nZXREaXJlY3Rpb25JbmZvKGRpcmVjdGlvbik7XHJcbiAgICAgICAgdmFyIGV2ZW50T2Zmc2V0ID0gZXZlbnQub2Zmc2V0W2RpcmVjdGlvbkluZm8ucG9zaXRpb25Db29yZGluYXRlTmFtZV07XHJcbiAgICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZS5fc2F2ZVZhbHVlQ2hhbmdlRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRSZXZlcnRPZmZzZXQoZGlyZWN0aW9uKSkge1xyXG4gICAgICAgICAgICBldmVudE9mZnNldCA9IC1ldmVudE9mZnNldFxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3VycmVudExpbmVOZXdTaXplID0gdGhpcy5fc3RhcnRMaW5lU2l6ZSArIGV2ZW50T2Zmc2V0O1xyXG4gICAgICAgIGlmIChcImhvcml6b250YWxcIiA9PT0gZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hvcml6b250YWxEcmFnSGFuZGxlcih7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZU5ld1NpemU6IGN1cnJlbnRMaW5lTmV3U2l6ZSxcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbkluZm86IGRpcmVjdGlvbkluZm8sXHJcbiAgICAgICAgICAgICAgICBldmVudE9mZnNldDogZXZlbnRPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAkZGV0ZXJtaW5hbnRFbGVtZW50czogJGRldGVybWluYW50RWxlbWVudHMsXHJcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBmcmFtZTogZnJhbWVcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl92ZXJ0aWNhbERyYWdIYW5kbGVyKHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lTmV3U2l6ZTogY3VycmVudExpbmVOZXdTaXplLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uSW5mbzogZGlyZWN0aW9uSW5mbyxcclxuICAgICAgICAgICAgICAgIGV2ZW50T2Zmc2V0OiBldmVudE9mZnNldCxcclxuICAgICAgICAgICAgICAgICRkZXRlcm1pbmFudEVsZW1lbnRzOiAkZGV0ZXJtaW5hbnRFbGVtZW50cyxcclxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgICAgICAgICAgIGZyYW1lOiBmcmFtZVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl91cGRhdGVGcmFtZVBvc2l0aW9uKGZyYW1lLiR0YWJsZSwgZnJhbWUuJGZyYW1lKVxyXG4gICAgfVxyXG4gICAgX2RyYWdFbmRIYW5kbGVyKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMkXyRoaWdobGlnaHRlZEVsO1xyXG4gICAgICAgIG51bGwgPT09IChfdGhpcyRfJGhpZ2hsaWdodGVkRWwgPSB0aGlzLl8kaGlnaGxpZ2h0ZWRFbGVtZW50KSB8fCB2b2lkIDAgPT09IF90aGlzJF8kaGlnaGxpZ2h0ZWRFbCA/IHZvaWQgMCA6IF90aGlzJF8kaGlnaGxpZ2h0ZWRFbC5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdm9pZCAwO1xyXG4gICAgICAgIHRoaXMuX25leHRDb2x1bW5PZmZzZXRMaW1pdCA9IHZvaWQgMDtcclxuICAgICAgICB0aGlzLl90YWJsZUxhc3RXaWR0aChvcHRpb25zLmZyYW1lLCBnZXRPdXRlcldpZHRoKG9wdGlvbnMuZnJhbWUuJHRhYmxlKSk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlRnJhbWVzUG9zaXRpb25zKCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlRnJhbWVzU2VwYXJhdG9ycygpXHJcbiAgICB9XHJcbiAgICBfaXNMYXN0Q29sdW1uUmVzaXppbmcoX3JlZjUpIHtcclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAkZGV0ZXJtaW5hbnRFbGVtZW50czogJGRldGVybWluYW50RWxlbWVudHMsXHJcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxyXG4gICAgICAgIH0gPSBfcmVmNTtcclxuICAgICAgICByZXR1cm4gIWlzRGVmaW5lZCgkZGV0ZXJtaW5hbnRFbGVtZW50c1tpbmRleCArIDFdKVxyXG4gICAgfVxyXG4gICAgX2dldEJvdW5kYXJ5Q29uZmlnKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgaWYgKFwidmVydGljYWxcIiA9PT0gb3B0aW9ucy5kaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgcmVzdWx0LmJvdW5kYXJ5ID0gb3B0aW9ucy5mcmFtZS4kdGFibGU7XHJcbiAgICAgICAgICAgIHJlc3VsdC5ib3VuZE9mZnNldCA9IHtcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogaGFzV2luZG93KCkgPyAtZ2V0SGVpZ2h0KGdldFdpbmRvdygpKSA6IC1nZXRPdXRlckhlaWdodCh0aGlzLl9xdWlsbENvbnRhaW5lciksXHJcbiAgICAgICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzTGFzdENvbHVtblJlc2l6aW5nKG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5ib3VuZGFyeSA9IG9wdGlvbnMuZnJhbWUuJHRhYmxlXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyICRjb250ZW50ID0gdGhpcy5lZGl0b3JJbnN0YW5jZS5fZ2V0Q29udGVudCgpO1xyXG4gICAgICAgICAgICByZXN1bHQuYm91bmRhcnkgPSAkY29udGVudDtcclxuICAgICAgICAgICAgcmVzdWx0LmJvdW5kT2Zmc2V0ID0ge1xyXG4gICAgICAgICAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogJGNvbnRlbnQuY3NzKFwicGFkZGluZ0xlZnRcIiksXHJcbiAgICAgICAgICAgICAgICByaWdodDogJGNvbnRlbnQuY3NzKFwicGFkZGluZ1JpZ2h0XCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgfVxyXG4gICAgX2NyZWF0ZURyYWdnYWJsZUVsZW1lbnQob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyRfJGhpZ2hsaWdodGVkRWwyO1xyXG4gICAgICAgIHZhciBib3VuZGFyeUNvbmZpZyA9IHRoaXMuX2dldEJvdW5kYXJ5Q29uZmlnKG9wdGlvbnMpO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb25DbGFzcyA9IFwidmVydGljYWxcIiA9PT0gb3B0aW9ucy5kaXJlY3Rpb24gPyBcImR4LWh0bWxlZGl0b3ItaGlnaGxpZ2h0ZWQtcm93XCIgOiBcImR4LWh0bWxlZGl0b3ItaGlnaGxpZ2h0ZWQtY29sdW1uXCI7XHJcbiAgICAgICAgbnVsbCA9PT0gKF90aGlzJF8kaGlnaGxpZ2h0ZWRFbDIgPSB0aGlzLl8kaGlnaGxpZ2h0ZWRFbGVtZW50KSB8fCB2b2lkIDAgPT09IF90aGlzJF8kaGlnaGxpZ2h0ZWRFbDIgPyB2b2lkIDAgOiBfdGhpcyRfJGhpZ2hsaWdodGVkRWwyLnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMuXyRoaWdobGlnaHRlZEVsZW1lbnQgPSAkKFwiPGRpdj5cIikuYWRkQ2xhc3MoXCJcIi5jb25jYXQoZGlyZWN0aW9uQ2xhc3MpKS5pbnNlcnRBZnRlcigkKG9wdGlvbnMubGluZVNlcGFyYXRvcikpO1xyXG4gICAgICAgIHZhciBjb25maWcgPSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnRUZW1wbGF0ZTogbnVsbCxcclxuICAgICAgICAgICAgYWxsb3dNb3ZlQnlDbGljazogZmFsc2UsXHJcbiAgICAgICAgICAgIGRyYWdEaXJlY3Rpb246IG9wdGlvbnMuZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICBvbkRyYWdNb3ZlOiBfcmVmNiA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxyXG4gICAgICAgICAgICAgICAgfSA9IF9yZWY2O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ01vdmVIYW5kbGVyKGV2ZW50LCBvcHRpb25zKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkRyYWdTdGFydDogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ1N0YXJ0SGFuZGxlcihvcHRpb25zKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkRyYWdFbmQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdFbmRIYW5kbGVyKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJvdW5kYXJ5Q29uZmlnKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50RHJhZ2dhYmxlRWxlbWVudCA9IHRoaXMuZWRpdG9ySW5zdGFuY2UuX2NyZWF0ZUNvbXBvbmVudChvcHRpb25zLmxpbmVTZXBhcmF0b3IsIERyYWdnYWJsZSwgY29uZmlnKVxyXG4gICAgfVxyXG4gICAgX2ZpeENvbHVtbnNXaWR0aCgkdGFibGUpIHtcclxuICAgICAgICB2YXIgZGV0ZXJtaW5hbnRFbGVtZW50cyA9IHRoaXMuX2dldFRhYmxlRGV0ZXJtaW5hbnRFbGVtZW50cygkdGFibGUpO1xyXG4gICAgICAgIGVhY2goZGV0ZXJtaW5hbnRFbGVtZW50cywgKGluZGV4LCBlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5XaWR0aCA9IGdldE91dGVyV2lkdGgoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIHZhciAkbGluZUVsZW1lbnRzID0gZ2V0TGluZUVsZW1lbnRzKCR0YWJsZSwgaW5kZXgpO1xyXG4gICAgICAgICAgICBzZXRMaW5lRWxlbWVudHNGb3JtYXQodGhpcywge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudHM6ICRsaW5lRWxlbWVudHMsXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogXCJ3aWR0aFwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IE1hdGgubWF4KGNvbHVtbldpZHRoLCB0aGlzLl9taW5Db2x1bW5XaWR0aClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgX2dldENvbHVtbkVsZW1lbnRzU3VtKGNvbHVtbkVsZW1lbnRzKSB7XHJcbiAgICAgICAgdmFyIGNvbHVtbnNXaWR0aHMgPSBbXTtcclxuICAgICAgICB2YXIgY29sdW1uc1N1bSA9IDA7XHJcbiAgICAgICAgZWFjaChjb2x1bW5FbGVtZW50cywgKGluZGV4LCBlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIHZhciBjb2x1bW5XaWR0aCA9IHRoaXMuX2dldFdpZHRoU3R5bGVWYWx1ZSgkZWxlbWVudCkgfHwgZ2V0T3V0ZXJXaWR0aCgkZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGNvbHVtbnNXaWR0aHNbaW5kZXhdID0gTWF0aC5tYXgoY29sdW1uV2lkdGgsIHRoaXMuX21pbkNvbHVtbldpZHRoKTtcclxuICAgICAgICAgICAgY29sdW1uc1N1bSArPSBjb2x1bW5zV2lkdGhzW2luZGV4XVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbHVtbnNXaWR0aHM6IGNvbHVtbnNXaWR0aHMsXHJcbiAgICAgICAgICAgIGNvbHVtbnNTdW06IGNvbHVtbnNTdW1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc2V0Q29sdW1uc1JhdGlvV2lkdGgoY29sdW1uRWxlbWVudHMsIHJhdGlvLCBjb2x1bW5zV2lkdGhzLCAkdGFibGUpIHtcclxuICAgICAgICBlYWNoKGNvbHVtbkVsZW1lbnRzLCBpbmRleCA9PiB7XHJcbiAgICAgICAgICAgIHZhciAkbGluZUVsZW1lbnRzID0gZ2V0TGluZUVsZW1lbnRzKCR0YWJsZSwgaW5kZXgpO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0V2lkdGg7XHJcbiAgICAgICAgICAgIGlmIChyYXRpbyA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFdpZHRoID0gdGhpcy5fbWluQ29sdW1uV2lkdGggKyBNYXRoLnJvdW5kKChjb2x1bW5zV2lkdGhzW2luZGV4XSAtIHRoaXMuX21pbkNvbHVtbldpZHRoKSAqIHJhdGlvKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0V2lkdGggPSB0aGlzLl9taW5Db2x1bW5XaWR0aFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldExpbmVFbGVtZW50c0Zvcm1hdCh0aGlzLCB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50czogJGxpbmVFbGVtZW50cyxcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBcIndpZHRoXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0V2lkdGhcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUNvbHVtbnNXaWR0aCgkdGFibGUsIGZyYW1lSW5kZXgpIHtcclxuICAgICAgICB2YXIgZGV0ZXJtaW5hbnRFbGVtZW50cyA9IHRoaXMuX2dldFRhYmxlRGV0ZXJtaW5hbnRFbGVtZW50cygkdGFibGUpO1xyXG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMuX3RhYmxlUmVzaXplRnJhbWVzW2ZyYW1lSW5kZXhdO1xyXG4gICAgICAgIGlmICghZnJhbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGFibGVSZXNpemVGcmFtZXNbZnJhbWVJbmRleF0gPSB7fVxyXG4gICAgICAgIH1cclxuICAgICAgICBmcmFtZSA9IHRoaXMuX3RhYmxlUmVzaXplRnJhbWVzW2ZyYW1lSW5kZXhdO1xyXG4gICAgICAgIHZhciB0YWJsZVdpZHRoID0gdGhpcy5fdGFibGVMYXN0V2lkdGgoZnJhbWUpIHx8IGdldE91dGVyV2lkdGgoJHRhYmxlKTtcclxuICAgICAgICB2YXIgcmF0aW87XHJcbiAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgY29sdW1uc1dpZHRoczogY29sdW1uc1dpZHRocyxcclxuICAgICAgICAgICAgY29sdW1uc1N1bTogY29sdW1uc1N1bVxyXG4gICAgICAgIH0gPSB0aGlzLl9nZXRDb2x1bW5FbGVtZW50c1N1bShkZXRlcm1pbmFudEVsZW1lbnRzKTtcclxuICAgICAgICB2YXIgbWluV2lkdGhGb3JDb2x1bW5zID0gZGV0ZXJtaW5hbnRFbGVtZW50cy5sZW5ndGggKiB0aGlzLl9taW5Db2x1bW5XaWR0aDtcclxuICAgICAgICBpZiAoY29sdW1uc1N1bSA+IG1pbldpZHRoRm9yQ29sdW1ucykge1xyXG4gICAgICAgICAgICByYXRpbyA9ICh0YWJsZVdpZHRoIC0gbWluV2lkdGhGb3JDb2x1bW5zKSAvIChjb2x1bW5zU3VtIC0gbWluV2lkdGhGb3JDb2x1bW5zKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJhdGlvID0gLTFcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdGFibGVMYXN0V2lkdGgoZnJhbWUsIHJhdGlvID4gMCA/IHRhYmxlV2lkdGggOiBtaW5XaWR0aEZvckNvbHVtbnMpO1xyXG4gICAgICAgIHRoaXMuX3NldENvbHVtbnNSYXRpb1dpZHRoKGRldGVybWluYW50RWxlbWVudHMsIHJhdGlvLCBjb2x1bW5zV2lkdGhzLCAkdGFibGUpXHJcbiAgICB9XHJcbiAgICBfdXBkYXRlVGFibGVzQ29sdW1uc1dpZHRoKCR0YWJsZXMpIHtcclxuICAgICAgICBlYWNoKCR0YWJsZXMsIChpbmRleCwgdGFibGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29sdW1uc1dpZHRoKCQodGFibGUpLCBpbmRleClcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgb3B0aW9uKG9wdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoXCJ0YWJsZVJlc2l6aW5nXCIgPT09IG9wdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZU9wdGlvbkNoYW5nZVZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChcImVuYWJsZWRcIiA9PT0gb3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB2YWx1ZSA/IHRoaXMuX2FwcGx5UmVzaXppbmcodHJ1ZSkgOiB0aGlzLmNsZWFuKClcclxuICAgICAgICB9IGVsc2UgaWYgKFtcIm1pbkNvbHVtbldpZHRoXCIsIFwibWluUm93SGVpZ2h0XCJdLmluY2x1ZGVzKG9wdGlvbikpIHtcclxuICAgICAgICAgICAgdGhpc1tcIl9cIi5jb25jYXQob3B0aW9uKV0gPSB0aGlzLl9taW5TaXplTGltaXQob3B0aW9uLCB2YWx1ZSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbGVhbigpIHtcclxuICAgICAgICB0aGlzLl9yZW1vdmVSZXNpemVGcmFtZXModHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5fZGV0YWNoRXZlbnRzKCk7XHJcbiAgICAgICAgX3dpbmRvd1Jlc2l6ZUNhbGxiYWNrcy5yZW1vdmUodGhpcy5fcmVzaXplSGFuZGxlcldpdGhDb250ZXh0KTtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fd2luZG93UmVzaXplVGltZW91dCk7XHJcbiAgICAgICAgdGhpcy5fcmVzaXplSGFuZGxlcldpdGhDb250ZXh0ID0gdm9pZCAwO1xyXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB2b2lkIDA7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRUYWJsZVdpZHRoID0gdm9pZCAwO1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9hdHRhY2hSZXNpemVyVGltZW91dClcclxuICAgIH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/modules/tableResizing.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/modules/toolbar.js":
/*!***********************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/modules/toolbar.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ \"./node_modules/devextreme/esm/ui/html_editor/modules/base.js\");\n/* harmony import */ var _toolbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../toolbar */ \"./node_modules/devextreme/esm/ui/toolbar.js\");\n/* harmony import */ var _select_box__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../select_box */ \"./node_modules/devextreme/esm/ui/select_box.js\");\n/* harmony import */ var _color_box_color_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../color_box/color_view */ \"./node_modules/devextreme/esm/ui/color_box/color_view.js\");\n/* harmony import */ var _number_box__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../number_box */ \"./node_modules/devextreme/esm/ui/number_box.js\");\n/* harmony import */ var _widget_ui_errors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../widget/ui.errors */ \"./node_modules/devextreme/esm/ui/widget/ui.errors.js\");\n/* harmony import */ var _widget_collector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./widget_collector */ \"./node_modules/devextreme/esm/ui/html_editor/modules/widget_collector.js\");\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _localization_message__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../localization/message */ \"./node_modules/devextreme/esm/localization/message.js\");\n/* harmony import */ var _core_utils_inflector__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../core/utils/inflector */ \"./node_modules/devextreme/esm/core/utils/inflector.js\");\n/* harmony import */ var _events_core_events_engine__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../events/core/events_engine */ \"./node_modules/devextreme/esm/events/core/events_engine.js\");\n/* harmony import */ var _events_utils_index__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../events/utils/index */ \"./node_modules/devextreme/esm/events/utils/index.js\");\n/* harmony import */ var _utils_table_helper__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/table_helper */ \"./node_modules/devextreme/esm/ui/html_editor/utils/table_helper.js\");\n/* harmony import */ var _utils_toolbar_helper__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../utils/toolbar_helper */ \"./node_modules/devextreme/esm/ui/html_editor/utils/toolbar_helper.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/modules/toolbar.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar ToolbarModule = _base__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a) {\r\n    var TOOLBAR_WRAPPER_CLASS = \"dx-htmleditor-toolbar-wrapper\";\r\n    var TOOLBAR_CLASS = \"dx-htmleditor-toolbar\";\r\n    var TOOLBAR_FORMAT_WIDGET_CLASS = \"dx-htmleditor-toolbar-format\";\r\n    var TOOLBAR_SEPARATOR_CLASS = \"dx-htmleditor-toolbar-separator\";\r\n    var TOOLBAR_MENU_SEPARATOR_CLASS = \"dx-htmleditor-toolbar-menu-separator\";\r\n    var ACTIVE_FORMAT_CLASS = \"dx-format-active\";\r\n    var ICON_CLASS = \"dx-icon\";\r\n    var SELECTION_CHANGE_EVENT = \"selection-change\";\r\n    var USER_ACTION = \"user\";\r\n    var SILENT_ACTION = \"silent\";\r\n    var FORMAT_HOTKEYS = {\r\n        66: \"bold\",\r\n        73: \"italic\",\r\n        85: \"underline\"\r\n    };\r\n    var KEY_CODES = {\r\n        b: 66,\r\n        i: 73,\r\n        u: 85\r\n    };\r\n    var localize = name => _localization_message__WEBPACK_IMPORTED_MODULE_12__[\"default\"].format(\"dxHtmlEditor-\".concat(Object(_core_utils_inflector__WEBPACK_IMPORTED_MODULE_13__[\"camelize\"])(name)));\r\n    var localizeValue = (value, name) => {\r\n        if (\"header\" === name) {\r\n            var isHeaderValue = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_10__[\"isDefined\"])(value) && false !== value;\r\n            return isHeaderValue ? \"\".concat(localize(\"heading\"), \" \").concat(value) : localize(\"normalText\")\r\n        }\r\n        return localize(value) || value\r\n    };\r\n    ToolbarModule = class extends _base__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\r\n        constructor(quill, options) {\r\n            super(quill, options);\r\n            this._toolbarWidgets = new _widget_collector__WEBPACK_IMPORTED_MODULE_8__[\"default\"];\r\n            this._formatHandlers = Object(_utils_toolbar_helper__WEBPACK_IMPORTED_MODULE_17__[\"getFormatHandlers\"])(this);\r\n            this._tableFormats = Object(_utils_table_helper__WEBPACK_IMPORTED_MODULE_16__[\"getTableFormats\"])(quill);\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_10__[\"isDefined\"])(options.items)) {\r\n                this._addCallbacks();\r\n                this._renderToolbar();\r\n                this.quill.on(\"editor-change\", (eventName, newValue, oldValue, eventSource) => {\r\n                    var isSilentMode = eventSource === SILENT_ACTION && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_10__[\"isEmptyObject\"])(this.quill.getFormat());\r\n                    if (!isSilentMode) {\r\n                        var isSelectionChanged = eventName === SELECTION_CHANGE_EVENT;\r\n                        this._updateToolbar(isSelectionChanged)\r\n                    }\r\n                })\r\n            }\r\n        }\r\n        _addCallbacks() {\r\n            this.addCleanCallback(this.clean.bind(this));\r\n            this.editorInstance.addContentInitializedCallback(this.updateHistoryWidgets.bind(this))\r\n        }\r\n        _updateToolbar(isSelectionChanged) {\r\n            this.updateFormatWidgets(isSelectionChanged);\r\n            this.updateHistoryWidgets();\r\n            this.updateTableWidgets()\r\n        }\r\n        _updateFormatWidget(name, isApplied, formats) {\r\n            var widget = this._toolbarWidgets.getByName(name);\r\n            if (!widget) {\r\n                return\r\n            }\r\n            if (isApplied) {\r\n                this._markActiveFormatWidget(name, widget, formats)\r\n            } else {\r\n                this._resetFormatWidget(name, widget);\r\n                if (Object.prototype.hasOwnProperty.call(name)) {\r\n                    delete formats[name]\r\n                }\r\n            }\r\n            this._toggleClearFormatting(isApplied || !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_10__[\"isEmptyObject\"])(formats))\r\n        }\r\n        _renderToolbar() {\r\n            var container = this.options.container || this._getContainer();\r\n            this._$toolbar = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\").addClass(TOOLBAR_CLASS).appendTo(container);\r\n            this._$toolbarContainer = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(container).addClass(TOOLBAR_WRAPPER_CLASS);\r\n            _events_core_events_engine__WEBPACK_IMPORTED_MODULE_14__[\"default\"].on(this._$toolbarContainer, Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_15__[\"addNamespace\"])(\"mousedown\", this.editorInstance.NAME), e => {\r\n                e.preventDefault()\r\n            });\r\n            this._subscribeFormatHotKeys();\r\n            this.toolbarInstance = this.editorInstance._createComponent(this._$toolbar, _toolbar__WEBPACK_IMPORTED_MODULE_3__[\"default\"], this.toolbarConfig);\r\n            this.editorInstance.on(\"optionChanged\", _ref => {\r\n                var {\r\n                    name: name\r\n                } = _ref;\r\n                if (\"readOnly\" === name || \"disabled\" === name) {\r\n                    this.toolbarInstance.option(\"disabled\", this.isInteractionDisabled)\r\n                }\r\n            })\r\n        }\r\n        get toolbarConfig() {\r\n            return {\r\n                dataSource: this._prepareToolbarItems(),\r\n                disabled: this.isInteractionDisabled,\r\n                menuContainer: this._$toolbarContainer,\r\n                multiline: this.isMultilineMode()\r\n            }\r\n        }\r\n        get isInteractionDisabled() {\r\n            return this.editorInstance.option(\"readOnly\") || this.editorInstance.option(\"disabled\")\r\n        }\r\n        isMultilineMode() {\r\n            var _this$options$multili;\r\n            return null !== (_this$options$multili = this.options.multiline) && void 0 !== _this$options$multili ? _this$options$multili : true\r\n        }\r\n        clean() {\r\n            this._toolbarWidgets.clear();\r\n            if (this._$toolbarContainer) {\r\n                this._$toolbarContainer.empty().removeClass(TOOLBAR_WRAPPER_CLASS)\r\n            }\r\n        }\r\n        repaint() {\r\n            this.toolbarInstance && this.toolbarInstance.repaint()\r\n        }\r\n        _getContainer() {\r\n            var $container = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"<div>\");\r\n            this.editorInstance.$element().prepend($container);\r\n            return $container\r\n        }\r\n        _detectRenamedOptions(item) {\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_10__[\"isObject\"])(item)) {\r\n                Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_9__[\"each\"])([{\r\n                    newName: \"name\",\r\n                    oldName: \"formatName\"\r\n                }, {\r\n                    newName: \"acceptedValues\",\r\n                    oldName: \"formatValues\"\r\n                }], (index, optionName) => {\r\n                    if (Object.prototype.hasOwnProperty.call(item, optionName.oldName)) {\r\n                        _widget_ui_errors__WEBPACK_IMPORTED_MODULE_7__[\"default\"].log(\"W1016\", optionName.oldName, optionName.newName)\r\n                    }\r\n                })\r\n            }\r\n        }\r\n        _subscribeFormatHotKeys() {\r\n            this.quill.keyboard.addBinding({\r\n                which: KEY_CODES.b,\r\n                shortKey: true\r\n            }, this._handleFormatHotKey.bind(this));\r\n            this.quill.keyboard.addBinding({\r\n                which: KEY_CODES.i,\r\n                shortKey: true\r\n            }, this._handleFormatHotKey.bind(this));\r\n            this.quill.keyboard.addBinding({\r\n                which: KEY_CODES.u,\r\n                shortKey: true\r\n            }, this._handleFormatHotKey.bind(this))\r\n        }\r\n        _handleFormatHotKey(range, context, _ref2) {\r\n            var {\r\n                which: which\r\n            } = _ref2;\r\n            var formatName = FORMAT_HOTKEYS[which];\r\n            this._updateButtonState(formatName)\r\n        }\r\n        _updateButtonState(formatName) {\r\n            var formatWidget = this._toolbarWidgets.getByName(formatName);\r\n            var currentFormat = this.quill.getFormat();\r\n            var formatValue = currentFormat[formatName];\r\n            if (formatValue) {\r\n                this._markActiveFormatWidget(formatName, formatWidget, currentFormat)\r\n            } else {\r\n                this._resetFormatWidget(formatName, formatWidget)\r\n            }\r\n        }\r\n        _prepareToolbarItems() {\r\n            var resultItems = [];\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_9__[\"each\"])(this.options.items, (index, item) => {\r\n                var newItem;\r\n                this._detectRenamedOptions(item);\r\n                if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_10__[\"isObject\"])(item)) {\r\n                    newItem = this._handleObjectItem(item)\r\n                } else if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_10__[\"isString\"])(item)) {\r\n                    var buttonItemConfig = this._prepareButtonItemConfig(item);\r\n                    newItem = this._getToolbarItem(buttonItemConfig)\r\n                }\r\n                if (newItem) {\r\n                    resultItems.push(newItem)\r\n                }\r\n            });\r\n            return resultItems\r\n        }\r\n        _handleObjectItem(item) {\r\n            if (item.name && item.acceptedValues && this._isAcceptableItem(item.widget, \"dxSelectBox\")) {\r\n                var selectItemConfig = this._prepareSelectItemConfig(item);\r\n                return this._getToolbarItem(selectItemConfig)\r\n            } else if (item.name && this._isAcceptableItem(item.widget, \"dxButton\")) {\r\n                var defaultButtonItemConfig = this._prepareButtonItemConfig(item.name);\r\n                var buttonItemConfig = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_11__[\"extend\"])(true, defaultButtonItemConfig, item);\r\n                return this._getToolbarItem(buttonItemConfig)\r\n            } else {\r\n                return this._getToolbarItem(item)\r\n            }\r\n        }\r\n        _isAcceptableItem(widget, acceptableWidgetName) {\r\n            return !widget || widget === acceptableWidgetName\r\n        }\r\n        _prepareButtonItemConfig(name) {\r\n            var _ICON_MAP$name;\r\n            var iconName = null !== (_ICON_MAP$name = _utils_toolbar_helper__WEBPACK_IMPORTED_MODULE_17__[\"ICON_MAP\"][name]) && void 0 !== _ICON_MAP$name ? _ICON_MAP$name : name;\r\n            var buttonText = Object(_core_utils_inflector__WEBPACK_IMPORTED_MODULE_13__[\"titleize\"])(name);\r\n            return {\r\n                widget: \"dxButton\",\r\n                name: name,\r\n                options: {\r\n                    hint: localize(buttonText),\r\n                    text: localize(buttonText),\r\n                    icon: iconName.toLowerCase(),\r\n                    onClick: this._formatHandlers[name] || Object(_utils_toolbar_helper__WEBPACK_IMPORTED_MODULE_17__[\"getDefaultClickHandler\"])(this, name),\r\n                    stylingMode: \"text\"\r\n                },\r\n                showText: \"inMenu\"\r\n            }\r\n        }\r\n        _prepareSelectItemConfig(item) {\r\n            var {\r\n                name: name,\r\n                acceptedValues: acceptedValues\r\n            } = item;\r\n            return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_11__[\"extend\"])(true, {\r\n                widget: \"dxSelectBox\",\r\n                name: name,\r\n                options: {\r\n                    stylingMode: \"filled\",\r\n                    dataSource: acceptedValues,\r\n                    displayExpr: value => localizeValue(value, name),\r\n                    placeholder: localize(name),\r\n                    onValueChanged: e => {\r\n                        if (!this._isReset) {\r\n                            this._hideAdaptiveMenu();\r\n                            Object(_utils_toolbar_helper__WEBPACK_IMPORTED_MODULE_17__[\"applyFormat\"])(this, [name, e.value, USER_ACTION], e.event);\r\n                            this._setValueSilent(e.component, e.value)\r\n                        }\r\n                    }\r\n                }\r\n            }, item)\r\n        }\r\n        _hideAdaptiveMenu() {\r\n            if (this.toolbarInstance.option(\"overflowMenuVisible\")) {\r\n                this.toolbarInstance.option(\"overflowMenuVisible\", false)\r\n            }\r\n        }\r\n        _getToolbarItem(item) {\r\n            var baseItem = {\r\n                options: {\r\n                    onInitialized: e => {\r\n                        if (item.name) {\r\n                            e.component.$element().addClass(TOOLBAR_FORMAT_WIDGET_CLASS);\r\n                            e.component.$element().toggleClass(\"dx-\".concat(item.name.toLowerCase(), \"-format\"), !!item.name);\r\n                            this._toolbarWidgets.add(item.name, e.component)\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            var multilineItem = this.isMultilineMode() ? {\r\n                location: \"before\",\r\n                locateInMenu: \"never\"\r\n            } : {};\r\n            return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_11__[\"extend\"])(true, {\r\n                location: \"before\",\r\n                locateInMenu: \"auto\"\r\n            }, this._getDefaultConfig(item.name), item, baseItem, multilineItem)\r\n        }\r\n        _getDefaultItemsConfig() {\r\n            return {\r\n                clear: {\r\n                    options: {\r\n                        disabled: true\r\n                    }\r\n                },\r\n                undo: {\r\n                    options: {\r\n                        disabled: true\r\n                    }\r\n                },\r\n                redo: {\r\n                    options: {\r\n                        disabled: true\r\n                    }\r\n                },\r\n                insertRowAbove: {\r\n                    options: {\r\n                        disabled: true\r\n                    }\r\n                },\r\n                insertRowBelow: {\r\n                    options: {\r\n                        disabled: true\r\n                    }\r\n                },\r\n                insertHeaderRow: {\r\n                    options: {\r\n                        disabled: true\r\n                    }\r\n                },\r\n                insertColumnLeft: {\r\n                    options: {\r\n                        disabled: true\r\n                    }\r\n                },\r\n                insertColumnRight: {\r\n                    options: {\r\n                        disabled: true\r\n                    }\r\n                },\r\n                deleteRow: {\r\n                    options: {\r\n                        disabled: true\r\n                    }\r\n                },\r\n                deleteColumn: {\r\n                    options: {\r\n                        disabled: true\r\n                    }\r\n                },\r\n                deleteTable: {\r\n                    options: {\r\n                        disabled: true\r\n                    }\r\n                },\r\n                cellProperties: {\r\n                    options: {\r\n                        disabled: true\r\n                    }\r\n                },\r\n                tableProperties: {\r\n                    options: {\r\n                        disabled: true\r\n                    }\r\n                },\r\n                separator: {\r\n                    template: (data, index, element) => {\r\n                        Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element).addClass(TOOLBAR_SEPARATOR_CLASS)\r\n                    },\r\n                    menuItemTemplate: (data, index, element) => {\r\n                        Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element).addClass(TOOLBAR_MENU_SEPARATOR_CLASS)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        _getDefaultConfig(name) {\r\n            return this._getDefaultItemsConfig()[name]\r\n        }\r\n        updateHistoryWidgets() {\r\n            var historyModule = this.quill.history;\r\n            if (!historyModule) {\r\n                return\r\n            }\r\n            var {\r\n                undo: undoOps,\r\n                redo: redoOps\r\n            } = historyModule.stack;\r\n            this._updateManipulationWidget(this._toolbarWidgets.getByName(\"undo\"), Boolean(undoOps.length));\r\n            this._updateManipulationWidget(this._toolbarWidgets.getByName(\"redo\"), Boolean(redoOps.length))\r\n        }\r\n        updateTableWidgets() {\r\n            var table = this.quill.getModule(\"table\");\r\n            if (!table) {\r\n                return\r\n            }\r\n            var selection = this.quill.getSelection();\r\n            var formats = selection && this.quill.getFormat(selection) || {};\r\n            var isTableOperationsEnabled = this._tableFormats.some(format => Boolean(formats[format]));\r\n            _utils_table_helper__WEBPACK_IMPORTED_MODULE_16__[\"TABLE_OPERATIONS\"].forEach(operationName => {\r\n                var isInsertTable = \"insertTable\" === operationName;\r\n                var widget = this._toolbarWidgets.getByName(operationName);\r\n                this._updateManipulationWidget(widget, isInsertTable ? !isTableOperationsEnabled : isTableOperationsEnabled)\r\n            })\r\n        }\r\n        _updateManipulationWidget(widget, isOperationEnabled) {\r\n            if (!widget) {\r\n                return\r\n            }\r\n            widget.option(\"disabled\", !isOperationEnabled)\r\n        }\r\n        updateFormatWidgets(isResetRequired) {\r\n            var selection = this.quill.getSelection();\r\n            if (!selection) {\r\n                return\r\n            }\r\n            var formats = this.quill.getFormat(selection);\r\n            var hasFormats = !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_10__[\"isEmptyObject\"])(formats);\r\n            if (!hasFormats || isResetRequired) {\r\n                this._resetFormatWidgets()\r\n            }\r\n            for (var formatName in formats) {\r\n                var widgetName = this._getFormatWidgetName(formatName, formats);\r\n                var formatWidget = this._toolbarWidgets.getByName(widgetName) || this._toolbarWidgets.getByName(formatName);\r\n                if (!formatWidget) {\r\n                    continue\r\n                }\r\n                this._markActiveFormatWidget(formatName, formatWidget, formats)\r\n            }\r\n            this._toggleClearFormatting(hasFormats || selection.length > 1)\r\n        }\r\n        _markActiveFormatWidget(name, widget, formats) {\r\n            if (this._isColorFormat(name)) {\r\n                this._updateColorWidget(name, formats[name])\r\n            }\r\n            if (\"value\" in widget.option()) {\r\n                this._setValueSilent(widget, formats[name])\r\n            } else {\r\n                widget.$element().addClass(ACTIVE_FORMAT_CLASS)\r\n            }\r\n        }\r\n        _toggleClearFormatting(hasFormats) {\r\n            var clearWidget = this._toolbarWidgets.getByName(\"clear\");\r\n            if (clearWidget) {\r\n                clearWidget.option(\"disabled\", !hasFormats)\r\n            }\r\n        }\r\n        _isColorFormat(name) {\r\n            return \"color\" === name || \"background\" === name\r\n        }\r\n        _updateColorWidget(name, color) {\r\n            var formatWidget = this._toolbarWidgets.getByName(name);\r\n            if (!formatWidget) {\r\n                return\r\n            }\r\n            formatWidget.$element().find(\".\".concat(ICON_CLASS)).css(\"borderBottomColor\", color || \"transparent\")\r\n        }\r\n        _getFormatWidgetName(name, formats) {\r\n            var widgetName;\r\n            switch (name) {\r\n                case \"align\":\r\n                    widgetName = name + Object(_core_utils_inflector__WEBPACK_IMPORTED_MODULE_13__[\"titleize\"])(formats[name]);\r\n                    break;\r\n                case \"list\":\r\n                    widgetName = formats[name] + Object(_core_utils_inflector__WEBPACK_IMPORTED_MODULE_13__[\"titleize\"])(name);\r\n                    break;\r\n                case \"code-block\":\r\n                    widgetName = \"codeBlock\";\r\n                    break;\r\n                case \"script\":\r\n                    widgetName = formats[name] + name;\r\n                    break;\r\n                case \"imageSrc\":\r\n                    widgetName = \"image\";\r\n                    break;\r\n                default:\r\n                    widgetName = name\r\n            }\r\n            return widgetName\r\n        }\r\n        _setValueSilent(widget, value) {\r\n            this._isReset = true;\r\n            widget.option(\"value\", value);\r\n            this._isReset = false\r\n        }\r\n        _resetFormatWidgets() {\r\n            this._toolbarWidgets.each((name, widget) => {\r\n                this._resetFormatWidget(name, widget)\r\n            })\r\n        }\r\n        _resetFormatWidget(name, widget) {\r\n            widget.$element().removeClass(ACTIVE_FORMAT_CLASS);\r\n            if (this._isColorFormat(name)) {\r\n                this._updateColorWidget(name)\r\n            }\r\n            if (\"clear\" === name) {\r\n                widget.option(\"disabled\", true)\r\n            }\r\n            if (\"dxSelectBox\" === widget.NAME) {\r\n                this._setValueSilent(widget, null)\r\n            }\r\n        }\r\n        addClickHandler(name, handler) {\r\n            this._formatHandlers[name] = handler;\r\n            var formatWidget = this._toolbarWidgets.getByName(name);\r\n            if (formatWidget && \"dxButton\" === formatWidget.NAME) {\r\n                formatWidget.option(\"onClick\", handler)\r\n            }\r\n        }\r\n    }\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ToolbarModule);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy90b29sYmFyLmpzPzZhNDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUM7QUFDRTtBQUNQO0FBQ0k7QUFDVjtBQUNVO0FBQ1Y7QUFDa0I7QUFDSztBQUdYO0FBTUo7QUFHRTtBQUM0QjtBQUl6QjtBQUN1QjtBQUd6QjtBQUlOO0FBTUU7QUFDakMsb0JBQW9CLDZDQUFVO0FBQzlCLElBQUksdURBQUs7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhEQUFtQiwrQkFBK0IsdUVBQVE7QUFDckY7QUFDQTtBQUNBLGdDQUFnQyxtRUFBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2Q0FBVTtBQUM1QztBQUNBO0FBQ0EsdUNBQXVDLHlEQUFlO0FBQ3RELG1DQUFtQyxnRkFBaUI7QUFDcEQsaUNBQWlDLDRFQUFlO0FBQ2hELGdCQUFnQixtRUFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsdUVBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsdUVBQWE7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REFBQztBQUN6QixxQkFBcUI7QUFDckI7QUFDQSx3QkFBd0IsOERBQUM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFFQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUVBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1RUFBUTtBQUNoRDtBQUNBO0FBQ0EsaURBQWlELHVFQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSw0RUFBYSxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3VpL2h0bWxfZWRpdG9yL21vZHVsZXMvdG9vbGJhci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy90b29sYmFyLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQgUXVpbGwgZnJvbSBcImRldmV4dHJlbWUtcXVpbGxcIjtcclxuaW1wb3J0ICQgZnJvbSBcIi4uLy4uLy4uL2NvcmUvcmVuZGVyZXJcIjtcclxuaW1wb3J0IEJhc2VNb2R1bGUgZnJvbSBcIi4vYmFzZVwiO1xyXG5pbXBvcnQgVG9vbGJhciBmcm9tIFwiLi4vLi4vdG9vbGJhclwiO1xyXG5pbXBvcnQgXCIuLi8uLi9zZWxlY3RfYm94XCI7XHJcbmltcG9ydCBcIi4uLy4uL2NvbG9yX2JveC9jb2xvcl92aWV3XCI7XHJcbmltcG9ydCBcIi4uLy4uL251bWJlcl9ib3hcIjtcclxuaW1wb3J0IGVycm9ycyBmcm9tIFwiLi4vLi4vd2lkZ2V0L3VpLmVycm9yc1wiO1xyXG5pbXBvcnQgV2lkZ2V0Q29sbGVjdG9yIGZyb20gXCIuL3dpZGdldF9jb2xsZWN0b3JcIjtcclxuaW1wb3J0IHtcclxuICAgIGVhY2hcclxufSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlscy9pdGVyYXRvclwiO1xyXG5pbXBvcnQge1xyXG4gICAgaXNTdHJpbmcsXHJcbiAgICBpc09iamVjdCxcclxuICAgIGlzRGVmaW5lZCxcclxuICAgIGlzRW1wdHlPYmplY3RcclxufSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlscy90eXBlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBleHRlbmRcclxufSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlscy9leHRlbmRcIjtcclxuaW1wb3J0IGxvY2FsaXphdGlvbk1lc3NhZ2UgZnJvbSBcIi4uLy4uLy4uL2xvY2FsaXphdGlvbi9tZXNzYWdlXCI7XHJcbmltcG9ydCB7XHJcbiAgICB0aXRsZWl6ZSxcclxuICAgIGNhbWVsaXplXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvaW5mbGVjdG9yXCI7XHJcbmltcG9ydCBldmVudHNFbmdpbmUgZnJvbSBcIi4uLy4uLy4uL2V2ZW50cy9jb3JlL2V2ZW50c19lbmdpbmVcIjtcclxuaW1wb3J0IHtcclxuICAgIGFkZE5hbWVzcGFjZVxyXG59IGZyb20gXCIuLi8uLi8uLi9ldmVudHMvdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldFRhYmxlRm9ybWF0cyxcclxuICAgIFRBQkxFX09QRVJBVElPTlNcclxufSBmcm9tIFwiLi4vdXRpbHMvdGFibGVfaGVscGVyXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRGb3JtYXRIYW5kbGVycyxcclxuICAgIGdldERlZmF1bHRDbGlja0hhbmRsZXIsXHJcbiAgICBJQ09OX01BUCxcclxuICAgIGFwcGx5Rm9ybWF0XHJcbn0gZnJvbSBcIi4uL3V0aWxzL3Rvb2xiYXJfaGVscGVyXCI7XHJcbnZhciBUb29sYmFyTW9kdWxlID0gQmFzZU1vZHVsZTtcclxuaWYgKFF1aWxsKSB7XHJcbiAgICB2YXIgVE9PTEJBUl9XUkFQUEVSX0NMQVNTID0gXCJkeC1odG1sZWRpdG9yLXRvb2xiYXItd3JhcHBlclwiO1xyXG4gICAgdmFyIFRPT0xCQVJfQ0xBU1MgPSBcImR4LWh0bWxlZGl0b3ItdG9vbGJhclwiO1xyXG4gICAgdmFyIFRPT0xCQVJfRk9STUFUX1dJREdFVF9DTEFTUyA9IFwiZHgtaHRtbGVkaXRvci10b29sYmFyLWZvcm1hdFwiO1xyXG4gICAgdmFyIFRPT0xCQVJfU0VQQVJBVE9SX0NMQVNTID0gXCJkeC1odG1sZWRpdG9yLXRvb2xiYXItc2VwYXJhdG9yXCI7XHJcbiAgICB2YXIgVE9PTEJBUl9NRU5VX1NFUEFSQVRPUl9DTEFTUyA9IFwiZHgtaHRtbGVkaXRvci10b29sYmFyLW1lbnUtc2VwYXJhdG9yXCI7XHJcbiAgICB2YXIgQUNUSVZFX0ZPUk1BVF9DTEFTUyA9IFwiZHgtZm9ybWF0LWFjdGl2ZVwiO1xyXG4gICAgdmFyIElDT05fQ0xBU1MgPSBcImR4LWljb25cIjtcclxuICAgIHZhciBTRUxFQ1RJT05fQ0hBTkdFX0VWRU5UID0gXCJzZWxlY3Rpb24tY2hhbmdlXCI7XHJcbiAgICB2YXIgVVNFUl9BQ1RJT04gPSBcInVzZXJcIjtcclxuICAgIHZhciBTSUxFTlRfQUNUSU9OID0gXCJzaWxlbnRcIjtcclxuICAgIHZhciBGT1JNQVRfSE9US0VZUyA9IHtcclxuICAgICAgICA2NjogXCJib2xkXCIsXHJcbiAgICAgICAgNzM6IFwiaXRhbGljXCIsXHJcbiAgICAgICAgODU6IFwidW5kZXJsaW5lXCJcclxuICAgIH07XHJcbiAgICB2YXIgS0VZX0NPREVTID0ge1xyXG4gICAgICAgIGI6IDY2LFxyXG4gICAgICAgIGk6IDczLFxyXG4gICAgICAgIHU6IDg1XHJcbiAgICB9O1xyXG4gICAgdmFyIGxvY2FsaXplID0gbmFtZSA9PiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci1cIi5jb25jYXQoY2FtZWxpemUobmFtZSkpKTtcclxuICAgIHZhciBsb2NhbGl6ZVZhbHVlID0gKHZhbHVlLCBuYW1lKSA9PiB7XHJcbiAgICAgICAgaWYgKFwiaGVhZGVyXCIgPT09IG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGlzSGVhZGVyVmFsdWUgPSBpc0RlZmluZWQodmFsdWUpICYmIGZhbHNlICE9PSB2YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzSGVhZGVyVmFsdWUgPyBcIlwiLmNvbmNhdChsb2NhbGl6ZShcImhlYWRpbmdcIiksIFwiIFwiKS5jb25jYXQodmFsdWUpIDogbG9jYWxpemUoXCJub3JtYWxUZXh0XCIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZSh2YWx1ZSkgfHwgdmFsdWVcclxuICAgIH07XHJcbiAgICBUb29sYmFyTW9kdWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihxdWlsbCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBzdXBlcihxdWlsbCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2xiYXJXaWRnZXRzID0gbmV3IFdpZGdldENvbGxlY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fZm9ybWF0SGFuZGxlcnMgPSBnZXRGb3JtYXRIYW5kbGVycyh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fdGFibGVGb3JtYXRzID0gZ2V0VGFibGVGb3JtYXRzKHF1aWxsKTtcclxuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChvcHRpb25zLml0ZW1zKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQ2FsbGJhY2tzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUb29sYmFyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1aWxsLm9uKFwiZWRpdG9yLWNoYW5nZVwiLCAoZXZlbnROYW1lLCBuZXdWYWx1ZSwgb2xkVmFsdWUsIGV2ZW50U291cmNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzU2lsZW50TW9kZSA9IGV2ZW50U291cmNlID09PSBTSUxFTlRfQUNUSU9OICYmIGlzRW1wdHlPYmplY3QodGhpcy5xdWlsbC5nZXRGb3JtYXQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NpbGVudE1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzU2VsZWN0aW9uQ2hhbmdlZCA9IGV2ZW50TmFtZSA9PT0gU0VMRUNUSU9OX0NIQU5HRV9FVkVOVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVG9vbGJhcihpc1NlbGVjdGlvbkNoYW5nZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfYWRkQ2FsbGJhY2tzKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZENsZWFuQ2FsbGJhY2sodGhpcy5jbGVhbi5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZS5hZGRDb250ZW50SW5pdGlhbGl6ZWRDYWxsYmFjayh0aGlzLnVwZGF0ZUhpc3RvcnlXaWRnZXRzLmJpbmQodGhpcykpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF91cGRhdGVUb29sYmFyKGlzU2VsZWN0aW9uQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvcm1hdFdpZGdldHMoaXNTZWxlY3Rpb25DaGFuZ2VkKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVIaXN0b3J5V2lkZ2V0cygpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRhYmxlV2lkZ2V0cygpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF91cGRhdGVGb3JtYXRXaWRnZXQobmFtZSwgaXNBcHBsaWVkLCBmb3JtYXRzKSB7XHJcbiAgICAgICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLl90b29sYmFyV2lkZ2V0cy5nZXRCeU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghd2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNBcHBsaWVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrQWN0aXZlRm9ybWF0V2lkZ2V0KG5hbWUsIHdpZGdldCwgZm9ybWF0cylcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0Rm9ybWF0V2lkZ2V0KG5hbWUsIHdpZGdldCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZvcm1hdHNbbmFtZV1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90b2dnbGVDbGVhckZvcm1hdHRpbmcoaXNBcHBsaWVkIHx8ICFpc0VtcHR5T2JqZWN0KGZvcm1hdHMpKVxyXG4gICAgICAgIH1cclxuICAgICAgICBfcmVuZGVyVG9vbGJhcigpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXIgfHwgdGhpcy5fZ2V0Q29udGFpbmVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuXyR0b29sYmFyID0gJChcIjxkaXY+XCIpLmFkZENsYXNzKFRPT0xCQVJfQ0xBU1MpLmFwcGVuZFRvKGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIHRoaXMuXyR0b29sYmFyQ29udGFpbmVyID0gJChjb250YWluZXIpLmFkZENsYXNzKFRPT0xCQVJfV1JBUFBFUl9DTEFTUyk7XHJcbiAgICAgICAgICAgIGV2ZW50c0VuZ2luZS5vbih0aGlzLl8kdG9vbGJhckNvbnRhaW5lciwgYWRkTmFtZXNwYWNlKFwibW91c2Vkb3duXCIsIHRoaXMuZWRpdG9ySW5zdGFuY2UuTkFNRSksIGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVGb3JtYXRIb3RLZXlzKCk7XHJcbiAgICAgICAgICAgIHRoaXMudG9vbGJhckluc3RhbmNlID0gdGhpcy5lZGl0b3JJbnN0YW5jZS5fY3JlYXRlQ29tcG9uZW50KHRoaXMuXyR0b29sYmFyLCBUb29sYmFyLCB0aGlzLnRvb2xiYXJDb25maWcpO1xyXG4gICAgICAgICAgICB0aGlzLmVkaXRvckluc3RhbmNlLm9uKFwib3B0aW9uQ2hhbmdlZFwiLCBfcmVmID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZVxyXG4gICAgICAgICAgICAgICAgfSA9IF9yZWY7XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJyZWFkT25seVwiID09PSBuYW1lIHx8IFwiZGlzYWJsZWRcIiA9PT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9vbGJhckluc3RhbmNlLm9wdGlvbihcImRpc2FibGVkXCIsIHRoaXMuaXNJbnRlcmFjdGlvbkRpc2FibGVkKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgdG9vbGJhckNvbmZpZygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2U6IHRoaXMuX3ByZXBhcmVUb29sYmFySXRlbXMoKSxcclxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmlzSW50ZXJhY3Rpb25EaXNhYmxlZCxcclxuICAgICAgICAgICAgICAgIG1lbnVDb250YWluZXI6IHRoaXMuXyR0b29sYmFyQ29udGFpbmVyLFxyXG4gICAgICAgICAgICAgICAgbXVsdGlsaW5lOiB0aGlzLmlzTXVsdGlsaW5lTW9kZSgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IGlzSW50ZXJhY3Rpb25EaXNhYmxlZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9ySW5zdGFuY2Uub3B0aW9uKFwicmVhZE9ubHlcIikgfHwgdGhpcy5lZGl0b3JJbnN0YW5jZS5vcHRpb24oXCJkaXNhYmxlZFwiKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpc011bHRpbGluZU1vZGUoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyRvcHRpb25zJG11bHRpbGk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsICE9PSAoX3RoaXMkb3B0aW9ucyRtdWx0aWxpID0gdGhpcy5vcHRpb25zLm11bHRpbGluZSkgJiYgdm9pZCAwICE9PSBfdGhpcyRvcHRpb25zJG11bHRpbGkgPyBfdGhpcyRvcHRpb25zJG11bHRpbGkgOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsZWFuKCkge1xyXG4gICAgICAgICAgICB0aGlzLl90b29sYmFyV2lkZ2V0cy5jbGVhcigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fJHRvb2xiYXJDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuXyR0b29sYmFyQ29udGFpbmVyLmVtcHR5KCkucmVtb3ZlQ2xhc3MoVE9PTEJBUl9XUkFQUEVSX0NMQVNTKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcGFpbnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9vbGJhckluc3RhbmNlICYmIHRoaXMudG9vbGJhckluc3RhbmNlLnJlcGFpbnQoKVxyXG4gICAgICAgIH1cclxuICAgICAgICBfZ2V0Q29udGFpbmVyKCkge1xyXG4gICAgICAgICAgICB2YXIgJGNvbnRhaW5lciA9ICQoXCI8ZGl2PlwiKTtcclxuICAgICAgICAgICAgdGhpcy5lZGl0b3JJbnN0YW5jZS4kZWxlbWVudCgpLnByZXBlbmQoJGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIHJldHVybiAkY29udGFpbmVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9kZXRlY3RSZW5hbWVkT3B0aW9ucyhpdGVtKSB7XHJcbiAgICAgICAgICAgIGlmIChpc09iamVjdChpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgZWFjaChbe1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld05hbWU6IFwibmFtZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIG9sZE5hbWU6IFwiZm9ybWF0TmFtZVwiXHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3TmFtZTogXCJhY2NlcHRlZFZhbHVlc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIG9sZE5hbWU6IFwiZm9ybWF0VmFsdWVzXCJcclxuICAgICAgICAgICAgICAgIH1dLCAoaW5kZXgsIG9wdGlvbk5hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZW0sIG9wdGlvbk5hbWUub2xkTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmxvZyhcIlcxMDE2XCIsIG9wdGlvbk5hbWUub2xkTmFtZSwgb3B0aW9uTmFtZS5uZXdOYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX3N1YnNjcmliZUZvcm1hdEhvdEtleXMoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucXVpbGwua2V5Ym9hcmQuYWRkQmluZGluZyh7XHJcbiAgICAgICAgICAgICAgICB3aGljaDogS0VZX0NPREVTLmIsXHJcbiAgICAgICAgICAgICAgICBzaG9ydEtleTogdHJ1ZVxyXG4gICAgICAgICAgICB9LCB0aGlzLl9oYW5kbGVGb3JtYXRIb3RLZXkuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMucXVpbGwua2V5Ym9hcmQuYWRkQmluZGluZyh7XHJcbiAgICAgICAgICAgICAgICB3aGljaDogS0VZX0NPREVTLmksXHJcbiAgICAgICAgICAgICAgICBzaG9ydEtleTogdHJ1ZVxyXG4gICAgICAgICAgICB9LCB0aGlzLl9oYW5kbGVGb3JtYXRIb3RLZXkuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMucXVpbGwua2V5Ym9hcmQuYWRkQmluZGluZyh7XHJcbiAgICAgICAgICAgICAgICB3aGljaDogS0VZX0NPREVTLnUsXHJcbiAgICAgICAgICAgICAgICBzaG9ydEtleTogdHJ1ZVxyXG4gICAgICAgICAgICB9LCB0aGlzLl9oYW5kbGVGb3JtYXRIb3RLZXkuYmluZCh0aGlzKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgX2hhbmRsZUZvcm1hdEhvdEtleShyYW5nZSwgY29udGV4dCwgX3JlZjIpIHtcclxuICAgICAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgICAgIHdoaWNoOiB3aGljaFxyXG4gICAgICAgICAgICB9ID0gX3JlZjI7XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXROYW1lID0gRk9STUFUX0hPVEtFWVNbd2hpY2hdO1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCdXR0b25TdGF0ZShmb3JtYXROYW1lKVxyXG4gICAgICAgIH1cclxuICAgICAgICBfdXBkYXRlQnV0dG9uU3RhdGUoZm9ybWF0TmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0V2lkZ2V0ID0gdGhpcy5fdG9vbGJhcldpZGdldHMuZ2V0QnlOYW1lKGZvcm1hdE5hbWUpO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudEZvcm1hdCA9IHRoaXMucXVpbGwuZ2V0Rm9ybWF0KCk7XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXRWYWx1ZSA9IGN1cnJlbnRGb3JtYXRbZm9ybWF0TmFtZV07XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya0FjdGl2ZUZvcm1hdFdpZGdldChmb3JtYXROYW1lLCBmb3JtYXRXaWRnZXQsIGN1cnJlbnRGb3JtYXQpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldEZvcm1hdFdpZGdldChmb3JtYXROYW1lLCBmb3JtYXRXaWRnZXQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX3ByZXBhcmVUb29sYmFySXRlbXMoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRJdGVtcyA9IFtdO1xyXG4gICAgICAgICAgICBlYWNoKHRoaXMub3B0aW9ucy5pdGVtcywgKGluZGV4LCBpdGVtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3SXRlbTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RldGVjdFJlbmFtZWRPcHRpb25zKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SXRlbSA9IHRoaXMuX2hhbmRsZU9iamVjdEl0ZW0oaXRlbSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoaXRlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uSXRlbUNvbmZpZyA9IHRoaXMuX3ByZXBhcmVCdXR0b25JdGVtQ29uZmlnKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0gPSB0aGlzLl9nZXRUb29sYmFySXRlbShidXR0b25JdGVtQ29uZmlnKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0l0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRJdGVtcy5wdXNoKG5ld0l0ZW0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0SXRlbXNcclxuICAgICAgICB9XHJcbiAgICAgICAgX2hhbmRsZU9iamVjdEl0ZW0oaXRlbSkge1xyXG4gICAgICAgICAgICBpZiAoaXRlbS5uYW1lICYmIGl0ZW0uYWNjZXB0ZWRWYWx1ZXMgJiYgdGhpcy5faXNBY2NlcHRhYmxlSXRlbShpdGVtLndpZGdldCwgXCJkeFNlbGVjdEJveFwiKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdEl0ZW1Db25maWcgPSB0aGlzLl9wcmVwYXJlU2VsZWN0SXRlbUNvbmZpZyhpdGVtKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRUb29sYmFySXRlbShzZWxlY3RJdGVtQ29uZmlnKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0ubmFtZSAmJiB0aGlzLl9pc0FjY2VwdGFibGVJdGVtKGl0ZW0ud2lkZ2V0LCBcImR4QnV0dG9uXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdEJ1dHRvbkl0ZW1Db25maWcgPSB0aGlzLl9wcmVwYXJlQnV0dG9uSXRlbUNvbmZpZyhpdGVtLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkl0ZW1Db25maWcgPSBleHRlbmQodHJ1ZSwgZGVmYXVsdEJ1dHRvbkl0ZW1Db25maWcsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRvb2xiYXJJdGVtKGJ1dHRvbkl0ZW1Db25maWcpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VG9vbGJhckl0ZW0oaXRlbSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfaXNBY2NlcHRhYmxlSXRlbSh3aWRnZXQsIGFjY2VwdGFibGVXaWRnZXROYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhd2lkZ2V0IHx8IHdpZGdldCA9PT0gYWNjZXB0YWJsZVdpZGdldE5hbWVcclxuICAgICAgICB9XHJcbiAgICAgICAgX3ByZXBhcmVCdXR0b25JdGVtQ29uZmlnKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIF9JQ09OX01BUCRuYW1lO1xyXG4gICAgICAgICAgICB2YXIgaWNvbk5hbWUgPSBudWxsICE9PSAoX0lDT05fTUFQJG5hbWUgPSBJQ09OX01BUFtuYW1lXSkgJiYgdm9pZCAwICE9PSBfSUNPTl9NQVAkbmFtZSA/IF9JQ09OX01BUCRuYW1lIDogbmFtZTtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvblRleHQgPSB0aXRsZWl6ZShuYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHdpZGdldDogXCJkeEJ1dHRvblwiLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBoaW50OiBsb2NhbGl6ZShidXR0b25UZXh0KSxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsb2NhbGl6ZShidXR0b25UZXh0KSxcclxuICAgICAgICAgICAgICAgICAgICBpY29uOiBpY29uTmFtZS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuX2Zvcm1hdEhhbmRsZXJzW25hbWVdIHx8IGdldERlZmF1bHRDbGlja0hhbmRsZXIodGhpcywgbmFtZSksXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGluZ01vZGU6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2hvd1RleHQ6IFwiaW5NZW51XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfcHJlcGFyZVNlbGVjdEl0ZW1Db25maWcoaXRlbSkge1xyXG4gICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICAgIGFjY2VwdGVkVmFsdWVzOiBhY2NlcHRlZFZhbHVlc1xyXG4gICAgICAgICAgICB9ID0gaXRlbTtcclxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZCh0cnVlLCB7XHJcbiAgICAgICAgICAgICAgICB3aWRnZXQ6IFwiZHhTZWxlY3RCb3hcIixcclxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGluZ01vZGU6IFwiZmlsbGVkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNvdXJjZTogYWNjZXB0ZWRWYWx1ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheUV4cHI6IHZhbHVlID0+IGxvY2FsaXplVmFsdWUodmFsdWUsIG5hbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBsb2NhbGl6ZShuYW1lKSxcclxuICAgICAgICAgICAgICAgICAgICBvblZhbHVlQ2hhbmdlZDogZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNSZXNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZUFkYXB0aXZlTWVudSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlGb3JtYXQodGhpcywgW25hbWUsIGUudmFsdWUsIFVTRVJfQUNUSU9OXSwgZS5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVNpbGVudChlLmNvbXBvbmVudCwgZS52YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgaXRlbSlcclxuICAgICAgICB9XHJcbiAgICAgICAgX2hpZGVBZGFwdGl2ZU1lbnUoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRvb2xiYXJJbnN0YW5jZS5vcHRpb24oXCJvdmVyZmxvd01lbnVWaXNpYmxlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xiYXJJbnN0YW5jZS5vcHRpb24oXCJvdmVyZmxvd01lbnVWaXNpYmxlXCIsIGZhbHNlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9nZXRUb29sYmFySXRlbShpdGVtKSB7XHJcbiAgICAgICAgICAgIHZhciBiYXNlSXRlbSA9IHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkluaXRpYWxpemVkOiBlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jb21wb25lbnQuJGVsZW1lbnQoKS5hZGRDbGFzcyhUT09MQkFSX0ZPUk1BVF9XSURHRVRfQ0xBU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jb21wb25lbnQuJGVsZW1lbnQoKS50b2dnbGVDbGFzcyhcImR4LVwiLmNvbmNhdChpdGVtLm5hbWUudG9Mb3dlckNhc2UoKSwgXCItZm9ybWF0XCIpLCAhIWl0ZW0ubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sYmFyV2lkZ2V0cy5hZGQoaXRlbS5uYW1lLCBlLmNvbXBvbmVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIG11bHRpbGluZUl0ZW0gPSB0aGlzLmlzTXVsdGlsaW5lTW9kZSgpID8ge1xyXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IFwiYmVmb3JlXCIsXHJcbiAgICAgICAgICAgICAgICBsb2NhdGVJbk1lbnU6IFwibmV2ZXJcIlxyXG4gICAgICAgICAgICB9IDoge307XHJcbiAgICAgICAgICAgIHJldHVybiBleHRlbmQodHJ1ZSwge1xyXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IFwiYmVmb3JlXCIsXHJcbiAgICAgICAgICAgICAgICBsb2NhdGVJbk1lbnU6IFwiYXV0b1wiXHJcbiAgICAgICAgICAgIH0sIHRoaXMuX2dldERlZmF1bHRDb25maWcoaXRlbS5uYW1lKSwgaXRlbSwgYmFzZUl0ZW0sIG11bHRpbGluZUl0ZW0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9nZXREZWZhdWx0SXRlbXNDb25maWcoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjbGVhcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdW5kbzoge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVkbzoge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0Um93QWJvdmU6IHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGluc2VydFJvd0JlbG93OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBpbnNlcnRIZWFkZXJSb3c6IHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGluc2VydENvbHVtbkxlZnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGluc2VydENvbHVtblJpZ2h0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBkZWxldGVSb3c6IHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRlbGV0ZUNvbHVtbjoge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGVsZXRlVGFibGU6IHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0YWJsZVByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAoZGF0YSwgaW5kZXgsIGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJChlbGVtZW50KS5hZGRDbGFzcyhUT09MQkFSX1NFUEFSQVRPUl9DTEFTUylcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG1lbnVJdGVtVGVtcGxhdGU6IChkYXRhLCBpbmRleCwgZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmFkZENsYXNzKFRPT0xCQVJfTUVOVV9TRVBBUkFUT1JfQ0xBU1MpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9nZXREZWZhdWx0Q29uZmlnKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldERlZmF1bHRJdGVtc0NvbmZpZygpW25hbWVdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZUhpc3RvcnlXaWRnZXRzKCkge1xyXG4gICAgICAgICAgICB2YXIgaGlzdG9yeU1vZHVsZSA9IHRoaXMucXVpbGwuaGlzdG9yeTtcclxuICAgICAgICAgICAgaWYgKCFoaXN0b3J5TW9kdWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgdW5kbzogdW5kb09wcyxcclxuICAgICAgICAgICAgICAgIHJlZG86IHJlZG9PcHNcclxuICAgICAgICAgICAgfSA9IGhpc3RvcnlNb2R1bGUuc3RhY2s7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1hbmlwdWxhdGlvbldpZGdldCh0aGlzLl90b29sYmFyV2lkZ2V0cy5nZXRCeU5hbWUoXCJ1bmRvXCIpLCBCb29sZWFuKHVuZG9PcHMubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1hbmlwdWxhdGlvbldpZGdldCh0aGlzLl90b29sYmFyV2lkZ2V0cy5nZXRCeU5hbWUoXCJyZWRvXCIpLCBCb29sZWFuKHJlZG9PcHMubGVuZ3RoKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlVGFibGVXaWRnZXRzKCkge1xyXG4gICAgICAgICAgICB2YXIgdGFibGUgPSB0aGlzLnF1aWxsLmdldE1vZHVsZShcInRhYmxlXCIpO1xyXG4gICAgICAgICAgICBpZiAoIXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgdmFyIGZvcm1hdHMgPSBzZWxlY3Rpb24gJiYgdGhpcy5xdWlsbC5nZXRGb3JtYXQoc2VsZWN0aW9uKSB8fCB7fTtcclxuICAgICAgICAgICAgdmFyIGlzVGFibGVPcGVyYXRpb25zRW5hYmxlZCA9IHRoaXMuX3RhYmxlRm9ybWF0cy5zb21lKGZvcm1hdCA9PiBCb29sZWFuKGZvcm1hdHNbZm9ybWF0XSkpO1xyXG4gICAgICAgICAgICBUQUJMRV9PUEVSQVRJT05TLmZvckVhY2gob3BlcmF0aW9uTmFtZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNJbnNlcnRUYWJsZSA9IFwiaW5zZXJ0VGFibGVcIiA9PT0gb3BlcmF0aW9uTmFtZTtcclxuICAgICAgICAgICAgICAgIHZhciB3aWRnZXQgPSB0aGlzLl90b29sYmFyV2lkZ2V0cy5nZXRCeU5hbWUob3BlcmF0aW9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYW5pcHVsYXRpb25XaWRnZXQod2lkZ2V0LCBpc0luc2VydFRhYmxlID8gIWlzVGFibGVPcGVyYXRpb25zRW5hYmxlZCA6IGlzVGFibGVPcGVyYXRpb25zRW5hYmxlZClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgX3VwZGF0ZU1hbmlwdWxhdGlvbldpZGdldCh3aWRnZXQsIGlzT3BlcmF0aW9uRW5hYmxlZCkge1xyXG4gICAgICAgICAgICBpZiAoIXdpZGdldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2lkZ2V0Lm9wdGlvbihcImRpc2FibGVkXCIsICFpc09wZXJhdGlvbkVuYWJsZWQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZUZvcm1hdFdpZGdldHMoaXNSZXNldFJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnF1aWxsLmdldFNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZvcm1hdHMgPSB0aGlzLnF1aWxsLmdldEZvcm1hdChzZWxlY3Rpb24pO1xyXG4gICAgICAgICAgICB2YXIgaGFzRm9ybWF0cyA9ICFpc0VtcHR5T2JqZWN0KGZvcm1hdHMpO1xyXG4gICAgICAgICAgICBpZiAoIWhhc0Zvcm1hdHMgfHwgaXNSZXNldFJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldEZvcm1hdFdpZGdldHMoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGZvcm1hdE5hbWUgaW4gZm9ybWF0cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpZGdldE5hbWUgPSB0aGlzLl9nZXRGb3JtYXRXaWRnZXROYW1lKGZvcm1hdE5hbWUsIGZvcm1hdHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdFdpZGdldCA9IHRoaXMuX3Rvb2xiYXJXaWRnZXRzLmdldEJ5TmFtZSh3aWRnZXROYW1lKSB8fCB0aGlzLl90b29sYmFyV2lkZ2V0cy5nZXRCeU5hbWUoZm9ybWF0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZvcm1hdFdpZGdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrQWN0aXZlRm9ybWF0V2lkZ2V0KGZvcm1hdE5hbWUsIGZvcm1hdFdpZGdldCwgZm9ybWF0cylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90b2dnbGVDbGVhckZvcm1hdHRpbmcoaGFzRm9ybWF0cyB8fCBzZWxlY3Rpb24ubGVuZ3RoID4gMSlcclxuICAgICAgICB9XHJcbiAgICAgICAgX21hcmtBY3RpdmVGb3JtYXRXaWRnZXQobmFtZSwgd2lkZ2V0LCBmb3JtYXRzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NvbG9yRm9ybWF0KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVDb2xvcldpZGdldChuYW1lLCBmb3JtYXRzW25hbWVdKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChcInZhbHVlXCIgaW4gd2lkZ2V0Lm9wdGlvbigpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVNpbGVudCh3aWRnZXQsIGZvcm1hdHNbbmFtZV0pXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aWRnZXQuJGVsZW1lbnQoKS5hZGRDbGFzcyhBQ1RJVkVfRk9STUFUX0NMQVNTKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90b2dnbGVDbGVhckZvcm1hdHRpbmcoaGFzRm9ybWF0cykge1xyXG4gICAgICAgICAgICB2YXIgY2xlYXJXaWRnZXQgPSB0aGlzLl90b29sYmFyV2lkZ2V0cy5nZXRCeU5hbWUoXCJjbGVhclwiKTtcclxuICAgICAgICAgICAgaWYgKGNsZWFyV2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhcldpZGdldC5vcHRpb24oXCJkaXNhYmxlZFwiLCAhaGFzRm9ybWF0cylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfaXNDb2xvckZvcm1hdChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcImNvbG9yXCIgPT09IG5hbWUgfHwgXCJiYWNrZ3JvdW5kXCIgPT09IG5hbWVcclxuICAgICAgICB9XHJcbiAgICAgICAgX3VwZGF0ZUNvbG9yV2lkZ2V0KG5hbWUsIGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXRXaWRnZXQgPSB0aGlzLl90b29sYmFyV2lkZ2V0cy5nZXRCeU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghZm9ybWF0V2lkZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3JtYXRXaWRnZXQuJGVsZW1lbnQoKS5maW5kKFwiLlwiLmNvbmNhdChJQ09OX0NMQVNTKSkuY3NzKFwiYm9yZGVyQm90dG9tQ29sb3JcIiwgY29sb3IgfHwgXCJ0cmFuc3BhcmVudFwiKVxyXG4gICAgICAgIH1cclxuICAgICAgICBfZ2V0Rm9ybWF0V2lkZ2V0TmFtZShuYW1lLCBmb3JtYXRzKSB7XHJcbiAgICAgICAgICAgIHZhciB3aWRnZXROYW1lO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJhbGlnblwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldE5hbWUgPSBuYW1lICsgdGl0bGVpemUoZm9ybWF0c1tuYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibGlzdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldE5hbWUgPSBmb3JtYXRzW25hbWVdICsgdGl0bGVpemUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29kZS1ibG9ja1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldE5hbWUgPSBcImNvZGVCbG9ja1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldE5hbWUgPSBmb3JtYXRzW25hbWVdICsgbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJpbWFnZVNyY1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldE5hbWUgPSBcImltYWdlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldE5hbWUgPSBuYW1lXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHdpZGdldE5hbWVcclxuICAgICAgICB9XHJcbiAgICAgICAgX3NldFZhbHVlU2lsZW50KHdpZGdldCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNSZXNldCA9IHRydWU7XHJcbiAgICAgICAgICAgIHdpZGdldC5vcHRpb24oXCJ2YWx1ZVwiLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzZXQgPSBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgICAgICBfcmVzZXRGb3JtYXRXaWRnZXRzKCkge1xyXG4gICAgICAgICAgICB0aGlzLl90b29sYmFyV2lkZ2V0cy5lYWNoKChuYW1lLCB3aWRnZXQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0Rm9ybWF0V2lkZ2V0KG5hbWUsIHdpZGdldClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgX3Jlc2V0Rm9ybWF0V2lkZ2V0KG5hbWUsIHdpZGdldCkge1xyXG4gICAgICAgICAgICB3aWRnZXQuJGVsZW1lbnQoKS5yZW1vdmVDbGFzcyhBQ1RJVkVfRk9STUFUX0NMQVNTKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ29sb3JGb3JtYXQobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yV2lkZ2V0KG5hbWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFwiY2xlYXJcIiA9PT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgd2lkZ2V0Lm9wdGlvbihcImRpc2FibGVkXCIsIHRydWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFwiZHhTZWxlY3RCb3hcIiA9PT0gd2lkZ2V0Lk5BTUUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlU2lsZW50KHdpZGdldCwgbnVsbClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRDbGlja0hhbmRsZXIobmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9mb3JtYXRIYW5kbGVyc1tuYW1lXSA9IGhhbmRsZXI7XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXRXaWRnZXQgPSB0aGlzLl90b29sYmFyV2lkZ2V0cy5nZXRCeU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXRXaWRnZXQgJiYgXCJkeEJ1dHRvblwiID09PSBmb3JtYXRXaWRnZXQuTkFNRSkge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0V2lkZ2V0Lm9wdGlvbihcIm9uQ2xpY2tcIiwgaGFuZGxlcilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBUb29sYmFyTW9kdWxlO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/modules/toolbar.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/modules/variables.js":
/*!*************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/modules/variables.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/* harmony import */ var _core_utils_position__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/utils/position */ \"./node_modules/devextreme/esm/core/utils/position.js\");\n/* harmony import */ var _popup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./popup */ \"./node_modules/devextreme/esm/ui/html_editor/modules/popup.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base */ \"./node_modules/devextreme/esm/ui/html_editor/modules/base.js\");\n/* harmony import */ var _formats_variable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../formats/variable */ \"./node_modules/devextreme/esm/ui/html_editor/formats/variable.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/modules/variables.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar VariableModule = _base__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a) {\r\n    var VARIABLE_FORMAT_CLASS = \"dx-variable-format\";\r\n    var ACTIVE_FORMAT_CLASS = \"dx-format-active\";\r\n    devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a.register({\r\n        \"formats/variable\": _formats_variable__WEBPACK_IMPORTED_MODULE_5__[\"default\"]\r\n    }, true);\r\n    VariableModule = class extends _popup__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\r\n        _getDefaultOptions() {\r\n            var baseConfig = super._getDefaultOptions();\r\n            return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_6__[\"extend\"])(baseConfig, {\r\n                escapeChar: \"\"\r\n            })\r\n        }\r\n        constructor(quill, options) {\r\n            super(quill, options);\r\n            var toolbar = quill.getModule(\"toolbar\");\r\n            if (toolbar) {\r\n                toolbar.addClickHandler(\"variable\", this.showPopup.bind(this))\r\n            }\r\n            quill.keyboard.addBinding({\r\n                key: \"P\",\r\n                altKey: true\r\n            }, this.showPopup.bind(this));\r\n            this._popup.on(\"shown\", e => {\r\n                var $ofElement = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(e.component.option(\"position\").of);\r\n                if ($ofElement.hasClass(VARIABLE_FORMAT_CLASS)) {\r\n                    $ofElement.addClass(ACTIVE_FORMAT_CLASS)\r\n                }\r\n            })\r\n        }\r\n        showPopup(event) {\r\n            var selection = this.quill.getSelection(true);\r\n            var position = selection ? selection.index : this.quill.getLength();\r\n            this.savePosition(position);\r\n            this._resetPopupPosition(event, position);\r\n            super.showPopup()\r\n        }\r\n        _resetPopupPosition(event, position) {\r\n            if (event && event.element) {\r\n                this._popup.option(\"position\", {\r\n                    of: event.element,\r\n                    offset: {\r\n                        h: 0,\r\n                        v: 0\r\n                    },\r\n                    my: \"top center\",\r\n                    at: \"bottom center\",\r\n                    collision: \"fit\"\r\n                })\r\n            } else {\r\n                var mentionBounds = this.quill.getBounds(position);\r\n                var rootRect = Object(_core_utils_position__WEBPACK_IMPORTED_MODULE_2__[\"getBoundingRect\"])(this.quill.root);\r\n                this._popup.option(\"position\", {\r\n                    of: this.quill.root,\r\n                    offset: {\r\n                        h: mentionBounds.left,\r\n                        v: mentionBounds.bottom - rootRect.height\r\n                    },\r\n                    my: \"top center\",\r\n                    at: \"bottom left\",\r\n                    collision: \"fit flip\"\r\n                })\r\n            }\r\n        }\r\n        insertEmbedContent(selectionChangedEvent) {\r\n            var caretPosition = this.getPosition();\r\n            var selectedItem = selectionChangedEvent.component.option(\"selectedItem\");\r\n            var variableData = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_6__[\"extend\"])({}, {\r\n                value: selectedItem,\r\n                escapeChar: this.options.escapeChar\r\n            });\r\n            setTimeout(function() {\r\n                this.quill.insertEmbed(caretPosition, \"variable\", variableData);\r\n                this.quill.setSelection(caretPosition + 1)\r\n            }.bind(this))\r\n        }\r\n    }\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (VariableModule);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy92YXJpYWJsZXMuanM/NWFlYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FDO0FBQ0U7QUFHRDtBQUNKO0FBQ0Y7QUFDVztBQUdQO0FBQ3BDLHFCQUFxQiw2Q0FBVTtBQUMvQixJQUFJLHVEQUFLO0FBQ1Q7QUFDQTtBQUNBLElBQUksdURBQUs7QUFDVCw0QkFBNEIseURBQVE7QUFDcEMsS0FBSztBQUNMLG1DQUFtQyw4Q0FBVztBQUM5QztBQUNBO0FBQ0EsbUJBQW1CLGlFQUFNO0FBQ3pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUNBQWlDLDhEQUFDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLCtCQUErQiw0RUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlFQUFNLEdBQUc7QUFDeEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ2UsNkVBQWMsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9odG1sX2VkaXRvci9tb2R1bGVzL3ZhcmlhYmxlcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy92YXJpYWJsZXMuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCBRdWlsbCBmcm9tIFwiZGV2ZXh0cmVtZS1xdWlsbFwiO1xyXG5pbXBvcnQgJCBmcm9tIFwiLi4vLi4vLi4vY29yZS9yZW5kZXJlclwiO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0Qm91bmRpbmdSZWN0XHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvcG9zaXRpb25cIjtcclxuaW1wb3J0IFBvcHVwTW9kdWxlIGZyb20gXCIuL3BvcHVwXCI7XHJcbmltcG9ydCBCYXNlTW9kdWxlIGZyb20gXCIuL2Jhc2VcIjtcclxuaW1wb3J0IFZhcmlhYmxlIGZyb20gXCIuLi9mb3JtYXRzL3ZhcmlhYmxlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBleHRlbmRcclxufSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlscy9leHRlbmRcIjtcclxudmFyIFZhcmlhYmxlTW9kdWxlID0gQmFzZU1vZHVsZTtcclxuaWYgKFF1aWxsKSB7XHJcbiAgICB2YXIgVkFSSUFCTEVfRk9STUFUX0NMQVNTID0gXCJkeC12YXJpYWJsZS1mb3JtYXRcIjtcclxuICAgIHZhciBBQ1RJVkVfRk9STUFUX0NMQVNTID0gXCJkeC1mb3JtYXQtYWN0aXZlXCI7XHJcbiAgICBRdWlsbC5yZWdpc3Rlcih7XHJcbiAgICAgICAgXCJmb3JtYXRzL3ZhcmlhYmxlXCI6IFZhcmlhYmxlXHJcbiAgICB9LCB0cnVlKTtcclxuICAgIFZhcmlhYmxlTW9kdWxlID0gY2xhc3MgZXh0ZW5kcyBQb3B1cE1vZHVsZSB7XHJcbiAgICAgICAgX2dldERlZmF1bHRPcHRpb25zKCkge1xyXG4gICAgICAgICAgICB2YXIgYmFzZUNvbmZpZyA9IHN1cGVyLl9nZXREZWZhdWx0T3B0aW9ucygpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kKGJhc2VDb25maWcsIHtcclxuICAgICAgICAgICAgICAgIGVzY2FwZUNoYXI6IFwiXCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3RydWN0b3IocXVpbGwsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgc3VwZXIocXVpbGwsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB2YXIgdG9vbGJhciA9IHF1aWxsLmdldE1vZHVsZShcInRvb2xiYXJcIik7XHJcbiAgICAgICAgICAgIGlmICh0b29sYmFyKSB7XHJcbiAgICAgICAgICAgICAgICB0b29sYmFyLmFkZENsaWNrSGFuZGxlcihcInZhcmlhYmxlXCIsIHRoaXMuc2hvd1BvcHVwLmJpbmQodGhpcykpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcXVpbGwua2V5Ym9hcmQuYWRkQmluZGluZyh7XHJcbiAgICAgICAgICAgICAgICBrZXk6IFwiUFwiLFxyXG4gICAgICAgICAgICAgICAgYWx0S2V5OiB0cnVlXHJcbiAgICAgICAgICAgIH0sIHRoaXMuc2hvd1BvcHVwLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLl9wb3B1cC5vbihcInNob3duXCIsIGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyICRvZkVsZW1lbnQgPSAkKGUuY29tcG9uZW50Lm9wdGlvbihcInBvc2l0aW9uXCIpLm9mKTtcclxuICAgICAgICAgICAgICAgIGlmICgkb2ZFbGVtZW50Lmhhc0NsYXNzKFZBUklBQkxFX0ZPUk1BVF9DTEFTUykpIHtcclxuICAgICAgICAgICAgICAgICAgICAkb2ZFbGVtZW50LmFkZENsYXNzKEFDVElWRV9GT1JNQVRfQ0xBU1MpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNob3dQb3B1cChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5xdWlsbC5nZXRTZWxlY3Rpb24odHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5pbmRleCA6IHRoaXMucXVpbGwuZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2F2ZVBvc2l0aW9uKHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVzZXRQb3B1cFBvc2l0aW9uKGV2ZW50LCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHN1cGVyLnNob3dQb3B1cCgpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yZXNldFBvcHVwUG9zaXRpb24oZXZlbnQsIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudCAmJiBldmVudC5lbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3B1cC5vcHRpb24oXCJwb3NpdGlvblwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Y6IGV2ZW50LmVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHY6IDBcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG15OiBcInRvcCBjZW50ZXJcIixcclxuICAgICAgICAgICAgICAgICAgICBhdDogXCJib3R0b20gY2VudGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uOiBcImZpdFwiXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lbnRpb25Cb3VuZHMgPSB0aGlzLnF1aWxsLmdldEJvdW5kcyhwb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm9vdFJlY3QgPSBnZXRCb3VuZGluZ1JlY3QodGhpcy5xdWlsbC5yb290KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVwLm9wdGlvbihcInBvc2l0aW9uXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBvZjogdGhpcy5xdWlsbC5yb290LFxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoOiBtZW50aW9uQm91bmRzLmxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHY6IG1lbnRpb25Cb3VuZHMuYm90dG9tIC0gcm9vdFJlY3QuaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBteTogXCJ0b3AgY2VudGVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgYXQ6IFwiYm90dG9tIGxlZnRcIixcclxuICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb246IFwiZml0IGZsaXBcIlxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpbnNlcnRFbWJlZENvbnRlbnQoc2VsZWN0aW9uQ2hhbmdlZEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRJdGVtID0gc2VsZWN0aW9uQ2hhbmdlZEV2ZW50LmNvbXBvbmVudC5vcHRpb24oXCJzZWxlY3RlZEl0ZW1cIik7XHJcbiAgICAgICAgICAgIHZhciB2YXJpYWJsZURhdGEgPSBleHRlbmQoe30sIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBzZWxlY3RlZEl0ZW0sXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVDaGFyOiB0aGlzLm9wdGlvbnMuZXNjYXBlQ2hhclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVpbGwuaW5zZXJ0RW1iZWQoY2FyZXRQb3NpdGlvbiwgXCJ2YXJpYWJsZVwiLCB2YXJpYWJsZURhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWlsbC5zZXRTZWxlY3Rpb24oY2FyZXRQb3NpdGlvbiArIDEpXHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgVmFyaWFibGVNb2R1bGU7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/modules/variables.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/modules/widget_collector.js":
/*!********************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/modules/widget_collector.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WidgetCollector; });\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/modules/widget_collector.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\nclass WidgetCollector {\r\n    constructor() {\r\n        this._collection = []\r\n    }\r\n    clear() {\r\n        this._collection = []\r\n    }\r\n    add(name, instance) {\r\n        this._collection.push({\r\n            name: name,\r\n            instance: instance\r\n        })\r\n    }\r\n    getByName(widgetName) {\r\n        var widget = null;\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(this._collection, (index, _ref) => {\r\n            var {\r\n                name: name,\r\n                instance: instance\r\n            } = _ref;\r\n            if (name === widgetName) {\r\n                widget = instance;\r\n                return false\r\n            }\r\n        });\r\n        return widget\r\n    }\r\n    each(handler) {\r\n        this._collection.forEach(_ref2 => {\r\n            var {\r\n                name: name,\r\n                instance: instance\r\n            } = _ref2;\r\n            return instance && handler(name, instance)\r\n        })\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvbW9kdWxlcy93aWRnZXRfY29sbGVjdG9yLmpzP2NkYTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdzQztBQUN2QjtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9odG1sX2VkaXRvci9tb2R1bGVzL3dpZGdldF9jb2xsZWN0b3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3VpL2h0bWxfZWRpdG9yL21vZHVsZXMvd2lkZ2V0X2NvbGxlY3Rvci5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IHtcclxuICAgIGVhY2hcclxufSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlscy9pdGVyYXRvclwiO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaWRnZXRDb2xsZWN0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IFtdXHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gW11cclxuICAgIH1cclxuICAgIGFkZChuYW1lLCBpbnN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb24ucHVzaCh7XHJcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBnZXRCeU5hbWUod2lkZ2V0TmFtZSkge1xyXG4gICAgICAgIHZhciB3aWRnZXQgPSBudWxsO1xyXG4gICAgICAgIGVhY2godGhpcy5fY29sbGVjdGlvbiwgKGluZGV4LCBfcmVmKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXHJcbiAgICAgICAgICAgIH0gPSBfcmVmO1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gd2lkZ2V0TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgd2lkZ2V0ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB3aWRnZXRcclxuICAgIH1cclxuICAgIGVhY2goaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb24uZm9yRWFjaChfcmVmMiA9PiB7XHJcbiAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXHJcbiAgICAgICAgICAgIH0gPSBfcmVmMjtcclxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlICYmIGhhbmRsZXIobmFtZSwgaW5zdGFuY2UpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/modules/widget_collector.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/quill_importer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/quill_importer.js ***!
  \**********************************************************************/
/*! exports provided: getQuill */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getQuill\", function() { return getQuill; });\n/* harmony import */ var _widget_ui_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../widget/ui.errors */ \"./node_modules/devextreme/esm/ui/widget/ui.errors.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_1__);\n/**\r\n * DevExtreme (esm/ui/html_editor/quill_importer.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\nfunction getQuill() {\r\n    if (!devextreme_quill__WEBPACK_IMPORTED_MODULE_1___default.a) {\r\n        throw _widget_ui_errors__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Error(\"E1041\", \"Quill\")\r\n    }\r\n    return devextreme_quill__WEBPACK_IMPORTED_MODULE_1___default.a\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvcXVpbGxfaW1wb3J0ZXIuanM/MTA1MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5QztBQUNKO0FBQzlCO0FBQ1AsU0FBUyx1REFBSztBQUNkLGNBQWMseURBQU07QUFDcEI7QUFDQSxXQUFXLHVEQUFLO0FBQ2hCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3VpL2h0bWxfZWRpdG9yL3F1aWxsX2ltcG9ydGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS91aS9odG1sX2VkaXRvci9xdWlsbF9pbXBvcnRlci5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IEVycm9ycyBmcm9tIFwiLi4vd2lkZ2V0L3VpLmVycm9yc1wiO1xyXG5pbXBvcnQgUXVpbGwgZnJvbSBcImRldmV4dHJlbWUtcXVpbGxcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIGdldFF1aWxsKCkge1xyXG4gICAgaWYgKCFRdWlsbCkge1xyXG4gICAgICAgIHRocm93IEVycm9ycy5FcnJvcihcIkUxMDQxXCIsIFwiUXVpbGxcIilcclxuICAgIH1cclxuICAgIHJldHVybiBRdWlsbFxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/quill_importer.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/quill_registrator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/quill_registrator.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _quill_importer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quill_importer */ \"./node_modules/devextreme/esm/ui/html_editor/quill_importer.js\");\n/* harmony import */ var _themes_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./themes/base */ \"./node_modules/devextreme/esm/ui/html_editor/themes/base.js\");\n/* harmony import */ var _formats_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formats/image */ \"./node_modules/devextreme/esm/ui/html_editor/formats/image.js\");\n/* harmony import */ var _formats_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formats/link */ \"./node_modules/devextreme/esm/ui/html_editor/formats/link.js\");\n/* harmony import */ var _formats_font__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formats/font */ \"./node_modules/devextreme/esm/ui/html_editor/formats/font.js\");\n/* harmony import */ var _formats_size__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formats/size */ \"./node_modules/devextreme/esm/ui/html_editor/formats/size.js\");\n/* harmony import */ var _formats_align__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formats/align */ \"./node_modules/devextreme/esm/ui/html_editor/formats/align.js\");\n/* harmony import */ var _modules_toolbar__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules/toolbar */ \"./node_modules/devextreme/esm/ui/html_editor/modules/toolbar.js\");\n/* harmony import */ var _modules_dropImage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modules/dropImage */ \"./node_modules/devextreme/esm/ui/html_editor/modules/dropImage.js\");\n/* harmony import */ var _modules_variables__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modules/variables */ \"./node_modules/devextreme/esm/ui/html_editor/modules/variables.js\");\n/* harmony import */ var _modules_resizing__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modules/resizing */ \"./node_modules/devextreme/esm/ui/html_editor/modules/resizing.js\");\n/* harmony import */ var _modules_tableResizing__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modules/tableResizing */ \"./node_modules/devextreme/esm/ui/html_editor/modules/tableResizing.js\");\n/* harmony import */ var _modules_tableContextMenu__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modules/tableContextMenu */ \"./node_modules/devextreme/esm/ui/html_editor/modules/tableContextMenu.js\");\n/* harmony import */ var _modules_mentions__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./modules/mentions */ \"./node_modules/devextreme/esm/ui/html_editor/modules/mentions.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/quill_registrator.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass QuillRegistrator {\r\n    constructor() {\r\n        if (QuillRegistrator.initialized) {\r\n            return\r\n        }\r\n        var quill = this.getQuill();\r\n        var DirectionStyle = quill.import(\"attributors/style/direction\");\r\n        quill.register({\r\n            \"formats/align\": _formats_align__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\r\n            \"formats/direction\": DirectionStyle,\r\n            \"formats/font\": _formats_font__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\r\n            \"formats/size\": _formats_size__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\r\n            \"formats/extendedImage\": _formats_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\r\n            \"formats/link\": _formats_link__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\r\n            \"modules/toolbar\": _modules_toolbar__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\r\n            \"modules/dropImage\": _modules_dropImage__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\r\n            \"modules/variables\": _modules_variables__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\r\n            \"modules/resizing\": _modules_resizing__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\r\n            \"modules/tableResizing\": _modules_tableResizing__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\r\n            \"modules/tableContextMenu\": _modules_tableContextMenu__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\r\n            \"modules/mentions\": _modules_mentions__WEBPACK_IMPORTED_MODULE_13__[\"default\"],\r\n            \"themes/basic\": _themes_base__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\r\n        }, true);\r\n        this._customModules = [];\r\n        QuillRegistrator._initialized = true\r\n    }\r\n    createEditor(container, config) {\r\n        var quill = this.getQuill();\r\n        return new quill(container, config)\r\n    }\r\n    registerModules(modulesConfig) {\r\n        var isModule = RegExp(\"modules/*\");\r\n        var quill = this.getQuill();\r\n        var isRegisteredModule = modulePath => !!quill.imports[modulePath];\r\n        for (var modulePath in modulesConfig) {\r\n            if (isModule.test(modulePath) && !isRegisteredModule(modulePath)) {\r\n                this._customModules.push(modulePath.slice(8))\r\n            }\r\n        }\r\n        quill.register(modulesConfig, true)\r\n    }\r\n    getRegisteredModuleNames() {\r\n        return this._customModules\r\n    }\r\n    getQuill() {\r\n        return Object(_quill_importer__WEBPACK_IMPORTED_MODULE_0__[\"getQuill\"])()\r\n    }\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (QuillRegistrator);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvcXVpbGxfcmVnaXN0cmF0b3IuanM/NmU1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRzBCO0FBQ1k7QUFDRjtBQUNGO0FBQ0s7QUFDQTtBQUNFO0FBQ0Q7QUFDSTtBQUNBO0FBQ0Y7QUFDVTtBQUNNO0FBQ1Y7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBVTtBQUN2QztBQUNBLDRCQUE0QixxREFBUztBQUNyQyw0QkFBNEIscURBQVM7QUFDckMscUNBQXFDLHNEQUFLO0FBQzFDLDRCQUE0QixxREFBSTtBQUNoQywrQkFBK0Isd0RBQU87QUFDdEMsaUNBQWlDLDBEQUFTO0FBQzFDLGlDQUFpQywwREFBUztBQUMxQyxnQ0FBZ0MsMERBQVE7QUFDeEMscUNBQXFDLCtEQUFhO0FBQ2xELHdDQUF3QyxrRUFBZ0I7QUFDeEQsZ0NBQWdDLDBEQUFjO0FBQzlDLDRCQUE0QixvREFBUztBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdFQUFRO0FBQ3ZCO0FBQ0E7QUFDZSwrRUFBZ0IsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9odG1sX2VkaXRvci9xdWlsbF9yZWdpc3RyYXRvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdWkvaHRtbF9lZGl0b3IvcXVpbGxfcmVnaXN0cmF0b3IuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCB7XHJcbiAgICBnZXRRdWlsbFxyXG59IGZyb20gXCIuL3F1aWxsX2ltcG9ydGVyXCI7XHJcbmltcG9ydCBCYXNlVGhlbWUgZnJvbSBcIi4vdGhlbWVzL2Jhc2VcIjtcclxuaW1wb3J0IEltYWdlIGZyb20gXCIuL2Zvcm1hdHMvaW1hZ2VcIjtcclxuaW1wb3J0IExpbmsgZnJvbSBcIi4vZm9ybWF0cy9saW5rXCI7XHJcbmltcG9ydCBGb250U3R5bGUgZnJvbSBcIi4vZm9ybWF0cy9mb250XCI7XHJcbmltcG9ydCBTaXplU3R5bGUgZnJvbSBcIi4vZm9ybWF0cy9zaXplXCI7XHJcbmltcG9ydCBBbGlnblN0eWxlIGZyb20gXCIuL2Zvcm1hdHMvYWxpZ25cIjtcclxuaW1wb3J0IFRvb2xiYXIgZnJvbSBcIi4vbW9kdWxlcy90b29sYmFyXCI7XHJcbmltcG9ydCBEcm9wSW1hZ2UgZnJvbSBcIi4vbW9kdWxlcy9kcm9wSW1hZ2VcIjtcclxuaW1wb3J0IFZhcmlhYmxlcyBmcm9tIFwiLi9tb2R1bGVzL3ZhcmlhYmxlc1wiO1xyXG5pbXBvcnQgUmVzaXppbmcgZnJvbSBcIi4vbW9kdWxlcy9yZXNpemluZ1wiO1xyXG5pbXBvcnQgVGFibGVSZXNpemluZyBmcm9tIFwiLi9tb2R1bGVzL3RhYmxlUmVzaXppbmdcIjtcclxuaW1wb3J0IFRhYmxlQ29udGV4dE1lbnUgZnJvbSBcIi4vbW9kdWxlcy90YWJsZUNvbnRleHRNZW51XCI7XHJcbmltcG9ydCBNZW50aW9uc01vZHVsZSBmcm9tIFwiLi9tb2R1bGVzL21lbnRpb25zXCI7XHJcbmNsYXNzIFF1aWxsUmVnaXN0cmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgaWYgKFF1aWxsUmVnaXN0cmF0b3IuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBxdWlsbCA9IHRoaXMuZ2V0UXVpbGwoKTtcclxuICAgICAgICB2YXIgRGlyZWN0aW9uU3R5bGUgPSBxdWlsbC5pbXBvcnQoXCJhdHRyaWJ1dG9ycy9zdHlsZS9kaXJlY3Rpb25cIik7XHJcbiAgICAgICAgcXVpbGwucmVnaXN0ZXIoe1xyXG4gICAgICAgICAgICBcImZvcm1hdHMvYWxpZ25cIjogQWxpZ25TdHlsZSxcclxuICAgICAgICAgICAgXCJmb3JtYXRzL2RpcmVjdGlvblwiOiBEaXJlY3Rpb25TdHlsZSxcclxuICAgICAgICAgICAgXCJmb3JtYXRzL2ZvbnRcIjogRm9udFN0eWxlLFxyXG4gICAgICAgICAgICBcImZvcm1hdHMvc2l6ZVwiOiBTaXplU3R5bGUsXHJcbiAgICAgICAgICAgIFwiZm9ybWF0cy9leHRlbmRlZEltYWdlXCI6IEltYWdlLFxyXG4gICAgICAgICAgICBcImZvcm1hdHMvbGlua1wiOiBMaW5rLFxyXG4gICAgICAgICAgICBcIm1vZHVsZXMvdG9vbGJhclwiOiBUb29sYmFyLFxyXG4gICAgICAgICAgICBcIm1vZHVsZXMvZHJvcEltYWdlXCI6IERyb3BJbWFnZSxcclxuICAgICAgICAgICAgXCJtb2R1bGVzL3ZhcmlhYmxlc1wiOiBWYXJpYWJsZXMsXHJcbiAgICAgICAgICAgIFwibW9kdWxlcy9yZXNpemluZ1wiOiBSZXNpemluZyxcclxuICAgICAgICAgICAgXCJtb2R1bGVzL3RhYmxlUmVzaXppbmdcIjogVGFibGVSZXNpemluZyxcclxuICAgICAgICAgICAgXCJtb2R1bGVzL3RhYmxlQ29udGV4dE1lbnVcIjogVGFibGVDb250ZXh0TWVudSxcclxuICAgICAgICAgICAgXCJtb2R1bGVzL21lbnRpb25zXCI6IE1lbnRpb25zTW9kdWxlLFxyXG4gICAgICAgICAgICBcInRoZW1lcy9iYXNpY1wiOiBCYXNlVGhlbWVcclxuICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICB0aGlzLl9jdXN0b21Nb2R1bGVzID0gW107XHJcbiAgICAgICAgUXVpbGxSZWdpc3RyYXRvci5faW5pdGlhbGl6ZWQgPSB0cnVlXHJcbiAgICB9XHJcbiAgICBjcmVhdGVFZGl0b3IoY29udGFpbmVyLCBjb25maWcpIHtcclxuICAgICAgICB2YXIgcXVpbGwgPSB0aGlzLmdldFF1aWxsKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBxdWlsbChjb250YWluZXIsIGNvbmZpZylcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyTW9kdWxlcyhtb2R1bGVzQ29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGlzTW9kdWxlID0gUmVnRXhwKFwibW9kdWxlcy8qXCIpO1xyXG4gICAgICAgIHZhciBxdWlsbCA9IHRoaXMuZ2V0UXVpbGwoKTtcclxuICAgICAgICB2YXIgaXNSZWdpc3RlcmVkTW9kdWxlID0gbW9kdWxlUGF0aCA9PiAhIXF1aWxsLmltcG9ydHNbbW9kdWxlUGF0aF07XHJcbiAgICAgICAgZm9yICh2YXIgbW9kdWxlUGF0aCBpbiBtb2R1bGVzQ29uZmlnKSB7XHJcbiAgICAgICAgICAgIGlmIChpc01vZHVsZS50ZXN0KG1vZHVsZVBhdGgpICYmICFpc1JlZ2lzdGVyZWRNb2R1bGUobW9kdWxlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1c3RvbU1vZHVsZXMucHVzaChtb2R1bGVQYXRoLnNsaWNlKDgpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1aWxsLnJlZ2lzdGVyKG1vZHVsZXNDb25maWcsIHRydWUpXHJcbiAgICB9XHJcbiAgICBnZXRSZWdpc3RlcmVkTW9kdWxlTmFtZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1c3RvbU1vZHVsZXNcclxuICAgIH1cclxuICAgIGdldFF1aWxsKCkge1xyXG4gICAgICAgIHJldHVybiBnZXRRdWlsbCgpXHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgUXVpbGxSZWdpc3RyYXRvcjtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/quill_registrator.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/themes/base.js":
/*!*******************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/themes/base.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devextreme-quill */ \"./node_modules/devextreme-quill/dist/dx-quill.js\");\n/* harmony import */ var devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(devextreme_quill__WEBPACK_IMPORTED_MODULE_0__);\n/**\r\n * DevExtreme (esm/ui/html_editor/themes/base.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\nvar BaseTheme;\r\nif (devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a) {\r\n    var Theme = devextreme_quill__WEBPACK_IMPORTED_MODULE_0___default.a.import(\"core/theme\");\r\n    BaseTheme = class extends Theme {\r\n        constructor(quill, options) {\r\n            super(quill, options);\r\n            this.quill.root.classList.add(\"dx-htmleditor-content\");\r\n            this.quill.root.setAttribute(\"role\", \"textbox\")\r\n        }\r\n    }\r\n} else {\r\n    BaseTheme = {}\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (BaseTheme);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvdGhlbWVzL2Jhc2UuanM/M2JjNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FDO0FBQ3JDO0FBQ0EsSUFBSSx1REFBSztBQUNULGdCQUFnQix1REFBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ2Usd0VBQVMsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9odG1sX2VkaXRvci90aGVtZXMvYmFzZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdWkvaHRtbF9lZGl0b3IvdGhlbWVzL2Jhc2UuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCBRdWlsbCBmcm9tIFwiZGV2ZXh0cmVtZS1xdWlsbFwiO1xyXG52YXIgQmFzZVRoZW1lO1xyXG5pZiAoUXVpbGwpIHtcclxuICAgIHZhciBUaGVtZSA9IFF1aWxsLmltcG9ydChcImNvcmUvdGhlbWVcIik7XHJcbiAgICBCYXNlVGhlbWUgPSBjbGFzcyBleHRlbmRzIFRoZW1lIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihxdWlsbCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBzdXBlcihxdWlsbCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMucXVpbGwucm9vdC5jbGFzc0xpc3QuYWRkKFwiZHgtaHRtbGVkaXRvci1jb250ZW50XCIpO1xyXG4gICAgICAgICAgICB0aGlzLnF1aWxsLnJvb3Quc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRleHRib3hcIilcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0gZWxzZSB7XHJcbiAgICBCYXNlVGhlbWUgPSB7fVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IEJhc2VUaGVtZTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/themes/base.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/ui.html_editor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/ui.html_editor.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/element */ \"./node_modules/devextreme/esm/core/element.js\");\n/* harmony import */ var _core_utils_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/utils/common */ \"./node_modules/devextreme/esm/core/utils/common.js\");\n/* harmony import */ var _core_component_registrator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/component_registrator */ \"./node_modules/devextreme/esm/core/component_registrator.js\");\n/* harmony import */ var _core_templates_empty_template__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/templates/empty_template */ \"./node_modules/devextreme/esm/core/templates/empty_template.js\");\n/* harmony import */ var _editor_editor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../editor/editor */ \"./node_modules/devextreme/esm/ui/editor/editor.js\");\n/* harmony import */ var _widget_ui_errors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../widget/ui.errors */ \"./node_modules/devextreme/esm/ui/widget/ui.errors.js\");\n/* harmony import */ var _core_utils_callbacks__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/utils/callbacks */ \"./node_modules/devextreme/esm/core/utils/callbacks.js\");\n/* harmony import */ var _core_utils_deferred__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/utils/deferred */ \"./node_modules/devextreme/esm/core/utils/deferred.js\");\n/* harmony import */ var _events_core_events_engine__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../events/core/events_engine */ \"./node_modules/devextreme/esm/events/core/events_engine.js\");\n/* harmony import */ var _events_utils_index__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../events/utils/index */ \"./node_modules/devextreme/esm/events/utils/index.js\");\n/* harmony import */ var _events_index__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../events/index */ \"./node_modules/devextreme/esm/events/index.js\");\n/* harmony import */ var _events_gesture_emitter_gesture_scroll__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../events/gesture/emitter.gesture.scroll */ \"./node_modules/devextreme/esm/events/gesture/emitter.gesture.scroll.js\");\n/* harmony import */ var _text_box_utils_scroll__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../text_box/utils.scroll */ \"./node_modules/devextreme/esm/ui/text_box/utils.scroll.js\");\n/* harmony import */ var _events_pointer__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../events/pointer */ \"./node_modules/devextreme/esm/events/pointer.js\");\n/* harmony import */ var _core_devices__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../core/devices */ \"./node_modules/devextreme/esm/core/devices.js\");\n/* harmony import */ var _quill_registrator__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./quill_registrator */ \"./node_modules/devextreme/esm/ui/html_editor/quill_registrator.js\");\n/* harmony import */ var _converters_delta__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./converters/delta */ \"./node_modules/devextreme/esm/ui/html_editor/converters/delta.js\");\n/* harmony import */ var _converterController__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./converterController */ \"./node_modules/devextreme/esm/ui/html_editor/converterController.js\");\n/* harmony import */ var _matchers_wordLists__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./matchers/wordLists */ \"./node_modules/devextreme/esm/ui/html_editor/matchers/wordLists.js\");\n/* harmony import */ var _ui_formDialog__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./ui/formDialog */ \"./node_modules/devextreme/esm/ui/html_editor/ui/formDialog.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/ui.html_editor.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar HTML_EDITOR_CLASS = \"dx-htmleditor\";\r\nvar QUILL_CONTAINER_CLASS = \"dx-quill-container\";\r\nvar QUILL_CLIPBOARD_CLASS = \"ql-clipboard\";\r\nvar HTML_EDITOR_SUBMIT_ELEMENT_CLASS = \"dx-htmleditor-submit-element\";\r\nvar HTML_EDITOR_CONTENT_CLASS = \"dx-htmleditor-content\";\r\nvar MARKDOWN_VALUE_TYPE = \"markdown\";\r\nvar ANONYMOUS_TEMPLATE_NAME = \"htmlContent\";\r\nvar isIos = \"ios\" === _core_devices__WEBPACK_IMPORTED_MODULE_17__[\"default\"].current().platform;\r\nvar HtmlEditor = _editor_editor__WEBPACK_IMPORTED_MODULE_7__[\"default\"].inherit({\r\n    _getDefaultOptions: function() {\r\n        return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])(this.callBase(), {\r\n            focusStateEnabled: true,\r\n            valueType: \"html\",\r\n            placeholder: \"\",\r\n            toolbar: null,\r\n            variables: null,\r\n            mediaResizing: null,\r\n            tableResizing: null,\r\n            mentions: null,\r\n            customizeModules: null,\r\n            tableContextMenu: null,\r\n            allowSoftLineBreak: false,\r\n            formDialogOptions: null,\r\n            stylingMode: \"outlined\"\r\n        })\r\n    },\r\n    _init: function() {\r\n        this.callBase();\r\n        this._cleanCallback = Object(_core_utils_callbacks__WEBPACK_IMPORTED_MODULE_9__[\"default\"])();\r\n        this._contentInitializedCallback = Object(_core_utils_callbacks__WEBPACK_IMPORTED_MODULE_9__[\"default\"])()\r\n    },\r\n    _getAnonymousTemplateName: function() {\r\n        return ANONYMOUS_TEMPLATE_NAME\r\n    },\r\n    _initTemplates: function() {\r\n        this._templateManager.addDefaultTemplates({\r\n            [ANONYMOUS_TEMPLATE_NAME]: new _core_templates_empty_template__WEBPACK_IMPORTED_MODULE_6__[\"EmptyTemplate\"]\r\n        });\r\n        this.callBase()\r\n    },\r\n    _focusTarget: function() {\r\n        return this._getContent()\r\n    },\r\n    _getContent: function() {\r\n        return this.$element().find(\".\".concat(HTML_EDITOR_CONTENT_CLASS))\r\n    },\r\n    _focusInHandler: function(_ref) {\r\n        var {\r\n            relatedTarget: relatedTarget\r\n        } = _ref;\r\n        if (this._shouldSkipFocusEvent(relatedTarget)) {\r\n            return\r\n        }\r\n        this._toggleFocusClass(true, this.$element());\r\n        this.callBase.apply(this, arguments)\r\n    },\r\n    _focusOutHandler: function(_ref2) {\r\n        var {\r\n            relatedTarget: relatedTarget\r\n        } = _ref2;\r\n        if (this._shouldSkipFocusEvent(relatedTarget)) {\r\n            return\r\n        }\r\n        this._toggleFocusClass(false, this.$element());\r\n        this.callBase.apply(this, arguments)\r\n    },\r\n    _shouldSkipFocusEvent: function(relatedTarget) {\r\n        return Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(relatedTarget).hasClass(QUILL_CLIPBOARD_CLASS)\r\n    },\r\n    _initMarkup: function() {\r\n        this._$htmlContainer = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\").addClass(QUILL_CONTAINER_CLASS);\r\n        this.$element().attr(\"role\", \"application\").addClass(HTML_EDITOR_CLASS).wrapInner(this._$htmlContainer);\r\n        this._renderStylingMode();\r\n        var template = this._getTemplate(ANONYMOUS_TEMPLATE_NAME);\r\n        this._$templateResult = template && template.render({\r\n            container: Object(_core_element__WEBPACK_IMPORTED_MODULE_3__[\"getPublicElement\"])(this._$htmlContainer),\r\n            noModel: true,\r\n            transclude: true\r\n        });\r\n        this._renderSubmitElement();\r\n        this.callBase();\r\n        this._updateContainerMarkup()\r\n    },\r\n    _renderSubmitElement: function() {\r\n        this._$submitElement = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<textarea>\").addClass(HTML_EDITOR_SUBMIT_ELEMENT_CLASS).attr(\"hidden\", true).appendTo(this.$element());\r\n        this._setSubmitValue(this.option(\"value\"))\r\n    },\r\n    _setSubmitValue: function(value) {\r\n        this._getSubmitElement().val(value)\r\n    },\r\n    _getSubmitElement: function() {\r\n        return this._$submitElement\r\n    },\r\n    _updateContainerMarkup: function() {\r\n        var markup = this.option(\"value\");\r\n        if (this._isMarkdownValue()) {\r\n            this._prepareMarkdownConverter();\r\n            markup = this._markdownConverter.toHtml(markup)\r\n        }\r\n        if (markup) {\r\n            this._$htmlContainer.html(markup)\r\n        }\r\n    },\r\n    _prepareMarkdownConverter: function() {\r\n        var MarkdownConverter = _converterController__WEBPACK_IMPORTED_MODULE_20__[\"default\"].getConverter(\"markdown\");\r\n        if (MarkdownConverter) {\r\n            this._markdownConverter = new MarkdownConverter\r\n        } else {\r\n            throw _widget_ui_errors__WEBPACK_IMPORTED_MODULE_8__[\"default\"].Error(\"E1051\", \"markdown\")\r\n        }\r\n    },\r\n    _render: function() {\r\n        this._prepareConverters();\r\n        this.callBase()\r\n    },\r\n    _prepareQuillRegistrator: function() {\r\n        if (!this._quillRegistrator) {\r\n            this._quillRegistrator = new _quill_registrator__WEBPACK_IMPORTED_MODULE_18__[\"default\"]\r\n        }\r\n    },\r\n    _getRegistrator: function() {\r\n        this._prepareQuillRegistrator();\r\n        return this._quillRegistrator\r\n    },\r\n    _prepareConverters: function() {\r\n        if (!this._deltaConverter) {\r\n            var DeltaConverter = _converterController__WEBPACK_IMPORTED_MODULE_20__[\"default\"].getConverter(\"delta\");\r\n            if (DeltaConverter) {\r\n                this._deltaConverter = new DeltaConverter\r\n            }\r\n        }\r\n        if (this.option(\"valueType\") === MARKDOWN_VALUE_TYPE && !this._markdownConverter) {\r\n            this._prepareMarkdownConverter()\r\n        }\r\n    },\r\n    _renderContentImpl: function() {\r\n        this._contentRenderedDeferred = new _core_utils_deferred__WEBPACK_IMPORTED_MODULE_10__[\"Deferred\"];\r\n        var renderContentPromise = this._contentRenderedDeferred.promise();\r\n        this.callBase();\r\n        this._renderHtmlEditor();\r\n        this._renderFormDialog();\r\n        this._addKeyPressHandler();\r\n        return renderContentPromise\r\n    },\r\n    _pointerMoveHandler: function(e) {\r\n        if (isIos) {\r\n            e.stopPropagation()\r\n        }\r\n    },\r\n    _attachFocusEvents: function() {\r\n        Object(_core_utils_common__WEBPACK_IMPORTED_MODULE_4__[\"deferRender\"])(this.callBase.bind(this))\r\n    },\r\n    _addKeyPressHandler: function() {\r\n        var keyDownEvent = Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_12__[\"addNamespace\"])(\"keydown\", \"\".concat(this.NAME, \"TextChange\"));\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_11__[\"default\"].on(this._$htmlContainer, keyDownEvent, this._keyDownHandler.bind(this))\r\n    },\r\n    _keyDownHandler: function(e) {\r\n        this._saveValueChangeEvent(e)\r\n    },\r\n    _renderHtmlEditor: function() {\r\n        var customizeModules = this.option(\"customizeModules\");\r\n        var modulesConfig = this._getModulesConfig();\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(customizeModules)) {\r\n            customizeModules(modulesConfig)\r\n        }\r\n        this._quillInstance = this._getRegistrator().createEditor(this._$htmlContainer[0], {\r\n            placeholder: this.option(\"placeholder\"),\r\n            readOnly: this.option(\"readOnly\") || this.option(\"disabled\"),\r\n            modules: modulesConfig,\r\n            theme: \"basic\"\r\n        });\r\n        this._deltaConverter.setQuillInstance(this._quillInstance);\r\n        this._textChangeHandlerWithContext = this._textChangeHandler.bind(this);\r\n        this._quillInstance.on(\"text-change\", this._textChangeHandlerWithContext);\r\n        this._renderScrollHandler();\r\n        if (this._hasTranscludedContent()) {\r\n            this._updateContentTask = Object(_core_utils_common__WEBPACK_IMPORTED_MODULE_4__[\"executeAsync\"])(() => {\r\n                this._applyTranscludedContent()\r\n            })\r\n        } else {\r\n            this._finalizeContentRendering()\r\n        }\r\n    },\r\n    _renderScrollHandler: function() {\r\n        var $scrollContainer = this._getContent();\r\n        var initScrollData = Object(_text_box_utils_scroll__WEBPACK_IMPORTED_MODULE_15__[\"prepareScrollData\"])($scrollContainer);\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_11__[\"default\"].on($scrollContainer, Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_12__[\"addNamespace\"])(_events_gesture_emitter_gesture_scroll__WEBPACK_IMPORTED_MODULE_14__[\"default\"].init, this.NAME), initScrollData, _core_utils_common__WEBPACK_IMPORTED_MODULE_4__[\"noop\"]);\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_11__[\"default\"].on($scrollContainer, Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_12__[\"addNamespace\"])(_events_pointer__WEBPACK_IMPORTED_MODULE_16__[\"default\"].move, this.NAME), this._pointerMoveHandler.bind(this))\r\n    },\r\n    _applyTranscludedContent: function() {\r\n        var valueOption = this.option(\"value\");\r\n        if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(valueOption)) {\r\n            var html = this._deltaConverter.toHtml();\r\n            var newDelta = this._quillInstance.clipboard.convert({\r\n                html: html\r\n            });\r\n            if (newDelta.ops.length) {\r\n                this._quillInstance.setContents(newDelta);\r\n                return\r\n            }\r\n        }\r\n        this._finalizeContentRendering()\r\n    },\r\n    _hasTranscludedContent: function() {\r\n        return this._$templateResult && this._$templateResult.length\r\n    },\r\n    _getModulesConfig: function() {\r\n        var quill = this._getRegistrator().getQuill();\r\n        var wordListMatcher = Object(_matchers_wordLists__WEBPACK_IMPORTED_MODULE_21__[\"default\"])(quill);\r\n        var modulesConfig = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])({}, {\r\n            table: true,\r\n            toolbar: this._getModuleConfigByOption(\"toolbar\"),\r\n            variables: this._getModuleConfigByOption(\"variables\"),\r\n            resizing: this._getModuleConfigByOption(\"mediaResizing\"),\r\n            tableResizing: this._getModuleConfigByOption(\"tableResizing\"),\r\n            tableContextMenu: this._getModuleConfigByOption(\"tableContextMenu\"),\r\n            mentions: this._getModuleConfigByOption(\"mentions\"),\r\n            uploader: {\r\n                onDrop: e => this._saveValueChangeEvent(Object(_events_index__WEBPACK_IMPORTED_MODULE_13__[\"Event\"])(e)),\r\n                imageBlot: \"extendedImage\"\r\n            },\r\n            keyboard: {\r\n                onKeydown: e => this._saveValueChangeEvent(Object(_events_index__WEBPACK_IMPORTED_MODULE_13__[\"Event\"])(e))\r\n            },\r\n            clipboard: {\r\n                onPaste: e => this._saveValueChangeEvent(Object(_events_index__WEBPACK_IMPORTED_MODULE_13__[\"Event\"])(e)),\r\n                onCut: e => this._saveValueChangeEvent(Object(_events_index__WEBPACK_IMPORTED_MODULE_13__[\"Event\"])(e)),\r\n                matchers: [\r\n                    [\"p.MsoListParagraphCxSpFirst\", wordListMatcher],\r\n                    [\"p.MsoListParagraphCxSpMiddle\", wordListMatcher],\r\n                    [\"p.MsoListParagraphCxSpLast\", wordListMatcher]\r\n                ]\r\n            },\r\n            multiline: Boolean(this.option(\"allowSoftLineBreak\"))\r\n        }, this._getCustomModules());\r\n        return modulesConfig\r\n    },\r\n    _getModuleConfigByOption: function(userOptionName) {\r\n        var optionValue = this.option(userOptionName);\r\n        var config = {};\r\n        if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(optionValue)) {\r\n            return\r\n        }\r\n        if (Array.isArray(optionValue)) {\r\n            config[userOptionName] = optionValue\r\n        } else {\r\n            config = optionValue\r\n        }\r\n        return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])(this._getBaseModuleConfig(), config)\r\n    },\r\n    _getBaseModuleConfig: function() {\r\n        return {\r\n            editorInstance: this\r\n        }\r\n    },\r\n    _getCustomModules: function() {\r\n        var modules = {};\r\n        var moduleNames = this._getRegistrator().getRegisteredModuleNames();\r\n        moduleNames.forEach(modulePath => {\r\n            modules[modulePath] = this._getBaseModuleConfig()\r\n        });\r\n        return modules\r\n    },\r\n    _textChangeHandler: function(newDelta, oldDelta, source) {\r\n        var htmlMarkup = this._deltaConverter.toHtml();\r\n        var convertedValue = this._isMarkdownValue() ? this._updateValueByType(MARKDOWN_VALUE_TYPE, htmlMarkup) : htmlMarkup;\r\n        var currentValue = this.option(\"value\");\r\n        if (currentValue !== convertedValue && !this._isNullValueConverted(currentValue, convertedValue)) {\r\n            this._isEditorUpdating = true;\r\n            this.option(\"value\", convertedValue)\r\n        }\r\n        this._finalizeContentRendering()\r\n    },\r\n    _isNullValueConverted: function(currentValue, convertedValue) {\r\n        return null === currentValue && \"\" === convertedValue\r\n    },\r\n    _finalizeContentRendering: function() {\r\n        if (this._contentRenderedDeferred) {\r\n            this.clearHistory();\r\n            this._contentInitializedCallback.fire();\r\n            this._contentRenderedDeferred.resolve();\r\n            this._contentRenderedDeferred = void 0\r\n        }\r\n    },\r\n    _updateValueByType: function(valueType, value) {\r\n        var converter = this._markdownConverter;\r\n        if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(converter)) {\r\n            return\r\n        }\r\n        var currentValue = Object(_core_utils_common__WEBPACK_IMPORTED_MODULE_4__[\"ensureDefined\"])(value, this.option(\"value\"));\r\n        return valueType === MARKDOWN_VALUE_TYPE ? converter.toMarkdown(currentValue) : converter.toHtml(currentValue)\r\n    },\r\n    _isMarkdownValue: function() {\r\n        return this.option(\"valueType\") === MARKDOWN_VALUE_TYPE\r\n    },\r\n    _resetEnabledState: function() {\r\n        if (this._quillInstance) {\r\n            var isEnabled = !(this.option(\"readOnly\") || this.option(\"disabled\"));\r\n            this._quillInstance.enable(isEnabled)\r\n        }\r\n    },\r\n    _renderFormDialog: function() {\r\n        var userOptions = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])(true, {\r\n            width: \"auto\",\r\n            height: \"auto\",\r\n            closeOnOutsideClick: true\r\n        }, this.option(\"formDialogOptions\"));\r\n        this._formDialog = new _ui_formDialog__WEBPACK_IMPORTED_MODULE_22__[\"default\"](this, userOptions)\r\n    },\r\n    _getStylingModePrefix: function() {\r\n        return \"dx-htmleditor-\"\r\n    },\r\n    _getQuillContainer: function() {\r\n        return this._$htmlContainer\r\n    },\r\n    _moduleOptionChanged: function(moduleName, args) {\r\n        var _this$_quillInstance;\r\n        var moduleInstance = null === (_this$_quillInstance = this._quillInstance) || void 0 === _this$_quillInstance ? void 0 : _this$_quillInstance.getModule(moduleName);\r\n        var shouldPassOptionsToModule = Boolean(moduleInstance);\r\n        if (shouldPassOptionsToModule) {\r\n            var _args$fullName;\r\n            var optionData = null === (_args$fullName = args.fullName) || void 0 === _args$fullName ? void 0 : _args$fullName.split(\".\");\r\n            var optionName = 2 === optionData.length ? optionData[1] : args.name;\r\n            moduleInstance.option(optionName, args.value)\r\n        } else {\r\n            this._invalidate()\r\n        }\r\n    },\r\n    _optionChanged: function(args) {\r\n        switch (args.name) {\r\n            case \"value\":\r\n                if (this._quillInstance) {\r\n                    if (this._isEditorUpdating) {\r\n                        this._isEditorUpdating = false\r\n                    } else {\r\n                        var updatedValue = this._isMarkdownValue() ? this._updateValueByType(\"HTML\", args.value) : args.value;\r\n                        this._updateHtmlContent(updatedValue)\r\n                    }\r\n                } else {\r\n                    this._$htmlContainer.html(args.value)\r\n                }\r\n                this._setSubmitValue(args.value);\r\n                this.callBase(args);\r\n                break;\r\n            case \"placeholder\":\r\n            case \"variables\":\r\n            case \"toolbar\":\r\n            case \"mentions\":\r\n            case \"customizeModules\":\r\n            case \"allowSoftLineBreak\":\r\n                this._invalidate();\r\n                break;\r\n            case \"tableResizing\":\r\n                this._moduleOptionChanged(\"tableResizing\", args);\r\n                break;\r\n            case \"valueType\":\r\n                this._prepareConverters();\r\n                var newValue = this._updateValueByType(args.value);\r\n                if (\"html\" === args.value && this._quillInstance) {\r\n                    this._updateHtmlContent(newValue)\r\n                } else {\r\n                    this.option(\"value\", newValue)\r\n                }\r\n                break;\r\n            case \"stylingMode\":\r\n                this._renderStylingMode();\r\n                break;\r\n            case \"readOnly\":\r\n            case \"disabled\":\r\n                this.callBase(args);\r\n                this._resetEnabledState();\r\n                break;\r\n            case \"formDialogOptions\":\r\n                this._renderFormDialog();\r\n                break;\r\n            case \"tableContextMenu\":\r\n                this._moduleOptionChanged(\"tableContextMenu\", args);\r\n                break;\r\n            case \"mediaResizing\":\r\n                if (!args.previousValue || !args.value) {\r\n                    this._invalidate()\r\n                } else {\r\n                    this._quillInstance.getModule(\"resizing\").option(args.name, args.value)\r\n                }\r\n                break;\r\n            case \"width\":\r\n                this.callBase(args);\r\n                this._repaintToolbar();\r\n                break;\r\n            default:\r\n                this.callBase(args)\r\n        }\r\n    },\r\n    _repaintToolbar: function() {\r\n        var toolbar = this._quillInstance.getModule(\"toolbar\");\r\n        toolbar && toolbar.repaint()\r\n    },\r\n    _updateHtmlContent: function(html) {\r\n        var newDelta = this._quillInstance.clipboard.convert({\r\n            html: html\r\n        });\r\n        this._quillInstance.setContents(newDelta)\r\n    },\r\n    _clean: function() {\r\n        if (this._quillInstance) {\r\n            _events_core_events_engine__WEBPACK_IMPORTED_MODULE_11__[\"default\"].off(this._getContent(), \".\".concat(this.NAME));\r\n            this._quillInstance.off(\"text-change\", this._textChangeHandlerWithContext);\r\n            this._cleanCallback.fire()\r\n        }\r\n        this._abortUpdateContentTask();\r\n        this._cleanCallback.empty();\r\n        this._contentInitializedCallback.empty();\r\n        this.callBase()\r\n    },\r\n    _abortUpdateContentTask: function() {\r\n        if (this._updateContentTask) {\r\n            this._updateContentTask.abort();\r\n            this._updateContentTask = void 0\r\n        }\r\n    },\r\n    _applyQuillMethod(methodName, args) {\r\n        if (this._quillInstance) {\r\n            return this._quillInstance[methodName].apply(this._quillInstance, args)\r\n        }\r\n    },\r\n    _applyQuillHistoryMethod(methodName) {\r\n        if (this._quillInstance && this._quillInstance.history) {\r\n            this._quillInstance.history[methodName]()\r\n        }\r\n    },\r\n    addCleanCallback(callback) {\r\n        this._cleanCallback.add(callback)\r\n    },\r\n    addContentInitializedCallback(callback) {\r\n        this._contentInitializedCallback.add(callback)\r\n    },\r\n    register: function(components) {\r\n        this._getRegistrator().registerModules(components);\r\n        if (this._quillInstance) {\r\n            this.repaint()\r\n        }\r\n    },\r\n    get: function(modulePath) {\r\n        return this._getRegistrator().getQuill().import(modulePath)\r\n    },\r\n    getModule: function(moduleName) {\r\n        return this._applyQuillMethod(\"getModule\", arguments)\r\n    },\r\n    getQuillInstance: function() {\r\n        return this._quillInstance\r\n    },\r\n    getSelection: function(focus) {\r\n        return this._applyQuillMethod(\"getSelection\", arguments)\r\n    },\r\n    setSelection: function(index, length) {\r\n        this._applyQuillMethod(\"setSelection\", arguments)\r\n    },\r\n    getText: function(index, length) {\r\n        return this._applyQuillMethod(\"getText\", arguments)\r\n    },\r\n    format: function(formatName, formatValue) {\r\n        this._applyQuillMethod(\"format\", arguments)\r\n    },\r\n    formatText: function(index, length, formatName, formatValue) {\r\n        this._applyQuillMethod(\"formatText\", arguments)\r\n    },\r\n    formatLine: function(index, length, formatName, formatValue) {\r\n        this._applyQuillMethod(\"formatLine\", arguments)\r\n    },\r\n    getFormat: function(index, length) {\r\n        return this._applyQuillMethod(\"getFormat\", arguments)\r\n    },\r\n    removeFormat: function(index, length) {\r\n        return this._applyQuillMethod(\"removeFormat\", arguments)\r\n    },\r\n    clearHistory: function() {\r\n        this._applyQuillHistoryMethod(\"clear\")\r\n    },\r\n    undo: function() {\r\n        this._applyQuillHistoryMethod(\"undo\")\r\n    },\r\n    redo: function() {\r\n        this._applyQuillHistoryMethod(\"redo\")\r\n    },\r\n    getLength: function() {\r\n        return this._applyQuillMethod(\"getLength\")\r\n    },\r\n    getBounds: function(index, length) {\r\n        return this._applyQuillMethod(\"getBounds\", arguments)\r\n    },\r\n    delete: function(index, length) {\r\n        this._applyQuillMethod(\"deleteText\", arguments)\r\n    },\r\n    insertText: function(index, text, formats) {\r\n        this._applyQuillMethod(\"insertText\", arguments)\r\n    },\r\n    insertEmbed: function(index, type, config) {\r\n        this._applyQuillMethod(\"insertEmbed\", arguments)\r\n    },\r\n    showFormDialog: function(formConfig) {\r\n        return this._formDialog.show(formConfig)\r\n    },\r\n    formDialogOption: function(optionName, optionValue) {\r\n        return this._formDialog.popupOption.apply(this._formDialog, arguments)\r\n    },\r\n    focus: function() {\r\n        this.callBase();\r\n        this._applyQuillMethod(\"focus\")\r\n    },\r\n    blur: function() {\r\n        this._applyQuillMethod(\"blur\")\r\n    }\r\n});\r\nObject(_core_component_registrator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\"dxHtmlEditor\", HtmlEditor);\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (HtmlEditor);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvdWkuaHRtbF9lZGl0b3IuanM/YWE3ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29DO0FBR0g7QUFJRjtBQUdIO0FBTUs7QUFDZ0M7QUFHcEI7QUFDUDtBQUNHO0FBQ1U7QUFHaEI7QUFDd0I7QUFHekI7QUFHTjtBQUMyQztBQUdyQztBQUNlO0FBQ1I7QUFDVTtBQUN2QjtBQUM0QjtBQUNOO0FBQ1Q7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQU87QUFDN0IsaUJBQWlCLHNEQUFNO0FBQ3ZCO0FBQ0EsZUFBZSxpRUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QixxRUFBUztBQUN2QywyQ0FBMkMscUVBQVM7QUFDcEQsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJDQUEyQyw0RUFBYTtBQUN4RCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSw4REFBQztBQUNoQixLQUFLO0FBQ0w7QUFDQSwrQkFBK0IsOERBQUM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0VBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0JBQStCLDhEQUFDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0MsNkRBQW1CO0FBQ25EO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0JBQWtCLHlEQUFNO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUNBQXlDLDJEQUFnQjtBQUN6RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQyw2REFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0Q0FBNEMsOERBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsUUFBUSxzRUFBVztBQUNuQixLQUFLO0FBQ0w7QUFDQSwyQkFBMkIseUVBQVk7QUFDdkMsUUFBUSxtRUFBWTtBQUNwQixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1FQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUVBQVk7QUFDbEQ7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZCQUE2QixpRkFBaUI7QUFDOUMsUUFBUSxtRUFBWSxzQkFBc0IseUVBQVksQ0FBQywrRUFBWSxtQ0FBbUMsdURBQUk7QUFDMUcsUUFBUSxtRUFBWSxzQkFBc0IseUVBQVksQ0FBQyx3REFBYTtBQUNwRSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsa0VBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsb0VBQWM7QUFDNUMsNEJBQTRCLGlFQUFNLEdBQUc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw0REFBTztBQUMvRDtBQUNBLGFBQWE7QUFDYjtBQUNBLDJEQUEyRCw0REFBTztBQUNsRSxhQUFhO0FBQ2I7QUFDQSx5REFBeUQsNERBQU87QUFDaEUsdURBQXVELDREQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrRUFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSxpRUFBTTtBQUNyQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSxrRUFBUztBQUN0QjtBQUNBO0FBQ0EsMkJBQTJCLHdFQUFhO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQixpRUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0JBQStCLHVEQUFVO0FBQ3pDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLG1FQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyRUFBaUI7QUFDRix5RUFBVSxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3VpL2h0bWxfZWRpdG9yL3VpLmh0bWxfZWRpdG9yLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS91aS9odG1sX2VkaXRvci91aS5odG1sX2VkaXRvci5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0ICQgZnJvbSBcIi4uLy4uL2NvcmUvcmVuZGVyZXJcIjtcclxuaW1wb3J0IHtcclxuICAgIGV4dGVuZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2V4dGVuZFwiO1xyXG5pbXBvcnQge1xyXG4gICAgaXNEZWZpbmVkLFxyXG4gICAgaXNGdW5jdGlvblxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL3R5cGVcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldFB1YmxpY0VsZW1lbnRcclxufSBmcm9tIFwiLi4vLi4vY29yZS9lbGVtZW50XCI7XHJcbmltcG9ydCB7XHJcbiAgICBleGVjdXRlQXN5bmMsXHJcbiAgICBub29wLFxyXG4gICAgZW5zdXJlRGVmaW5lZCxcclxuICAgIGRlZmVyUmVuZGVyXHJcbn0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvY29tbW9uXCI7XHJcbmltcG9ydCByZWdpc3RlckNvbXBvbmVudCBmcm9tIFwiLi4vLi4vY29yZS9jb21wb25lbnRfcmVnaXN0cmF0b3JcIjtcclxuaW1wb3J0IHtcclxuICAgIEVtcHR5VGVtcGxhdGVcclxufSBmcm9tIFwiLi4vLi4vY29yZS90ZW1wbGF0ZXMvZW1wdHlfdGVtcGxhdGVcIjtcclxuaW1wb3J0IEVkaXRvciBmcm9tIFwiLi4vZWRpdG9yL2VkaXRvclwiO1xyXG5pbXBvcnQgRXJyb3JzIGZyb20gXCIuLi93aWRnZXQvdWkuZXJyb3JzXCI7XHJcbmltcG9ydCBDYWxsYmFja3MgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvY2FsbGJhY2tzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBEZWZlcnJlZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2RlZmVycmVkXCI7XHJcbmltcG9ydCBldmVudHNFbmdpbmUgZnJvbSBcIi4uLy4uL2V2ZW50cy9jb3JlL2V2ZW50c19lbmdpbmVcIjtcclxuaW1wb3J0IHtcclxuICAgIGFkZE5hbWVzcGFjZVxyXG59IGZyb20gXCIuLi8uLi9ldmVudHMvdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IHtcclxuICAgIEV2ZW50IGFzIGR4RXZlbnRcclxufSBmcm9tIFwiLi4vLi4vZXZlbnRzL2luZGV4XCI7XHJcbmltcG9ydCBzY3JvbGxFdmVudHMgZnJvbSBcIi4uLy4uL2V2ZW50cy9nZXN0dXJlL2VtaXR0ZXIuZ2VzdHVyZS5zY3JvbGxcIjtcclxuaW1wb3J0IHtcclxuICAgIHByZXBhcmVTY3JvbGxEYXRhXHJcbn0gZnJvbSBcIi4uL3RleHRfYm94L3V0aWxzLnNjcm9sbFwiO1xyXG5pbXBvcnQgcG9pbnRlckV2ZW50cyBmcm9tIFwiLi4vLi4vZXZlbnRzL3BvaW50ZXJcIjtcclxuaW1wb3J0IGRldmljZXMgZnJvbSBcIi4uLy4uL2NvcmUvZGV2aWNlc1wiO1xyXG5pbXBvcnQgUXVpbGxSZWdpc3RyYXRvciBmcm9tIFwiLi9xdWlsbF9yZWdpc3RyYXRvclwiO1xyXG5pbXBvcnQgXCIuL2NvbnZlcnRlcnMvZGVsdGFcIjtcclxuaW1wb3J0IENvbnZlcnRlckNvbnRyb2xsZXIgZnJvbSBcIi4vY29udmVydGVyQ29udHJvbGxlclwiO1xyXG5pbXBvcnQgZ2V0V29yZE1hdGNoZXIgZnJvbSBcIi4vbWF0Y2hlcnMvd29yZExpc3RzXCI7XHJcbmltcG9ydCBGb3JtRGlhbG9nIGZyb20gXCIuL3VpL2Zvcm1EaWFsb2dcIjtcclxudmFyIEhUTUxfRURJVE9SX0NMQVNTID0gXCJkeC1odG1sZWRpdG9yXCI7XHJcbnZhciBRVUlMTF9DT05UQUlORVJfQ0xBU1MgPSBcImR4LXF1aWxsLWNvbnRhaW5lclwiO1xyXG52YXIgUVVJTExfQ0xJUEJPQVJEX0NMQVNTID0gXCJxbC1jbGlwYm9hcmRcIjtcclxudmFyIEhUTUxfRURJVE9SX1NVQk1JVF9FTEVNRU5UX0NMQVNTID0gXCJkeC1odG1sZWRpdG9yLXN1Ym1pdC1lbGVtZW50XCI7XHJcbnZhciBIVE1MX0VESVRPUl9DT05URU5UX0NMQVNTID0gXCJkeC1odG1sZWRpdG9yLWNvbnRlbnRcIjtcclxudmFyIE1BUktET1dOX1ZBTFVFX1RZUEUgPSBcIm1hcmtkb3duXCI7XHJcbnZhciBBTk9OWU1PVVNfVEVNUExBVEVfTkFNRSA9IFwiaHRtbENvbnRlbnRcIjtcclxudmFyIGlzSW9zID0gXCJpb3NcIiA9PT0gZGV2aWNlcy5jdXJyZW50KCkucGxhdGZvcm07XHJcbnZhciBIdG1sRWRpdG9yID0gRWRpdG9yLmluaGVyaXQoe1xyXG4gICAgX2dldERlZmF1bHRPcHRpb25zOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbEJhc2UoKSwge1xyXG4gICAgICAgICAgICBmb2N1c1N0YXRlRW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWVUeXBlOiBcImh0bWxcIixcclxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiXCIsXHJcbiAgICAgICAgICAgIHRvb2xiYXI6IG51bGwsXHJcbiAgICAgICAgICAgIHZhcmlhYmxlczogbnVsbCxcclxuICAgICAgICAgICAgbWVkaWFSZXNpemluZzogbnVsbCxcclxuICAgICAgICAgICAgdGFibGVSZXNpemluZzogbnVsbCxcclxuICAgICAgICAgICAgbWVudGlvbnM6IG51bGwsXHJcbiAgICAgICAgICAgIGN1c3RvbWl6ZU1vZHVsZXM6IG51bGwsXHJcbiAgICAgICAgICAgIHRhYmxlQ29udGV4dE1lbnU6IG51bGwsXHJcbiAgICAgICAgICAgIGFsbG93U29mdExpbmVCcmVhazogZmFsc2UsXHJcbiAgICAgICAgICAgIGZvcm1EaWFsb2dPcHRpb25zOiBudWxsLFxyXG4gICAgICAgICAgICBzdHlsaW5nTW9kZTogXCJvdXRsaW5lZFwiXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBfaW5pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZSgpO1xyXG4gICAgICAgIHRoaXMuX2NsZWFuQ2FsbGJhY2sgPSBDYWxsYmFja3MoKTtcclxuICAgICAgICB0aGlzLl9jb250ZW50SW5pdGlhbGl6ZWRDYWxsYmFjayA9IENhbGxiYWNrcygpXHJcbiAgICB9LFxyXG4gICAgX2dldEFub255bW91c1RlbXBsYXRlTmFtZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIEFOT05ZTU9VU19URU1QTEFURV9OQU1FXHJcbiAgICB9LFxyXG4gICAgX2luaXRUZW1wbGF0ZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlTWFuYWdlci5hZGREZWZhdWx0VGVtcGxhdGVzKHtcclxuICAgICAgICAgICAgW0FOT05ZTU9VU19URU1QTEFURV9OQU1FXTogbmV3IEVtcHR5VGVtcGxhdGVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNhbGxCYXNlKClcclxuICAgIH0sXHJcbiAgICBfZm9jdXNUYXJnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZW50KClcclxuICAgIH0sXHJcbiAgICBfZ2V0Q29udGVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQoKS5maW5kKFwiLlwiLmNvbmNhdChIVE1MX0VESVRPUl9DT05URU5UX0NMQVNTKSlcclxuICAgIH0sXHJcbiAgICBfZm9jdXNJbkhhbmRsZXI6IGZ1bmN0aW9uKF9yZWYpIHtcclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0XHJcbiAgICAgICAgfSA9IF9yZWY7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFNraXBGb2N1c0V2ZW50KHJlbGF0ZWRUYXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90b2dnbGVGb2N1c0NsYXNzKHRydWUsIHRoaXMuJGVsZW1lbnQoKSk7XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXHJcbiAgICB9LFxyXG4gICAgX2ZvY3VzT3V0SGFuZGxlcjogZnVuY3Rpb24oX3JlZjIpIHtcclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0XHJcbiAgICAgICAgfSA9IF9yZWYyO1xyXG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRTa2lwRm9jdXNFdmVudChyZWxhdGVkVGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdG9nZ2xlRm9jdXNDbGFzcyhmYWxzZSwgdGhpcy4kZWxlbWVudCgpKTtcclxuICAgICAgICB0aGlzLmNhbGxCYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcclxuICAgIH0sXHJcbiAgICBfc2hvdWxkU2tpcEZvY3VzRXZlbnQ6IGZ1bmN0aW9uKHJlbGF0ZWRUYXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gJChyZWxhdGVkVGFyZ2V0KS5oYXNDbGFzcyhRVUlMTF9DTElQQk9BUkRfQ0xBU1MpXHJcbiAgICB9LFxyXG4gICAgX2luaXRNYXJrdXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuXyRodG1sQ29udGFpbmVyID0gJChcIjxkaXY+XCIpLmFkZENsYXNzKFFVSUxMX0NPTlRBSU5FUl9DTEFTUyk7XHJcbiAgICAgICAgdGhpcy4kZWxlbWVudCgpLmF0dHIoXCJyb2xlXCIsIFwiYXBwbGljYXRpb25cIikuYWRkQ2xhc3MoSFRNTF9FRElUT1JfQ0xBU1MpLndyYXBJbm5lcih0aGlzLl8kaHRtbENvbnRhaW5lcik7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyU3R5bGluZ01vZGUoKTtcclxuICAgICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLl9nZXRUZW1wbGF0ZShBTk9OWU1PVVNfVEVNUExBVEVfTkFNRSk7XHJcbiAgICAgICAgdGhpcy5fJHRlbXBsYXRlUmVzdWx0ID0gdGVtcGxhdGUgJiYgdGVtcGxhdGUucmVuZGVyKHtcclxuICAgICAgICAgICAgY29udGFpbmVyOiBnZXRQdWJsaWNFbGVtZW50KHRoaXMuXyRodG1sQ29udGFpbmVyKSxcclxuICAgICAgICAgICAgbm9Nb2RlbDogdHJ1ZSxcclxuICAgICAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlclN1Ym1pdEVsZW1lbnQoKTtcclxuICAgICAgICB0aGlzLmNhbGxCYXNlKCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlQ29udGFpbmVyTWFya3VwKClcclxuICAgIH0sXHJcbiAgICBfcmVuZGVyU3VibWl0RWxlbWVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fJHN1Ym1pdEVsZW1lbnQgPSAkKFwiPHRleHRhcmVhPlwiKS5hZGRDbGFzcyhIVE1MX0VESVRPUl9TVUJNSVRfRUxFTUVOVF9DTEFTUykuYXR0cihcImhpZGRlblwiLCB0cnVlKS5hcHBlbmRUbyh0aGlzLiRlbGVtZW50KCkpO1xyXG4gICAgICAgIHRoaXMuX3NldFN1Ym1pdFZhbHVlKHRoaXMub3B0aW9uKFwidmFsdWVcIikpXHJcbiAgICB9LFxyXG4gICAgX3NldFN1Ym1pdFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2dldFN1Ym1pdEVsZW1lbnQoKS52YWwodmFsdWUpXHJcbiAgICB9LFxyXG4gICAgX2dldFN1Ym1pdEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl8kc3VibWl0RWxlbWVudFxyXG4gICAgfSxcclxuICAgIF91cGRhdGVDb250YWluZXJNYXJrdXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtYXJrdXAgPSB0aGlzLm9wdGlvbihcInZhbHVlXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc01hcmtkb3duVmFsdWUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmVwYXJlTWFya2Rvd25Db252ZXJ0ZXIoKTtcclxuICAgICAgICAgICAgbWFya3VwID0gdGhpcy5fbWFya2Rvd25Db252ZXJ0ZXIudG9IdG1sKG1hcmt1cClcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hcmt1cCkge1xyXG4gICAgICAgICAgICB0aGlzLl8kaHRtbENvbnRhaW5lci5odG1sKG1hcmt1cClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3ByZXBhcmVNYXJrZG93bkNvbnZlcnRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIE1hcmtkb3duQ29udmVydGVyID0gQ29udmVydGVyQ29udHJvbGxlci5nZXRDb252ZXJ0ZXIoXCJtYXJrZG93blwiKTtcclxuICAgICAgICBpZiAoTWFya2Rvd25Db252ZXJ0ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFya2Rvd25Db252ZXJ0ZXIgPSBuZXcgTWFya2Rvd25Db252ZXJ0ZXJcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcnMuRXJyb3IoXCJFMTA1MVwiLCBcIm1hcmtkb3duXCIpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3ByZXBhcmVDb252ZXJ0ZXJzKCk7XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZSgpXHJcbiAgICB9LFxyXG4gICAgX3ByZXBhcmVRdWlsbFJlZ2lzdHJhdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3F1aWxsUmVnaXN0cmF0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fcXVpbGxSZWdpc3RyYXRvciA9IG5ldyBRdWlsbFJlZ2lzdHJhdG9yXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9nZXRSZWdpc3RyYXRvcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fcHJlcGFyZVF1aWxsUmVnaXN0cmF0b3IoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcXVpbGxSZWdpc3RyYXRvclxyXG4gICAgfSxcclxuICAgIF9wcmVwYXJlQ29udmVydGVyczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kZWx0YUNvbnZlcnRlcikge1xyXG4gICAgICAgICAgICB2YXIgRGVsdGFDb252ZXJ0ZXIgPSBDb252ZXJ0ZXJDb250cm9sbGVyLmdldENvbnZlcnRlcihcImRlbHRhXCIpO1xyXG4gICAgICAgICAgICBpZiAoRGVsdGFDb252ZXJ0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RlbHRhQ29udmVydGVyID0gbmV3IERlbHRhQ29udmVydGVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uKFwidmFsdWVUeXBlXCIpID09PSBNQVJLRE9XTl9WQUxVRV9UWVBFICYmICF0aGlzLl9tYXJrZG93bkNvbnZlcnRlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmVwYXJlTWFya2Rvd25Db252ZXJ0ZXIoKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfcmVuZGVyQ29udGVudEltcGw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRlbnRSZW5kZXJlZERlZmVycmVkID0gbmV3IERlZmVycmVkO1xyXG4gICAgICAgIHZhciByZW5kZXJDb250ZW50UHJvbWlzZSA9IHRoaXMuX2NvbnRlbnRSZW5kZXJlZERlZmVycmVkLnByb21pc2UoKTtcclxuICAgICAgICB0aGlzLmNhbGxCYXNlKCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVySHRtbEVkaXRvcigpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckZvcm1EaWFsb2coKTtcclxuICAgICAgICB0aGlzLl9hZGRLZXlQcmVzc0hhbmRsZXIoKTtcclxuICAgICAgICByZXR1cm4gcmVuZGVyQ29udGVudFByb21pc2VcclxuICAgIH0sXHJcbiAgICBfcG9pbnRlck1vdmVIYW5kbGVyOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgaWYgKGlzSW9zKSB7XHJcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2F0dGFjaEZvY3VzRXZlbnRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBkZWZlclJlbmRlcih0aGlzLmNhbGxCYXNlLmJpbmQodGhpcykpXHJcbiAgICB9LFxyXG4gICAgX2FkZEtleVByZXNzSGFuZGxlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGtleURvd25FdmVudCA9IGFkZE5hbWVzcGFjZShcImtleWRvd25cIiwgXCJcIi5jb25jYXQodGhpcy5OQU1FLCBcIlRleHRDaGFuZ2VcIikpO1xyXG4gICAgICAgIGV2ZW50c0VuZ2luZS5vbih0aGlzLl8kaHRtbENvbnRhaW5lciwga2V5RG93bkV2ZW50LCB0aGlzLl9rZXlEb3duSGFuZGxlci5iaW5kKHRoaXMpKVxyXG4gICAgfSxcclxuICAgIF9rZXlEb3duSGFuZGxlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIHRoaXMuX3NhdmVWYWx1ZUNoYW5nZUV2ZW50KGUpXHJcbiAgICB9LFxyXG4gICAgX3JlbmRlckh0bWxFZGl0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjdXN0b21pemVNb2R1bGVzID0gdGhpcy5vcHRpb24oXCJjdXN0b21pemVNb2R1bGVzXCIpO1xyXG4gICAgICAgIHZhciBtb2R1bGVzQ29uZmlnID0gdGhpcy5fZ2V0TW9kdWxlc0NvbmZpZygpO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGN1c3RvbWl6ZU1vZHVsZXMpKSB7XHJcbiAgICAgICAgICAgIGN1c3RvbWl6ZU1vZHVsZXMobW9kdWxlc0NvbmZpZylcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcXVpbGxJbnN0YW5jZSA9IHRoaXMuX2dldFJlZ2lzdHJhdG9yKCkuY3JlYXRlRWRpdG9yKHRoaXMuXyRodG1sQ29udGFpbmVyWzBdLCB7XHJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiB0aGlzLm9wdGlvbihcInBsYWNlaG9sZGVyXCIpLFxyXG4gICAgICAgICAgICByZWFkT25seTogdGhpcy5vcHRpb24oXCJyZWFkT25seVwiKSB8fCB0aGlzLm9wdGlvbihcImRpc2FibGVkXCIpLFxyXG4gICAgICAgICAgICBtb2R1bGVzOiBtb2R1bGVzQ29uZmlnLFxyXG4gICAgICAgICAgICB0aGVtZTogXCJiYXNpY1wiXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZGVsdGFDb252ZXJ0ZXIuc2V0UXVpbGxJbnN0YW5jZSh0aGlzLl9xdWlsbEluc3RhbmNlKTtcclxuICAgICAgICB0aGlzLl90ZXh0Q2hhbmdlSGFuZGxlcldpdGhDb250ZXh0ID0gdGhpcy5fdGV4dENoYW5nZUhhbmRsZXIuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9xdWlsbEluc3RhbmNlLm9uKFwidGV4dC1jaGFuZ2VcIiwgdGhpcy5fdGV4dENoYW5nZUhhbmRsZXJXaXRoQ29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyU2Nyb2xsSGFuZGxlcigpO1xyXG4gICAgICAgIGlmICh0aGlzLl9oYXNUcmFuc2NsdWRlZENvbnRlbnQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDb250ZW50VGFzayA9IGV4ZWN1dGVBc3luYygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVRyYW5zY2x1ZGVkQ29udGVudCgpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZmluYWxpemVDb250ZW50UmVuZGVyaW5nKClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3JlbmRlclNjcm9sbEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciAkc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5fZ2V0Q29udGVudCgpO1xyXG4gICAgICAgIHZhciBpbml0U2Nyb2xsRGF0YSA9IHByZXBhcmVTY3JvbGxEYXRhKCRzY3JvbGxDb250YWluZXIpO1xyXG4gICAgICAgIGV2ZW50c0VuZ2luZS5vbigkc2Nyb2xsQ29udGFpbmVyLCBhZGROYW1lc3BhY2Uoc2Nyb2xsRXZlbnRzLmluaXQsIHRoaXMuTkFNRSksIGluaXRTY3JvbGxEYXRhLCBub29wKTtcclxuICAgICAgICBldmVudHNFbmdpbmUub24oJHNjcm9sbENvbnRhaW5lciwgYWRkTmFtZXNwYWNlKHBvaW50ZXJFdmVudHMubW92ZSwgdGhpcy5OQU1FKSwgdGhpcy5fcG9pbnRlck1vdmVIYW5kbGVyLmJpbmQodGhpcykpXHJcbiAgICB9LFxyXG4gICAgX2FwcGx5VHJhbnNjbHVkZWRDb250ZW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdmFsdWVPcHRpb24gPSB0aGlzLm9wdGlvbihcInZhbHVlXCIpO1xyXG4gICAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlT3B0aW9uKSkge1xyXG4gICAgICAgICAgICB2YXIgaHRtbCA9IHRoaXMuX2RlbHRhQ29udmVydGVyLnRvSHRtbCgpO1xyXG4gICAgICAgICAgICB2YXIgbmV3RGVsdGEgPSB0aGlzLl9xdWlsbEluc3RhbmNlLmNsaXBib2FyZC5jb252ZXJ0KHtcclxuICAgICAgICAgICAgICAgIGh0bWw6IGh0bWxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChuZXdEZWx0YS5vcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWlsbEluc3RhbmNlLnNldENvbnRlbnRzKG5ld0RlbHRhKTtcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ZpbmFsaXplQ29udGVudFJlbmRlcmluZygpXHJcbiAgICB9LFxyXG4gICAgX2hhc1RyYW5zY2x1ZGVkQ29udGVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuXyR0ZW1wbGF0ZVJlc3VsdCAmJiB0aGlzLl8kdGVtcGxhdGVSZXN1bHQubGVuZ3RoXHJcbiAgICB9LFxyXG4gICAgX2dldE1vZHVsZXNDb25maWc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBxdWlsbCA9IHRoaXMuX2dldFJlZ2lzdHJhdG9yKCkuZ2V0UXVpbGwoKTtcclxuICAgICAgICB2YXIgd29yZExpc3RNYXRjaGVyID0gZ2V0V29yZE1hdGNoZXIocXVpbGwpO1xyXG4gICAgICAgIHZhciBtb2R1bGVzQ29uZmlnID0gZXh0ZW5kKHt9LCB7XHJcbiAgICAgICAgICAgIHRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB0b29sYmFyOiB0aGlzLl9nZXRNb2R1bGVDb25maWdCeU9wdGlvbihcInRvb2xiYXJcIiksXHJcbiAgICAgICAgICAgIHZhcmlhYmxlczogdGhpcy5fZ2V0TW9kdWxlQ29uZmlnQnlPcHRpb24oXCJ2YXJpYWJsZXNcIiksXHJcbiAgICAgICAgICAgIHJlc2l6aW5nOiB0aGlzLl9nZXRNb2R1bGVDb25maWdCeU9wdGlvbihcIm1lZGlhUmVzaXppbmdcIiksXHJcbiAgICAgICAgICAgIHRhYmxlUmVzaXppbmc6IHRoaXMuX2dldE1vZHVsZUNvbmZpZ0J5T3B0aW9uKFwidGFibGVSZXNpemluZ1wiKSxcclxuICAgICAgICAgICAgdGFibGVDb250ZXh0TWVudTogdGhpcy5fZ2V0TW9kdWxlQ29uZmlnQnlPcHRpb24oXCJ0YWJsZUNvbnRleHRNZW51XCIpLFxyXG4gICAgICAgICAgICBtZW50aW9uczogdGhpcy5fZ2V0TW9kdWxlQ29uZmlnQnlPcHRpb24oXCJtZW50aW9uc1wiKSxcclxuICAgICAgICAgICAgdXBsb2FkZXI6IHtcclxuICAgICAgICAgICAgICAgIG9uRHJvcDogZSA9PiB0aGlzLl9zYXZlVmFsdWVDaGFuZ2VFdmVudChkeEV2ZW50KGUpKSxcclxuICAgICAgICAgICAgICAgIGltYWdlQmxvdDogXCJleHRlbmRlZEltYWdlXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAga2V5Ym9hcmQ6IHtcclxuICAgICAgICAgICAgICAgIG9uS2V5ZG93bjogZSA9PiB0aGlzLl9zYXZlVmFsdWVDaGFuZ2VFdmVudChkeEV2ZW50KGUpKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjbGlwYm9hcmQ6IHtcclxuICAgICAgICAgICAgICAgIG9uUGFzdGU6IGUgPT4gdGhpcy5fc2F2ZVZhbHVlQ2hhbmdlRXZlbnQoZHhFdmVudChlKSksXHJcbiAgICAgICAgICAgICAgICBvbkN1dDogZSA9PiB0aGlzLl9zYXZlVmFsdWVDaGFuZ2VFdmVudChkeEV2ZW50KGUpKSxcclxuICAgICAgICAgICAgICAgIG1hdGNoZXJzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgW1wicC5Nc29MaXN0UGFyYWdyYXBoQ3hTcEZpcnN0XCIsIHdvcmRMaXN0TWF0Y2hlcl0sXHJcbiAgICAgICAgICAgICAgICAgICAgW1wicC5Nc29MaXN0UGFyYWdyYXBoQ3hTcE1pZGRsZVwiLCB3b3JkTGlzdE1hdGNoZXJdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtcInAuTXNvTGlzdFBhcmFncmFwaEN4U3BMYXN0XCIsIHdvcmRMaXN0TWF0Y2hlcl1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbXVsdGlsaW5lOiBCb29sZWFuKHRoaXMub3B0aW9uKFwiYWxsb3dTb2Z0TGluZUJyZWFrXCIpKVxyXG4gICAgICAgIH0sIHRoaXMuX2dldEN1c3RvbU1vZHVsZXMoKSk7XHJcbiAgICAgICAgcmV0dXJuIG1vZHVsZXNDb25maWdcclxuICAgIH0sXHJcbiAgICBfZ2V0TW9kdWxlQ29uZmlnQnlPcHRpb246IGZ1bmN0aW9uKHVzZXJPcHRpb25OYW1lKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvblZhbHVlID0gdGhpcy5vcHRpb24odXNlck9wdGlvbk5hbWUpO1xyXG4gICAgICAgIHZhciBjb25maWcgPSB7fTtcclxuICAgICAgICBpZiAoIWlzRGVmaW5lZChvcHRpb25WYWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvblZhbHVlKSkge1xyXG4gICAgICAgICAgICBjb25maWdbdXNlck9wdGlvbk5hbWVdID0gb3B0aW9uVmFsdWVcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25maWcgPSBvcHRpb25WYWx1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuX2dldEJhc2VNb2R1bGVDb25maWcoKSwgY29uZmlnKVxyXG4gICAgfSxcclxuICAgIF9nZXRCYXNlTW9kdWxlQ29uZmlnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBlZGl0b3JJbnN0YW5jZTogdGhpc1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0Q3VzdG9tTW9kdWxlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG1vZHVsZXMgPSB7fTtcclxuICAgICAgICB2YXIgbW9kdWxlTmFtZXMgPSB0aGlzLl9nZXRSZWdpc3RyYXRvcigpLmdldFJlZ2lzdGVyZWRNb2R1bGVOYW1lcygpO1xyXG4gICAgICAgIG1vZHVsZU5hbWVzLmZvckVhY2gobW9kdWxlUGF0aCA9PiB7XHJcbiAgICAgICAgICAgIG1vZHVsZXNbbW9kdWxlUGF0aF0gPSB0aGlzLl9nZXRCYXNlTW9kdWxlQ29uZmlnKClcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbW9kdWxlc1xyXG4gICAgfSxcclxuICAgIF90ZXh0Q2hhbmdlSGFuZGxlcjogZnVuY3Rpb24obmV3RGVsdGEsIG9sZERlbHRhLCBzb3VyY2UpIHtcclxuICAgICAgICB2YXIgaHRtbE1hcmt1cCA9IHRoaXMuX2RlbHRhQ29udmVydGVyLnRvSHRtbCgpO1xyXG4gICAgICAgIHZhciBjb252ZXJ0ZWRWYWx1ZSA9IHRoaXMuX2lzTWFya2Rvd25WYWx1ZSgpID8gdGhpcy5fdXBkYXRlVmFsdWVCeVR5cGUoTUFSS0RPV05fVkFMVUVfVFlQRSwgaHRtbE1hcmt1cCkgOiBodG1sTWFya3VwO1xyXG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSB0aGlzLm9wdGlvbihcInZhbHVlXCIpO1xyXG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgIT09IGNvbnZlcnRlZFZhbHVlICYmICF0aGlzLl9pc051bGxWYWx1ZUNvbnZlcnRlZChjdXJyZW50VmFsdWUsIGNvbnZlcnRlZFZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc0VkaXRvclVwZGF0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb24oXCJ2YWx1ZVwiLCBjb252ZXJ0ZWRWYWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZmluYWxpemVDb250ZW50UmVuZGVyaW5nKClcclxuICAgIH0sXHJcbiAgICBfaXNOdWxsVmFsdWVDb252ZXJ0ZWQ6IGZ1bmN0aW9uKGN1cnJlbnRWYWx1ZSwgY29udmVydGVkVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbCA9PT0gY3VycmVudFZhbHVlICYmIFwiXCIgPT09IGNvbnZlcnRlZFZhbHVlXHJcbiAgICB9LFxyXG4gICAgX2ZpbmFsaXplQ29udGVudFJlbmRlcmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRSZW5kZXJlZERlZmVycmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJIaXN0b3J5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRJbml0aWFsaXplZENhbGxiYWNrLmZpcmUoKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGVudFJlbmRlcmVkRGVmZXJyZWQucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZW50UmVuZGVyZWREZWZlcnJlZCA9IHZvaWQgMFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfdXBkYXRlVmFsdWVCeVR5cGU6IGZ1bmN0aW9uKHZhbHVlVHlwZSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgY29udmVydGVyID0gdGhpcy5fbWFya2Rvd25Db252ZXJ0ZXI7XHJcbiAgICAgICAgaWYgKCFpc0RlZmluZWQoY29udmVydGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGVuc3VyZURlZmluZWQodmFsdWUsIHRoaXMub3B0aW9uKFwidmFsdWVcIikpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZVR5cGUgPT09IE1BUktET1dOX1ZBTFVFX1RZUEUgPyBjb252ZXJ0ZXIudG9NYXJrZG93bihjdXJyZW50VmFsdWUpIDogY29udmVydGVyLnRvSHRtbChjdXJyZW50VmFsdWUpXHJcbiAgICB9LFxyXG4gICAgX2lzTWFya2Rvd25WYWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uKFwidmFsdWVUeXBlXCIpID09PSBNQVJLRE9XTl9WQUxVRV9UWVBFXHJcbiAgICB9LFxyXG4gICAgX3Jlc2V0RW5hYmxlZFN0YXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fcXVpbGxJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB2YXIgaXNFbmFibGVkID0gISh0aGlzLm9wdGlvbihcInJlYWRPbmx5XCIpIHx8IHRoaXMub3B0aW9uKFwiZGlzYWJsZWRcIikpO1xyXG4gICAgICAgICAgICB0aGlzLl9xdWlsbEluc3RhbmNlLmVuYWJsZShpc0VuYWJsZWQpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9yZW5kZXJGb3JtRGlhbG9nOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdXNlck9wdGlvbnMgPSBleHRlbmQodHJ1ZSwge1xyXG4gICAgICAgICAgICB3aWR0aDogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgIGhlaWdodDogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgIGNsb3NlT25PdXRzaWRlQ2xpY2s6IHRydWVcclxuICAgICAgICB9LCB0aGlzLm9wdGlvbihcImZvcm1EaWFsb2dPcHRpb25zXCIpKTtcclxuICAgICAgICB0aGlzLl9mb3JtRGlhbG9nID0gbmV3IEZvcm1EaWFsb2codGhpcywgdXNlck9wdGlvbnMpXHJcbiAgICB9LFxyXG4gICAgX2dldFN0eWxpbmdNb2RlUHJlZml4OiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gXCJkeC1odG1sZWRpdG9yLVwiXHJcbiAgICB9LFxyXG4gICAgX2dldFF1aWxsQ29udGFpbmVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fJGh0bWxDb250YWluZXJcclxuICAgIH0sXHJcbiAgICBfbW9kdWxlT3B0aW9uQ2hhbmdlZDogZnVuY3Rpb24obW9kdWxlTmFtZSwgYXJncykge1xyXG4gICAgICAgIHZhciBfdGhpcyRfcXVpbGxJbnN0YW5jZTtcclxuICAgICAgICB2YXIgbW9kdWxlSW5zdGFuY2UgPSBudWxsID09PSAoX3RoaXMkX3F1aWxsSW5zdGFuY2UgPSB0aGlzLl9xdWlsbEluc3RhbmNlKSB8fCB2b2lkIDAgPT09IF90aGlzJF9xdWlsbEluc3RhbmNlID8gdm9pZCAwIDogX3RoaXMkX3F1aWxsSW5zdGFuY2UuZ2V0TW9kdWxlKG1vZHVsZU5hbWUpO1xyXG4gICAgICAgIHZhciBzaG91bGRQYXNzT3B0aW9uc1RvTW9kdWxlID0gQm9vbGVhbihtb2R1bGVJbnN0YW5jZSk7XHJcbiAgICAgICAgaWYgKHNob3VsZFBhc3NPcHRpb25zVG9Nb2R1bGUpIHtcclxuICAgICAgICAgICAgdmFyIF9hcmdzJGZ1bGxOYW1lO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uRGF0YSA9IG51bGwgPT09IChfYXJncyRmdWxsTmFtZSA9IGFyZ3MuZnVsbE5hbWUpIHx8IHZvaWQgMCA9PT0gX2FyZ3MkZnVsbE5hbWUgPyB2b2lkIDAgOiBfYXJncyRmdWxsTmFtZS5zcGxpdChcIi5cIik7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25OYW1lID0gMiA9PT0gb3B0aW9uRGF0YS5sZW5ndGggPyBvcHRpb25EYXRhWzFdIDogYXJncy5uYW1lO1xyXG4gICAgICAgICAgICBtb2R1bGVJbnN0YW5jZS5vcHRpb24ob3B0aW9uTmFtZSwgYXJncy52YWx1ZSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlKClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX29wdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKGFyZ3MpIHtcclxuICAgICAgICBzd2l0Y2ggKGFyZ3MubmFtZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9xdWlsbEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzRWRpdG9yVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNFZGl0b3JVcGRhdGluZyA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWRWYWx1ZSA9IHRoaXMuX2lzTWFya2Rvd25WYWx1ZSgpID8gdGhpcy5fdXBkYXRlVmFsdWVCeVR5cGUoXCJIVE1MXCIsIGFyZ3MudmFsdWUpIDogYXJncy52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlSHRtbENvbnRlbnQodXBkYXRlZFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fJGh0bWxDb250YWluZXIuaHRtbChhcmdzLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3VibWl0VmFsdWUoYXJncy52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxCYXNlKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwbGFjZWhvbGRlclwiOlxyXG4gICAgICAgICAgICBjYXNlIFwidmFyaWFibGVzXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0b29sYmFyXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJtZW50aW9uc1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiY3VzdG9taXplTW9kdWxlc1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiYWxsb3dTb2Z0TGluZUJyZWFrXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInRhYmxlUmVzaXppbmdcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vZHVsZU9wdGlvbkNoYW5nZWQoXCJ0YWJsZVJlc2l6aW5nXCIsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVR5cGVcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVDb252ZXJ0ZXJzKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLl91cGRhdGVWYWx1ZUJ5VHlwZShhcmdzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChcImh0bWxcIiA9PT0gYXJncy52YWx1ZSAmJiB0aGlzLl9xdWlsbEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlSHRtbENvbnRlbnQobmV3VmFsdWUpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uKFwidmFsdWVcIiwgbmV3VmFsdWUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInN0eWxpbmdNb2RlXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdHlsaW5nTW9kZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyZWFkT25seVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZGlzYWJsZWRcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEJhc2UoYXJncyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldEVuYWJsZWRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJmb3JtRGlhbG9nT3B0aW9uc1wiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyRm9ybURpYWxvZygpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0YWJsZUNvbnRleHRNZW51XCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2R1bGVPcHRpb25DaGFuZ2VkKFwidGFibGVDb250ZXh0TWVudVwiLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibWVkaWFSZXNpemluZ1wiOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFhcmdzLnByZXZpb3VzVmFsdWUgfHwgIWFyZ3MudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlKClcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVpbGxJbnN0YW5jZS5nZXRNb2R1bGUoXCJyZXNpemluZ1wiKS5vcHRpb24oYXJncy5uYW1lLCBhcmdzLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQmFzZShhcmdzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcGFpbnRUb29sYmFyKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEJhc2UoYXJncylcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3JlcGFpbnRUb29sYmFyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdG9vbGJhciA9IHRoaXMuX3F1aWxsSW5zdGFuY2UuZ2V0TW9kdWxlKFwidG9vbGJhclwiKTtcclxuICAgICAgICB0b29sYmFyICYmIHRvb2xiYXIucmVwYWludCgpXHJcbiAgICB9LFxyXG4gICAgX3VwZGF0ZUh0bWxDb250ZW50OiBmdW5jdGlvbihodG1sKSB7XHJcbiAgICAgICAgdmFyIG5ld0RlbHRhID0gdGhpcy5fcXVpbGxJbnN0YW5jZS5jbGlwYm9hcmQuY29udmVydCh7XHJcbiAgICAgICAgICAgIGh0bWw6IGh0bWxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9xdWlsbEluc3RhbmNlLnNldENvbnRlbnRzKG5ld0RlbHRhKVxyXG4gICAgfSxcclxuICAgIF9jbGVhbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3F1aWxsSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgZXZlbnRzRW5naW5lLm9mZih0aGlzLl9nZXRDb250ZW50KCksIFwiLlwiLmNvbmNhdCh0aGlzLk5BTUUpKTtcclxuICAgICAgICAgICAgdGhpcy5fcXVpbGxJbnN0YW5jZS5vZmYoXCJ0ZXh0LWNoYW5nZVwiLCB0aGlzLl90ZXh0Q2hhbmdlSGFuZGxlcldpdGhDb250ZXh0KTtcclxuICAgICAgICAgICAgdGhpcy5fY2xlYW5DYWxsYmFjay5maXJlKClcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYWJvcnRVcGRhdGVDb250ZW50VGFzaygpO1xyXG4gICAgICAgIHRoaXMuX2NsZWFuQ2FsbGJhY2suZW1wdHkoKTtcclxuICAgICAgICB0aGlzLl9jb250ZW50SW5pdGlhbGl6ZWRDYWxsYmFjay5lbXB0eSgpO1xyXG4gICAgICAgIHRoaXMuY2FsbEJhc2UoKVxyXG4gICAgfSxcclxuICAgIF9hYm9ydFVwZGF0ZUNvbnRlbnRUYXNrOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fdXBkYXRlQ29udGVudFRhc2spIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29udGVudFRhc2suYWJvcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29udGVudFRhc2sgPSB2b2lkIDBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2FwcGx5UXVpbGxNZXRob2QobWV0aG9kTmFtZSwgYXJncykge1xyXG4gICAgICAgIGlmICh0aGlzLl9xdWlsbEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xdWlsbEluc3RhbmNlW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMuX3F1aWxsSW5zdGFuY2UsIGFyZ3MpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9hcHBseVF1aWxsSGlzdG9yeU1ldGhvZChtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3F1aWxsSW5zdGFuY2UgJiYgdGhpcy5fcXVpbGxJbnN0YW5jZS5oaXN0b3J5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3F1aWxsSW5zdGFuY2UuaGlzdG9yeVttZXRob2ROYW1lXSgpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGFkZENsZWFuQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl9jbGVhbkNhbGxiYWNrLmFkZChjYWxsYmFjaylcclxuICAgIH0sXHJcbiAgICBhZGRDb250ZW50SW5pdGlhbGl6ZWRDYWxsYmFjayhjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuX2NvbnRlbnRJbml0aWFsaXplZENhbGxiYWNrLmFkZChjYWxsYmFjaylcclxuICAgIH0sXHJcbiAgICByZWdpc3RlcjogZnVuY3Rpb24oY29tcG9uZW50cykge1xyXG4gICAgICAgIHRoaXMuX2dldFJlZ2lzdHJhdG9yKCkucmVnaXN0ZXJNb2R1bGVzKGNvbXBvbmVudHMpO1xyXG4gICAgICAgIGlmICh0aGlzLl9xdWlsbEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldDogZnVuY3Rpb24obW9kdWxlUGF0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRSZWdpc3RyYXRvcigpLmdldFF1aWxsKCkuaW1wb3J0KG1vZHVsZVBhdGgpXHJcbiAgICB9LFxyXG4gICAgZ2V0TW9kdWxlOiBmdW5jdGlvbihtb2R1bGVOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5UXVpbGxNZXRob2QoXCJnZXRNb2R1bGVcIiwgYXJndW1lbnRzKVxyXG4gICAgfSxcclxuICAgIGdldFF1aWxsSW5zdGFuY2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9xdWlsbEluc3RhbmNlXHJcbiAgICB9LFxyXG4gICAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbihmb2N1cykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseVF1aWxsTWV0aG9kKFwiZ2V0U2VsZWN0aW9uXCIsIGFyZ3VtZW50cylcclxuICAgIH0sXHJcbiAgICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpIHtcclxuICAgICAgICB0aGlzLl9hcHBseVF1aWxsTWV0aG9kKFwic2V0U2VsZWN0aW9uXCIsIGFyZ3VtZW50cylcclxuICAgIH0sXHJcbiAgICBnZXRUZXh0OiBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5UXVpbGxNZXRob2QoXCJnZXRUZXh0XCIsIGFyZ3VtZW50cylcclxuICAgIH0sXHJcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uKGZvcm1hdE5hbWUsIGZvcm1hdFZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fYXBwbHlRdWlsbE1ldGhvZChcImZvcm1hdFwiLCBhcmd1bWVudHMpXHJcbiAgICB9LFxyXG4gICAgZm9ybWF0VGV4dDogZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCwgZm9ybWF0TmFtZSwgZm9ybWF0VmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9hcHBseVF1aWxsTWV0aG9kKFwiZm9ybWF0VGV4dFwiLCBhcmd1bWVudHMpXHJcbiAgICB9LFxyXG4gICAgZm9ybWF0TGluZTogZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCwgZm9ybWF0TmFtZSwgZm9ybWF0VmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9hcHBseVF1aWxsTWV0aG9kKFwiZm9ybWF0TGluZVwiLCBhcmd1bWVudHMpXHJcbiAgICB9LFxyXG4gICAgZ2V0Rm9ybWF0OiBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5UXVpbGxNZXRob2QoXCJnZXRGb3JtYXRcIiwgYXJndW1lbnRzKVxyXG4gICAgfSxcclxuICAgIHJlbW92ZUZvcm1hdDogZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseVF1aWxsTWV0aG9kKFwicmVtb3ZlRm9ybWF0XCIsIGFyZ3VtZW50cylcclxuICAgIH0sXHJcbiAgICBjbGVhckhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2FwcGx5UXVpbGxIaXN0b3J5TWV0aG9kKFwiY2xlYXJcIilcclxuICAgIH0sXHJcbiAgICB1bmRvOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9hcHBseVF1aWxsSGlzdG9yeU1ldGhvZChcInVuZG9cIilcclxuICAgIH0sXHJcbiAgICByZWRvOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9hcHBseVF1aWxsSGlzdG9yeU1ldGhvZChcInJlZG9cIilcclxuICAgIH0sXHJcbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseVF1aWxsTWV0aG9kKFwiZ2V0TGVuZ3RoXCIpXHJcbiAgICB9LFxyXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5UXVpbGxNZXRob2QoXCJnZXRCb3VuZHNcIiwgYXJndW1lbnRzKVxyXG4gICAgfSxcclxuICAgIGRlbGV0ZTogZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuX2FwcGx5UXVpbGxNZXRob2QoXCJkZWxldGVUZXh0XCIsIGFyZ3VtZW50cylcclxuICAgIH0sXHJcbiAgICBpbnNlcnRUZXh0OiBmdW5jdGlvbihpbmRleCwgdGV4dCwgZm9ybWF0cykge1xyXG4gICAgICAgIHRoaXMuX2FwcGx5UXVpbGxNZXRob2QoXCJpbnNlcnRUZXh0XCIsIGFyZ3VtZW50cylcclxuICAgIH0sXHJcbiAgICBpbnNlcnRFbWJlZDogZnVuY3Rpb24oaW5kZXgsIHR5cGUsIGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX2FwcGx5UXVpbGxNZXRob2QoXCJpbnNlcnRFbWJlZFwiLCBhcmd1bWVudHMpXHJcbiAgICB9LFxyXG4gICAgc2hvd0Zvcm1EaWFsb2c6IGZ1bmN0aW9uKGZvcm1Db25maWcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9ybURpYWxvZy5zaG93KGZvcm1Db25maWcpXHJcbiAgICB9LFxyXG4gICAgZm9ybURpYWxvZ09wdGlvbjogZnVuY3Rpb24ob3B0aW9uTmFtZSwgb3B0aW9uVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9ybURpYWxvZy5wb3B1cE9wdGlvbi5hcHBseSh0aGlzLl9mb3JtRGlhbG9nLCBhcmd1bWVudHMpXHJcbiAgICB9LFxyXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbEJhc2UoKTtcclxuICAgICAgICB0aGlzLl9hcHBseVF1aWxsTWV0aG9kKFwiZm9jdXNcIilcclxuICAgIH0sXHJcbiAgICBibHVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9hcHBseVF1aWxsTWV0aG9kKFwiYmx1clwiKVxyXG4gICAgfVxyXG59KTtcclxucmVnaXN0ZXJDb21wb25lbnQoXCJkeEh0bWxFZGl0b3JcIiwgSHRtbEVkaXRvcik7XHJcbmV4cG9ydCBkZWZhdWx0IEh0bWxFZGl0b3I7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/ui.html_editor.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/ui/formDialog.js":
/*!*********************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/ui/formDialog.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _popup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../popup */ \"./node_modules/devextreme/esm/ui/popup.js\");\n/* harmony import */ var _form__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../form */ \"./node_modules/devextreme/esm/ui/form.js\");\n/* harmony import */ var _core_utils_deferred__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/utils/deferred */ \"./node_modules/devextreme/esm/core/utils/deferred.js\");\n/* harmony import */ var _localization_message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../localization/message */ \"./node_modules/devextreme/esm/localization/message.js\");\n/* harmony import */ var _core_utils_window__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/utils/window */ \"./node_modules/devextreme/esm/core/utils/window.js\");\n/* harmony import */ var _core_devices__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/devices */ \"./node_modules/devextreme/esm/core/devices.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/ui/formDialog.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar DIALOG_CLASS = \"dx-formdialog\";\r\nvar FORM_CLASS = \"dx-formdialog-form\";\r\nclass FormDialog {\r\n    constructor(editorInstance, popupConfig) {\r\n        this._editorInstance = editorInstance;\r\n        this._popupUserConfig = popupConfig;\r\n        this._renderPopup();\r\n        this._attachOptionChangedHandler()\r\n    }\r\n    _renderPopup() {\r\n        var editorInstance = this._editorInstance;\r\n        var $container = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\").addClass(DIALOG_CLASS).appendTo(editorInstance.$element());\r\n        var popupConfig = this._getPopupConfig();\r\n        return editorInstance._createComponent($container, _popup__WEBPACK_IMPORTED_MODULE_2__[\"default\"], popupConfig)\r\n    }\r\n    _attachOptionChangedHandler() {\r\n        var _this$_popup;\r\n        null === (_this$_popup = this._popup) || void 0 === _this$_popup ? void 0 : _this$_popup.on(\"optionChanged\", _ref => {\r\n            var {\r\n                name: name,\r\n                value: value\r\n            } = _ref;\r\n            if (\"title\" === name) {\r\n                this._updateFormLabel(value)\r\n            }\r\n        })\r\n    }\r\n    _escKeyHandler() {\r\n        this._popup.hide()\r\n    }\r\n    _addEscapeHandler(e) {\r\n        e.component.registerKeyHandler(\"escape\", this._escKeyHandler.bind(this))\r\n    }\r\n    _isSmallScreen() {\r\n        var screenFactor = Object(_core_utils_window__WEBPACK_IMPORTED_MODULE_6__[\"hasWindow\"])() ? Object(_core_utils_window__WEBPACK_IMPORTED_MODULE_6__[\"getCurrentScreenFactor\"])() : null;\r\n        return \"phone\" === _core_devices__WEBPACK_IMPORTED_MODULE_7__[\"default\"].real().deviceType || \"xs\" === screenFactor\r\n    }\r\n    _getPopupConfig() {\r\n        return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])({\r\n            onInitialized: e => {\r\n                this._popup = e.component;\r\n                this._popup.on(\"hiding\", () => {\r\n                    this.deferred.reject()\r\n                });\r\n                this._popup.on(\"shown\", () => {\r\n                    this._form.focus()\r\n                })\r\n            },\r\n            deferRendering: false,\r\n            focusStateEnabled: false,\r\n            showCloseButton: false,\r\n            wrapperAttr: {\r\n                class: \"dx-formdialog\"\r\n            },\r\n            fullScreen: this._isSmallScreen(),\r\n            contentTemplate: contentElem => {\r\n                var $formContainer = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\").appendTo(contentElem);\r\n                this._renderForm($formContainer, {\r\n                    onEditorEnterKey: _ref2 => {\r\n                        var {\r\n                            component: component,\r\n                            dataField: dataField,\r\n                            event: event\r\n                        } = _ref2;\r\n                        this.hide(component.option(\"formData\"), event)\r\n                    },\r\n                    customizeItem: item => {\r\n                        if (\"simple\" === item.itemType) {\r\n                            item.editorOptions = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])(true, {}, item.editorOptions, {\r\n                                onInitialized: this._addEscapeHandler.bind(this)\r\n                            })\r\n                        }\r\n                    }\r\n                })\r\n            },\r\n            toolbarItems: [{\r\n                toolbar: \"bottom\",\r\n                location: \"after\",\r\n                widget: \"dxButton\",\r\n                options: {\r\n                    onInitialized: this._addEscapeHandler.bind(this),\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_5__[\"default\"].format(\"OK\"),\r\n                    onClick: _ref3 => {\r\n                        var {\r\n                            event: event\r\n                        } = _ref3;\r\n                        this.hide(this._form.option(\"formData\"), event)\r\n                    }\r\n                }\r\n            }, {\r\n                toolbar: \"bottom\",\r\n                location: \"after\",\r\n                widget: \"dxButton\",\r\n                options: {\r\n                    onInitialized: this._addEscapeHandler.bind(this),\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_5__[\"default\"].format(\"Cancel\"),\r\n                    onClick: () => {\r\n                        this._popup.hide()\r\n                    }\r\n                }\r\n            }]\r\n        }, this._popupUserConfig)\r\n    }\r\n    _renderForm($container, options) {\r\n        $container.addClass(FORM_CLASS);\r\n        this._form = this._editorInstance._createComponent($container, _form__WEBPACK_IMPORTED_MODULE_3__[\"default\"], options);\r\n        this._updateFormLabel()\r\n    }\r\n    _updateFormLabel(text) {\r\n        var _this$_form;\r\n        var label = null !== text && void 0 !== text ? text : this.popupOption(\"title\");\r\n        null === (_this$_form = this._form) || void 0 === _this$_form ? void 0 : _this$_form.$element().attr(\"aria-label\", label)\r\n    }\r\n    show(formUserConfig) {\r\n        if (this._popup.option(\"visible\")) {\r\n            return\r\n        }\r\n        this.deferred = new _core_utils_deferred__WEBPACK_IMPORTED_MODULE_4__[\"Deferred\"];\r\n        var formConfig = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])({}, formUserConfig);\r\n        this._form.option(formConfig);\r\n        this._popup.show();\r\n        return this.deferred.promise()\r\n    }\r\n    hide(formData, event) {\r\n        this.deferred.resolve(formData, event);\r\n        this._popup.hide()\r\n    }\r\n    popupOption(optionName, optionValue) {\r\n        return this._popup.option.apply(this._popup, arguments)\r\n    }\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (FormDialog);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvdWkvZm9ybURpYWxvZy5qcz8yNzhhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDdUM7QUFHSDtBQUNKO0FBQ0Y7QUFHUTtBQUMwQjtBQUk1QjtBQUNRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOERBQUM7QUFDMUI7QUFDQSwyREFBMkQsOENBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0VBQVMsS0FBSyxpRkFBc0I7QUFDL0QsMkJBQTJCLHFEQUFPO0FBQ2xDO0FBQ0E7QUFDQSxlQUFlLGlFQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHFDQUFxQyw4REFBQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlEQUFpRCxpRUFBTSxTQUFTO0FBQ2hFO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2REFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZEQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLDZDQUFJO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkRBQVE7QUFDcEMseUJBQXlCLGlFQUFNLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UseUVBQVUsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS91aS9odG1sX2VkaXRvci91aS9mb3JtRGlhbG9nLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS91aS9odG1sX2VkaXRvci91aS9mb3JtRGlhbG9nLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQgJCBmcm9tIFwiLi4vLi4vLi4vY29yZS9yZW5kZXJlclwiO1xyXG5pbXBvcnQge1xyXG4gICAgZXh0ZW5kXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvZXh0ZW5kXCI7XHJcbmltcG9ydCBQb3B1cCBmcm9tIFwiLi4vLi4vcG9wdXBcIjtcclxuaW1wb3J0IEZvcm0gZnJvbSBcIi4uLy4uL2Zvcm1cIjtcclxuaW1wb3J0IHtcclxuICAgIERlZmVycmVkXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvZGVmZXJyZWRcIjtcclxuaW1wb3J0IGxvY2FsaXphdGlvbk1lc3NhZ2UgZnJvbSBcIi4uLy4uLy4uL2xvY2FsaXphdGlvbi9tZXNzYWdlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRDdXJyZW50U2NyZWVuRmFjdG9yLFxyXG4gICAgaGFzV2luZG93XHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvd2luZG93XCI7XHJcbmltcG9ydCBkZXZpY2VzIGZyb20gXCIuLi8uLi8uLi9jb3JlL2RldmljZXNcIjtcclxudmFyIERJQUxPR19DTEFTUyA9IFwiZHgtZm9ybWRpYWxvZ1wiO1xyXG52YXIgRk9STV9DTEFTUyA9IFwiZHgtZm9ybWRpYWxvZy1mb3JtXCI7XHJcbmNsYXNzIEZvcm1EaWFsb2cge1xyXG4gICAgY29uc3RydWN0b3IoZWRpdG9ySW5zdGFuY2UsIHBvcHVwQ29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5fZWRpdG9ySW5zdGFuY2UgPSBlZGl0b3JJbnN0YW5jZTtcclxuICAgICAgICB0aGlzLl9wb3B1cFVzZXJDb25maWcgPSBwb3B1cENvbmZpZztcclxuICAgICAgICB0aGlzLl9yZW5kZXJQb3B1cCgpO1xyXG4gICAgICAgIHRoaXMuX2F0dGFjaE9wdGlvbkNoYW5nZWRIYW5kbGVyKClcclxuICAgIH1cclxuICAgIF9yZW5kZXJQb3B1cCgpIHtcclxuICAgICAgICB2YXIgZWRpdG9ySW5zdGFuY2UgPSB0aGlzLl9lZGl0b3JJbnN0YW5jZTtcclxuICAgICAgICB2YXIgJGNvbnRhaW5lciA9ICQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhESUFMT0dfQ0xBU1MpLmFwcGVuZFRvKGVkaXRvckluc3RhbmNlLiRlbGVtZW50KCkpO1xyXG4gICAgICAgIHZhciBwb3B1cENvbmZpZyA9IHRoaXMuX2dldFBvcHVwQ29uZmlnKCk7XHJcbiAgICAgICAgcmV0dXJuIGVkaXRvckluc3RhbmNlLl9jcmVhdGVDb21wb25lbnQoJGNvbnRhaW5lciwgUG9wdXAsIHBvcHVwQ29uZmlnKVxyXG4gICAgfVxyXG4gICAgX2F0dGFjaE9wdGlvbkNoYW5nZWRIYW5kbGVyKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyRfcG9wdXA7XHJcbiAgICAgICAgbnVsbCA9PT0gKF90aGlzJF9wb3B1cCA9IHRoaXMuX3BvcHVwKSB8fCB2b2lkIDAgPT09IF90aGlzJF9wb3B1cCA/IHZvaWQgMCA6IF90aGlzJF9wb3B1cC5vbihcIm9wdGlvbkNoYW5nZWRcIiwgX3JlZiA9PiB7XHJcbiAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgICAgIH0gPSBfcmVmO1xyXG4gICAgICAgICAgICBpZiAoXCJ0aXRsZVwiID09PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVGb3JtTGFiZWwodmFsdWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgX2VzY0tleUhhbmRsZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fcG9wdXAuaGlkZSgpXHJcbiAgICB9XHJcbiAgICBfYWRkRXNjYXBlSGFuZGxlcihlKSB7XHJcbiAgICAgICAgZS5jb21wb25lbnQucmVnaXN0ZXJLZXlIYW5kbGVyKFwiZXNjYXBlXCIsIHRoaXMuX2VzY0tleUhhbmRsZXIuYmluZCh0aGlzKSlcclxuICAgIH1cclxuICAgIF9pc1NtYWxsU2NyZWVuKCkge1xyXG4gICAgICAgIHZhciBzY3JlZW5GYWN0b3IgPSBoYXNXaW5kb3coKSA/IGdldEN1cnJlbnRTY3JlZW5GYWN0b3IoKSA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIFwicGhvbmVcIiA9PT0gZGV2aWNlcy5yZWFsKCkuZGV2aWNlVHlwZSB8fCBcInhzXCIgPT09IHNjcmVlbkZhY3RvclxyXG4gICAgfVxyXG4gICAgX2dldFBvcHVwQ29uZmlnKCkge1xyXG4gICAgICAgIHJldHVybiBleHRlbmQoe1xyXG4gICAgICAgICAgICBvbkluaXRpYWxpemVkOiBlID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVwID0gZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3B1cC5vbihcImhpZGluZ1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3B1cC5vbihcInNob3duXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb3JtLmZvY3VzKClcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRlZmVyUmVuZGVyaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgZm9jdXNTdGF0ZUVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93Q2xvc2VCdXR0b246IGZhbHNlLFxyXG4gICAgICAgICAgICB3cmFwcGVyQXR0cjoge1xyXG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiZHgtZm9ybWRpYWxvZ1wiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bGxTY3JlZW46IHRoaXMuX2lzU21hbGxTY3JlZW4oKSxcclxuICAgICAgICAgICAgY29udGVudFRlbXBsYXRlOiBjb250ZW50RWxlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJGZvcm1Db250YWluZXIgPSAkKFwiPGRpdj5cIikuYXBwZW5kVG8oY29udGVudEVsZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyRm9ybSgkZm9ybUNvbnRhaW5lciwge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRWRpdG9yRW50ZXJLZXk6IF9yZWYyID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUZpZWxkOiBkYXRhRmllbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSA9IF9yZWYyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGUoY29tcG9uZW50Lm9wdGlvbihcImZvcm1EYXRhXCIpLCBldmVudClcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbWl6ZUl0ZW06IGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzaW1wbGVcIiA9PT0gaXRlbS5pdGVtVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5lZGl0b3JPcHRpb25zID0gZXh0ZW5kKHRydWUsIHt9LCBpdGVtLmVkaXRvck9wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkluaXRpYWxpemVkOiB0aGlzLl9hZGRFc2NhcGVIYW5kbGVyLmJpbmQodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0b29sYmFySXRlbXM6IFt7XHJcbiAgICAgICAgICAgICAgICB0b29sYmFyOiBcImJvdHRvbVwiLFxyXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IFwiYWZ0ZXJcIixcclxuICAgICAgICAgICAgICAgIHdpZGdldDogXCJkeEJ1dHRvblwiLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uSW5pdGlhbGl6ZWQ6IHRoaXMuX2FkZEVzY2FwZUhhbmRsZXIuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcIk9LXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IF9yZWYzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ID0gX3JlZjM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSh0aGlzLl9mb3JtLm9wdGlvbihcImZvcm1EYXRhXCIpLCBldmVudClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIHRvb2xiYXI6IFwiYm90dG9tXCIsXHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogXCJhZnRlclwiLFxyXG4gICAgICAgICAgICAgICAgd2lkZ2V0OiBcImR4QnV0dG9uXCIsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Jbml0aWFsaXplZDogdGhpcy5fYWRkRXNjYXBlSGFuZGxlci5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxvY2FsaXphdGlvbk1lc3NhZ2UuZm9ybWF0KFwiQ2FuY2VsXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wdXAuaGlkZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XVxyXG4gICAgICAgIH0sIHRoaXMuX3BvcHVwVXNlckNvbmZpZylcclxuICAgIH1cclxuICAgIF9yZW5kZXJGb3JtKCRjb250YWluZXIsIG9wdGlvbnMpIHtcclxuICAgICAgICAkY29udGFpbmVyLmFkZENsYXNzKEZPUk1fQ0xBU1MpO1xyXG4gICAgICAgIHRoaXMuX2Zvcm0gPSB0aGlzLl9lZGl0b3JJbnN0YW5jZS5fY3JlYXRlQ29tcG9uZW50KCRjb250YWluZXIsIEZvcm0sIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUZvcm1MYWJlbCgpXHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRm9ybUxhYmVsKHRleHQpIHtcclxuICAgICAgICB2YXIgX3RoaXMkX2Zvcm07XHJcbiAgICAgICAgdmFyIGxhYmVsID0gbnVsbCAhPT0gdGV4dCAmJiB2b2lkIDAgIT09IHRleHQgPyB0ZXh0IDogdGhpcy5wb3B1cE9wdGlvbihcInRpdGxlXCIpO1xyXG4gICAgICAgIG51bGwgPT09IChfdGhpcyRfZm9ybSA9IHRoaXMuX2Zvcm0pIHx8IHZvaWQgMCA9PT0gX3RoaXMkX2Zvcm0gPyB2b2lkIDAgOiBfdGhpcyRfZm9ybS4kZWxlbWVudCgpLmF0dHIoXCJhcmlhLWxhYmVsXCIsIGxhYmVsKVxyXG4gICAgfVxyXG4gICAgc2hvdyhmb3JtVXNlckNvbmZpZykge1xyXG4gICAgICAgIGlmICh0aGlzLl9wb3B1cC5vcHRpb24oXCJ2aXNpYmxlXCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRlZmVycmVkID0gbmV3IERlZmVycmVkO1xyXG4gICAgICAgIHZhciBmb3JtQ29uZmlnID0gZXh0ZW5kKHt9LCBmb3JtVXNlckNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fZm9ybS5vcHRpb24oZm9ybUNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fcG9wdXAuc2hvdygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkLnByb21pc2UoKVxyXG4gICAgfVxyXG4gICAgaGlkZShmb3JtRGF0YSwgZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmRlZmVycmVkLnJlc29sdmUoZm9ybURhdGEsIGV2ZW50KTtcclxuICAgICAgICB0aGlzLl9wb3B1cC5oaWRlKClcclxuICAgIH1cclxuICAgIHBvcHVwT3B0aW9uKG9wdGlvbk5hbWUsIG9wdGlvblZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVwLm9wdGlvbi5hcHBseSh0aGlzLl9wb3B1cCwgYXJndW1lbnRzKVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IEZvcm1EaWFsb2c7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/ui/formDialog.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/utils/table_helper.js":
/*!**************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/utils/table_helper.js ***!
  \**************************************************************************/
/*! exports provided: TABLE_OPERATIONS, getTableFormats, getTableOperationHandler, unfixTableWidth, getColumnElements, getAutoSizedElements, setLineElementsFormat, getLineElements, getRowElements, hasEmbedContent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TABLE_OPERATIONS\", function() { return TABLE_OPERATIONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTableFormats\", function() { return getTableFormats; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTableOperationHandler\", function() { return getTableOperationHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unfixTableWidth\", function() { return unfixTableWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getColumnElements\", function() { return getColumnElements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAutoSizedElements\", function() { return getAutoSizedElements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setLineElementsFormat\", function() { return setLineElementsFormat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLineElements\", function() { return getLineElements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRowElements\", function() { return getRowElements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasEmbedContent\", function() { return hasEmbedContent; });\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/* harmony import */ var _core_utils_inflector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/utils/inflector */ \"./node_modules/devextreme/esm/core/utils/inflector.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/utils/table_helper.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\nvar TABLE_FORMATS = [\"table\", \"tableHeaderCell\"];\r\nvar TABLE_OPERATIONS = [\"insertTable\", \"insertHeaderRow\", \"insertRowAbove\", \"insertRowBelow\", \"insertColumnLeft\", \"insertColumnRight\", \"deleteColumn\", \"deleteRow\", \"deleteTable\", \"cellProperties\", \"tableProperties\"];\r\n\r\nfunction getTableFormats(quill) {\r\n    var tableModule = quill.getModule(\"table\");\r\n    return null !== tableModule && void 0 !== tableModule && tableModule.tableFormats ? tableModule.tableFormats() : TABLE_FORMATS\r\n}\r\n\r\nfunction hasEmbedContent(module, selection) {\r\n    return !!selection && module.quill.getText(selection).trim().length < selection.length\r\n}\r\n\r\nfunction unfixTableWidth($table, _ref) {\r\n    var {\r\n        tableBlot: tableBlot,\r\n        quill: quill\r\n    } = _ref;\r\n    var formatBlot = null !== tableBlot && void 0 !== tableBlot ? tableBlot : quill.scroll.find($table.get(0));\r\n    formatBlot.format(\"tableWidth\", \"initial\")\r\n}\r\n\r\nfunction getColumnElements($table) {\r\n    var index = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\r\n    return $table.find(\"tr\").eq(index).find(\"th, td\")\r\n}\r\n\r\nfunction getAutoSizedElements($table) {\r\n    var direction = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"horizontal\";\r\n    var result = [];\r\n    var isHorizontal = \"horizontal\" === direction;\r\n    var $lineElements = isHorizontal ? getColumnElements($table) : getRowElements($table);\r\n    $lineElements.each((index, element) => {\r\n        var $element = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element);\r\n        if (\"\" === $element.get(0).style[isHorizontal ? \"width\" : \"height\"]) {\r\n            result.push($element)\r\n        }\r\n    });\r\n    return result\r\n}\r\n\r\nfunction setLineElementsFormat(module, _ref2) {\r\n    var {\r\n        elements: elements,\r\n        property: property,\r\n        value: value\r\n    } = _ref2;\r\n    var tableBlotNames = module.quill.getModule(\"table\").tableBlots;\r\n    var fullPropertyName = \"cell\".concat(Object(_core_utils_inflector__WEBPACK_IMPORTED_MODULE_2__[\"camelize\"])(property, true));\r\n    Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_1__[\"each\"])(elements, (i, element) => {\r\n        var _formatBlot;\r\n        var formatBlot = module.quill.scroll.find(element);\r\n        if (!tableBlotNames.includes(formatBlot.statics.blotName)) {\r\n            var descendBlot = formatBlot.descendant(blot => tableBlotNames.includes(blot.statics.blotName));\r\n            formatBlot = descendBlot ? descendBlot[0] : null\r\n        }\r\n        null === (_formatBlot = formatBlot) || void 0 === _formatBlot ? void 0 : _formatBlot.format(fullPropertyName, value + \"px\")\r\n    })\r\n}\r\n\r\nfunction getLineElements($table, index) {\r\n    var direction = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : \"horizontal\";\r\n    return \"horizontal\" === direction ? getRowElements($table, index) : getColumnElements($table, index)\r\n}\r\n\r\nfunction getRowElements($table) {\r\n    var index = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\r\n    return $table.find(\"th:nth-child(\".concat(1 + index, \"), td:nth-child(\").concat(1 + index, \")\"))\r\n}\r\n\r\nfunction getTableOperationHandler(quill, operationName) {\r\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\r\n        rest[_key - 2] = arguments[_key]\r\n    }\r\n    return () => {\r\n        var table = quill.getModule(\"table\");\r\n        if (!table) {\r\n            return\r\n        }\r\n        quill.focus();\r\n        return table[operationName](...rest)\r\n    }\r\n}\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvdXRpbHMvdGFibGVfaGVscGVyLmpzP2FhZjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDdUM7QUFHRDtBQUdDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOERBQUM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlDQUF5QyxzRUFBUTtBQUNqRCxJQUFJLGlFQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRkFBMEYsYUFBYTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvdXRpbHMvdGFibGVfaGVscGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS91aS9odG1sX2VkaXRvci91dGlscy90YWJsZV9oZWxwZXIuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCAkIGZyb20gXCIuLi8uLi8uLi9jb3JlL3JlbmRlcmVyXCI7XHJcbmltcG9ydCB7XHJcbiAgICBlYWNoXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvaXRlcmF0b3JcIjtcclxuaW1wb3J0IHtcclxuICAgIGNhbWVsaXplXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvaW5mbGVjdG9yXCI7XHJcbnZhciBUQUJMRV9GT1JNQVRTID0gW1widGFibGVcIiwgXCJ0YWJsZUhlYWRlckNlbGxcIl07XHJcbnZhciBUQUJMRV9PUEVSQVRJT05TID0gW1wiaW5zZXJ0VGFibGVcIiwgXCJpbnNlcnRIZWFkZXJSb3dcIiwgXCJpbnNlcnRSb3dBYm92ZVwiLCBcImluc2VydFJvd0JlbG93XCIsIFwiaW5zZXJ0Q29sdW1uTGVmdFwiLCBcImluc2VydENvbHVtblJpZ2h0XCIsIFwiZGVsZXRlQ29sdW1uXCIsIFwiZGVsZXRlUm93XCIsIFwiZGVsZXRlVGFibGVcIiwgXCJjZWxsUHJvcGVydGllc1wiLCBcInRhYmxlUHJvcGVydGllc1wiXTtcclxuXHJcbmZ1bmN0aW9uIGdldFRhYmxlRm9ybWF0cyhxdWlsbCkge1xyXG4gICAgdmFyIHRhYmxlTW9kdWxlID0gcXVpbGwuZ2V0TW9kdWxlKFwidGFibGVcIik7XHJcbiAgICByZXR1cm4gbnVsbCAhPT0gdGFibGVNb2R1bGUgJiYgdm9pZCAwICE9PSB0YWJsZU1vZHVsZSAmJiB0YWJsZU1vZHVsZS50YWJsZUZvcm1hdHMgPyB0YWJsZU1vZHVsZS50YWJsZUZvcm1hdHMoKSA6IFRBQkxFX0ZPUk1BVFNcclxufVxyXG5cclxuZnVuY3Rpb24gaGFzRW1iZWRDb250ZW50KG1vZHVsZSwgc2VsZWN0aW9uKSB7XHJcbiAgICByZXR1cm4gISFzZWxlY3Rpb24gJiYgbW9kdWxlLnF1aWxsLmdldFRleHQoc2VsZWN0aW9uKS50cmltKCkubGVuZ3RoIDwgc2VsZWN0aW9uLmxlbmd0aFxyXG59XHJcblxyXG5mdW5jdGlvbiB1bmZpeFRhYmxlV2lkdGgoJHRhYmxlLCBfcmVmKSB7XHJcbiAgICB2YXIge1xyXG4gICAgICAgIHRhYmxlQmxvdDogdGFibGVCbG90LFxyXG4gICAgICAgIHF1aWxsOiBxdWlsbFxyXG4gICAgfSA9IF9yZWY7XHJcbiAgICB2YXIgZm9ybWF0QmxvdCA9IG51bGwgIT09IHRhYmxlQmxvdCAmJiB2b2lkIDAgIT09IHRhYmxlQmxvdCA/IHRhYmxlQmxvdCA6IHF1aWxsLnNjcm9sbC5maW5kKCR0YWJsZS5nZXQoMCkpO1xyXG4gICAgZm9ybWF0QmxvdC5mb3JtYXQoXCJ0YWJsZVdpZHRoXCIsIFwiaW5pdGlhbFwiKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb2x1bW5FbGVtZW50cygkdGFibGUpIHtcclxuICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogMDtcclxuICAgIHJldHVybiAkdGFibGUuZmluZChcInRyXCIpLmVxKGluZGV4KS5maW5kKFwidGgsIHRkXCIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEF1dG9TaXplZEVsZW1lbnRzKCR0YWJsZSkge1xyXG4gICAgdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogXCJob3Jpem9udGFsXCI7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICB2YXIgaXNIb3Jpem9udGFsID0gXCJob3Jpem9udGFsXCIgPT09IGRpcmVjdGlvbjtcclxuICAgIHZhciAkbGluZUVsZW1lbnRzID0gaXNIb3Jpem9udGFsID8gZ2V0Q29sdW1uRWxlbWVudHMoJHRhYmxlKSA6IGdldFJvd0VsZW1lbnRzKCR0YWJsZSk7XHJcbiAgICAkbGluZUVsZW1lbnRzLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KTtcclxuICAgICAgICBpZiAoXCJcIiA9PT0gJGVsZW1lbnQuZ2V0KDApLnN0eWxlW2lzSG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCRlbGVtZW50KVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRMaW5lRWxlbWVudHNGb3JtYXQobW9kdWxlLCBfcmVmMikge1xyXG4gICAgdmFyIHtcclxuICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXHJcbiAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxyXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgfSA9IF9yZWYyO1xyXG4gICAgdmFyIHRhYmxlQmxvdE5hbWVzID0gbW9kdWxlLnF1aWxsLmdldE1vZHVsZShcInRhYmxlXCIpLnRhYmxlQmxvdHM7XHJcbiAgICB2YXIgZnVsbFByb3BlcnR5TmFtZSA9IFwiY2VsbFwiLmNvbmNhdChjYW1lbGl6ZShwcm9wZXJ0eSwgdHJ1ZSkpO1xyXG4gICAgZWFjaChlbGVtZW50cywgKGksIGVsZW1lbnQpID0+IHtcclxuICAgICAgICB2YXIgX2Zvcm1hdEJsb3Q7XHJcbiAgICAgICAgdmFyIGZvcm1hdEJsb3QgPSBtb2R1bGUucXVpbGwuc2Nyb2xsLmZpbmQoZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKCF0YWJsZUJsb3ROYW1lcy5pbmNsdWRlcyhmb3JtYXRCbG90LnN0YXRpY3MuYmxvdE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXNjZW5kQmxvdCA9IGZvcm1hdEJsb3QuZGVzY2VuZGFudChibG90ID0+IHRhYmxlQmxvdE5hbWVzLmluY2x1ZGVzKGJsb3Quc3RhdGljcy5ibG90TmFtZSkpO1xyXG4gICAgICAgICAgICBmb3JtYXRCbG90ID0gZGVzY2VuZEJsb3QgPyBkZXNjZW5kQmxvdFswXSA6IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgbnVsbCA9PT0gKF9mb3JtYXRCbG90ID0gZm9ybWF0QmxvdCkgfHwgdm9pZCAwID09PSBfZm9ybWF0QmxvdCA/IHZvaWQgMCA6IF9mb3JtYXRCbG90LmZvcm1hdChmdWxsUHJvcGVydHlOYW1lLCB2YWx1ZSArIFwicHhcIilcclxuICAgIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldExpbmVFbGVtZW50cygkdGFibGUsIGluZGV4KSB7XHJcbiAgICB2YXIgZGlyZWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiBcImhvcml6b250YWxcIjtcclxuICAgIHJldHVybiBcImhvcml6b250YWxcIiA9PT0gZGlyZWN0aW9uID8gZ2V0Um93RWxlbWVudHMoJHRhYmxlLCBpbmRleCkgOiBnZXRDb2x1bW5FbGVtZW50cygkdGFibGUsIGluZGV4KVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRSb3dFbGVtZW50cygkdGFibGUpIHtcclxuICAgIHZhciBpbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogMDtcclxuICAgIHJldHVybiAkdGFibGUuZmluZChcInRoOm50aC1jaGlsZChcIi5jb25jYXQoMSArIGluZGV4LCBcIiksIHRkOm50aC1jaGlsZChcIikuY29uY2F0KDEgKyBpbmRleCwgXCIpXCIpKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUYWJsZU9wZXJhdGlvbkhhbmRsZXIocXVpbGwsIG9wZXJhdGlvbk5hbWUpIHtcclxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgICAgICByZXN0W19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB2YXIgdGFibGUgPSBxdWlsbC5nZXRNb2R1bGUoXCJ0YWJsZVwiKTtcclxuICAgICAgICBpZiAoIXRhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICBxdWlsbC5mb2N1cygpO1xyXG4gICAgICAgIHJldHVybiB0YWJsZVtvcGVyYXRpb25OYW1lXSguLi5yZXN0KVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCB7XHJcbiAgICBUQUJMRV9PUEVSQVRJT05TLFxyXG4gICAgZ2V0VGFibGVGb3JtYXRzLFxyXG4gICAgZ2V0VGFibGVPcGVyYXRpb25IYW5kbGVyLFxyXG4gICAgdW5maXhUYWJsZVdpZHRoLFxyXG4gICAgZ2V0Q29sdW1uRWxlbWVudHMsXHJcbiAgICBnZXRBdXRvU2l6ZWRFbGVtZW50cyxcclxuICAgIHNldExpbmVFbGVtZW50c0Zvcm1hdCxcclxuICAgIGdldExpbmVFbGVtZW50cyxcclxuICAgIGdldFJvd0VsZW1lbnRzLFxyXG4gICAgaGFzRW1iZWRDb250ZW50XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/utils/table_helper.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/ui/html_editor/utils/toolbar_helper.js":
/*!****************************************************************************!*\
  !*** ./node_modules/devextreme/esm/ui/html_editor/utils/toolbar_helper.js ***!
  \****************************************************************************/
/*! exports provided: getFormatHandlers, getDefaultClickHandler, ICON_MAP, applyFormat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFormatHandlers\", function() { return getFormatHandlers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDefaultClickHandler\", function() { return getDefaultClickHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ICON_MAP\", function() { return ICON_MAP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyFormat\", function() { return applyFormat; });\n/* harmony import */ var _core_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/renderer */ \"./node_modules/devextreme/esm/core/renderer.js\");\n/* harmony import */ var _localization_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../localization/message */ \"./node_modules/devextreme/esm/localization/message.js\");\n/* harmony import */ var _table_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./table_helper */ \"./node_modules/devextreme/esm/ui/html_editor/utils/table_helper.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/* harmony import */ var _form__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../form */ \"./node_modules/devextreme/esm/ui/form.js\");\n/* harmony import */ var _button_group__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../button_group */ \"./node_modules/devextreme/esm/ui/button_group.js\");\n/* harmony import */ var _color_box__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../color_box */ \"./node_modules/devextreme/esm/ui/color_box.js\");\n/* harmony import */ var _scroll_view__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../scroll_view */ \"./node_modules/devextreme/esm/ui/scroll_view.js\");\n/* harmony import */ var _core_utils_size__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../core/utils/size */ \"./node_modules/devextreme/esm/core/utils/size.js\");\n/* harmony import */ var _core_utils_window__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../core/utils/window */ \"./node_modules/devextreme/esm/core/utils/window.js\");\n/**\r\n * DevExtreme (esm/ui/html_editor/utils/toolbar_helper.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar MIN_HEIGHT = 400;\r\nvar BORDER_STYLES = [\"none\", \"hidden\", \"dotted\", \"dashed\", \"solid\", \"double\", \"groove\", \"ridge\", \"inset\", \"outset\"];\r\nvar USER_ACTION = \"user\";\r\nvar SILENT_ACTION = \"silent\";\r\nvar DIALOG_COLOR_CAPTION = \"dxHtmlEditor-dialogColorCaption\";\r\nvar DIALOG_BACKGROUND_CAPTION = \"dxHtmlEditor-dialogBackgroundCaption\";\r\nvar DIALOG_LINK_CAPTION = \"dxHtmlEditor-dialogLinkCaption\";\r\nvar DIALOG_IMAGE_CAPTION = \"dxHtmlEditor-dialogImageCaption\";\r\nvar DIALOG_TABLE_CAPTION = \"dxHtmlEditor-dialogInsertTableCaption\";\r\nvar DIALOG_LINK_FIELD_URL = \"dxHtmlEditor-dialogLinkUrlField\";\r\nvar DIALOG_LINK_FIELD_TEXT = \"dxHtmlEditor-dialogLinkTextField\";\r\nvar DIALOG_LINK_FIELD_TARGET = \"dxHtmlEditor-dialogLinkTargetField\";\r\nvar DIALOG_LINK_FIELD_TARGET_CLASS = \"dx-formdialog-field-target\";\r\nvar DIALOG_IMAGE_FIELD_URL = \"dxHtmlEditor-dialogImageUrlField\";\r\nvar DIALOG_IMAGE_FIELD_ALT = \"dxHtmlEditor-dialogImageAltField\";\r\nvar DIALOG_IMAGE_FIELD_WIDTH = \"dxHtmlEditor-dialogImageWidthField\";\r\nvar DIALOG_IMAGE_FIELD_HEIGHT = \"dxHtmlEditor-dialogImageHeightField\";\r\nvar DIALOG_TABLE_FIELD_COLUMNS = \"dxHtmlEditor-dialogInsertTableRowsField\";\r\nvar DIALOG_TABLE_FIELD_ROWS = \"dxHtmlEditor-dialogInsertTableColumnsField\";\r\nvar ICON_MAP = {\r\n    insertHeaderRow: \"header\",\r\n    clear: \"clearformat\"\r\n};\r\n\r\nfunction getFormatHandlers(module) {\r\n    return {\r\n        clear: _ref => {\r\n            var {\r\n                event: event\r\n            } = _ref;\r\n            var range = module.quill.getSelection();\r\n            if (range) {\r\n                var _getToolbarModule;\r\n                module.saveValueChangeEvent(event);\r\n                module.quill.removeFormat(range);\r\n                null === (_getToolbarModule = getToolbarModule(module)) || void 0 === _getToolbarModule ? void 0 : _getToolbarModule.updateFormatWidgets()\r\n            }\r\n        },\r\n        link: prepareLinkHandler(module),\r\n        image: prepareImageHandler(module),\r\n        color: prepareColorClickHandler(module, \"color\"),\r\n        background: prepareColorClickHandler(module, \"background\"),\r\n        orderedList: prepareShortcutHandler(module, \"list\", \"ordered\"),\r\n        bulletList: prepareShortcutHandler(module, \"list\", \"bullet\"),\r\n        alignLeft: prepareShortcutHandler(module, \"align\", \"left\"),\r\n        alignCenter: prepareShortcutHandler(module, \"align\", \"center\"),\r\n        alignRight: prepareShortcutHandler(module, \"align\", \"right\"),\r\n        alignJustify: prepareShortcutHandler(module, \"align\", \"justify\"),\r\n        codeBlock: getDefaultClickHandler(module, \"code-block\"),\r\n        undo: _ref2 => {\r\n            var {\r\n                event: event\r\n            } = _ref2;\r\n            module.saveValueChangeEvent(event);\r\n            module.quill.history.undo()\r\n        },\r\n        redo: _ref3 => {\r\n            var {\r\n                event: event\r\n            } = _ref3;\r\n            module.saveValueChangeEvent(event);\r\n            module.quill.history.redo()\r\n        },\r\n        increaseIndent: _ref4 => {\r\n            var {\r\n                event: event\r\n            } = _ref4;\r\n            applyFormat(module, [\"indent\", \"+1\", USER_ACTION], event)\r\n        },\r\n        decreaseIndent: _ref5 => {\r\n            var {\r\n                event: event\r\n            } = _ref5;\r\n            applyFormat(module, [\"indent\", \"-1\", USER_ACTION], event)\r\n        },\r\n        superscript: prepareShortcutHandler(module, \"script\", \"super\"),\r\n        subscript: prepareShortcutHandler(module, \"script\", \"sub\"),\r\n        insertTable: prepareInsertTableHandler(module),\r\n        insertHeaderRow: Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getTableOperationHandler\"])(module.quill, \"insertHeaderRow\"),\r\n        insertRowAbove: Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getTableOperationHandler\"])(module.quill, \"insertRowAbove\"),\r\n        insertRowBelow: Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getTableOperationHandler\"])(module.quill, \"insertRowBelow\"),\r\n        insertColumnLeft: Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getTableOperationHandler\"])(module.quill, \"insertColumnLeft\"),\r\n        insertColumnRight: Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getTableOperationHandler\"])(module.quill, \"insertColumnRight\"),\r\n        deleteColumn: Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getTableOperationHandler\"])(module.quill, \"deleteColumn\"),\r\n        deleteRow: Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getTableOperationHandler\"])(module.quill, \"deleteRow\"),\r\n        deleteTable: Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getTableOperationHandler\"])(module.quill, \"deleteTable\"),\r\n        cellProperties: prepareShowFormProperties(module, \"cell\"),\r\n        tableProperties: prepareShowFormProperties(module, \"table\")\r\n    }\r\n}\r\n\r\nfunction resetFormDialogOptions(editorInstance, _ref6) {\r\n    var {\r\n        contentTemplate: contentTemplate,\r\n        title: title,\r\n        minHeight: minHeight,\r\n        minWidth: minWidth,\r\n        maxWidth: maxWidth\r\n    } = _ref6;\r\n    editorInstance.formDialogOption({\r\n        contentTemplate: contentTemplate,\r\n        title: title,\r\n        minHeight: null !== minHeight && void 0 !== minHeight ? minHeight : 0,\r\n        minWidth: null !== minWidth && void 0 !== minWidth ? minWidth : 0,\r\n        maxWidth: null !== maxWidth && void 0 !== maxWidth ? maxWidth : \"none\"\r\n    })\r\n}\r\n\r\nfunction prepareShowFormProperties(module, type) {\r\n    return $element => {\r\n        var _$element, _module$quill$getModu;\r\n        if (!(null !== (_$element = $element) && void 0 !== _$element && _$element.length)) {\r\n            $element = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(getTargetTableNode(module, type))\r\n        }\r\n        var [tableBlot, rowBlot] = null !== (_module$quill$getModu = module.quill.getModule(\"table\").getTable()) && void 0 !== _module$quill$getModu ? _module$quill$getModu : [];\r\n        var formats = module.quill.getFormat(module.editorInstance.getSelection(true));\r\n        var tablePropertiesFormConfig = getFormConfigConstructor(type)(module, {\r\n            $element: $element,\r\n            formats: formats,\r\n            tableBlot: tableBlot,\r\n            rowBlot: rowBlot\r\n        });\r\n        var {\r\n            contentTemplate: contentTemplate,\r\n            title: title,\r\n            minHeight: minHeight,\r\n            minWidth: minWidth,\r\n            maxWidth: maxWidth\r\n        } = module.editorInstance._formDialog._popup.option();\r\n        var savedOptions = {\r\n            contentTemplate: contentTemplate,\r\n            title: title,\r\n            minHeight: minHeight,\r\n            minWidth: minWidth,\r\n            maxWidth: maxWidth\r\n        };\r\n        var formInstance;\r\n        module.editorInstance.formDialogOption({\r\n            contentTemplate: container => {\r\n                var $content = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\").appendTo(container);\r\n                var $form = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\").appendTo($content);\r\n                module.editorInstance._createComponent($form, _form__WEBPACK_IMPORTED_MODULE_5__[\"default\"], tablePropertiesFormConfig.formOptions);\r\n                module.editorInstance._createComponent($content, _scroll_view__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {});\r\n                formInstance = $form.dxForm(\"instance\");\r\n                return $content\r\n            },\r\n            title: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-\".concat(type, \"Properties\")),\r\n            minHeight: MIN_HEIGHT,\r\n            minWidth: Math.min(800, .9 * Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getWidth\"])(Object(_core_utils_window__WEBPACK_IMPORTED_MODULE_10__[\"getWindow\"])()) - 1),\r\n            maxWidth: .9 * Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getWidth\"])(Object(_core_utils_window__WEBPACK_IMPORTED_MODULE_10__[\"getWindow\"])())\r\n        });\r\n        var promise = module.editorInstance.showFormDialog();\r\n        promise.done((formData, event) => {\r\n            module.saveValueChangeEvent(event);\r\n            tablePropertiesFormConfig.applyHandler(formInstance);\r\n            resetFormDialogOptions(module.editorInstance, savedOptions)\r\n        });\r\n        promise.fail(() => {\r\n            module.quill.focus();\r\n            resetFormDialogOptions(module.editorInstance, savedOptions)\r\n        })\r\n    }\r\n}\r\n\r\nfunction applyFormat(module, formatArgs, event) {\r\n    module.editorInstance._saveValueChangeEvent(event);\r\n    module.quill.format(...formatArgs)\r\n}\r\n\r\nfunction getTargetTableNode(module, partName) {\r\n    var currentSelectionParts = module.quill.getModule(\"table\").getTable();\r\n    return \"table\" === partName ? currentSelectionParts[0].domNode : currentSelectionParts[2].domNode\r\n}\r\n\r\nfunction prepareLinkHandler(module) {\r\n    return () => {\r\n        module.quill.focus();\r\n        var selection = module.quill.getSelection();\r\n        var selectionHasEmbedContent = Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"hasEmbedContent\"])(module, selection);\r\n        var formats = selection ? module.quill.getFormat() : {};\r\n        var formData = {\r\n            href: formats.link || \"\",\r\n            text: selection && !selectionHasEmbedContent ? module.quill.getText(selection) : \"\",\r\n            target: Object.prototype.hasOwnProperty.call(formats, \"target\") ? !!formats.target : true\r\n        };\r\n        module.editorInstance.formDialogOption(\"title\", _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(DIALOG_LINK_CAPTION));\r\n        var promise = module.editorInstance.showFormDialog({\r\n            formData: formData,\r\n            items: getLinkFormItems(module, selection)\r\n        });\r\n        promise.done((formData, event) => {\r\n            if (selection && !selectionHasEmbedContent) {\r\n                var text = formData.text || formData.href;\r\n                var {\r\n                    index: index,\r\n                    length: length\r\n                } = selection;\r\n                formData.text = void 0;\r\n                module.saveValueChangeEvent(event);\r\n                length && module.quill.deleteText(index, length, SILENT_ACTION);\r\n                module.quill.insertText(index, text, \"link\", formData, USER_ACTION);\r\n                module.quill.setSelection(index + text.length, 0, USER_ACTION)\r\n            } else {\r\n                formData.text = !selection && !formData.text ? formData.href : formData.text;\r\n                applyFormat(module, [\"link\", formData, USER_ACTION], event)\r\n            }\r\n        });\r\n        promise.fail(() => {\r\n            module.quill.focus()\r\n        })\r\n    }\r\n}\r\n\r\nfunction prepareImageHandler(module) {\r\n    return () => {\r\n        var formData = module.quill.getFormat();\r\n        var isUpdateDialog = Object.prototype.hasOwnProperty.call(formData, \"imageSrc\");\r\n        var defaultIndex = defaultPasteIndex(module);\r\n        if (isUpdateDialog) {\r\n            var {\r\n                imageSrc: imageSrc\r\n            } = module.quill.getFormat(defaultIndex - 1, 1);\r\n            formData.src = formData.imageSrc;\r\n            delete formData.imageSrc;\r\n            if (!imageSrc || 0 === defaultIndex) {\r\n                module.quill.setSelection(defaultIndex + 1, 0, SILENT_ACTION)\r\n            }\r\n        }\r\n        var formatIndex = embedFormatIndex(module);\r\n        module.editorInstance.formDialogOption(\"title\", _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(DIALOG_IMAGE_CAPTION));\r\n        var promise = module.editorInstance.showFormDialog({\r\n            formData: formData,\r\n            items: imageFormItems()\r\n        });\r\n        promise.done((formData, event) => {\r\n            var index = defaultIndex;\r\n            module.saveValueChangeEvent(event);\r\n            if (isUpdateDialog) {\r\n                index = formatIndex;\r\n                module.quill.deleteText(index, 1, SILENT_ACTION)\r\n            }\r\n            module.quill.insertEmbed(index, \"extendedImage\", formData, USER_ACTION);\r\n            module.quill.setSelection(index + 1, 0, USER_ACTION)\r\n        }).always(() => {\r\n            module.quill.focus()\r\n        })\r\n    }\r\n}\r\n\r\nfunction getLinkFormItems(module, selection) {\r\n    return [{\r\n        dataField: \"href\",\r\n        label: {\r\n            text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(DIALOG_LINK_FIELD_URL)\r\n        }\r\n    }, {\r\n        dataField: \"text\",\r\n        label: {\r\n            text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(DIALOG_LINK_FIELD_TEXT)\r\n        },\r\n        visible: !Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"hasEmbedContent\"])(module, selection)\r\n    }, {\r\n        dataField: \"target\",\r\n        editorType: \"dxCheckBox\",\r\n        editorOptions: {\r\n            text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(DIALOG_LINK_FIELD_TARGET)\r\n        },\r\n        cssClass: DIALOG_LINK_FIELD_TARGET_CLASS,\r\n        label: {\r\n            visible: false\r\n        }\r\n    }]\r\n}\r\n\r\nfunction embedFormatIndex(module) {\r\n    var selection = module.quill.getSelection();\r\n    if (selection) {\r\n        if (selection.length) {\r\n            return selection.index\r\n        } else {\r\n            return selection.index - 1\r\n        }\r\n    } else {\r\n        return module.quill.getLength()\r\n    }\r\n}\r\n\r\nfunction defaultPasteIndex(module) {\r\n    var _selection$index;\r\n    var selection = module.quill.getSelection();\r\n    return null !== (_selection$index = null === selection || void 0 === selection ? void 0 : selection.index) && void 0 !== _selection$index ? _selection$index : module.quill.getLength()\r\n}\r\n\r\nfunction imageFormItems() {\r\n    return [{\r\n        dataField: \"src\",\r\n        label: {\r\n            text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(DIALOG_IMAGE_FIELD_URL)\r\n        }\r\n    }, {\r\n        dataField: \"width\",\r\n        label: {\r\n            text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(DIALOG_IMAGE_FIELD_WIDTH)\r\n        }\r\n    }, {\r\n        dataField: \"height\",\r\n        label: {\r\n            text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(DIALOG_IMAGE_FIELD_HEIGHT)\r\n        }\r\n    }, {\r\n        dataField: \"alt\",\r\n        label: {\r\n            text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(DIALOG_IMAGE_FIELD_ALT)\r\n        }\r\n    }]\r\n}\r\n\r\nfunction prepareColorClickHandler(module, name) {\r\n    return () => {\r\n        var formData = module.quill.getFormat();\r\n        var caption = \"color\" === name ? DIALOG_COLOR_CAPTION : DIALOG_BACKGROUND_CAPTION;\r\n        module.editorInstance.formDialogOption(\"title\", _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(caption));\r\n        var promise = module.editorInstance.showFormDialog({\r\n            formData: formData,\r\n            items: [{\r\n                dataField: name,\r\n                editorType: \"dxColorView\",\r\n                editorOptions: {\r\n                    focusStateEnabled: false\r\n                },\r\n                label: {\r\n                    visible: false\r\n                }\r\n            }]\r\n        });\r\n        promise.done((formData, event) => {\r\n            applyFormat(module, [name, formData[name], USER_ACTION], event)\r\n        });\r\n        promise.fail(() => {\r\n            module.quill.focus()\r\n        })\r\n    }\r\n}\r\n\r\nfunction prepareShortcutHandler(module, name, shortcutValue) {\r\n    return _ref7 => {\r\n        var _getToolbarModule2;\r\n        var {\r\n            event: event\r\n        } = _ref7;\r\n        var formats = module.quill.getFormat();\r\n        var value = formats[name] === shortcutValue ? false : shortcutValue;\r\n        applyFormat(module, [name, value, USER_ACTION], event);\r\n        null === (_getToolbarModule2 = getToolbarModule(module)) || void 0 === _getToolbarModule2 ? void 0 : _getToolbarModule2.updateFormatWidgets(true)\r\n    }\r\n}\r\n\r\nfunction getToolbarModule(module) {\r\n    return module._updateFormatWidget ? module : module.quill.getModule(\"toolbar\")\r\n}\r\n\r\nfunction getDefaultClickHandler(module, name) {\r\n    return _ref8 => {\r\n        var _getToolbarModule3;\r\n        var {\r\n            event: event\r\n        } = _ref8;\r\n        var formats = module.quill.getFormat();\r\n        var value = formats[name];\r\n        var newValue = !(Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isBoolean\"])(value) ? value : Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(value));\r\n        applyFormat(module, [name, newValue, USER_ACTION], event);\r\n        null === (_getToolbarModule3 = getToolbarModule(module)) || void 0 === _getToolbarModule3 ? void 0 : _getToolbarModule3._updateFormatWidget(name, newValue, formats)\r\n    }\r\n}\r\n\r\nfunction insertTableFormItems() {\r\n    return [{\r\n        dataField: \"columns\",\r\n        editorType: \"dxNumberBox\",\r\n        editorOptions: {\r\n            min: 1\r\n        },\r\n        label: {\r\n            text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(DIALOG_TABLE_FIELD_COLUMNS)\r\n        }\r\n    }, {\r\n        dataField: \"rows\",\r\n        editorType: \"dxNumberBox\",\r\n        editorOptions: {\r\n            min: 1\r\n        },\r\n        label: {\r\n            text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(DIALOG_TABLE_FIELD_ROWS)\r\n        }\r\n    }]\r\n}\r\n\r\nfunction prepareInsertTableHandler(module) {\r\n    return () => {\r\n        var formats = module.quill.getFormat();\r\n        var isTableFocused = module._tableFormats.some(format => Object.prototype.hasOwnProperty.call(formats, format));\r\n        if (isTableFocused) {\r\n            module.quill.focus();\r\n            return\r\n        }\r\n        module.editorInstance.formDialogOption(\"title\", _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(DIALOG_TABLE_CAPTION));\r\n        var promise = module.editorInstance.showFormDialog({\r\n            formData: {\r\n                rows: 1,\r\n                columns: 1\r\n            },\r\n            items: insertTableFormItems()\r\n        });\r\n        promise.done((formData, event) => {\r\n            module.quill.focus();\r\n            var table = module.quill.getModule(\"table\");\r\n            if (table) {\r\n                module.saveValueChangeEvent(event);\r\n                var {\r\n                    columns: columns,\r\n                    rows: rows\r\n                } = formData;\r\n                table.insertTable(columns, rows)\r\n            }\r\n        }).always(() => {\r\n            module.quill.focus()\r\n        })\r\n    }\r\n}\r\n\r\nfunction getTablePropertiesFormConfig(module, _ref9) {\r\n    var {\r\n        $element: $element,\r\n        formats: formats,\r\n        tableBlot: tableBlot\r\n    } = _ref9;\r\n    var window = Object(_core_utils_window__WEBPACK_IMPORTED_MODULE_10__[\"getWindow\"])();\r\n    var alignmentEditorInstance;\r\n    var borderColorEditorInstance;\r\n    var backgroundColorEditorInstance;\r\n    var $table = $element;\r\n    var editorInstance = module.editorInstance;\r\n    var startTableWidth = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(formats.tableWidth) ? parseInt(formats.tableWidth) : Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getOuterWidth\"])($table);\r\n    var tableStyles = window.getComputedStyle($table.get(0));\r\n    var startTextAlign = \"start\" === tableStyles.textAlign ? \"left\" : tableStyles.textAlign;\r\n    var formOptions = {\r\n        colCount: 2,\r\n        formData: {\r\n            width: startTableWidth,\r\n            height: Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(formats.tableHeight) ? parseInt(formats.tableHeight) : Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getOuterHeight\"])($table),\r\n            backgroundColor: formats.tableBackgroundColor || tableStyles.backgroundColor,\r\n            borderStyle: formats.tableBorderStyle || tableStyles.borderTopStyle,\r\n            borderColor: formats.tableBorderColor || tableStyles.borderTopColor,\r\n            borderWidth: parseInt(Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(formats.tableBorderWidth) ? formats.tableBorderWidth : tableStyles.borderTopWidth),\r\n            alignment: formats.tableAlign || startTextAlign\r\n        },\r\n        items: [{\r\n            itemType: \"group\",\r\n            caption: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-border\"),\r\n            colCountByScreen: {\r\n                xs: 2\r\n            },\r\n            colCount: 2,\r\n            items: [{\r\n                dataField: \"borderStyle\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-style\")\r\n                },\r\n                editorType: \"dxSelectBox\",\r\n                editorOptions: {\r\n                    items: BORDER_STYLES,\r\n                    placeholder: \"Select style\"\r\n                }\r\n            }, {\r\n                dataField: \"borderWidth\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-borderWidth\")\r\n                },\r\n                editorOptions: {\r\n                    placeholder: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-pixels\")\r\n                }\r\n            }, {\r\n                itemType: \"simple\",\r\n                dataField: \"borderColor\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-borderColor\")\r\n                },\r\n                colSpan: 2,\r\n                template: e => {\r\n                    var $content = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\");\r\n                    editorInstance._createComponent($content, _color_box__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\r\n                        editAlphaChannel: true,\r\n                        value: e.component.option(\"formData\").borderColor,\r\n                        onInitialized: e => {\r\n                            borderColorEditorInstance = e.component\r\n                        }\r\n                    });\r\n                    return $content\r\n                }\r\n            }]\r\n        }, {\r\n            itemType: \"group\",\r\n            caption: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-dimensions\"),\r\n            colCountByScreen: {\r\n                xs: 2\r\n            },\r\n            colCount: 2,\r\n            items: [{\r\n                dataField: \"width\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-width\")\r\n                },\r\n                editorOptions: {\r\n                    min: 0,\r\n                    placeholder: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-pixels\")\r\n                }\r\n            }, {\r\n                dataField: \"height\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-height\")\r\n                },\r\n                editorOptions: {\r\n                    min: 0,\r\n                    placeholder: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-pixels\")\r\n                }\r\n            }]\r\n        }, {\r\n            itemType: \"group\",\r\n            caption: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-tableBackground\"),\r\n            items: [{\r\n                itemType: \"simple\",\r\n                dataField: \"backgroundColor\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-borderColor\")\r\n                },\r\n                template: e => {\r\n                    var $content = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\");\r\n                    editorInstance._createComponent($content, _color_box__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\r\n                        editAlphaChannel: true,\r\n                        value: e.component.option(\"formData\").backgroundColor,\r\n                        onInitialized: e => {\r\n                            backgroundColorEditorInstance = e.component\r\n                        }\r\n                    });\r\n                    return $content\r\n                }\r\n            }]\r\n        }, {\r\n            itemType: \"group\",\r\n            caption: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-alignment\"),\r\n            items: [{\r\n                itemType: \"simple\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-horizontal\")\r\n                },\r\n                template: () => {\r\n                    var $content = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\");\r\n                    editorInstance._createComponent($content, _button_group__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\r\n                        items: [{\r\n                            value: \"left\",\r\n                            icon: \"alignleft\"\r\n                        }, {\r\n                            value: \"center\",\r\n                            icon: \"aligncenter\"\r\n                        }, {\r\n                            value: \"right\",\r\n                            icon: \"alignright\"\r\n                        }, {\r\n                            value: \"justify\",\r\n                            icon: \"alignjustify\"\r\n                        }],\r\n                        keyExpr: \"value\",\r\n                        selectedItemKeys: [startTextAlign],\r\n                        onInitialized: e => {\r\n                            alignmentEditorInstance = e.component\r\n                        }\r\n                    });\r\n                    return $content\r\n                }\r\n            }]\r\n        }],\r\n        showColonAfterLabel: true,\r\n        labelLocation: \"top\",\r\n        minColWidth: 400\r\n    };\r\n    return {\r\n        formOptions: formOptions,\r\n        applyHandler: formInstance => {\r\n            var formData = formInstance.option(\"formData\");\r\n            var newWidth = formData.width === startTableWidth ? void 0 : formData.width;\r\n            var newHeight = formData.height;\r\n            applyTableDimensionChanges(module, {\r\n                $table: $table,\r\n                newHeight: newHeight,\r\n                newWidth: newWidth,\r\n                tableBlot: tableBlot\r\n            });\r\n            module.editorInstance.format(\"tableBorderStyle\", formData.borderStyle);\r\n            module.editorInstance.format(\"tableBorderWidth\", formData.borderWidth + \"px\");\r\n            module.editorInstance.format(\"tableBorderColor\", borderColorEditorInstance.option(\"value\"));\r\n            module.editorInstance.format(\"tableBackgroundColor\", backgroundColorEditorInstance.option(\"value\"));\r\n            module.editorInstance.format(\"tableTextAlign\", alignmentEditorInstance.option(\"selectedItemKeys\")[0])\r\n        }\r\n    }\r\n}\r\n\r\nfunction getCellPropertiesFormConfig(module, _ref10) {\r\n    var {\r\n        $element: $element,\r\n        formats: formats,\r\n        tableBlot: tableBlot,\r\n        rowBlot: rowBlot\r\n    } = _ref10;\r\n    var window = Object(_core_utils_window__WEBPACK_IMPORTED_MODULE_10__[\"getWindow\"])();\r\n    var alignmentEditorInstance;\r\n    var verticalAlignmentEditorInstance;\r\n    var borderColorEditorInstance;\r\n    var backgroundColorEditorInstance;\r\n    var $cell = $element;\r\n    var startCellWidth = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(formats.cellWidth) ? parseInt(formats.cellWidth) : Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getOuterWidth\"])($cell);\r\n    var editorInstance = module.editorInstance;\r\n    var cellStyles = window.getComputedStyle($cell.get(0));\r\n    var startTextAlign = \"start\" === cellStyles.textAlign ? \"left\" : cellStyles.textAlign;\r\n    var formOptions = {\r\n        colCount: 2,\r\n        formData: {\r\n            width: startCellWidth,\r\n            height: Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(formats.cellHeight) ? parseInt(formats.cellHeight) : Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getOuterHeight\"])($cell),\r\n            backgroundColor: formats.cellBackgroundColor || cellStyles.backgroundColor,\r\n            borderStyle: formats.cellBorderStyle || cellStyles.borderTopStyle,\r\n            borderColor: formats.cellBorderColor || cellStyles.borderTopColor,\r\n            borderWidth: parseInt(Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(formats.cellBorderWidth) ? formats.cellBorderWidth : cellStyles.borderTopWidth),\r\n            alignment: formats.cellTextAlign || startTextAlign,\r\n            verticalAlignment: formats.cellVerticalAlign || cellStyles.verticalAlign,\r\n            verticalPadding: parseInt(Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(formats.cellPaddingTop) ? formats.cellPaddingTop : cellStyles.paddingTop),\r\n            horizontalPadding: parseInt(Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(formats.cellPaddingLeft) ? formats.cellPaddingLeft : cellStyles.paddingLeft)\r\n        },\r\n        items: [{\r\n            itemType: \"group\",\r\n            caption: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-border\"),\r\n            colCountByScreen: {\r\n                xs: 2\r\n            },\r\n            colCount: 2,\r\n            items: [{\r\n                dataField: \"borderStyle\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-style\")\r\n                },\r\n                editorType: \"dxSelectBox\",\r\n                editorOptions: {\r\n                    items: BORDER_STYLES\r\n                }\r\n            }, {\r\n                dataField: \"borderWidth\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-borderWidth\")\r\n                },\r\n                editorOptions: {\r\n                    placeholder: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-pixels\")\r\n                }\r\n            }, {\r\n                itemType: \"simple\",\r\n                dataField: \"borderColor\",\r\n                colSpan: 2,\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-borderColor\")\r\n                },\r\n                template: e => {\r\n                    var $content = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\");\r\n                    editorInstance._createComponent($content, _color_box__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\r\n                        editAlphaChannel: true,\r\n                        value: e.component.option(\"formData\").borderColor,\r\n                        onInitialized: e => {\r\n                            borderColorEditorInstance = e.component\r\n                        }\r\n                    });\r\n                    return $content\r\n                }\r\n            }]\r\n        }, {\r\n            itemType: \"group\",\r\n            caption: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-dimensions\"),\r\n            colCount: 2,\r\n            colCountByScreen: {\r\n                xs: 2\r\n            },\r\n            items: [{\r\n                dataField: \"width\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-width\")\r\n                },\r\n                editorOptions: {\r\n                    min: 0,\r\n                    placeholder: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-pixels\")\r\n                }\r\n            }, {\r\n                dataField: \"height\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-height\")\r\n                },\r\n                editorOptions: {\r\n                    min: 0,\r\n                    placeholder: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-pixels\")\r\n                }\r\n            }, {\r\n                dataField: \"verticalPadding\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-paddingVertical\")\r\n                },\r\n                editorOptions: {\r\n                    placeholder: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-pixels\")\r\n                }\r\n            }, {\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-paddingHorizontal\")\r\n                },\r\n                dataField: \"horizontalPadding\",\r\n                editorOptions: {\r\n                    placeholder: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-pixels\")\r\n                }\r\n            }]\r\n        }, {\r\n            itemType: \"group\",\r\n            caption: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-tableBackground\"),\r\n            items: [{\r\n                itemType: \"simple\",\r\n                dataField: \"backgroundColor\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-borderColor\")\r\n                },\r\n                template: e => {\r\n                    var $content = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\");\r\n                    editorInstance._createComponent($content, _color_box__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\r\n                        editAlphaChannel: true,\r\n                        value: e.component.option(\"formData\").backgroundColor,\r\n                        onInitialized: e => {\r\n                            backgroundColorEditorInstance = e.component\r\n                        }\r\n                    });\r\n                    return $content\r\n                }\r\n            }]\r\n        }, {\r\n            itemType: \"group\",\r\n            caption: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-alignment\"),\r\n            colCount: 2,\r\n            items: [{\r\n                itemType: \"simple\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-horizontal\")\r\n                },\r\n                template: () => {\r\n                    var $content = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\");\r\n                    editorInstance._createComponent($content, _button_group__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\r\n                        items: [{\r\n                            value: \"left\",\r\n                            icon: \"alignleft\"\r\n                        }, {\r\n                            value: \"center\",\r\n                            icon: \"aligncenter\"\r\n                        }, {\r\n                            value: \"right\",\r\n                            icon: \"alignright\"\r\n                        }, {\r\n                            value: \"justify\",\r\n                            icon: \"alignjustify\"\r\n                        }],\r\n                        keyExpr: \"value\",\r\n                        selectedItemKeys: [startTextAlign],\r\n                        onInitialized: e => {\r\n                            alignmentEditorInstance = e.component\r\n                        }\r\n                    });\r\n                    return $content\r\n                }\r\n            }, {\r\n                itemType: \"simple\",\r\n                label: {\r\n                    text: _localization_message__WEBPACK_IMPORTED_MODULE_1__[\"default\"].format(\"dxHtmlEditor-vertical\")\r\n                },\r\n                template: () => {\r\n                    var $content = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"<div>\");\r\n                    editorInstance._createComponent($content, _button_group__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\r\n                        items: [{\r\n                            value: \"top\",\r\n                            icon: \"verticalaligntop\"\r\n                        }, {\r\n                            value: \"middle\",\r\n                            icon: \"verticalaligncenter\"\r\n                        }, {\r\n                            value: \"bottom\",\r\n                            icon: \"verticalalignbottom\"\r\n                        }],\r\n                        keyExpr: \"value\",\r\n                        selectedItemKeys: [cellStyles.verticalAlign],\r\n                        onInitialized: e => {\r\n                            verticalAlignmentEditorInstance = e.component\r\n                        }\r\n                    });\r\n                    return $content\r\n                }\r\n            }]\r\n        }],\r\n        showColonAfterLabel: true,\r\n        labelLocation: \"top\",\r\n        minColWidth: 400\r\n    };\r\n    return {\r\n        formOptions: formOptions,\r\n        applyHandler: formInstance => {\r\n            var formData = formInstance.option(\"formData\");\r\n            var newWidth = formData.width === parseInt(startCellWidth) ? void 0 : formData.width;\r\n            var newHeight = formData.height;\r\n            applyCellDimensionChanges(module, {\r\n                $cell: $cell,\r\n                newHeight: newHeight,\r\n                newWidth: newWidth,\r\n                tableBlot: tableBlot,\r\n                rowBlot: rowBlot\r\n            });\r\n            module.editorInstance.format(\"cellBorderWidth\", formData.borderWidth + \"px\");\r\n            module.editorInstance.format(\"cellBorderColor\", borderColorEditorInstance.option(\"value\"));\r\n            module.editorInstance.format(\"cellBorderStyle\", formData.borderStyle);\r\n            module.editorInstance.format(\"cellBackgroundColor\", backgroundColorEditorInstance.option(\"value\"));\r\n            module.editorInstance.format(\"cellTextAlign\", alignmentEditorInstance.option(\"selectedItemKeys\")[0]);\r\n            module.editorInstance.format(\"cellVerticalAlign\", verticalAlignmentEditorInstance.option(\"selectedItemKeys\")[0]);\r\n            module.editorInstance.format(\"cellPaddingLeft\", formData.horizontalPadding + \"px\");\r\n            module.editorInstance.format(\"cellPaddingRight\", formData.horizontalPadding + \"px\");\r\n            module.editorInstance.format(\"cellPaddingTop\", formData.verticalPadding + \"px\");\r\n            module.editorInstance.format(\"cellPaddingBottom\", formData.verticalPadding + \"px\")\r\n        }\r\n    }\r\n}\r\n\r\nfunction getFormConfigConstructor(type) {\r\n    return \"cell\" === type ? getCellPropertiesFormConfig : getTablePropertiesFormConfig\r\n}\r\n\r\nfunction applyTableDimensionChanges(module, _ref11) {\r\n    var {\r\n        $table: $table,\r\n        newHeight: newHeight,\r\n        newWidth: newWidth,\r\n        tableBlot: tableBlot\r\n    } = _ref11;\r\n    if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(newWidth)) {\r\n        var autoWidthColumns = Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getAutoSizedElements\"])($table);\r\n        if (autoWidthColumns.length > 0) {\r\n            module.editorInstance.format(\"tableWidth\", newWidth + \"px\")\r\n        } else {\r\n            var $columns = Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getColumnElements\"])($table);\r\n            var oldTableWidth = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getOuterWidth\"])($table);\r\n            Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"unfixTableWidth\"])($table, {\r\n                tableBlot: tableBlot\r\n            });\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_4__[\"each\"])($columns, (i, element) => {\r\n                var $element = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element);\r\n                var newElementWidth = newWidth / oldTableWidth * Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getOuterWidth\"])($element);\r\n                var $lineElements = Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getLineElements\"])($table, $element.index(), \"horizontal\");\r\n                Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"setLineElementsFormat\"])(module, {\r\n                    elements: $lineElements,\r\n                    property: \"width\",\r\n                    value: newElementWidth\r\n                })\r\n            })\r\n        }\r\n    }\r\n    var autoHeightRows = Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getAutoSizedElements\"])($table, \"vertical\");\r\n    if ((null === autoHeightRows || void 0 === autoHeightRows ? void 0 : autoHeightRows.length) > 0) {\r\n        tableBlot.format(\"tableHeight\", newHeight + \"px\")\r\n    } else {\r\n        var $rows = Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getRowElements\"])($table);\r\n        var oldTableHeight = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getOuterHeight\"])($table);\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_4__[\"each\"])($rows, (i, element) => {\r\n            var $element = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element);\r\n            var newElementHeight = newHeight / oldTableHeight * Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getOuterHeight\"])($element);\r\n            var $lineElements = Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getLineElements\"])($table, i, \"vertical\");\r\n            Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"setLineElementsFormat\"])(module, {\r\n                elements: $lineElements,\r\n                property: \"height\",\r\n                value: newElementHeight\r\n            })\r\n        })\r\n    }\r\n}\r\n\r\nfunction applyCellDimensionChanges(module, _ref12) {\r\n    var {\r\n        $cell: $cell,\r\n        newHeight: newHeight,\r\n        newWidth: newWidth,\r\n        tableBlot: tableBlot,\r\n        rowBlot: rowBlot\r\n    } = _ref12;\r\n    var $table = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])($cell.closest(\"table\"));\r\n    if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_3__[\"isDefined\"])(newWidth)) {\r\n        var index = Object(_core_renderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"])($cell).index();\r\n        var $verticalCells = Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getLineElements\"])($table, index);\r\n        var widthDiff = newWidth - Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getOuterWidth\"])($cell);\r\n        var tableWidth = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getOuterWidth\"])($table);\r\n        if (newWidth > tableWidth) {\r\n            Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"unfixTableWidth\"])($table, {\r\n                tableBlot: tableBlot\r\n            })\r\n        }\r\n        Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"setLineElementsFormat\"])(module, {\r\n            elements: $verticalCells,\r\n            property: \"width\",\r\n            value: newWidth\r\n        });\r\n        var $nextColumnCell = $cell.next();\r\n        var shouldUpdateNearestColumnWidth = 0 === Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getAutoSizedElements\"])($table).length;\r\n        if (shouldUpdateNearestColumnWidth) {\r\n            Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"unfixTableWidth\"])($table, {\r\n                tableBlot: tableBlot\r\n            });\r\n            if (1 === $nextColumnCell.length) {\r\n                $verticalCells = Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getLineElements\"])($table, index + 1);\r\n                var nextColumnWidth = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getOuterWidth\"])($verticalCells.eq(0)) - widthDiff;\r\n                Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"setLineElementsFormat\"])(module, {\r\n                    elements: $verticalCells,\r\n                    property: \"width\",\r\n                    value: Math.max(nextColumnWidth, 0)\r\n                })\r\n            } else {\r\n                var $prevColumnCell = $cell.prev();\r\n                if (1 === $prevColumnCell.length) {\r\n                    $verticalCells = Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getLineElements\"])($table, index - 1);\r\n                    var prevColumnWidth = Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_9__[\"getOuterWidth\"])($verticalCells.eq(0)) - widthDiff;\r\n                    Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"setLineElementsFormat\"])(module, {\r\n                        elements: $verticalCells,\r\n                        property: \"width\",\r\n                        value: Math.max(prevColumnWidth, 0)\r\n                    })\r\n                }\r\n            }\r\n        }\r\n    }\r\n    rowBlot.children.forEach(rowCell => {\r\n        rowCell.format(\"cellHeight\", newHeight + \"px\")\r\n    });\r\n    var autoHeightRows = Object(_table_helper__WEBPACK_IMPORTED_MODULE_2__[\"getAutoSizedElements\"])($table, \"vertical\");\r\n    if (0 === autoHeightRows.length) {\r\n        $table.css(\"height\", \"auto\")\r\n    }\r\n}\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdWkvaHRtbF9lZGl0b3IvdXRpbHMvdG9vbGJhcl9oZWxwZXIuanM/NjAxMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDdUM7QUFDeUI7QUFVeEM7QUFJVTtBQUdJO0FBQ1I7QUFDZTtBQUNOO0FBQ0k7QUFLVDtBQUdFO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOEVBQXdCO0FBQ2pELHdCQUF3Qiw4RUFBd0I7QUFDaEQsd0JBQXdCLDhFQUF3QjtBQUNoRCwwQkFBMEIsOEVBQXdCO0FBQ2xELDJCQUEyQiw4RUFBd0I7QUFDbkQsc0JBQXNCLDhFQUF3QjtBQUM5QyxtQkFBbUIsOEVBQXdCO0FBQzNDLHFCQUFx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LG1DQUFtQyxzRUFBYTtBQUNoRCx5QkFBeUIsc0VBQWE7QUFDdEM7QUFDQSxZQUFZLHFFQUFlO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsUUFBUSwyRUFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbURBQW1ELDBFQUFvQjtBQUN2RTtBQUNBLFlBQVkscUVBQWU7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpQ0FBaUMscUVBQWU7QUFDaEQsc0NBQXNDLHNFQUFhO0FBQ25ELGdCQUFnQiwyRUFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUNBQXFDLHFFQUFlO0FBQ3BELDBDQUEwQyxzRUFBYTtBQUN2RCxvQkFBb0IsMkVBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLDBFQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQU1FIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3VpL2h0bWxfZWRpdG9yL3V0aWxzL3Rvb2xiYXJfaGVscGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS91aS9odG1sX2VkaXRvci91dGlscy90b29sYmFyX2hlbHBlci5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0ICQgZnJvbSBcIi4uLy4uLy4uL2NvcmUvcmVuZGVyZXJcIjtcclxuaW1wb3J0IGxvY2FsaXphdGlvbk1lc3NhZ2UgZnJvbSBcIi4uLy4uLy4uL2xvY2FsaXphdGlvbi9tZXNzYWdlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRUYWJsZU9wZXJhdGlvbkhhbmRsZXIsXHJcbiAgICBoYXNFbWJlZENvbnRlbnQsXHJcbiAgICB1bmZpeFRhYmxlV2lkdGgsXHJcbiAgICBnZXRDb2x1bW5FbGVtZW50cyxcclxuICAgIGdldEF1dG9TaXplZEVsZW1lbnRzLFxyXG4gICAgc2V0TGluZUVsZW1lbnRzRm9ybWF0LFxyXG4gICAgZ2V0TGluZUVsZW1lbnRzLFxyXG4gICAgZ2V0Um93RWxlbWVudHNcclxufSBmcm9tIFwiLi90YWJsZV9oZWxwZXJcIjtcclxuaW1wb3J0IHtcclxuICAgIGlzRGVmaW5lZCxcclxuICAgIGlzQm9vbGVhblxyXG59IGZyb20gXCIuLi8uLi8uLi9jb3JlL3V0aWxzL3R5cGVcIjtcclxuaW1wb3J0IHtcclxuICAgIGVhY2hcclxufSBmcm9tIFwiLi4vLi4vLi4vY29yZS91dGlscy9pdGVyYXRvclwiO1xyXG5pbXBvcnQgRm9ybSBmcm9tIFwiLi4vLi4vZm9ybVwiO1xyXG5pbXBvcnQgQnV0dG9uR3JvdXAgZnJvbSBcIi4uLy4uL2J1dHRvbl9ncm91cFwiO1xyXG5pbXBvcnQgQ29sb3JCb3ggZnJvbSBcIi4uLy4uL2NvbG9yX2JveFwiO1xyXG5pbXBvcnQgU2Nyb2xsVmlldyBmcm9tIFwiLi4vLi4vc2Nyb2xsX3ZpZXdcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldE91dGVySGVpZ2h0LFxyXG4gICAgZ2V0V2lkdGgsXHJcbiAgICBnZXRPdXRlcldpZHRoXHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvc2l6ZVwiO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0V2luZG93XHJcbn0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvdXRpbHMvd2luZG93XCI7XHJcbnZhciBNSU5fSEVJR0hUID0gNDAwO1xyXG52YXIgQk9SREVSX1NUWUxFUyA9IFtcIm5vbmVcIiwgXCJoaWRkZW5cIiwgXCJkb3R0ZWRcIiwgXCJkYXNoZWRcIiwgXCJzb2xpZFwiLCBcImRvdWJsZVwiLCBcImdyb292ZVwiLCBcInJpZGdlXCIsIFwiaW5zZXRcIiwgXCJvdXRzZXRcIl07XHJcbnZhciBVU0VSX0FDVElPTiA9IFwidXNlclwiO1xyXG52YXIgU0lMRU5UX0FDVElPTiA9IFwic2lsZW50XCI7XHJcbnZhciBESUFMT0dfQ09MT1JfQ0FQVElPTiA9IFwiZHhIdG1sRWRpdG9yLWRpYWxvZ0NvbG9yQ2FwdGlvblwiO1xyXG52YXIgRElBTE9HX0JBQ0tHUk9VTkRfQ0FQVElPTiA9IFwiZHhIdG1sRWRpdG9yLWRpYWxvZ0JhY2tncm91bmRDYXB0aW9uXCI7XHJcbnZhciBESUFMT0dfTElOS19DQVBUSU9OID0gXCJkeEh0bWxFZGl0b3ItZGlhbG9nTGlua0NhcHRpb25cIjtcclxudmFyIERJQUxPR19JTUFHRV9DQVBUSU9OID0gXCJkeEh0bWxFZGl0b3ItZGlhbG9nSW1hZ2VDYXB0aW9uXCI7XHJcbnZhciBESUFMT0dfVEFCTEVfQ0FQVElPTiA9IFwiZHhIdG1sRWRpdG9yLWRpYWxvZ0luc2VydFRhYmxlQ2FwdGlvblwiO1xyXG52YXIgRElBTE9HX0xJTktfRklFTERfVVJMID0gXCJkeEh0bWxFZGl0b3ItZGlhbG9nTGlua1VybEZpZWxkXCI7XHJcbnZhciBESUFMT0dfTElOS19GSUVMRF9URVhUID0gXCJkeEh0bWxFZGl0b3ItZGlhbG9nTGlua1RleHRGaWVsZFwiO1xyXG52YXIgRElBTE9HX0xJTktfRklFTERfVEFSR0VUID0gXCJkeEh0bWxFZGl0b3ItZGlhbG9nTGlua1RhcmdldEZpZWxkXCI7XHJcbnZhciBESUFMT0dfTElOS19GSUVMRF9UQVJHRVRfQ0xBU1MgPSBcImR4LWZvcm1kaWFsb2ctZmllbGQtdGFyZ2V0XCI7XHJcbnZhciBESUFMT0dfSU1BR0VfRklFTERfVVJMID0gXCJkeEh0bWxFZGl0b3ItZGlhbG9nSW1hZ2VVcmxGaWVsZFwiO1xyXG52YXIgRElBTE9HX0lNQUdFX0ZJRUxEX0FMVCA9IFwiZHhIdG1sRWRpdG9yLWRpYWxvZ0ltYWdlQWx0RmllbGRcIjtcclxudmFyIERJQUxPR19JTUFHRV9GSUVMRF9XSURUSCA9IFwiZHhIdG1sRWRpdG9yLWRpYWxvZ0ltYWdlV2lkdGhGaWVsZFwiO1xyXG52YXIgRElBTE9HX0lNQUdFX0ZJRUxEX0hFSUdIVCA9IFwiZHhIdG1sRWRpdG9yLWRpYWxvZ0ltYWdlSGVpZ2h0RmllbGRcIjtcclxudmFyIERJQUxPR19UQUJMRV9GSUVMRF9DT0xVTU5TID0gXCJkeEh0bWxFZGl0b3ItZGlhbG9nSW5zZXJ0VGFibGVSb3dzRmllbGRcIjtcclxudmFyIERJQUxPR19UQUJMRV9GSUVMRF9ST1dTID0gXCJkeEh0bWxFZGl0b3ItZGlhbG9nSW5zZXJ0VGFibGVDb2x1bW5zRmllbGRcIjtcclxudmFyIElDT05fTUFQID0ge1xyXG4gICAgaW5zZXJ0SGVhZGVyUm93OiBcImhlYWRlclwiLFxyXG4gICAgY2xlYXI6IFwiY2xlYXJmb3JtYXRcIlxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0Rm9ybWF0SGFuZGxlcnMobW9kdWxlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNsZWFyOiBfcmVmID0+IHtcclxuICAgICAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxyXG4gICAgICAgICAgICB9ID0gX3JlZjtcclxuICAgICAgICAgICAgdmFyIHJhbmdlID0gbW9kdWxlLnF1aWxsLmdldFNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfZ2V0VG9vbGJhck1vZHVsZTtcclxuICAgICAgICAgICAgICAgIG1vZHVsZS5zYXZlVmFsdWVDaGFuZ2VFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgICAgICBtb2R1bGUucXVpbGwucmVtb3ZlRm9ybWF0KHJhbmdlKTtcclxuICAgICAgICAgICAgICAgIG51bGwgPT09IChfZ2V0VG9vbGJhck1vZHVsZSA9IGdldFRvb2xiYXJNb2R1bGUobW9kdWxlKSkgfHwgdm9pZCAwID09PSBfZ2V0VG9vbGJhck1vZHVsZSA/IHZvaWQgMCA6IF9nZXRUb29sYmFyTW9kdWxlLnVwZGF0ZUZvcm1hdFdpZGdldHMoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBwcmVwYXJlTGlua0hhbmRsZXIobW9kdWxlKSxcclxuICAgICAgICBpbWFnZTogcHJlcGFyZUltYWdlSGFuZGxlcihtb2R1bGUpLFxyXG4gICAgICAgIGNvbG9yOiBwcmVwYXJlQ29sb3JDbGlja0hhbmRsZXIobW9kdWxlLCBcImNvbG9yXCIpLFxyXG4gICAgICAgIGJhY2tncm91bmQ6IHByZXBhcmVDb2xvckNsaWNrSGFuZGxlcihtb2R1bGUsIFwiYmFja2dyb3VuZFwiKSxcclxuICAgICAgICBvcmRlcmVkTGlzdDogcHJlcGFyZVNob3J0Y3V0SGFuZGxlcihtb2R1bGUsIFwibGlzdFwiLCBcIm9yZGVyZWRcIiksXHJcbiAgICAgICAgYnVsbGV0TGlzdDogcHJlcGFyZVNob3J0Y3V0SGFuZGxlcihtb2R1bGUsIFwibGlzdFwiLCBcImJ1bGxldFwiKSxcclxuICAgICAgICBhbGlnbkxlZnQ6IHByZXBhcmVTaG9ydGN1dEhhbmRsZXIobW9kdWxlLCBcImFsaWduXCIsIFwibGVmdFwiKSxcclxuICAgICAgICBhbGlnbkNlbnRlcjogcHJlcGFyZVNob3J0Y3V0SGFuZGxlcihtb2R1bGUsIFwiYWxpZ25cIiwgXCJjZW50ZXJcIiksXHJcbiAgICAgICAgYWxpZ25SaWdodDogcHJlcGFyZVNob3J0Y3V0SGFuZGxlcihtb2R1bGUsIFwiYWxpZ25cIiwgXCJyaWdodFwiKSxcclxuICAgICAgICBhbGlnbkp1c3RpZnk6IHByZXBhcmVTaG9ydGN1dEhhbmRsZXIobW9kdWxlLCBcImFsaWduXCIsIFwianVzdGlmeVwiKSxcclxuICAgICAgICBjb2RlQmxvY2s6IGdldERlZmF1bHRDbGlja0hhbmRsZXIobW9kdWxlLCBcImNvZGUtYmxvY2tcIiksXHJcbiAgICAgICAgdW5kbzogX3JlZjIgPT4ge1xyXG4gICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XHJcbiAgICAgICAgICAgIH0gPSBfcmVmMjtcclxuICAgICAgICAgICAgbW9kdWxlLnNhdmVWYWx1ZUNoYW5nZUV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgbW9kdWxlLnF1aWxsLmhpc3RvcnkudW5kbygpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWRvOiBfcmVmMyA9PiB7XHJcbiAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcclxuICAgICAgICAgICAgfSA9IF9yZWYzO1xyXG4gICAgICAgICAgICBtb2R1bGUuc2F2ZVZhbHVlQ2hhbmdlRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICBtb2R1bGUucXVpbGwuaGlzdG9yeS5yZWRvKClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluY3JlYXNlSW5kZW50OiBfcmVmNCA9PiB7XHJcbiAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcclxuICAgICAgICAgICAgfSA9IF9yZWY0O1xyXG4gICAgICAgICAgICBhcHBseUZvcm1hdChtb2R1bGUsIFtcImluZGVudFwiLCBcIisxXCIsIFVTRVJfQUNUSU9OXSwgZXZlbnQpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWNyZWFzZUluZGVudDogX3JlZjUgPT4ge1xyXG4gICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XHJcbiAgICAgICAgICAgIH0gPSBfcmVmNTtcclxuICAgICAgICAgICAgYXBwbHlGb3JtYXQobW9kdWxlLCBbXCJpbmRlbnRcIiwgXCItMVwiLCBVU0VSX0FDVElPTl0sIGV2ZW50KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3VwZXJzY3JpcHQ6IHByZXBhcmVTaG9ydGN1dEhhbmRsZXIobW9kdWxlLCBcInNjcmlwdFwiLCBcInN1cGVyXCIpLFxyXG4gICAgICAgIHN1YnNjcmlwdDogcHJlcGFyZVNob3J0Y3V0SGFuZGxlcihtb2R1bGUsIFwic2NyaXB0XCIsIFwic3ViXCIpLFxyXG4gICAgICAgIGluc2VydFRhYmxlOiBwcmVwYXJlSW5zZXJ0VGFibGVIYW5kbGVyKG1vZHVsZSksXHJcbiAgICAgICAgaW5zZXJ0SGVhZGVyUm93OiBnZXRUYWJsZU9wZXJhdGlvbkhhbmRsZXIobW9kdWxlLnF1aWxsLCBcImluc2VydEhlYWRlclJvd1wiKSxcclxuICAgICAgICBpbnNlcnRSb3dBYm92ZTogZ2V0VGFibGVPcGVyYXRpb25IYW5kbGVyKG1vZHVsZS5xdWlsbCwgXCJpbnNlcnRSb3dBYm92ZVwiKSxcclxuICAgICAgICBpbnNlcnRSb3dCZWxvdzogZ2V0VGFibGVPcGVyYXRpb25IYW5kbGVyKG1vZHVsZS5xdWlsbCwgXCJpbnNlcnRSb3dCZWxvd1wiKSxcclxuICAgICAgICBpbnNlcnRDb2x1bW5MZWZ0OiBnZXRUYWJsZU9wZXJhdGlvbkhhbmRsZXIobW9kdWxlLnF1aWxsLCBcImluc2VydENvbHVtbkxlZnRcIiksXHJcbiAgICAgICAgaW5zZXJ0Q29sdW1uUmlnaHQ6IGdldFRhYmxlT3BlcmF0aW9uSGFuZGxlcihtb2R1bGUucXVpbGwsIFwiaW5zZXJ0Q29sdW1uUmlnaHRcIiksXHJcbiAgICAgICAgZGVsZXRlQ29sdW1uOiBnZXRUYWJsZU9wZXJhdGlvbkhhbmRsZXIobW9kdWxlLnF1aWxsLCBcImRlbGV0ZUNvbHVtblwiKSxcclxuICAgICAgICBkZWxldGVSb3c6IGdldFRhYmxlT3BlcmF0aW9uSGFuZGxlcihtb2R1bGUucXVpbGwsIFwiZGVsZXRlUm93XCIpLFxyXG4gICAgICAgIGRlbGV0ZVRhYmxlOiBnZXRUYWJsZU9wZXJhdGlvbkhhbmRsZXIobW9kdWxlLnF1aWxsLCBcImRlbGV0ZVRhYmxlXCIpLFxyXG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzOiBwcmVwYXJlU2hvd0Zvcm1Qcm9wZXJ0aWVzKG1vZHVsZSwgXCJjZWxsXCIpLFxyXG4gICAgICAgIHRhYmxlUHJvcGVydGllczogcHJlcGFyZVNob3dGb3JtUHJvcGVydGllcyhtb2R1bGUsIFwidGFibGVcIilcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVzZXRGb3JtRGlhbG9nT3B0aW9ucyhlZGl0b3JJbnN0YW5jZSwgX3JlZjYpIHtcclxuICAgIHZhciB7XHJcbiAgICAgICAgY29udGVudFRlbXBsYXRlOiBjb250ZW50VGVtcGxhdGUsXHJcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxyXG4gICAgICAgIG1pbkhlaWdodDogbWluSGVpZ2h0LFxyXG4gICAgICAgIG1pbldpZHRoOiBtaW5XaWR0aCxcclxuICAgICAgICBtYXhXaWR0aDogbWF4V2lkdGhcclxuICAgIH0gPSBfcmVmNjtcclxuICAgIGVkaXRvckluc3RhbmNlLmZvcm1EaWFsb2dPcHRpb24oe1xyXG4gICAgICAgIGNvbnRlbnRUZW1wbGF0ZTogY29udGVudFRlbXBsYXRlLFxyXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcclxuICAgICAgICBtaW5IZWlnaHQ6IG51bGwgIT09IG1pbkhlaWdodCAmJiB2b2lkIDAgIT09IG1pbkhlaWdodCA/IG1pbkhlaWdodCA6IDAsXHJcbiAgICAgICAgbWluV2lkdGg6IG51bGwgIT09IG1pbldpZHRoICYmIHZvaWQgMCAhPT0gbWluV2lkdGggPyBtaW5XaWR0aCA6IDAsXHJcbiAgICAgICAgbWF4V2lkdGg6IG51bGwgIT09IG1heFdpZHRoICYmIHZvaWQgMCAhPT0gbWF4V2lkdGggPyBtYXhXaWR0aCA6IFwibm9uZVwiXHJcbiAgICB9KVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcmVwYXJlU2hvd0Zvcm1Qcm9wZXJ0aWVzKG1vZHVsZSwgdHlwZSkge1xyXG4gICAgcmV0dXJuICRlbGVtZW50ID0+IHtcclxuICAgICAgICB2YXIgXyRlbGVtZW50LCBfbW9kdWxlJHF1aWxsJGdldE1vZHU7XHJcbiAgICAgICAgaWYgKCEobnVsbCAhPT0gKF8kZWxlbWVudCA9ICRlbGVtZW50KSAmJiB2b2lkIDAgIT09IF8kZWxlbWVudCAmJiBfJGVsZW1lbnQubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAkZWxlbWVudCA9ICQoZ2V0VGFyZ2V0VGFibGVOb2RlKG1vZHVsZSwgdHlwZSkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBbdGFibGVCbG90LCByb3dCbG90XSA9IG51bGwgIT09IChfbW9kdWxlJHF1aWxsJGdldE1vZHUgPSBtb2R1bGUucXVpbGwuZ2V0TW9kdWxlKFwidGFibGVcIikuZ2V0VGFibGUoKSkgJiYgdm9pZCAwICE9PSBfbW9kdWxlJHF1aWxsJGdldE1vZHUgPyBfbW9kdWxlJHF1aWxsJGdldE1vZHUgOiBbXTtcclxuICAgICAgICB2YXIgZm9ybWF0cyA9IG1vZHVsZS5xdWlsbC5nZXRGb3JtYXQobW9kdWxlLmVkaXRvckluc3RhbmNlLmdldFNlbGVjdGlvbih0cnVlKSk7XHJcbiAgICAgICAgdmFyIHRhYmxlUHJvcGVydGllc0Zvcm1Db25maWcgPSBnZXRGb3JtQ29uZmlnQ29uc3RydWN0b3IodHlwZSkobW9kdWxlLCB7XHJcbiAgICAgICAgICAgICRlbGVtZW50OiAkZWxlbWVudCxcclxuICAgICAgICAgICAgZm9ybWF0czogZm9ybWF0cyxcclxuICAgICAgICAgICAgdGFibGVCbG90OiB0YWJsZUJsb3QsXHJcbiAgICAgICAgICAgIHJvd0Jsb3Q6IHJvd0Jsb3RcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICBjb250ZW50VGVtcGxhdGU6IGNvbnRlbnRUZW1wbGF0ZSxcclxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxyXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IG1pbkhlaWdodCxcclxuICAgICAgICAgICAgbWluV2lkdGg6IG1pbldpZHRoLFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogbWF4V2lkdGhcclxuICAgICAgICB9ID0gbW9kdWxlLmVkaXRvckluc3RhbmNlLl9mb3JtRGlhbG9nLl9wb3B1cC5vcHRpb24oKTtcclxuICAgICAgICB2YXIgc2F2ZWRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBjb250ZW50VGVtcGxhdGU6IGNvbnRlbnRUZW1wbGF0ZSxcclxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxyXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IG1pbkhlaWdodCxcclxuICAgICAgICAgICAgbWluV2lkdGg6IG1pbldpZHRoLFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogbWF4V2lkdGhcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBmb3JtSW5zdGFuY2U7XHJcbiAgICAgICAgbW9kdWxlLmVkaXRvckluc3RhbmNlLmZvcm1EaWFsb2dPcHRpb24oe1xyXG4gICAgICAgICAgICBjb250ZW50VGVtcGxhdGU6IGNvbnRhaW5lciA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJGNvbnRlbnQgPSAkKFwiPGRpdj5cIikuYXBwZW5kVG8oY29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIHZhciAkZm9ybSA9ICQoXCI8ZGl2PlwiKS5hcHBlbmRUbygkY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICBtb2R1bGUuZWRpdG9ySW5zdGFuY2UuX2NyZWF0ZUNvbXBvbmVudCgkZm9ybSwgRm9ybSwgdGFibGVQcm9wZXJ0aWVzRm9ybUNvbmZpZy5mb3JtT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBtb2R1bGUuZWRpdG9ySW5zdGFuY2UuX2NyZWF0ZUNvbXBvbmVudCgkY29udGVudCwgU2Nyb2xsVmlldywge30pO1xyXG4gICAgICAgICAgICAgICAgZm9ybUluc3RhbmNlID0gJGZvcm0uZHhGb3JtKFwiaW5zdGFuY2VcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnRlbnRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGl0bGU6IGxvY2FsaXphdGlvbk1lc3NhZ2UuZm9ybWF0KFwiZHhIdG1sRWRpdG9yLVwiLmNvbmNhdCh0eXBlLCBcIlByb3BlcnRpZXNcIikpLFxyXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IE1JTl9IRUlHSFQsXHJcbiAgICAgICAgICAgIG1pbldpZHRoOiBNYXRoLm1pbig4MDAsIC45ICogZ2V0V2lkdGgoZ2V0V2luZG93KCkpIC0gMSksXHJcbiAgICAgICAgICAgIG1heFdpZHRoOiAuOSAqIGdldFdpZHRoKGdldFdpbmRvdygpKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbW9kdWxlLmVkaXRvckluc3RhbmNlLnNob3dGb3JtRGlhbG9nKCk7XHJcbiAgICAgICAgcHJvbWlzZS5kb25lKChmb3JtRGF0YSwgZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgbW9kdWxlLnNhdmVWYWx1ZUNoYW5nZUV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgdGFibGVQcm9wZXJ0aWVzRm9ybUNvbmZpZy5hcHBseUhhbmRsZXIoZm9ybUluc3RhbmNlKTtcclxuICAgICAgICAgICAgcmVzZXRGb3JtRGlhbG9nT3B0aW9ucyhtb2R1bGUuZWRpdG9ySW5zdGFuY2UsIHNhdmVkT3B0aW9ucylcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcm9taXNlLmZhaWwoKCkgPT4ge1xyXG4gICAgICAgICAgICBtb2R1bGUucXVpbGwuZm9jdXMoKTtcclxuICAgICAgICAgICAgcmVzZXRGb3JtRGlhbG9nT3B0aW9ucyhtb2R1bGUuZWRpdG9ySW5zdGFuY2UsIHNhdmVkT3B0aW9ucylcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseUZvcm1hdChtb2R1bGUsIGZvcm1hdEFyZ3MsIGV2ZW50KSB7XHJcbiAgICBtb2R1bGUuZWRpdG9ySW5zdGFuY2UuX3NhdmVWYWx1ZUNoYW5nZUV2ZW50KGV2ZW50KTtcclxuICAgIG1vZHVsZS5xdWlsbC5mb3JtYXQoLi4uZm9ybWF0QXJncylcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VGFyZ2V0VGFibGVOb2RlKG1vZHVsZSwgcGFydE5hbWUpIHtcclxuICAgIHZhciBjdXJyZW50U2VsZWN0aW9uUGFydHMgPSBtb2R1bGUucXVpbGwuZ2V0TW9kdWxlKFwidGFibGVcIikuZ2V0VGFibGUoKTtcclxuICAgIHJldHVybiBcInRhYmxlXCIgPT09IHBhcnROYW1lID8gY3VycmVudFNlbGVjdGlvblBhcnRzWzBdLmRvbU5vZGUgOiBjdXJyZW50U2VsZWN0aW9uUGFydHNbMl0uZG9tTm9kZVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcmVwYXJlTGlua0hhbmRsZXIobW9kdWxlKSB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIG1vZHVsZS5xdWlsbC5mb2N1cygpO1xyXG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBtb2R1bGUucXVpbGwuZ2V0U2VsZWN0aW9uKCk7XHJcbiAgICAgICAgdmFyIHNlbGVjdGlvbkhhc0VtYmVkQ29udGVudCA9IGhhc0VtYmVkQ29udGVudChtb2R1bGUsIHNlbGVjdGlvbik7XHJcbiAgICAgICAgdmFyIGZvcm1hdHMgPSBzZWxlY3Rpb24gPyBtb2R1bGUucXVpbGwuZ2V0Rm9ybWF0KCkgOiB7fTtcclxuICAgICAgICB2YXIgZm9ybURhdGEgPSB7XHJcbiAgICAgICAgICAgIGhyZWY6IGZvcm1hdHMubGluayB8fCBcIlwiLFxyXG4gICAgICAgICAgICB0ZXh0OiBzZWxlY3Rpb24gJiYgIXNlbGVjdGlvbkhhc0VtYmVkQ29udGVudCA/IG1vZHVsZS5xdWlsbC5nZXRUZXh0KHNlbGVjdGlvbikgOiBcIlwiLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb3JtYXRzLCBcInRhcmdldFwiKSA/ICEhZm9ybWF0cy50YXJnZXQgOiB0cnVlXHJcbiAgICAgICAgfTtcclxuICAgICAgICBtb2R1bGUuZWRpdG9ySW5zdGFuY2UuZm9ybURpYWxvZ09wdGlvbihcInRpdGxlXCIsIGxvY2FsaXphdGlvbk1lc3NhZ2UuZm9ybWF0KERJQUxPR19MSU5LX0NBUFRJT04pKTtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG1vZHVsZS5lZGl0b3JJbnN0YW5jZS5zaG93Rm9ybURpYWxvZyh7XHJcbiAgICAgICAgICAgIGZvcm1EYXRhOiBmb3JtRGF0YSxcclxuICAgICAgICAgICAgaXRlbXM6IGdldExpbmtGb3JtSXRlbXMobW9kdWxlLCBzZWxlY3Rpb24pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcHJvbWlzZS5kb25lKChmb3JtRGF0YSwgZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiAhc2VsZWN0aW9uSGFzRW1iZWRDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGZvcm1EYXRhLnRleHQgfHwgZm9ybURhdGEuaHJlZjtcclxuICAgICAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICB9ID0gc2VsZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgZm9ybURhdGEudGV4dCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIG1vZHVsZS5zYXZlVmFsdWVDaGFuZ2VFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgICAgICBsZW5ndGggJiYgbW9kdWxlLnF1aWxsLmRlbGV0ZVRleHQoaW5kZXgsIGxlbmd0aCwgU0lMRU5UX0FDVElPTik7XHJcbiAgICAgICAgICAgICAgICBtb2R1bGUucXVpbGwuaW5zZXJ0VGV4dChpbmRleCwgdGV4dCwgXCJsaW5rXCIsIGZvcm1EYXRhLCBVU0VSX0FDVElPTik7XHJcbiAgICAgICAgICAgICAgICBtb2R1bGUucXVpbGwuc2V0U2VsZWN0aW9uKGluZGV4ICsgdGV4dC5sZW5ndGgsIDAsIFVTRVJfQUNUSU9OKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9ybURhdGEudGV4dCA9ICFzZWxlY3Rpb24gJiYgIWZvcm1EYXRhLnRleHQgPyBmb3JtRGF0YS5ocmVmIDogZm9ybURhdGEudGV4dDtcclxuICAgICAgICAgICAgICAgIGFwcGx5Rm9ybWF0KG1vZHVsZSwgW1wibGlua1wiLCBmb3JtRGF0YSwgVVNFUl9BQ1RJT05dLCBldmVudClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByb21pc2UuZmFpbCgoKSA9PiB7XHJcbiAgICAgICAgICAgIG1vZHVsZS5xdWlsbC5mb2N1cygpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJlcGFyZUltYWdlSGFuZGxlcihtb2R1bGUpIHtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgdmFyIGZvcm1EYXRhID0gbW9kdWxlLnF1aWxsLmdldEZvcm1hdCgpO1xyXG4gICAgICAgIHZhciBpc1VwZGF0ZURpYWxvZyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb3JtRGF0YSwgXCJpbWFnZVNyY1wiKTtcclxuICAgICAgICB2YXIgZGVmYXVsdEluZGV4ID0gZGVmYXVsdFBhc3RlSW5kZXgobW9kdWxlKTtcclxuICAgICAgICBpZiAoaXNVcGRhdGVEaWFsb2cpIHtcclxuICAgICAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgICAgIGltYWdlU3JjOiBpbWFnZVNyY1xyXG4gICAgICAgICAgICB9ID0gbW9kdWxlLnF1aWxsLmdldEZvcm1hdChkZWZhdWx0SW5kZXggLSAxLCAxKTtcclxuICAgICAgICAgICAgZm9ybURhdGEuc3JjID0gZm9ybURhdGEuaW1hZ2VTcmM7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBmb3JtRGF0YS5pbWFnZVNyYztcclxuICAgICAgICAgICAgaWYgKCFpbWFnZVNyYyB8fCAwID09PSBkZWZhdWx0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIG1vZHVsZS5xdWlsbC5zZXRTZWxlY3Rpb24oZGVmYXVsdEluZGV4ICsgMSwgMCwgU0lMRU5UX0FDVElPTilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZm9ybWF0SW5kZXggPSBlbWJlZEZvcm1hdEluZGV4KG1vZHVsZSk7XHJcbiAgICAgICAgbW9kdWxlLmVkaXRvckluc3RhbmNlLmZvcm1EaWFsb2dPcHRpb24oXCJ0aXRsZVwiLCBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChESUFMT0dfSU1BR0VfQ0FQVElPTikpO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gbW9kdWxlLmVkaXRvckluc3RhbmNlLnNob3dGb3JtRGlhbG9nKHtcclxuICAgICAgICAgICAgZm9ybURhdGE6IGZvcm1EYXRhLFxyXG4gICAgICAgICAgICBpdGVtczogaW1hZ2VGb3JtSXRlbXMoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByb21pc2UuZG9uZSgoZm9ybURhdGEsIGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGRlZmF1bHRJbmRleDtcclxuICAgICAgICAgICAgbW9kdWxlLnNhdmVWYWx1ZUNoYW5nZUV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKGlzVXBkYXRlRGlhbG9nKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgbW9kdWxlLnF1aWxsLmRlbGV0ZVRleHQoaW5kZXgsIDEsIFNJTEVOVF9BQ1RJT04pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbW9kdWxlLnF1aWxsLmluc2VydEVtYmVkKGluZGV4LCBcImV4dGVuZGVkSW1hZ2VcIiwgZm9ybURhdGEsIFVTRVJfQUNUSU9OKTtcclxuICAgICAgICAgICAgbW9kdWxlLnF1aWxsLnNldFNlbGVjdGlvbihpbmRleCArIDEsIDAsIFVTRVJfQUNUSU9OKVxyXG4gICAgICAgIH0pLmFsd2F5cygoKSA9PiB7XHJcbiAgICAgICAgICAgIG1vZHVsZS5xdWlsbC5mb2N1cygpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TGlua0Zvcm1JdGVtcyhtb2R1bGUsIHNlbGVjdGlvbikge1xyXG4gICAgcmV0dXJuIFt7XHJcbiAgICAgICAgZGF0YUZpZWxkOiBcImhyZWZcIixcclxuICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICB0ZXh0OiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChESUFMT0dfTElOS19GSUVMRF9VUkwpXHJcbiAgICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICAgIGRhdGFGaWVsZDogXCJ0ZXh0XCIsXHJcbiAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgdGV4dDogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoRElBTE9HX0xJTktfRklFTERfVEVYVClcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpc2libGU6ICFoYXNFbWJlZENvbnRlbnQobW9kdWxlLCBzZWxlY3Rpb24pXHJcbiAgICB9LCB7XHJcbiAgICAgICAgZGF0YUZpZWxkOiBcInRhcmdldFwiLFxyXG4gICAgICAgIGVkaXRvclR5cGU6IFwiZHhDaGVja0JveFwiLFxyXG4gICAgICAgIGVkaXRvck9wdGlvbnM6IHtcclxuICAgICAgICAgICAgdGV4dDogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoRElBTE9HX0xJTktfRklFTERfVEFSR0VUKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3NzQ2xhc3M6IERJQUxPR19MSU5LX0ZJRUxEX1RBUkdFVF9DTEFTUyxcclxuICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH1dXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVtYmVkRm9ybWF0SW5kZXgobW9kdWxlKSB7XHJcbiAgICB2YXIgc2VsZWN0aW9uID0gbW9kdWxlLnF1aWxsLmdldFNlbGVjdGlvbigpO1xyXG4gICAgaWYgKHNlbGVjdGlvbikge1xyXG4gICAgICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24uaW5kZXhcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uLmluZGV4IC0gMVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5xdWlsbC5nZXRMZW5ndGgoKVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0UGFzdGVJbmRleChtb2R1bGUpIHtcclxuICAgIHZhciBfc2VsZWN0aW9uJGluZGV4O1xyXG4gICAgdmFyIHNlbGVjdGlvbiA9IG1vZHVsZS5xdWlsbC5nZXRTZWxlY3Rpb24oKTtcclxuICAgIHJldHVybiBudWxsICE9PSAoX3NlbGVjdGlvbiRpbmRleCA9IG51bGwgPT09IHNlbGVjdGlvbiB8fCB2b2lkIDAgPT09IHNlbGVjdGlvbiA/IHZvaWQgMCA6IHNlbGVjdGlvbi5pbmRleCkgJiYgdm9pZCAwICE9PSBfc2VsZWN0aW9uJGluZGV4ID8gX3NlbGVjdGlvbiRpbmRleCA6IG1vZHVsZS5xdWlsbC5nZXRMZW5ndGgoKVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbWFnZUZvcm1JdGVtcygpIHtcclxuICAgIHJldHVybiBbe1xyXG4gICAgICAgIGRhdGFGaWVsZDogXCJzcmNcIixcclxuICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICB0ZXh0OiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChESUFMT0dfSU1BR0VfRklFTERfVVJMKVxyXG4gICAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAgICBkYXRhRmllbGQ6IFwid2lkdGhcIixcclxuICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICB0ZXh0OiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChESUFMT0dfSU1BR0VfRklFTERfV0lEVEgpXHJcbiAgICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICAgIGRhdGFGaWVsZDogXCJoZWlnaHRcIixcclxuICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICB0ZXh0OiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChESUFMT0dfSU1BR0VfRklFTERfSEVJR0hUKVxyXG4gICAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAgICBkYXRhRmllbGQ6IFwiYWx0XCIsXHJcbiAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgdGV4dDogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoRElBTE9HX0lNQUdFX0ZJRUxEX0FMVClcclxuICAgICAgICB9XHJcbiAgICB9XVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcmVwYXJlQ29sb3JDbGlja0hhbmRsZXIobW9kdWxlLCBuYW1lKSB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHZhciBmb3JtRGF0YSA9IG1vZHVsZS5xdWlsbC5nZXRGb3JtYXQoKTtcclxuICAgICAgICB2YXIgY2FwdGlvbiA9IFwiY29sb3JcIiA9PT0gbmFtZSA/IERJQUxPR19DT0xPUl9DQVBUSU9OIDogRElBTE9HX0JBQ0tHUk9VTkRfQ0FQVElPTjtcclxuICAgICAgICBtb2R1bGUuZWRpdG9ySW5zdGFuY2UuZm9ybURpYWxvZ09wdGlvbihcInRpdGxlXCIsIGxvY2FsaXphdGlvbk1lc3NhZ2UuZm9ybWF0KGNhcHRpb24pKTtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG1vZHVsZS5lZGl0b3JJbnN0YW5jZS5zaG93Rm9ybURpYWxvZyh7XHJcbiAgICAgICAgICAgIGZvcm1EYXRhOiBmb3JtRGF0YSxcclxuICAgICAgICAgICAgaXRlbXM6IFt7XHJcbiAgICAgICAgICAgICAgICBkYXRhRmllbGQ6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICBlZGl0b3JUeXBlOiBcImR4Q29sb3JWaWV3XCIsXHJcbiAgICAgICAgICAgICAgICBlZGl0b3JPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNTdGF0ZUVuYWJsZWQ6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByb21pc2UuZG9uZSgoZm9ybURhdGEsIGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGFwcGx5Rm9ybWF0KG1vZHVsZSwgW25hbWUsIGZvcm1EYXRhW25hbWVdLCBVU0VSX0FDVElPTl0sIGV2ZW50KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByb21pc2UuZmFpbCgoKSA9PiB7XHJcbiAgICAgICAgICAgIG1vZHVsZS5xdWlsbC5mb2N1cygpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcHJlcGFyZVNob3J0Y3V0SGFuZGxlcihtb2R1bGUsIG5hbWUsIHNob3J0Y3V0VmFsdWUpIHtcclxuICAgIHJldHVybiBfcmVmNyA9PiB7XHJcbiAgICAgICAgdmFyIF9nZXRUb29sYmFyTW9kdWxlMjtcclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICBldmVudDogZXZlbnRcclxuICAgICAgICB9ID0gX3JlZjc7XHJcbiAgICAgICAgdmFyIGZvcm1hdHMgPSBtb2R1bGUucXVpbGwuZ2V0Rm9ybWF0KCk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZm9ybWF0c1tuYW1lXSA9PT0gc2hvcnRjdXRWYWx1ZSA/IGZhbHNlIDogc2hvcnRjdXRWYWx1ZTtcclxuICAgICAgICBhcHBseUZvcm1hdChtb2R1bGUsIFtuYW1lLCB2YWx1ZSwgVVNFUl9BQ1RJT05dLCBldmVudCk7XHJcbiAgICAgICAgbnVsbCA9PT0gKF9nZXRUb29sYmFyTW9kdWxlMiA9IGdldFRvb2xiYXJNb2R1bGUobW9kdWxlKSkgfHwgdm9pZCAwID09PSBfZ2V0VG9vbGJhck1vZHVsZTIgPyB2b2lkIDAgOiBfZ2V0VG9vbGJhck1vZHVsZTIudXBkYXRlRm9ybWF0V2lkZ2V0cyh0cnVlKVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUb29sYmFyTW9kdWxlKG1vZHVsZSkge1xyXG4gICAgcmV0dXJuIG1vZHVsZS5fdXBkYXRlRm9ybWF0V2lkZ2V0ID8gbW9kdWxlIDogbW9kdWxlLnF1aWxsLmdldE1vZHVsZShcInRvb2xiYXJcIilcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGVmYXVsdENsaWNrSGFuZGxlcihtb2R1bGUsIG5hbWUpIHtcclxuICAgIHJldHVybiBfcmVmOCA9PiB7XHJcbiAgICAgICAgdmFyIF9nZXRUb29sYmFyTW9kdWxlMztcclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICBldmVudDogZXZlbnRcclxuICAgICAgICB9ID0gX3JlZjg7XHJcbiAgICAgICAgdmFyIGZvcm1hdHMgPSBtb2R1bGUucXVpbGwuZ2V0Rm9ybWF0KCk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZm9ybWF0c1tuYW1lXTtcclxuICAgICAgICB2YXIgbmV3VmFsdWUgPSAhKGlzQm9vbGVhbih2YWx1ZSkgPyB2YWx1ZSA6IGlzRGVmaW5lZCh2YWx1ZSkpO1xyXG4gICAgICAgIGFwcGx5Rm9ybWF0KG1vZHVsZSwgW25hbWUsIG5ld1ZhbHVlLCBVU0VSX0FDVElPTl0sIGV2ZW50KTtcclxuICAgICAgICBudWxsID09PSAoX2dldFRvb2xiYXJNb2R1bGUzID0gZ2V0VG9vbGJhck1vZHVsZShtb2R1bGUpKSB8fCB2b2lkIDAgPT09IF9nZXRUb29sYmFyTW9kdWxlMyA/IHZvaWQgMCA6IF9nZXRUb29sYmFyTW9kdWxlMy5fdXBkYXRlRm9ybWF0V2lkZ2V0KG5hbWUsIG5ld1ZhbHVlLCBmb3JtYXRzKVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRUYWJsZUZvcm1JdGVtcygpIHtcclxuICAgIHJldHVybiBbe1xyXG4gICAgICAgIGRhdGFGaWVsZDogXCJjb2x1bW5zXCIsXHJcbiAgICAgICAgZWRpdG9yVHlwZTogXCJkeE51bWJlckJveFwiLFxyXG4gICAgICAgIGVkaXRvck9wdGlvbnM6IHtcclxuICAgICAgICAgICAgbWluOiAxXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICB0ZXh0OiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChESUFMT0dfVEFCTEVfRklFTERfQ09MVU1OUylcclxuICAgICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgICAgZGF0YUZpZWxkOiBcInJvd3NcIixcclxuICAgICAgICBlZGl0b3JUeXBlOiBcImR4TnVtYmVyQm94XCIsXHJcbiAgICAgICAgZWRpdG9yT3B0aW9uczoge1xyXG4gICAgICAgICAgICBtaW46IDFcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgIHRleHQ6IGxvY2FsaXphdGlvbk1lc3NhZ2UuZm9ybWF0KERJQUxPR19UQUJMRV9GSUVMRF9ST1dTKVxyXG4gICAgICAgIH1cclxuICAgIH1dXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByZXBhcmVJbnNlcnRUYWJsZUhhbmRsZXIobW9kdWxlKSB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHZhciBmb3JtYXRzID0gbW9kdWxlLnF1aWxsLmdldEZvcm1hdCgpO1xyXG4gICAgICAgIHZhciBpc1RhYmxlRm9jdXNlZCA9IG1vZHVsZS5fdGFibGVGb3JtYXRzLnNvbWUoZm9ybWF0ID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb3JtYXRzLCBmb3JtYXQpKTtcclxuICAgICAgICBpZiAoaXNUYWJsZUZvY3VzZWQpIHtcclxuICAgICAgICAgICAgbW9kdWxlLnF1aWxsLmZvY3VzKCk7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICBtb2R1bGUuZWRpdG9ySW5zdGFuY2UuZm9ybURpYWxvZ09wdGlvbihcInRpdGxlXCIsIGxvY2FsaXphdGlvbk1lc3NhZ2UuZm9ybWF0KERJQUxPR19UQUJMRV9DQVBUSU9OKSk7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBtb2R1bGUuZWRpdG9ySW5zdGFuY2Uuc2hvd0Zvcm1EaWFsb2coe1xyXG4gICAgICAgICAgICBmb3JtRGF0YToge1xyXG4gICAgICAgICAgICAgICAgcm93czogMSxcclxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IDFcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaXRlbXM6IGluc2VydFRhYmxlRm9ybUl0ZW1zKClcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcm9taXNlLmRvbmUoKGZvcm1EYXRhLCBldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBtb2R1bGUucXVpbGwuZm9jdXMoKTtcclxuICAgICAgICAgICAgdmFyIHRhYmxlID0gbW9kdWxlLnF1aWxsLmdldE1vZHVsZShcInRhYmxlXCIpO1xyXG4gICAgICAgICAgICBpZiAodGFibGUpIHtcclxuICAgICAgICAgICAgICAgIG1vZHVsZS5zYXZlVmFsdWVDaGFuZ2VFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IGNvbHVtbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgcm93czogcm93c1xyXG4gICAgICAgICAgICAgICAgfSA9IGZvcm1EYXRhO1xyXG4gICAgICAgICAgICAgICAgdGFibGUuaW5zZXJ0VGFibGUoY29sdW1ucywgcm93cylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLmFsd2F5cygoKSA9PiB7XHJcbiAgICAgICAgICAgIG1vZHVsZS5xdWlsbC5mb2N1cygpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VGFibGVQcm9wZXJ0aWVzRm9ybUNvbmZpZyhtb2R1bGUsIF9yZWY5KSB7XHJcbiAgICB2YXIge1xyXG4gICAgICAgICRlbGVtZW50OiAkZWxlbWVudCxcclxuICAgICAgICBmb3JtYXRzOiBmb3JtYXRzLFxyXG4gICAgICAgIHRhYmxlQmxvdDogdGFibGVCbG90XHJcbiAgICB9ID0gX3JlZjk7XHJcbiAgICB2YXIgd2luZG93ID0gZ2V0V2luZG93KCk7XHJcbiAgICB2YXIgYWxpZ25tZW50RWRpdG9ySW5zdGFuY2U7XHJcbiAgICB2YXIgYm9yZGVyQ29sb3JFZGl0b3JJbnN0YW5jZTtcclxuICAgIHZhciBiYWNrZ3JvdW5kQ29sb3JFZGl0b3JJbnN0YW5jZTtcclxuICAgIHZhciAkdGFibGUgPSAkZWxlbWVudDtcclxuICAgIHZhciBlZGl0b3JJbnN0YW5jZSA9IG1vZHVsZS5lZGl0b3JJbnN0YW5jZTtcclxuICAgIHZhciBzdGFydFRhYmxlV2lkdGggPSBpc0RlZmluZWQoZm9ybWF0cy50YWJsZVdpZHRoKSA/IHBhcnNlSW50KGZvcm1hdHMudGFibGVXaWR0aCkgOiBnZXRPdXRlcldpZHRoKCR0YWJsZSk7XHJcbiAgICB2YXIgdGFibGVTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSgkdGFibGUuZ2V0KDApKTtcclxuICAgIHZhciBzdGFydFRleHRBbGlnbiA9IFwic3RhcnRcIiA9PT0gdGFibGVTdHlsZXMudGV4dEFsaWduID8gXCJsZWZ0XCIgOiB0YWJsZVN0eWxlcy50ZXh0QWxpZ247XHJcbiAgICB2YXIgZm9ybU9wdGlvbnMgPSB7XHJcbiAgICAgICAgY29sQ291bnQ6IDIsXHJcbiAgICAgICAgZm9ybURhdGE6IHtcclxuICAgICAgICAgICAgd2lkdGg6IHN0YXJ0VGFibGVXaWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBpc0RlZmluZWQoZm9ybWF0cy50YWJsZUhlaWdodCkgPyBwYXJzZUludChmb3JtYXRzLnRhYmxlSGVpZ2h0KSA6IGdldE91dGVySGVpZ2h0KCR0YWJsZSksXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZm9ybWF0cy50YWJsZUJhY2tncm91bmRDb2xvciB8fCB0YWJsZVN0eWxlcy5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIGJvcmRlclN0eWxlOiBmb3JtYXRzLnRhYmxlQm9yZGVyU3R5bGUgfHwgdGFibGVTdHlsZXMuYm9yZGVyVG9wU3R5bGUsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBmb3JtYXRzLnRhYmxlQm9yZGVyQ29sb3IgfHwgdGFibGVTdHlsZXMuYm9yZGVyVG9wQ29sb3IsXHJcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiBwYXJzZUludChpc0RlZmluZWQoZm9ybWF0cy50YWJsZUJvcmRlcldpZHRoKSA/IGZvcm1hdHMudGFibGVCb3JkZXJXaWR0aCA6IHRhYmxlU3R5bGVzLmJvcmRlclRvcFdpZHRoKSxcclxuICAgICAgICAgICAgYWxpZ25tZW50OiBmb3JtYXRzLnRhYmxlQWxpZ24gfHwgc3RhcnRUZXh0QWxpZ25cclxuICAgICAgICB9LFxyXG4gICAgICAgIGl0ZW1zOiBbe1xyXG4gICAgICAgICAgICBpdGVtVHlwZTogXCJncm91cFwiLFxyXG4gICAgICAgICAgICBjYXB0aW9uOiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci1ib3JkZXJcIiksXHJcbiAgICAgICAgICAgIGNvbENvdW50QnlTY3JlZW46IHtcclxuICAgICAgICAgICAgICAgIHhzOiAyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbENvdW50OiAyLFxyXG4gICAgICAgICAgICBpdGVtczogW3tcclxuICAgICAgICAgICAgICAgIGRhdGFGaWVsZDogXCJib3JkZXJTdHlsZVwiLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci1zdHlsZVwiKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVkaXRvclR5cGU6IFwiZHhTZWxlY3RCb3hcIixcclxuICAgICAgICAgICAgICAgIGVkaXRvck9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtczogQk9SREVSX1NUWUxFUyxcclxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJTZWxlY3Qgc3R5bGVcIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICBkYXRhRmllbGQ6IFwiYm9yZGVyV2lkdGhcIixcclxuICAgICAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItYm9yZGVyV2lkdGhcIilcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlZGl0b3JPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IGxvY2FsaXphdGlvbk1lc3NhZ2UuZm9ybWF0KFwiZHhIdG1sRWRpdG9yLXBpeGVsc1wiKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICBpdGVtVHlwZTogXCJzaW1wbGVcIixcclxuICAgICAgICAgICAgICAgIGRhdGFGaWVsZDogXCJib3JkZXJDb2xvclwiLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci1ib3JkZXJDb2xvclwiKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNvbFNwYW46IDIsXHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyICRjb250ZW50ID0gJChcIjxkaXY+XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvckluc3RhbmNlLl9jcmVhdGVDb21wb25lbnQoJGNvbnRlbnQsIENvbG9yQm94LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRBbHBoYUNoYW5uZWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlLmNvbXBvbmVudC5vcHRpb24oXCJmb3JtRGF0YVwiKS5ib3JkZXJDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Jbml0aWFsaXplZDogZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvckVkaXRvckluc3RhbmNlID0gZS5jb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY29udGVudFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XVxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgICAgaXRlbVR5cGU6IFwiZ3JvdXBcIixcclxuICAgICAgICAgICAgY2FwdGlvbjogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItZGltZW5zaW9uc1wiKSxcclxuICAgICAgICAgICAgY29sQ291bnRCeVNjcmVlbjoge1xyXG4gICAgICAgICAgICAgICAgeHM6IDJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29sQ291bnQ6IDIsXHJcbiAgICAgICAgICAgIGl0ZW1zOiBbe1xyXG4gICAgICAgICAgICAgICAgZGF0YUZpZWxkOiBcIndpZHRoXCIsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxvY2FsaXphdGlvbk1lc3NhZ2UuZm9ybWF0KFwiZHhIdG1sRWRpdG9yLXdpZHRoXCIpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWRpdG9yT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbjogMCxcclxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItcGl4ZWxzXCIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIGRhdGFGaWVsZDogXCJoZWlnaHRcIixcclxuICAgICAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItaGVpZ2h0XCIpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWRpdG9yT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbjogMCxcclxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItcGl4ZWxzXCIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1dXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICBpdGVtVHlwZTogXCJncm91cFwiLFxyXG4gICAgICAgICAgICBjYXB0aW9uOiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci10YWJsZUJhY2tncm91bmRcIiksXHJcbiAgICAgICAgICAgIGl0ZW1zOiBbe1xyXG4gICAgICAgICAgICAgICAgaXRlbVR5cGU6IFwic2ltcGxlXCIsXHJcbiAgICAgICAgICAgICAgICBkYXRhRmllbGQ6IFwiYmFja2dyb3VuZENvbG9yXCIsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxvY2FsaXphdGlvbk1lc3NhZ2UuZm9ybWF0KFwiZHhIdG1sRWRpdG9yLWJvcmRlckNvbG9yXCIpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciAkY29udGVudCA9ICQoXCI8ZGl2PlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBlZGl0b3JJbnN0YW5jZS5fY3JlYXRlQ29tcG9uZW50KCRjb250ZW50LCBDb2xvckJveCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0QWxwaGFDaGFubmVsOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZS5jb21wb25lbnQub3B0aW9uKFwiZm9ybURhdGFcIikuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkluaXRpYWxpemVkOiBlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvckVkaXRvckluc3RhbmNlID0gZS5jb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY29udGVudFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XVxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgICAgaXRlbVR5cGU6IFwiZ3JvdXBcIixcclxuICAgICAgICAgICAgY2FwdGlvbjogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItYWxpZ25tZW50XCIpLFxyXG4gICAgICAgICAgICBpdGVtczogW3tcclxuICAgICAgICAgICAgICAgIGl0ZW1UeXBlOiBcInNpbXBsZVwiLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci1ob3Jpem9udGFsXCIpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgJGNvbnRlbnQgPSAkKFwiPGRpdj5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9ySW5zdGFuY2UuX2NyZWF0ZUNvbXBvbmVudCgkY29udGVudCwgQnV0dG9uR3JvdXAsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJsZWZ0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiBcImFsaWdubGVmdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogXCJhbGlnbmNlbnRlclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcInJpZ2h0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiBcImFsaWducmlnaHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJqdXN0aWZ5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiBcImFsaWduanVzdGlmeVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlFeHByOiBcInZhbHVlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbUtleXM6IFtzdGFydFRleHRBbGlnbl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5pdGlhbGl6ZWQ6IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50RWRpdG9ySW5zdGFuY2UgPSBlLmNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjb250ZW50XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1dXHJcbiAgICAgICAgfV0sXHJcbiAgICAgICAgc2hvd0NvbG9uQWZ0ZXJMYWJlbDogdHJ1ZSxcclxuICAgICAgICBsYWJlbExvY2F0aW9uOiBcInRvcFwiLFxyXG4gICAgICAgIG1pbkNvbFdpZHRoOiA0MDBcclxuICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZvcm1PcHRpb25zOiBmb3JtT3B0aW9ucyxcclxuICAgICAgICBhcHBseUhhbmRsZXI6IGZvcm1JbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBmb3JtRGF0YSA9IGZvcm1JbnN0YW5jZS5vcHRpb24oXCJmb3JtRGF0YVwiKTtcclxuICAgICAgICAgICAgdmFyIG5ld1dpZHRoID0gZm9ybURhdGEud2lkdGggPT09IHN0YXJ0VGFibGVXaWR0aCA/IHZvaWQgMCA6IGZvcm1EYXRhLndpZHRoO1xyXG4gICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gZm9ybURhdGEuaGVpZ2h0O1xyXG4gICAgICAgICAgICBhcHBseVRhYmxlRGltZW5zaW9uQ2hhbmdlcyhtb2R1bGUsIHtcclxuICAgICAgICAgICAgICAgICR0YWJsZTogJHRhYmxlLFxyXG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0OiBuZXdIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBuZXdXaWR0aDogbmV3V2lkdGgsXHJcbiAgICAgICAgICAgICAgICB0YWJsZUJsb3Q6IHRhYmxlQmxvdFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbW9kdWxlLmVkaXRvckluc3RhbmNlLmZvcm1hdChcInRhYmxlQm9yZGVyU3R5bGVcIiwgZm9ybURhdGEuYm9yZGVyU3R5bGUpO1xyXG4gICAgICAgICAgICBtb2R1bGUuZWRpdG9ySW5zdGFuY2UuZm9ybWF0KFwidGFibGVCb3JkZXJXaWR0aFwiLCBmb3JtRGF0YS5ib3JkZXJXaWR0aCArIFwicHhcIik7XHJcbiAgICAgICAgICAgIG1vZHVsZS5lZGl0b3JJbnN0YW5jZS5mb3JtYXQoXCJ0YWJsZUJvcmRlckNvbG9yXCIsIGJvcmRlckNvbG9yRWRpdG9ySW5zdGFuY2Uub3B0aW9uKFwidmFsdWVcIikpO1xyXG4gICAgICAgICAgICBtb2R1bGUuZWRpdG9ySW5zdGFuY2UuZm9ybWF0KFwidGFibGVCYWNrZ3JvdW5kQ29sb3JcIiwgYmFja2dyb3VuZENvbG9yRWRpdG9ySW5zdGFuY2Uub3B0aW9uKFwidmFsdWVcIikpO1xyXG4gICAgICAgICAgICBtb2R1bGUuZWRpdG9ySW5zdGFuY2UuZm9ybWF0KFwidGFibGVUZXh0QWxpZ25cIiwgYWxpZ25tZW50RWRpdG9ySW5zdGFuY2Uub3B0aW9uKFwic2VsZWN0ZWRJdGVtS2V5c1wiKVswXSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENlbGxQcm9wZXJ0aWVzRm9ybUNvbmZpZyhtb2R1bGUsIF9yZWYxMCkge1xyXG4gICAgdmFyIHtcclxuICAgICAgICAkZWxlbWVudDogJGVsZW1lbnQsXHJcbiAgICAgICAgZm9ybWF0czogZm9ybWF0cyxcclxuICAgICAgICB0YWJsZUJsb3Q6IHRhYmxlQmxvdCxcclxuICAgICAgICByb3dCbG90OiByb3dCbG90XHJcbiAgICB9ID0gX3JlZjEwO1xyXG4gICAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdygpO1xyXG4gICAgdmFyIGFsaWdubWVudEVkaXRvckluc3RhbmNlO1xyXG4gICAgdmFyIHZlcnRpY2FsQWxpZ25tZW50RWRpdG9ySW5zdGFuY2U7XHJcbiAgICB2YXIgYm9yZGVyQ29sb3JFZGl0b3JJbnN0YW5jZTtcclxuICAgIHZhciBiYWNrZ3JvdW5kQ29sb3JFZGl0b3JJbnN0YW5jZTtcclxuICAgIHZhciAkY2VsbCA9ICRlbGVtZW50O1xyXG4gICAgdmFyIHN0YXJ0Q2VsbFdpZHRoID0gaXNEZWZpbmVkKGZvcm1hdHMuY2VsbFdpZHRoKSA/IHBhcnNlSW50KGZvcm1hdHMuY2VsbFdpZHRoKSA6IGdldE91dGVyV2lkdGgoJGNlbGwpO1xyXG4gICAgdmFyIGVkaXRvckluc3RhbmNlID0gbW9kdWxlLmVkaXRvckluc3RhbmNlO1xyXG4gICAgdmFyIGNlbGxTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSgkY2VsbC5nZXQoMCkpO1xyXG4gICAgdmFyIHN0YXJ0VGV4dEFsaWduID0gXCJzdGFydFwiID09PSBjZWxsU3R5bGVzLnRleHRBbGlnbiA/IFwibGVmdFwiIDogY2VsbFN0eWxlcy50ZXh0QWxpZ247XHJcbiAgICB2YXIgZm9ybU9wdGlvbnMgPSB7XHJcbiAgICAgICAgY29sQ291bnQ6IDIsXHJcbiAgICAgICAgZm9ybURhdGE6IHtcclxuICAgICAgICAgICAgd2lkdGg6IHN0YXJ0Q2VsbFdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGlzRGVmaW5lZChmb3JtYXRzLmNlbGxIZWlnaHQpID8gcGFyc2VJbnQoZm9ybWF0cy5jZWxsSGVpZ2h0KSA6IGdldE91dGVySGVpZ2h0KCRjZWxsKSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBmb3JtYXRzLmNlbGxCYWNrZ3JvdW5kQ29sb3IgfHwgY2VsbFN0eWxlcy5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIGJvcmRlclN0eWxlOiBmb3JtYXRzLmNlbGxCb3JkZXJTdHlsZSB8fCBjZWxsU3R5bGVzLmJvcmRlclRvcFN0eWxlLFxyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogZm9ybWF0cy5jZWxsQm9yZGVyQ29sb3IgfHwgY2VsbFN0eWxlcy5ib3JkZXJUb3BDb2xvcixcclxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IHBhcnNlSW50KGlzRGVmaW5lZChmb3JtYXRzLmNlbGxCb3JkZXJXaWR0aCkgPyBmb3JtYXRzLmNlbGxCb3JkZXJXaWR0aCA6IGNlbGxTdHlsZXMuYm9yZGVyVG9wV2lkdGgpLFxyXG4gICAgICAgICAgICBhbGlnbm1lbnQ6IGZvcm1hdHMuY2VsbFRleHRBbGlnbiB8fCBzdGFydFRleHRBbGlnbixcclxuICAgICAgICAgICAgdmVydGljYWxBbGlnbm1lbnQ6IGZvcm1hdHMuY2VsbFZlcnRpY2FsQWxpZ24gfHwgY2VsbFN0eWxlcy52ZXJ0aWNhbEFsaWduLFxyXG4gICAgICAgICAgICB2ZXJ0aWNhbFBhZGRpbmc6IHBhcnNlSW50KGlzRGVmaW5lZChmb3JtYXRzLmNlbGxQYWRkaW5nVG9wKSA/IGZvcm1hdHMuY2VsbFBhZGRpbmdUb3AgOiBjZWxsU3R5bGVzLnBhZGRpbmdUb3ApLFxyXG4gICAgICAgICAgICBob3Jpem9udGFsUGFkZGluZzogcGFyc2VJbnQoaXNEZWZpbmVkKGZvcm1hdHMuY2VsbFBhZGRpbmdMZWZ0KSA/IGZvcm1hdHMuY2VsbFBhZGRpbmdMZWZ0IDogY2VsbFN0eWxlcy5wYWRkaW5nTGVmdClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGl0ZW1zOiBbe1xyXG4gICAgICAgICAgICBpdGVtVHlwZTogXCJncm91cFwiLFxyXG4gICAgICAgICAgICBjYXB0aW9uOiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci1ib3JkZXJcIiksXHJcbiAgICAgICAgICAgIGNvbENvdW50QnlTY3JlZW46IHtcclxuICAgICAgICAgICAgICAgIHhzOiAyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbENvdW50OiAyLFxyXG4gICAgICAgICAgICBpdGVtczogW3tcclxuICAgICAgICAgICAgICAgIGRhdGFGaWVsZDogXCJib3JkZXJTdHlsZVwiLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci1zdHlsZVwiKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVkaXRvclR5cGU6IFwiZHhTZWxlY3RCb3hcIixcclxuICAgICAgICAgICAgICAgIGVkaXRvck9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtczogQk9SREVSX1NUWUxFU1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICBkYXRhRmllbGQ6IFwiYm9yZGVyV2lkdGhcIixcclxuICAgICAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItYm9yZGVyV2lkdGhcIilcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlZGl0b3JPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IGxvY2FsaXphdGlvbk1lc3NhZ2UuZm9ybWF0KFwiZHhIdG1sRWRpdG9yLXBpeGVsc1wiKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICBpdGVtVHlwZTogXCJzaW1wbGVcIixcclxuICAgICAgICAgICAgICAgIGRhdGFGaWVsZDogXCJib3JkZXJDb2xvclwiLFxyXG4gICAgICAgICAgICAgICAgY29sU3BhbjogMixcclxuICAgICAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItYm9yZGVyQ29sb3JcIilcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyICRjb250ZW50ID0gJChcIjxkaXY+XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvckluc3RhbmNlLl9jcmVhdGVDb21wb25lbnQoJGNvbnRlbnQsIENvbG9yQm94LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRBbHBoYUNoYW5uZWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlLmNvbXBvbmVudC5vcHRpb24oXCJmb3JtRGF0YVwiKS5ib3JkZXJDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Jbml0aWFsaXplZDogZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvckVkaXRvckluc3RhbmNlID0gZS5jb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY29udGVudFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XVxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgICAgaXRlbVR5cGU6IFwiZ3JvdXBcIixcclxuICAgICAgICAgICAgY2FwdGlvbjogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItZGltZW5zaW9uc1wiKSxcclxuICAgICAgICAgICAgY29sQ291bnQ6IDIsXHJcbiAgICAgICAgICAgIGNvbENvdW50QnlTY3JlZW46IHtcclxuICAgICAgICAgICAgICAgIHhzOiAyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGl0ZW1zOiBbe1xyXG4gICAgICAgICAgICAgICAgZGF0YUZpZWxkOiBcIndpZHRoXCIsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxvY2FsaXphdGlvbk1lc3NhZ2UuZm9ybWF0KFwiZHhIdG1sRWRpdG9yLXdpZHRoXCIpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWRpdG9yT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbjogMCxcclxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItcGl4ZWxzXCIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIGRhdGFGaWVsZDogXCJoZWlnaHRcIixcclxuICAgICAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItaGVpZ2h0XCIpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWRpdG9yT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbjogMCxcclxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItcGl4ZWxzXCIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIGRhdGFGaWVsZDogXCJ2ZXJ0aWNhbFBhZGRpbmdcIixcclxuICAgICAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItcGFkZGluZ1ZlcnRpY2FsXCIpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWRpdG9yT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci1waXhlbHNcIilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci1wYWRkaW5nSG9yaXpvbnRhbFwiKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRhdGFGaWVsZDogXCJob3Jpem9udGFsUGFkZGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgZWRpdG9yT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci1waXhlbHNcIilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfV1cclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIGl0ZW1UeXBlOiBcImdyb3VwXCIsXHJcbiAgICAgICAgICAgIGNhcHRpb246IGxvY2FsaXphdGlvbk1lc3NhZ2UuZm9ybWF0KFwiZHhIdG1sRWRpdG9yLXRhYmxlQmFja2dyb3VuZFwiKSxcclxuICAgICAgICAgICAgaXRlbXM6IFt7XHJcbiAgICAgICAgICAgICAgICBpdGVtVHlwZTogXCJzaW1wbGVcIixcclxuICAgICAgICAgICAgICAgIGRhdGFGaWVsZDogXCJiYWNrZ3JvdW5kQ29sb3JcIixcclxuICAgICAgICAgICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbG9jYWxpemF0aW9uTWVzc2FnZS5mb3JtYXQoXCJkeEh0bWxFZGl0b3ItYm9yZGVyQ29sb3JcIilcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyICRjb250ZW50ID0gJChcIjxkaXY+XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvckluc3RhbmNlLl9jcmVhdGVDb21wb25lbnQoJGNvbnRlbnQsIENvbG9yQm94LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRBbHBoYUNoYW5uZWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlLmNvbXBvbmVudC5vcHRpb24oXCJmb3JtRGF0YVwiKS5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5pdGlhbGl6ZWQ6IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yRWRpdG9ySW5zdGFuY2UgPSBlLmNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjb250ZW50XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1dXHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICBpdGVtVHlwZTogXCJncm91cFwiLFxyXG4gICAgICAgICAgICBjYXB0aW9uOiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci1hbGlnbm1lbnRcIiksXHJcbiAgICAgICAgICAgIGNvbENvdW50OiAyLFxyXG4gICAgICAgICAgICBpdGVtczogW3tcclxuICAgICAgICAgICAgICAgIGl0ZW1UeXBlOiBcInNpbXBsZVwiLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci1ob3Jpem9udGFsXCIpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgJGNvbnRlbnQgPSAkKFwiPGRpdj5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9ySW5zdGFuY2UuX2NyZWF0ZUNvbXBvbmVudCgkY29udGVudCwgQnV0dG9uR3JvdXAsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJsZWZ0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiBcImFsaWdubGVmdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogXCJhbGlnbmNlbnRlclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcInJpZ2h0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiBcImFsaWducmlnaHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJqdXN0aWZ5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiBcImFsaWduanVzdGlmeVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlFeHByOiBcInZhbHVlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbUtleXM6IFtzdGFydFRleHRBbGlnbl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5pdGlhbGl6ZWQ6IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50RWRpdG9ySW5zdGFuY2UgPSBlLmNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjb250ZW50XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1UeXBlOiBcInNpbXBsZVwiLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsb2NhbGl6YXRpb25NZXNzYWdlLmZvcm1hdChcImR4SHRtbEVkaXRvci12ZXJ0aWNhbFwiKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyICRjb250ZW50ID0gJChcIjxkaXY+XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvckluc3RhbmNlLl9jcmVhdGVDb21wb25lbnQoJGNvbnRlbnQsIEJ1dHRvbkdyb3VwLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwidG9wXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiBcInZlcnRpY2FsYWxpZ250b3BcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJtaWRkbGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246IFwidmVydGljYWxhbGlnbmNlbnRlclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcImJvdHRvbVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogXCJ2ZXJ0aWNhbGFsaWduYm90dG9tXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleUV4cHI6IFwidmFsdWVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJdGVtS2V5czogW2NlbGxTdHlsZXMudmVydGljYWxBbGlnbl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uSW5pdGlhbGl6ZWQ6IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbm1lbnRFZGl0b3JJbnN0YW5jZSA9IGUuY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGNvbnRlbnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfV1cclxuICAgICAgICB9XSxcclxuICAgICAgICBzaG93Q29sb25BZnRlckxhYmVsOiB0cnVlLFxyXG4gICAgICAgIGxhYmVsTG9jYXRpb246IFwidG9wXCIsXHJcbiAgICAgICAgbWluQ29sV2lkdGg6IDQwMFxyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZm9ybU9wdGlvbnM6IGZvcm1PcHRpb25zLFxyXG4gICAgICAgIGFwcGx5SGFuZGxlcjogZm9ybUluc3RhbmNlID0+IHtcclxuICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gZm9ybUluc3RhbmNlLm9wdGlvbihcImZvcm1EYXRhXCIpO1xyXG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBmb3JtRGF0YS53aWR0aCA9PT0gcGFyc2VJbnQoc3RhcnRDZWxsV2lkdGgpID8gdm9pZCAwIDogZm9ybURhdGEud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSBmb3JtRGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGFwcGx5Q2VsbERpbWVuc2lvbkNoYW5nZXMobW9kdWxlLCB7XHJcbiAgICAgICAgICAgICAgICAkY2VsbDogJGNlbGwsXHJcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQ6IG5ld0hlaWdodCxcclxuICAgICAgICAgICAgICAgIG5ld1dpZHRoOiBuZXdXaWR0aCxcclxuICAgICAgICAgICAgICAgIHRhYmxlQmxvdDogdGFibGVCbG90LFxyXG4gICAgICAgICAgICAgICAgcm93QmxvdDogcm93QmxvdFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbW9kdWxlLmVkaXRvckluc3RhbmNlLmZvcm1hdChcImNlbGxCb3JkZXJXaWR0aFwiLCBmb3JtRGF0YS5ib3JkZXJXaWR0aCArIFwicHhcIik7XHJcbiAgICAgICAgICAgIG1vZHVsZS5lZGl0b3JJbnN0YW5jZS5mb3JtYXQoXCJjZWxsQm9yZGVyQ29sb3JcIiwgYm9yZGVyQ29sb3JFZGl0b3JJbnN0YW5jZS5vcHRpb24oXCJ2YWx1ZVwiKSk7XHJcbiAgICAgICAgICAgIG1vZHVsZS5lZGl0b3JJbnN0YW5jZS5mb3JtYXQoXCJjZWxsQm9yZGVyU3R5bGVcIiwgZm9ybURhdGEuYm9yZGVyU3R5bGUpO1xyXG4gICAgICAgICAgICBtb2R1bGUuZWRpdG9ySW5zdGFuY2UuZm9ybWF0KFwiY2VsbEJhY2tncm91bmRDb2xvclwiLCBiYWNrZ3JvdW5kQ29sb3JFZGl0b3JJbnN0YW5jZS5vcHRpb24oXCJ2YWx1ZVwiKSk7XHJcbiAgICAgICAgICAgIG1vZHVsZS5lZGl0b3JJbnN0YW5jZS5mb3JtYXQoXCJjZWxsVGV4dEFsaWduXCIsIGFsaWdubWVudEVkaXRvckluc3RhbmNlLm9wdGlvbihcInNlbGVjdGVkSXRlbUtleXNcIilbMF0pO1xyXG4gICAgICAgICAgICBtb2R1bGUuZWRpdG9ySW5zdGFuY2UuZm9ybWF0KFwiY2VsbFZlcnRpY2FsQWxpZ25cIiwgdmVydGljYWxBbGlnbm1lbnRFZGl0b3JJbnN0YW5jZS5vcHRpb24oXCJzZWxlY3RlZEl0ZW1LZXlzXCIpWzBdKTtcclxuICAgICAgICAgICAgbW9kdWxlLmVkaXRvckluc3RhbmNlLmZvcm1hdChcImNlbGxQYWRkaW5nTGVmdFwiLCBmb3JtRGF0YS5ob3Jpem9udGFsUGFkZGluZyArIFwicHhcIik7XHJcbiAgICAgICAgICAgIG1vZHVsZS5lZGl0b3JJbnN0YW5jZS5mb3JtYXQoXCJjZWxsUGFkZGluZ1JpZ2h0XCIsIGZvcm1EYXRhLmhvcml6b250YWxQYWRkaW5nICsgXCJweFwiKTtcclxuICAgICAgICAgICAgbW9kdWxlLmVkaXRvckluc3RhbmNlLmZvcm1hdChcImNlbGxQYWRkaW5nVG9wXCIsIGZvcm1EYXRhLnZlcnRpY2FsUGFkZGluZyArIFwicHhcIik7XHJcbiAgICAgICAgICAgIG1vZHVsZS5lZGl0b3JJbnN0YW5jZS5mb3JtYXQoXCJjZWxsUGFkZGluZ0JvdHRvbVwiLCBmb3JtRGF0YS52ZXJ0aWNhbFBhZGRpbmcgKyBcInB4XCIpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRGb3JtQ29uZmlnQ29uc3RydWN0b3IodHlwZSkge1xyXG4gICAgcmV0dXJuIFwiY2VsbFwiID09PSB0eXBlID8gZ2V0Q2VsbFByb3BlcnRpZXNGb3JtQ29uZmlnIDogZ2V0VGFibGVQcm9wZXJ0aWVzRm9ybUNvbmZpZ1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRhYmxlRGltZW5zaW9uQ2hhbmdlcyhtb2R1bGUsIF9yZWYxMSkge1xyXG4gICAgdmFyIHtcclxuICAgICAgICAkdGFibGU6ICR0YWJsZSxcclxuICAgICAgICBuZXdIZWlnaHQ6IG5ld0hlaWdodCxcclxuICAgICAgICBuZXdXaWR0aDogbmV3V2lkdGgsXHJcbiAgICAgICAgdGFibGVCbG90OiB0YWJsZUJsb3RcclxuICAgIH0gPSBfcmVmMTE7XHJcbiAgICBpZiAoaXNEZWZpbmVkKG5ld1dpZHRoKSkge1xyXG4gICAgICAgIHZhciBhdXRvV2lkdGhDb2x1bW5zID0gZ2V0QXV0b1NpemVkRWxlbWVudHMoJHRhYmxlKTtcclxuICAgICAgICBpZiAoYXV0b1dpZHRoQ29sdW1ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIG1vZHVsZS5lZGl0b3JJbnN0YW5jZS5mb3JtYXQoXCJ0YWJsZVdpZHRoXCIsIG5ld1dpZHRoICsgXCJweFwiKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciAkY29sdW1ucyA9IGdldENvbHVtbkVsZW1lbnRzKCR0YWJsZSk7XHJcbiAgICAgICAgICAgIHZhciBvbGRUYWJsZVdpZHRoID0gZ2V0T3V0ZXJXaWR0aCgkdGFibGUpO1xyXG4gICAgICAgICAgICB1bmZpeFRhYmxlV2lkdGgoJHRhYmxlLCB7XHJcbiAgICAgICAgICAgICAgICB0YWJsZUJsb3Q6IHRhYmxlQmxvdFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZWFjaCgkY29sdW1ucywgKGksIGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3RWxlbWVudFdpZHRoID0gbmV3V2lkdGggLyBvbGRUYWJsZVdpZHRoICogZ2V0T3V0ZXJXaWR0aCgkZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgJGxpbmVFbGVtZW50cyA9IGdldExpbmVFbGVtZW50cygkdGFibGUsICRlbGVtZW50LmluZGV4KCksIFwiaG9yaXpvbnRhbFwiKTtcclxuICAgICAgICAgICAgICAgIHNldExpbmVFbGVtZW50c0Zvcm1hdChtb2R1bGUsIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogJGxpbmVFbGVtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogXCJ3aWR0aFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdFbGVtZW50V2lkdGhcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGF1dG9IZWlnaHRSb3dzID0gZ2V0QXV0b1NpemVkRWxlbWVudHMoJHRhYmxlLCBcInZlcnRpY2FsXCIpO1xyXG4gICAgaWYgKChudWxsID09PSBhdXRvSGVpZ2h0Um93cyB8fCB2b2lkIDAgPT09IGF1dG9IZWlnaHRSb3dzID8gdm9pZCAwIDogYXV0b0hlaWdodFJvd3MubGVuZ3RoKSA+IDApIHtcclxuICAgICAgICB0YWJsZUJsb3QuZm9ybWF0KFwidGFibGVIZWlnaHRcIiwgbmV3SGVpZ2h0ICsgXCJweFwiKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgJHJvd3MgPSBnZXRSb3dFbGVtZW50cygkdGFibGUpO1xyXG4gICAgICAgIHZhciBvbGRUYWJsZUhlaWdodCA9IGdldE91dGVySGVpZ2h0KCR0YWJsZSk7XHJcbiAgICAgICAgZWFjaCgkcm93cywgKGksIGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KTtcclxuICAgICAgICAgICAgdmFyIG5ld0VsZW1lbnRIZWlnaHQgPSBuZXdIZWlnaHQgLyBvbGRUYWJsZUhlaWdodCAqIGdldE91dGVySGVpZ2h0KCRlbGVtZW50KTtcclxuICAgICAgICAgICAgdmFyICRsaW5lRWxlbWVudHMgPSBnZXRMaW5lRWxlbWVudHMoJHRhYmxlLCBpLCBcInZlcnRpY2FsXCIpO1xyXG4gICAgICAgICAgICBzZXRMaW5lRWxlbWVudHNGb3JtYXQobW9kdWxlLCB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50czogJGxpbmVFbGVtZW50cyxcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBcImhlaWdodFwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ld0VsZW1lbnRIZWlnaHRcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseUNlbGxEaW1lbnNpb25DaGFuZ2VzKG1vZHVsZSwgX3JlZjEyKSB7XHJcbiAgICB2YXIge1xyXG4gICAgICAgICRjZWxsOiAkY2VsbCxcclxuICAgICAgICBuZXdIZWlnaHQ6IG5ld0hlaWdodCxcclxuICAgICAgICBuZXdXaWR0aDogbmV3V2lkdGgsXHJcbiAgICAgICAgdGFibGVCbG90OiB0YWJsZUJsb3QsXHJcbiAgICAgICAgcm93QmxvdDogcm93QmxvdFxyXG4gICAgfSA9IF9yZWYxMjtcclxuICAgIHZhciAkdGFibGUgPSAkKCRjZWxsLmNsb3Nlc3QoXCJ0YWJsZVwiKSk7XHJcbiAgICBpZiAoaXNEZWZpbmVkKG5ld1dpZHRoKSkge1xyXG4gICAgICAgIHZhciBpbmRleCA9ICQoJGNlbGwpLmluZGV4KCk7XHJcbiAgICAgICAgdmFyICR2ZXJ0aWNhbENlbGxzID0gZ2V0TGluZUVsZW1lbnRzKCR0YWJsZSwgaW5kZXgpO1xyXG4gICAgICAgIHZhciB3aWR0aERpZmYgPSBuZXdXaWR0aCAtIGdldE91dGVyV2lkdGgoJGNlbGwpO1xyXG4gICAgICAgIHZhciB0YWJsZVdpZHRoID0gZ2V0T3V0ZXJXaWR0aCgkdGFibGUpO1xyXG4gICAgICAgIGlmIChuZXdXaWR0aCA+IHRhYmxlV2lkdGgpIHtcclxuICAgICAgICAgICAgdW5maXhUYWJsZVdpZHRoKCR0YWJsZSwge1xyXG4gICAgICAgICAgICAgICAgdGFibGVCbG90OiB0YWJsZUJsb3RcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0TGluZUVsZW1lbnRzRm9ybWF0KG1vZHVsZSwge1xyXG4gICAgICAgICAgICBlbGVtZW50czogJHZlcnRpY2FsQ2VsbHMsXHJcbiAgICAgICAgICAgIHByb3BlcnR5OiBcIndpZHRoXCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXdXaWR0aFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciAkbmV4dENvbHVtbkNlbGwgPSAkY2VsbC5uZXh0KCk7XHJcbiAgICAgICAgdmFyIHNob3VsZFVwZGF0ZU5lYXJlc3RDb2x1bW5XaWR0aCA9IDAgPT09IGdldEF1dG9TaXplZEVsZW1lbnRzKCR0YWJsZSkubGVuZ3RoO1xyXG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVOZWFyZXN0Q29sdW1uV2lkdGgpIHtcclxuICAgICAgICAgICAgdW5maXhUYWJsZVdpZHRoKCR0YWJsZSwge1xyXG4gICAgICAgICAgICAgICAgdGFibGVCbG90OiB0YWJsZUJsb3RcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICgxID09PSAkbmV4dENvbHVtbkNlbGwubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAkdmVydGljYWxDZWxscyA9IGdldExpbmVFbGVtZW50cygkdGFibGUsIGluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENvbHVtbldpZHRoID0gZ2V0T3V0ZXJXaWR0aCgkdmVydGljYWxDZWxscy5lcSgwKSkgLSB3aWR0aERpZmY7XHJcbiAgICAgICAgICAgICAgICBzZXRMaW5lRWxlbWVudHNGb3JtYXQobW9kdWxlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6ICR2ZXJ0aWNhbENlbGxzLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBcIndpZHRoXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IE1hdGgubWF4KG5leHRDb2x1bW5XaWR0aCwgMClcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJHByZXZDb2x1bW5DZWxsID0gJGNlbGwucHJldigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKDEgPT09ICRwcmV2Q29sdW1uQ2VsbC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAkdmVydGljYWxDZWxscyA9IGdldExpbmVFbGVtZW50cygkdGFibGUsIGluZGV4IC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZDb2x1bW5XaWR0aCA9IGdldE91dGVyV2lkdGgoJHZlcnRpY2FsQ2VsbHMuZXEoMCkpIC0gd2lkdGhEaWZmO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldExpbmVFbGVtZW50c0Zvcm1hdChtb2R1bGUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6ICR2ZXJ0aWNhbENlbGxzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogXCJ3aWR0aFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogTWF0aC5tYXgocHJldkNvbHVtbldpZHRoLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByb3dCbG90LmNoaWxkcmVuLmZvckVhY2gocm93Q2VsbCA9PiB7XHJcbiAgICAgICAgcm93Q2VsbC5mb3JtYXQoXCJjZWxsSGVpZ2h0XCIsIG5ld0hlaWdodCArIFwicHhcIilcclxuICAgIH0pO1xyXG4gICAgdmFyIGF1dG9IZWlnaHRSb3dzID0gZ2V0QXV0b1NpemVkRWxlbWVudHMoJHRhYmxlLCBcInZlcnRpY2FsXCIpO1xyXG4gICAgaWYgKDAgPT09IGF1dG9IZWlnaHRSb3dzLmxlbmd0aCkge1xyXG4gICAgICAgICR0YWJsZS5jc3MoXCJoZWlnaHRcIiwgXCJhdXRvXCIpXHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IHtcclxuICAgIGdldEZvcm1hdEhhbmRsZXJzLFxyXG4gICAgZ2V0RGVmYXVsdENsaWNrSGFuZGxlcixcclxuICAgIElDT05fTUFQLFxyXG4gICAgYXBwbHlGb3JtYXRcclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/ui/html_editor/utils/toolbar_helper.js\n");

/***/ })

}]);