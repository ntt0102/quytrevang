(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[11],{

/***/ "./node_modules/devextreme-vue/chart.js":
/*!**********************************************!*\
  !*** ./node_modules/devextreme-vue/chart.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * devextreme-vue\n * Version: 21.2.7\n * Build date: Mon Apr 11 2022\n *\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\n *\n * This software may be modified and distributed under the terms\n * of the MIT license. See the LICENSE file in the root of the project for details.\n *\n * https://github.com/DevExpress/devextreme-vue\n */\n\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DxLegendTitle = exports.DxLegend = exports.DxLabel = exports.DxImage = exports.DxHoverStyle = exports.DxHorizontalLineLabel = exports.DxHorizontalLine = exports.DxHeight = exports.DxHatching = exports.DxGrid = exports.DxFormat = exports.DxFont = exports.DxExport = exports.DxDragBoxStyle = exports.DxDataPrepareSettings = exports.DxCrosshair = exports.DxConstantLineStyle = exports.DxConstantLineLabel = exports.DxConstantLine = exports.DxConnector = exports.DxCommonSeriesSettingsSelectionStyle = exports.DxCommonSeriesSettingsLabel = exports.DxCommonSeriesSettingsHoverStyle = exports.DxCommonSeriesSettings = exports.DxCommonPaneSettings = exports.DxCommonAxisSettingsTitle = exports.DxCommonAxisSettingsLabel = exports.DxCommonAxisSettingsConstantLineStyleLabel = exports.DxCommonAxisSettingsConstantLineStyle = exports.DxCommonAxisSettings = exports.DxCommonAnnotationSettings = exports.DxChartTitleSubtitle = exports.DxChartTitle = exports.DxBreakStyle = exports.DxBreak = exports.DxBorder = exports.DxAxisTitle = exports.DxAxisLabel = exports.DxAxisConstantLineStyleLabel = exports.DxAxisConstantLineStyle = exports.DxArgumentFormat = exports.DxArgumentAxis = exports.DxAnnotationImage = exports.DxAnnotationBorder = exports.DxAnnotation = exports.DxAnimation = exports.DxAggregationInterval = exports.DxAggregation = exports.DxAdaptiveLayout = exports.DxChart = void 0;\nexports.DxZoomAndPan = exports.DxWidth = exports.DxWholeRange = exports.DxVisualRange = exports.DxVerticalLine = exports.DxValueErrorBar = exports.DxValueAxis = exports.DxUrl = exports.DxTooltipBorder = exports.DxTooltip = exports.DxTitle = exports.DxTickInterval = exports.DxTick = exports.DxSubtitle = exports.DxStripStyleLabel = exports.DxStripStyle = exports.DxStripLabel = exports.DxStrip = exports.DxSize = exports.DxShadow = exports.DxSeriesTemplate = exports.DxSeriesBorder = exports.DxSeries = exports.DxSelectionStyle = exports.DxScrollBar = exports.DxReduction = exports.DxPointSelectionStyle = exports.DxPointImage = exports.DxPointHoverStyle = exports.DxPointBorder = exports.DxPoint = exports.DxPaneBorder = exports.DxPane = exports.DxMinVisualRangeLength = exports.DxMinorTickInterval = exports.DxMinorTick = exports.DxMinorGrid = exports.DxMargin = exports.DxLoadingIndicator = exports.DxLength = exports.DxLegendTitleSubtitle = void 0;\nvar chart_1 = __importDefault(__webpack_require__(/*! devextreme/viz/chart */ \"./node_modules/devextreme/esm/viz/chart.js\"));\nvar index_1 = __webpack_require__(/*! ./core/index */ \"./node_modules/devextreme-vue/core/index.js\");\nvar index_2 = __webpack_require__(/*! ./core/index */ \"./node_modules/devextreme-vue/core/index.js\");\nvar DxChart = index_1.createComponent({\n    props: {\n        adaptiveLayout: Object,\n        adjustOnZoom: Boolean,\n        animation: [Boolean, Object],\n        annotations: Array,\n        argumentAxis: Object,\n        autoHidePointMarkers: Boolean,\n        barGroupPadding: Number,\n        barGroupWidth: Number,\n        commonAnnotationSettings: Object,\n        commonAxisSettings: Object,\n        commonPaneSettings: Object,\n        commonSeriesSettings: Object,\n        containerBackgroundColor: String,\n        crosshair: Object,\n        customizeAnnotation: Function,\n        customizeLabel: Function,\n        customizePoint: Function,\n        dataPrepareSettings: Object,\n        dataSource: [Array, Object, String],\n        defaultPane: String,\n        disabled: Boolean,\n        elementAttr: Object,\n        export: Object,\n        legend: Object,\n        loadingIndicator: Object,\n        margin: Object,\n        maxBubbleSize: Number,\n        minBubbleSize: Number,\n        negativesAsZeroes: Boolean,\n        onArgumentAxisClick: Function,\n        onDisposing: Function,\n        onDone: Function,\n        onDrawn: Function,\n        onExported: Function,\n        onExporting: Function,\n        onFileSaving: Function,\n        onIncidentOccurred: Function,\n        onInitialized: Function,\n        onLegendClick: Function,\n        onOptionChanged: Function,\n        onPointClick: Function,\n        onPointHoverChanged: Function,\n        onPointSelectionChanged: Function,\n        onSeriesClick: Function,\n        onSeriesHoverChanged: Function,\n        onSeriesSelectionChanged: Function,\n        onTooltipHidden: Function,\n        onTooltipShown: Function,\n        onZoomEnd: Function,\n        onZoomStart: Function,\n        palette: [Array, String],\n        paletteExtensionMode: String,\n        panes: [Array, Object],\n        pathModified: Boolean,\n        pointSelectionMode: String,\n        redrawOnResize: Boolean,\n        resizePanesOnZoom: Boolean,\n        resolveLabelOverlapping: String,\n        rotated: Boolean,\n        rtlEnabled: Boolean,\n        scrollBar: Object,\n        series: [Array, Object],\n        seriesSelectionMode: String,\n        seriesTemplate: Object,\n        size: Object,\n        stickyHovering: Boolean,\n        synchronizeMultiAxes: Boolean,\n        theme: String,\n        title: [Object, String],\n        tooltip: Object,\n        valueAxis: [Array, Object],\n        zoomAndPan: Object\n    },\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:adaptiveLayout\": null,\n        \"update:adjustOnZoom\": null,\n        \"update:animation\": null,\n        \"update:annotations\": null,\n        \"update:argumentAxis\": null,\n        \"update:autoHidePointMarkers\": null,\n        \"update:barGroupPadding\": null,\n        \"update:barGroupWidth\": null,\n        \"update:commonAnnotationSettings\": null,\n        \"update:commonAxisSettings\": null,\n        \"update:commonPaneSettings\": null,\n        \"update:commonSeriesSettings\": null,\n        \"update:containerBackgroundColor\": null,\n        \"update:crosshair\": null,\n        \"update:customizeAnnotation\": null,\n        \"update:customizeLabel\": null,\n        \"update:customizePoint\": null,\n        \"update:dataPrepareSettings\": null,\n        \"update:dataSource\": null,\n        \"update:defaultPane\": null,\n        \"update:disabled\": null,\n        \"update:elementAttr\": null,\n        \"update:export\": null,\n        \"update:legend\": null,\n        \"update:loadingIndicator\": null,\n        \"update:margin\": null,\n        \"update:maxBubbleSize\": null,\n        \"update:minBubbleSize\": null,\n        \"update:negativesAsZeroes\": null,\n        \"update:onArgumentAxisClick\": null,\n        \"update:onDisposing\": null,\n        \"update:onDone\": null,\n        \"update:onDrawn\": null,\n        \"update:onExported\": null,\n        \"update:onExporting\": null,\n        \"update:onFileSaving\": null,\n        \"update:onIncidentOccurred\": null,\n        \"update:onInitialized\": null,\n        \"update:onLegendClick\": null,\n        \"update:onOptionChanged\": null,\n        \"update:onPointClick\": null,\n        \"update:onPointHoverChanged\": null,\n        \"update:onPointSelectionChanged\": null,\n        \"update:onSeriesClick\": null,\n        \"update:onSeriesHoverChanged\": null,\n        \"update:onSeriesSelectionChanged\": null,\n        \"update:onTooltipHidden\": null,\n        \"update:onTooltipShown\": null,\n        \"update:onZoomEnd\": null,\n        \"update:onZoomStart\": null,\n        \"update:palette\": null,\n        \"update:paletteExtensionMode\": null,\n        \"update:panes\": null,\n        \"update:pathModified\": null,\n        \"update:pointSelectionMode\": null,\n        \"update:redrawOnResize\": null,\n        \"update:resizePanesOnZoom\": null,\n        \"update:resolveLabelOverlapping\": null,\n        \"update:rotated\": null,\n        \"update:rtlEnabled\": null,\n        \"update:scrollBar\": null,\n        \"update:series\": null,\n        \"update:seriesSelectionMode\": null,\n        \"update:seriesTemplate\": null,\n        \"update:size\": null,\n        \"update:stickyHovering\": null,\n        \"update:synchronizeMultiAxes\": null,\n        \"update:theme\": null,\n        \"update:title\": null,\n        \"update:tooltip\": null,\n        \"update:valueAxis\": null,\n        \"update:zoomAndPan\": null,\n    },\n    computed: {\n        instance: function () {\n            return this.$_instance;\n        }\n    },\n    beforeCreate: function () {\n        this.$_WidgetClass = chart_1.default;\n        this.$_hasAsyncTemplate = true;\n        this.$_expectedChildren = {\n            adaptiveLayout: { isCollectionItem: false, optionName: \"adaptiveLayout\" },\n            animation: { isCollectionItem: false, optionName: \"animation\" },\n            annotation: { isCollectionItem: true, optionName: \"annotations\" },\n            argumentAxis: { isCollectionItem: false, optionName: \"argumentAxis\" },\n            chartTitle: { isCollectionItem: false, optionName: \"title\" },\n            commonAnnotationSettings: { isCollectionItem: false, optionName: \"commonAnnotationSettings\" },\n            commonAxisSettings: { isCollectionItem: false, optionName: \"commonAxisSettings\" },\n            commonPaneSettings: { isCollectionItem: false, optionName: \"commonPaneSettings\" },\n            commonSeriesSettings: { isCollectionItem: false, optionName: \"commonSeriesSettings\" },\n            crosshair: { isCollectionItem: false, optionName: \"crosshair\" },\n            dataPrepareSettings: { isCollectionItem: false, optionName: \"dataPrepareSettings\" },\n            export: { isCollectionItem: false, optionName: \"export\" },\n            legend: { isCollectionItem: false, optionName: \"legend\" },\n            loadingIndicator: { isCollectionItem: false, optionName: \"loadingIndicator\" },\n            margin: { isCollectionItem: false, optionName: \"margin\" },\n            pane: { isCollectionItem: true, optionName: \"panes\" },\n            scrollBar: { isCollectionItem: false, optionName: \"scrollBar\" },\n            series: { isCollectionItem: true, optionName: \"series\" },\n            seriesTemplate: { isCollectionItem: false, optionName: \"seriesTemplate\" },\n            size: { isCollectionItem: false, optionName: \"size\" },\n            title: { isCollectionItem: false, optionName: \"title\" },\n            tooltip: { isCollectionItem: false, optionName: \"tooltip\" },\n            valueAxis: { isCollectionItem: true, optionName: \"valueAxis\" },\n            zoomAndPan: { isCollectionItem: false, optionName: \"zoomAndPan\" }\n        };\n    }\n});\nexports.DxChart = DxChart;\nvar DxAdaptiveLayout = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:height\": null,\n        \"update:keepLabels\": null,\n        \"update:width\": null,\n    },\n    props: {\n        height: Number,\n        keepLabels: Boolean,\n        width: Number\n    }\n});\nexports.DxAdaptiveLayout = DxAdaptiveLayout;\nDxAdaptiveLayout.$_optionName = \"adaptiveLayout\";\nvar DxAggregation = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:calculate\": null,\n        \"update:enabled\": null,\n        \"update:method\": null,\n    },\n    props: {\n        calculate: Function,\n        enabled: Boolean,\n        method: String\n    }\n});\nexports.DxAggregation = DxAggregation;\nDxAggregation.$_optionName = \"aggregation\";\nvar DxAggregationInterval = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:days\": null,\n        \"update:hours\": null,\n        \"update:milliseconds\": null,\n        \"update:minutes\": null,\n        \"update:months\": null,\n        \"update:quarters\": null,\n        \"update:seconds\": null,\n        \"update:weeks\": null,\n        \"update:years\": null,\n    },\n    props: {\n        days: Number,\n        hours: Number,\n        milliseconds: Number,\n        minutes: Number,\n        months: Number,\n        quarters: Number,\n        seconds: Number,\n        weeks: Number,\n        years: Number\n    }\n});\nexports.DxAggregationInterval = DxAggregationInterval;\nDxAggregationInterval.$_optionName = \"aggregationInterval\";\nvar DxAnimation = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:duration\": null,\n        \"update:easing\": null,\n        \"update:enabled\": null,\n        \"update:maxPointCountSupported\": null,\n    },\n    props: {\n        duration: Number,\n        easing: String,\n        enabled: Boolean,\n        maxPointCountSupported: Number\n    }\n});\nexports.DxAnimation = DxAnimation;\nDxAnimation.$_optionName = \"animation\";\nvar DxAnnotation = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:allowDragging\": null,\n        \"update:argument\": null,\n        \"update:arrowLength\": null,\n        \"update:arrowWidth\": null,\n        \"update:axis\": null,\n        \"update:border\": null,\n        \"update:color\": null,\n        \"update:customizeTooltip\": null,\n        \"update:data\": null,\n        \"update:description\": null,\n        \"update:font\": null,\n        \"update:height\": null,\n        \"update:image\": null,\n        \"update:name\": null,\n        \"update:offsetX\": null,\n        \"update:offsetY\": null,\n        \"update:opacity\": null,\n        \"update:paddingLeftRight\": null,\n        \"update:paddingTopBottom\": null,\n        \"update:series\": null,\n        \"update:shadow\": null,\n        \"update:template\": null,\n        \"update:text\": null,\n        \"update:textOverflow\": null,\n        \"update:tooltipEnabled\": null,\n        \"update:tooltipTemplate\": null,\n        \"update:type\": null,\n        \"update:value\": null,\n        \"update:width\": null,\n        \"update:wordWrap\": null,\n        \"update:x\": null,\n        \"update:y\": null,\n    },\n    props: {\n        allowDragging: Boolean,\n        argument: {},\n        arrowLength: Number,\n        arrowWidth: Number,\n        axis: String,\n        border: Object,\n        color: String,\n        customizeTooltip: Function,\n        data: {},\n        description: String,\n        font: Object,\n        height: Number,\n        image: [Object, String],\n        name: String,\n        offsetX: Number,\n        offsetY: Number,\n        opacity: Number,\n        paddingLeftRight: Number,\n        paddingTopBottom: Number,\n        series: String,\n        shadow: Object,\n        template: {},\n        text: String,\n        textOverflow: String,\n        tooltipEnabled: Boolean,\n        tooltipTemplate: {},\n        type: String,\n        value: {},\n        width: Number,\n        wordWrap: String,\n        x: Number,\n        y: Number\n    }\n});\nexports.DxAnnotation = DxAnnotation;\nDxAnnotation.$_optionName = \"annotations\";\nDxAnnotation.$_isCollectionItem = true;\nDxAnnotation.$_expectedChildren = {\n    annotationBorder: { isCollectionItem: false, optionName: \"border\" },\n    annotationImage: { isCollectionItem: false, optionName: \"image\" },\n    border: { isCollectionItem: false, optionName: \"border\" },\n    font: { isCollectionItem: false, optionName: \"font\" },\n    image: { isCollectionItem: false, optionName: \"image\" },\n    shadow: { isCollectionItem: false, optionName: \"shadow\" }\n};\nvar DxAnnotationBorder = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:cornerRadius\": null,\n        \"update:dashStyle\": null,\n        \"update:opacity\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        cornerRadius: Number,\n        dashStyle: String,\n        opacity: Number,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxAnnotationBorder = DxAnnotationBorder;\nDxAnnotationBorder.$_optionName = \"border\";\nvar DxAnnotationImage = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:height\": null,\n        \"update:url\": null,\n        \"update:width\": null,\n    },\n    props: {\n        height: Number,\n        url: String,\n        width: Number\n    }\n});\nexports.DxAnnotationImage = DxAnnotationImage;\nDxAnnotationImage.$_optionName = \"image\";\nvar DxArgumentAxis = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:aggregateByCategory\": null,\n        \"update:aggregatedPointsPosition\": null,\n        \"update:aggregationGroupWidth\": null,\n        \"update:aggregationInterval\": null,\n        \"update:allowDecimals\": null,\n        \"update:argumentType\": null,\n        \"update:axisDivisionFactor\": null,\n        \"update:breaks\": null,\n        \"update:breakStyle\": null,\n        \"update:categories\": null,\n        \"update:color\": null,\n        \"update:constantLines\": null,\n        \"update:constantLineStyle\": null,\n        \"update:customPosition\": null,\n        \"update:customPositionAxis\": null,\n        \"update:discreteAxisDivisionMode\": null,\n        \"update:endOnTick\": null,\n        \"update:grid\": null,\n        \"update:holidays\": null,\n        \"update:hoverMode\": null,\n        \"update:inverted\": null,\n        \"update:label\": null,\n        \"update:linearThreshold\": null,\n        \"update:logarithmBase\": null,\n        \"update:maxValueMargin\": null,\n        \"update:minorGrid\": null,\n        \"update:minorTick\": null,\n        \"update:minorTickCount\": null,\n        \"update:minorTickInterval\": null,\n        \"update:minValueMargin\": null,\n        \"update:minVisualRangeLength\": null,\n        \"update:offset\": null,\n        \"update:opacity\": null,\n        \"update:placeholderSize\": null,\n        \"update:position\": null,\n        \"update:singleWorkdays\": null,\n        \"update:strips\": null,\n        \"update:stripStyle\": null,\n        \"update:tick\": null,\n        \"update:tickInterval\": null,\n        \"update:title\": null,\n        \"update:type\": null,\n        \"update:valueMarginsEnabled\": null,\n        \"update:visible\": null,\n        \"update:visualRange\": null,\n        \"update:visualRangeUpdateMode\": null,\n        \"update:wholeRange\": null,\n        \"update:width\": null,\n        \"update:workdaysOnly\": null,\n        \"update:workWeek\": null,\n    },\n    props: {\n        aggregateByCategory: Boolean,\n        aggregatedPointsPosition: String,\n        aggregationGroupWidth: Number,\n        aggregationInterval: [Number, Object, String],\n        allowDecimals: Boolean,\n        argumentType: String,\n        axisDivisionFactor: Number,\n        breaks: Array,\n        breakStyle: Object,\n        categories: Array,\n        color: String,\n        constantLines: Array,\n        constantLineStyle: Object,\n        customPosition: {},\n        customPositionAxis: String,\n        discreteAxisDivisionMode: String,\n        endOnTick: Boolean,\n        grid: Object,\n        holidays: Array,\n        hoverMode: String,\n        inverted: Boolean,\n        label: Object,\n        linearThreshold: Number,\n        logarithmBase: Number,\n        maxValueMargin: Number,\n        minorGrid: Object,\n        minorTick: Object,\n        minorTickCount: Number,\n        minorTickInterval: [Number, Object, String],\n        minValueMargin: Number,\n        minVisualRangeLength: [Number, Object, String],\n        offset: Number,\n        opacity: Number,\n        placeholderSize: Number,\n        position: String,\n        singleWorkdays: Array,\n        strips: Array,\n        stripStyle: Object,\n        tick: Object,\n        tickInterval: [Number, Object, String],\n        title: [Object, String],\n        type: String,\n        valueMarginsEnabled: Boolean,\n        visible: Boolean,\n        visualRange: [Array, Object],\n        visualRangeUpdateMode: String,\n        wholeRange: [Array, Object],\n        width: Number,\n        workdaysOnly: Boolean,\n        workWeek: Array\n    }\n});\nexports.DxArgumentAxis = DxArgumentAxis;\nDxArgumentAxis.$_optionName = \"argumentAxis\";\nDxArgumentAxis.$_expectedChildren = {\n    aggregationInterval: { isCollectionItem: false, optionName: \"aggregationInterval\" },\n    axisConstantLineStyle: { isCollectionItem: false, optionName: \"constantLineStyle\" },\n    axisLabel: { isCollectionItem: false, optionName: \"label\" },\n    axisTitle: { isCollectionItem: false, optionName: \"title\" },\n    break: { isCollectionItem: true, optionName: \"breaks\" },\n    breakStyle: { isCollectionItem: false, optionName: \"breakStyle\" },\n    constantLine: { isCollectionItem: true, optionName: \"constantLines\" },\n    constantLineStyle: { isCollectionItem: false, optionName: \"constantLineStyle\" },\n    grid: { isCollectionItem: false, optionName: \"grid\" },\n    label: { isCollectionItem: false, optionName: \"label\" },\n    minorGrid: { isCollectionItem: false, optionName: \"minorGrid\" },\n    minorTick: { isCollectionItem: false, optionName: \"minorTick\" },\n    minorTickInterval: { isCollectionItem: false, optionName: \"minorTickInterval\" },\n    minVisualRangeLength: { isCollectionItem: false, optionName: \"minVisualRangeLength\" },\n    strip: { isCollectionItem: true, optionName: \"strips\" },\n    stripStyle: { isCollectionItem: false, optionName: \"stripStyle\" },\n    tick: { isCollectionItem: false, optionName: \"tick\" },\n    tickInterval: { isCollectionItem: false, optionName: \"tickInterval\" },\n    title: { isCollectionItem: false, optionName: \"title\" },\n    visualRange: { isCollectionItem: false, optionName: \"visualRange\" },\n    wholeRange: { isCollectionItem: false, optionName: \"wholeRange\" }\n};\nvar DxArgumentFormat = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:currency\": null,\n        \"update:formatter\": null,\n        \"update:parser\": null,\n        \"update:precision\": null,\n        \"update:type\": null,\n    },\n    props: {\n        currency: String,\n        formatter: Function,\n        parser: Function,\n        precision: Number,\n        type: String\n    }\n});\nexports.DxArgumentFormat = DxArgumentFormat;\nDxArgumentFormat.$_optionName = \"argumentFormat\";\nvar DxAxisConstantLineStyle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:label\": null,\n        \"update:paddingLeftRight\": null,\n        \"update:paddingTopBottom\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        dashStyle: String,\n        label: Object,\n        paddingLeftRight: Number,\n        paddingTopBottom: Number,\n        width: Number\n    }\n});\nexports.DxAxisConstantLineStyle = DxAxisConstantLineStyle;\nDxAxisConstantLineStyle.$_optionName = \"constantLineStyle\";\nvar DxAxisConstantLineStyleLabel = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:font\": null,\n        \"update:horizontalAlignment\": null,\n        \"update:position\": null,\n        \"update:verticalAlignment\": null,\n        \"update:visible\": null,\n    },\n    props: {\n        font: Object,\n        horizontalAlignment: String,\n        position: String,\n        verticalAlignment: String,\n        visible: Boolean\n    }\n});\nexports.DxAxisConstantLineStyleLabel = DxAxisConstantLineStyleLabel;\nDxAxisConstantLineStyleLabel.$_optionName = \"label\";\nvar DxAxisLabel = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:alignment\": null,\n        \"update:customizeHint\": null,\n        \"update:customizeText\": null,\n        \"update:displayMode\": null,\n        \"update:font\": null,\n        \"update:format\": null,\n        \"update:indentFromAxis\": null,\n        \"update:overlappingBehavior\": null,\n        \"update:position\": null,\n        \"update:rotationAngle\": null,\n        \"update:staggeringSpacing\": null,\n        \"update:template\": null,\n        \"update:textOverflow\": null,\n        \"update:visible\": null,\n        \"update:wordWrap\": null,\n    },\n    props: {\n        alignment: String,\n        customizeHint: Function,\n        customizeText: Function,\n        displayMode: String,\n        font: Object,\n        format: [Object, Function, String],\n        indentFromAxis: Number,\n        overlappingBehavior: String,\n        position: String,\n        rotationAngle: Number,\n        staggeringSpacing: Number,\n        template: {},\n        textOverflow: String,\n        visible: Boolean,\n        wordWrap: String\n    }\n});\nexports.DxAxisLabel = DxAxisLabel;\nDxAxisLabel.$_optionName = \"label\";\nvar DxAxisTitle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:alignment\": null,\n        \"update:font\": null,\n        \"update:margin\": null,\n        \"update:text\": null,\n        \"update:textOverflow\": null,\n        \"update:wordWrap\": null,\n    },\n    props: {\n        alignment: String,\n        font: Object,\n        margin: Number,\n        text: String,\n        textOverflow: String,\n        wordWrap: String\n    }\n});\nexports.DxAxisTitle = DxAxisTitle;\nDxAxisTitle.$_optionName = \"title\";\nvar DxBorder = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:bottom\": null,\n        \"update:color\": null,\n        \"update:cornerRadius\": null,\n        \"update:dashStyle\": null,\n        \"update:left\": null,\n        \"update:opacity\": null,\n        \"update:right\": null,\n        \"update:top\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        bottom: Boolean,\n        color: String,\n        cornerRadius: Number,\n        dashStyle: String,\n        left: Boolean,\n        opacity: Number,\n        right: Boolean,\n        top: Boolean,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxBorder = DxBorder;\nDxBorder.$_optionName = \"border\";\nvar DxBreak = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:endValue\": null,\n        \"update:startValue\": null,\n    },\n    props: {\n        endValue: {},\n        startValue: {}\n    }\n});\nexports.DxBreak = DxBreak;\nDxBreak.$_optionName = \"breaks\";\nDxBreak.$_isCollectionItem = true;\nvar DxBreakStyle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:line\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        line: String,\n        width: Number\n    }\n});\nexports.DxBreakStyle = DxBreakStyle;\nDxBreakStyle.$_optionName = \"breakStyle\";\nvar DxChartTitle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:font\": null,\n        \"update:horizontalAlignment\": null,\n        \"update:margin\": null,\n        \"update:placeholderSize\": null,\n        \"update:subtitle\": null,\n        \"update:text\": null,\n        \"update:textOverflow\": null,\n        \"update:verticalAlignment\": null,\n        \"update:wordWrap\": null,\n    },\n    props: {\n        font: Object,\n        horizontalAlignment: String,\n        margin: [Number, Object],\n        placeholderSize: Number,\n        subtitle: [Object, String],\n        text: String,\n        textOverflow: String,\n        verticalAlignment: String,\n        wordWrap: String\n    }\n});\nexports.DxChartTitle = DxChartTitle;\nDxChartTitle.$_optionName = \"title\";\nDxChartTitle.$_expectedChildren = {\n    chartTitleSubtitle: { isCollectionItem: false, optionName: \"subtitle\" },\n    font: { isCollectionItem: false, optionName: \"font\" },\n    margin: { isCollectionItem: false, optionName: \"margin\" },\n    subtitle: { isCollectionItem: false, optionName: \"subtitle\" }\n};\nvar DxChartTitleSubtitle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:font\": null,\n        \"update:offset\": null,\n        \"update:text\": null,\n        \"update:textOverflow\": null,\n        \"update:wordWrap\": null,\n    },\n    props: {\n        font: Object,\n        offset: Number,\n        text: String,\n        textOverflow: String,\n        wordWrap: String\n    }\n});\nexports.DxChartTitleSubtitle = DxChartTitleSubtitle;\nDxChartTitleSubtitle.$_optionName = \"subtitle\";\nDxChartTitleSubtitle.$_expectedChildren = {\n    font: { isCollectionItem: false, optionName: \"font\" }\n};\nvar DxCommonAnnotationSettings = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:allowDragging\": null,\n        \"update:argument\": null,\n        \"update:arrowLength\": null,\n        \"update:arrowWidth\": null,\n        \"update:axis\": null,\n        \"update:border\": null,\n        \"update:color\": null,\n        \"update:customizeTooltip\": null,\n        \"update:data\": null,\n        \"update:description\": null,\n        \"update:font\": null,\n        \"update:height\": null,\n        \"update:image\": null,\n        \"update:offsetX\": null,\n        \"update:offsetY\": null,\n        \"update:opacity\": null,\n        \"update:paddingLeftRight\": null,\n        \"update:paddingTopBottom\": null,\n        \"update:series\": null,\n        \"update:shadow\": null,\n        \"update:template\": null,\n        \"update:text\": null,\n        \"update:textOverflow\": null,\n        \"update:tooltipEnabled\": null,\n        \"update:tooltipTemplate\": null,\n        \"update:type\": null,\n        \"update:value\": null,\n        \"update:width\": null,\n        \"update:wordWrap\": null,\n        \"update:x\": null,\n        \"update:y\": null,\n    },\n    props: {\n        allowDragging: Boolean,\n        argument: {},\n        arrowLength: Number,\n        arrowWidth: Number,\n        axis: String,\n        border: Object,\n        color: String,\n        customizeTooltip: Function,\n        data: {},\n        description: String,\n        font: Object,\n        height: Number,\n        image: [Object, String],\n        offsetX: Number,\n        offsetY: Number,\n        opacity: Number,\n        paddingLeftRight: Number,\n        paddingTopBottom: Number,\n        series: String,\n        shadow: Object,\n        template: {},\n        text: String,\n        textOverflow: String,\n        tooltipEnabled: Boolean,\n        tooltipTemplate: {},\n        type: String,\n        value: {},\n        width: Number,\n        wordWrap: String,\n        x: Number,\n        y: Number\n    }\n});\nexports.DxCommonAnnotationSettings = DxCommonAnnotationSettings;\nDxCommonAnnotationSettings.$_optionName = \"commonAnnotationSettings\";\nvar DxCommonAxisSettings = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:aggregatedPointsPosition\": null,\n        \"update:allowDecimals\": null,\n        \"update:breakStyle\": null,\n        \"update:color\": null,\n        \"update:constantLineStyle\": null,\n        \"update:discreteAxisDivisionMode\": null,\n        \"update:endOnTick\": null,\n        \"update:grid\": null,\n        \"update:inverted\": null,\n        \"update:label\": null,\n        \"update:maxValueMargin\": null,\n        \"update:minorGrid\": null,\n        \"update:minorTick\": null,\n        \"update:minValueMargin\": null,\n        \"update:opacity\": null,\n        \"update:placeholderSize\": null,\n        \"update:stripStyle\": null,\n        \"update:tick\": null,\n        \"update:title\": null,\n        \"update:valueMarginsEnabled\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        aggregatedPointsPosition: String,\n        allowDecimals: Boolean,\n        breakStyle: Object,\n        color: String,\n        constantLineStyle: Object,\n        discreteAxisDivisionMode: String,\n        endOnTick: Boolean,\n        grid: Object,\n        inverted: Boolean,\n        label: Object,\n        maxValueMargin: Number,\n        minorGrid: Object,\n        minorTick: Object,\n        minValueMargin: Number,\n        opacity: Number,\n        placeholderSize: Number,\n        stripStyle: Object,\n        tick: Object,\n        title: Object,\n        valueMarginsEnabled: Boolean,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxCommonAxisSettings = DxCommonAxisSettings;\nDxCommonAxisSettings.$_optionName = \"commonAxisSettings\";\nDxCommonAxisSettings.$_expectedChildren = {\n    commonAxisSettingsConstantLineStyle: { isCollectionItem: false, optionName: \"constantLineStyle\" },\n    commonAxisSettingsLabel: { isCollectionItem: false, optionName: \"label\" },\n    commonAxisSettingsTitle: { isCollectionItem: false, optionName: \"title\" },\n    constantLineStyle: { isCollectionItem: false, optionName: \"constantLineStyle\" },\n    label: { isCollectionItem: false, optionName: \"label\" },\n    title: { isCollectionItem: false, optionName: \"title\" }\n};\nvar DxCommonAxisSettingsConstantLineStyle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:label\": null,\n        \"update:paddingLeftRight\": null,\n        \"update:paddingTopBottom\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        dashStyle: String,\n        label: Object,\n        paddingLeftRight: Number,\n        paddingTopBottom: Number,\n        width: Number\n    }\n});\nexports.DxCommonAxisSettingsConstantLineStyle = DxCommonAxisSettingsConstantLineStyle;\nDxCommonAxisSettingsConstantLineStyle.$_optionName = \"constantLineStyle\";\nDxCommonAxisSettingsConstantLineStyle.$_expectedChildren = {\n    commonAxisSettingsConstantLineStyleLabel: { isCollectionItem: false, optionName: \"label\" },\n    label: { isCollectionItem: false, optionName: \"label\" }\n};\nvar DxCommonAxisSettingsConstantLineStyleLabel = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:font\": null,\n        \"update:position\": null,\n        \"update:visible\": null,\n    },\n    props: {\n        font: Object,\n        position: String,\n        visible: Boolean\n    }\n});\nexports.DxCommonAxisSettingsConstantLineStyleLabel = DxCommonAxisSettingsConstantLineStyleLabel;\nDxCommonAxisSettingsConstantLineStyleLabel.$_optionName = \"label\";\nvar DxCommonAxisSettingsLabel = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:alignment\": null,\n        \"update:displayMode\": null,\n        \"update:font\": null,\n        \"update:indentFromAxis\": null,\n        \"update:overlappingBehavior\": null,\n        \"update:position\": null,\n        \"update:rotationAngle\": null,\n        \"update:staggeringSpacing\": null,\n        \"update:template\": null,\n        \"update:textOverflow\": null,\n        \"update:visible\": null,\n        \"update:wordWrap\": null,\n    },\n    props: {\n        alignment: String,\n        displayMode: String,\n        font: Object,\n        indentFromAxis: Number,\n        overlappingBehavior: String,\n        position: String,\n        rotationAngle: Number,\n        staggeringSpacing: Number,\n        template: {},\n        textOverflow: String,\n        visible: Boolean,\n        wordWrap: String\n    }\n});\nexports.DxCommonAxisSettingsLabel = DxCommonAxisSettingsLabel;\nDxCommonAxisSettingsLabel.$_optionName = \"label\";\nvar DxCommonAxisSettingsTitle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:alignment\": null,\n        \"update:font\": null,\n        \"update:margin\": null,\n        \"update:textOverflow\": null,\n        \"update:wordWrap\": null,\n    },\n    props: {\n        alignment: String,\n        font: Object,\n        margin: Number,\n        textOverflow: String,\n        wordWrap: String\n    }\n});\nexports.DxCommonAxisSettingsTitle = DxCommonAxisSettingsTitle;\nDxCommonAxisSettingsTitle.$_optionName = \"title\";\nvar DxCommonPaneSettings = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:backgroundColor\": null,\n        \"update:border\": null,\n    },\n    props: {\n        backgroundColor: String,\n        border: Object\n    }\n});\nexports.DxCommonPaneSettings = DxCommonPaneSettings;\nDxCommonPaneSettings.$_optionName = \"commonPaneSettings\";\nDxCommonPaneSettings.$_expectedChildren = {\n    border: { isCollectionItem: false, optionName: \"border\" },\n    paneBorder: { isCollectionItem: false, optionName: \"border\" }\n};\nvar DxCommonSeriesSettings = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:aggregation\": null,\n        \"update:area\": null,\n        \"update:argumentField\": null,\n        \"update:axis\": null,\n        \"update:bar\": null,\n        \"update:barOverlapGroup\": null,\n        \"update:barPadding\": null,\n        \"update:barWidth\": null,\n        \"update:border\": null,\n        \"update:bubble\": null,\n        \"update:candlestick\": null,\n        \"update:closeValueField\": null,\n        \"update:color\": null,\n        \"update:cornerRadius\": null,\n        \"update:dashStyle\": null,\n        \"update:fullstackedarea\": null,\n        \"update:fullstackedbar\": null,\n        \"update:fullstackedline\": null,\n        \"update:fullstackedspline\": null,\n        \"update:fullstackedsplinearea\": null,\n        \"update:highValueField\": null,\n        \"update:hoverMode\": null,\n        \"update:hoverStyle\": null,\n        \"update:ignoreEmptyPoints\": null,\n        \"update:innerColor\": null,\n        \"update:label\": null,\n        \"update:line\": null,\n        \"update:lowValueField\": null,\n        \"update:maxLabelCount\": null,\n        \"update:minBarSize\": null,\n        \"update:opacity\": null,\n        \"update:openValueField\": null,\n        \"update:pane\": null,\n        \"update:point\": null,\n        \"update:rangearea\": null,\n        \"update:rangebar\": null,\n        \"update:rangeValue1Field\": null,\n        \"update:rangeValue2Field\": null,\n        \"update:reduction\": null,\n        \"update:scatter\": null,\n        \"update:selectionMode\": null,\n        \"update:selectionStyle\": null,\n        \"update:showInLegend\": null,\n        \"update:sizeField\": null,\n        \"update:spline\": null,\n        \"update:splinearea\": null,\n        \"update:stack\": null,\n        \"update:stackedarea\": null,\n        \"update:stackedbar\": null,\n        \"update:stackedline\": null,\n        \"update:stackedspline\": null,\n        \"update:stackedsplinearea\": null,\n        \"update:steparea\": null,\n        \"update:stepline\": null,\n        \"update:stock\": null,\n        \"update:tagField\": null,\n        \"update:type\": null,\n        \"update:valueErrorBar\": null,\n        \"update:valueField\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        aggregation: Object,\n        area: {},\n        argumentField: String,\n        axis: String,\n        bar: {},\n        barOverlapGroup: String,\n        barPadding: Number,\n        barWidth: Number,\n        border: Object,\n        bubble: {},\n        candlestick: {},\n        closeValueField: String,\n        color: String,\n        cornerRadius: Number,\n        dashStyle: String,\n        fullstackedarea: {},\n        fullstackedbar: {},\n        fullstackedline: {},\n        fullstackedspline: {},\n        fullstackedsplinearea: {},\n        highValueField: String,\n        hoverMode: String,\n        hoverStyle: Object,\n        ignoreEmptyPoints: Boolean,\n        innerColor: String,\n        label: Object,\n        line: {},\n        lowValueField: String,\n        maxLabelCount: Number,\n        minBarSize: Number,\n        opacity: Number,\n        openValueField: String,\n        pane: String,\n        point: Object,\n        rangearea: {},\n        rangebar: {},\n        rangeValue1Field: String,\n        rangeValue2Field: String,\n        reduction: Object,\n        scatter: {},\n        selectionMode: String,\n        selectionStyle: Object,\n        showInLegend: Boolean,\n        sizeField: String,\n        spline: {},\n        splinearea: {},\n        stack: String,\n        stackedarea: {},\n        stackedbar: {},\n        stackedline: {},\n        stackedspline: {},\n        stackedsplinearea: {},\n        steparea: {},\n        stepline: {},\n        stock: {},\n        tagField: String,\n        type: String,\n        valueErrorBar: Object,\n        valueField: String,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxCommonSeriesSettings = DxCommonSeriesSettings;\nDxCommonSeriesSettings.$_optionName = \"commonSeriesSettings\";\nDxCommonSeriesSettings.$_expectedChildren = {\n    aggregation: { isCollectionItem: false, optionName: \"aggregation\" },\n    border: { isCollectionItem: false, optionName: \"border\" },\n    commonSeriesSettingsHoverStyle: { isCollectionItem: false, optionName: \"hoverStyle\" },\n    commonSeriesSettingsLabel: { isCollectionItem: false, optionName: \"label\" },\n    commonSeriesSettingsSelectionStyle: { isCollectionItem: false, optionName: \"selectionStyle\" },\n    hoverStyle: { isCollectionItem: false, optionName: \"hoverStyle\" },\n    label: { isCollectionItem: false, optionName: \"label\" },\n    point: { isCollectionItem: false, optionName: \"point\" },\n    reduction: { isCollectionItem: false, optionName: \"reduction\" },\n    selectionStyle: { isCollectionItem: false, optionName: \"selectionStyle\" },\n    seriesBorder: { isCollectionItem: false, optionName: \"border\" },\n    valueErrorBar: { isCollectionItem: false, optionName: \"valueErrorBar\" }\n};\nvar DxCommonSeriesSettingsHoverStyle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:border\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:hatching\": null,\n        \"update:width\": null,\n    },\n    props: {\n        border: Object,\n        color: String,\n        dashStyle: String,\n        hatching: Object,\n        width: Number\n    }\n});\nexports.DxCommonSeriesSettingsHoverStyle = DxCommonSeriesSettingsHoverStyle;\nDxCommonSeriesSettingsHoverStyle.$_optionName = \"hoverStyle\";\nDxCommonSeriesSettingsHoverStyle.$_expectedChildren = {\n    border: { isCollectionItem: false, optionName: \"border\" },\n    hatching: { isCollectionItem: false, optionName: \"hatching\" },\n    seriesBorder: { isCollectionItem: false, optionName: \"border\" }\n};\nvar DxCommonSeriesSettingsLabel = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:alignment\": null,\n        \"update:argumentFormat\": null,\n        \"update:backgroundColor\": null,\n        \"update:border\": null,\n        \"update:connector\": null,\n        \"update:customizeText\": null,\n        \"update:font\": null,\n        \"update:format\": null,\n        \"update:horizontalOffset\": null,\n        \"update:position\": null,\n        \"update:rotationAngle\": null,\n        \"update:showForZeroValues\": null,\n        \"update:verticalOffset\": null,\n        \"update:visible\": null,\n    },\n    props: {\n        alignment: String,\n        argumentFormat: [Object, Function, String],\n        backgroundColor: String,\n        border: Object,\n        connector: Object,\n        customizeText: Function,\n        font: Object,\n        format: [Object, Function, String],\n        horizontalOffset: Number,\n        position: String,\n        rotationAngle: Number,\n        showForZeroValues: Boolean,\n        verticalOffset: Number,\n        visible: Boolean\n    }\n});\nexports.DxCommonSeriesSettingsLabel = DxCommonSeriesSettingsLabel;\nDxCommonSeriesSettingsLabel.$_optionName = \"label\";\nDxCommonSeriesSettingsLabel.$_expectedChildren = {\n    argumentFormat: { isCollectionItem: false, optionName: \"argumentFormat\" },\n    border: { isCollectionItem: false, optionName: \"border\" },\n    connector: { isCollectionItem: false, optionName: \"connector\" },\n    font: { isCollectionItem: false, optionName: \"font\" },\n    format: { isCollectionItem: false, optionName: \"format\" },\n    seriesBorder: { isCollectionItem: false, optionName: \"border\" }\n};\nvar DxCommonSeriesSettingsSelectionStyle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:border\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:hatching\": null,\n        \"update:width\": null,\n    },\n    props: {\n        border: Object,\n        color: String,\n        dashStyle: String,\n        hatching: Object,\n        width: Number\n    }\n});\nexports.DxCommonSeriesSettingsSelectionStyle = DxCommonSeriesSettingsSelectionStyle;\nDxCommonSeriesSettingsSelectionStyle.$_optionName = \"selectionStyle\";\nDxCommonSeriesSettingsSelectionStyle.$_expectedChildren = {\n    border: { isCollectionItem: false, optionName: \"border\" },\n    hatching: { isCollectionItem: false, optionName: \"hatching\" },\n    seriesBorder: { isCollectionItem: false, optionName: \"border\" }\n};\nvar DxConnector = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxConnector = DxConnector;\nDxConnector.$_optionName = \"connector\";\nvar DxConstantLine = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:displayBehindSeries\": null,\n        \"update:extendAxis\": null,\n        \"update:label\": null,\n        \"update:paddingLeftRight\": null,\n        \"update:paddingTopBottom\": null,\n        \"update:value\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        dashStyle: String,\n        displayBehindSeries: Boolean,\n        extendAxis: Boolean,\n        label: Object,\n        paddingLeftRight: Number,\n        paddingTopBottom: Number,\n        value: {},\n        width: Number\n    }\n});\nexports.DxConstantLine = DxConstantLine;\nDxConstantLine.$_optionName = \"constantLines\";\nDxConstantLine.$_isCollectionItem = true;\nvar DxConstantLineLabel = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:font\": null,\n        \"update:horizontalAlignment\": null,\n        \"update:position\": null,\n        \"update:text\": null,\n        \"update:verticalAlignment\": null,\n        \"update:visible\": null,\n    },\n    props: {\n        font: Object,\n        horizontalAlignment: String,\n        position: String,\n        text: String,\n        verticalAlignment: String,\n        visible: Boolean\n    }\n});\nexports.DxConstantLineLabel = DxConstantLineLabel;\nDxConstantLineLabel.$_optionName = \"label\";\nvar DxConstantLineStyle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:label\": null,\n        \"update:paddingLeftRight\": null,\n        \"update:paddingTopBottom\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        dashStyle: String,\n        label: Object,\n        paddingLeftRight: Number,\n        paddingTopBottom: Number,\n        width: Number\n    }\n});\nexports.DxConstantLineStyle = DxConstantLineStyle;\nDxConstantLineStyle.$_optionName = \"constantLineStyle\";\nvar DxCrosshair = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:enabled\": null,\n        \"update:horizontalLine\": null,\n        \"update:label\": null,\n        \"update:opacity\": null,\n        \"update:verticalLine\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        dashStyle: String,\n        enabled: Boolean,\n        horizontalLine: [Boolean, Object],\n        label: Object,\n        opacity: Number,\n        verticalLine: [Boolean, Object],\n        width: Number\n    }\n});\nexports.DxCrosshair = DxCrosshair;\nDxCrosshair.$_optionName = \"crosshair\";\nDxCrosshair.$_expectedChildren = {\n    horizontalLine: { isCollectionItem: false, optionName: \"horizontalLine\" },\n    horizontalLineLabel: { isCollectionItem: false, optionName: \"label\" },\n    label: { isCollectionItem: false, optionName: \"label\" },\n    verticalLine: { isCollectionItem: false, optionName: \"verticalLine\" }\n};\nvar DxDataPrepareSettings = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:checkTypeForAllData\": null,\n        \"update:convertToAxisDataType\": null,\n        \"update:sortingMethod\": null,\n    },\n    props: {\n        checkTypeForAllData: Boolean,\n        convertToAxisDataType: Boolean,\n        sortingMethod: [Boolean, Function]\n    }\n});\nexports.DxDataPrepareSettings = DxDataPrepareSettings;\nDxDataPrepareSettings.$_optionName = \"dataPrepareSettings\";\nvar DxDragBoxStyle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:opacity\": null,\n    },\n    props: {\n        color: String,\n        opacity: Number\n    }\n});\nexports.DxDragBoxStyle = DxDragBoxStyle;\nDxDragBoxStyle.$_optionName = \"dragBoxStyle\";\nvar DxExport = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:backgroundColor\": null,\n        \"update:enabled\": null,\n        \"update:fileName\": null,\n        \"update:formats\": null,\n        \"update:margin\": null,\n        \"update:printingEnabled\": null,\n        \"update:proxyUrl\": null,\n        \"update:svgToCanvas\": null,\n    },\n    props: {\n        backgroundColor: String,\n        enabled: Boolean,\n        fileName: String,\n        formats: Array,\n        margin: Number,\n        printingEnabled: Boolean,\n        proxyUrl: String,\n        svgToCanvas: Function\n    }\n});\nexports.DxExport = DxExport;\nDxExport.$_optionName = \"export\";\nvar DxFont = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:family\": null,\n        \"update:opacity\": null,\n        \"update:size\": null,\n        \"update:weight\": null,\n    },\n    props: {\n        color: String,\n        family: String,\n        opacity: Number,\n        size: [Number, String],\n        weight: Number\n    }\n});\nexports.DxFont = DxFont;\nDxFont.$_optionName = \"font\";\nvar DxFormat = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:currency\": null,\n        \"update:formatter\": null,\n        \"update:parser\": null,\n        \"update:precision\": null,\n        \"update:type\": null,\n    },\n    props: {\n        currency: String,\n        formatter: Function,\n        parser: Function,\n        precision: Number,\n        type: String\n    }\n});\nexports.DxFormat = DxFormat;\nDxFormat.$_optionName = \"format\";\nvar DxGrid = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:opacity\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        opacity: Number,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxGrid = DxGrid;\nDxGrid.$_optionName = \"grid\";\nvar DxHatching = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:direction\": null,\n        \"update:opacity\": null,\n        \"update:step\": null,\n        \"update:width\": null,\n    },\n    props: {\n        direction: String,\n        opacity: Number,\n        step: Number,\n        width: Number\n    }\n});\nexports.DxHatching = DxHatching;\nDxHatching.$_optionName = \"hatching\";\nvar DxHeight = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:rangeMaxPoint\": null,\n        \"update:rangeMinPoint\": null,\n    },\n    props: {\n        rangeMaxPoint: Number,\n        rangeMinPoint: Number\n    }\n});\nexports.DxHeight = DxHeight;\nDxHeight.$_optionName = \"height\";\nvar DxHorizontalLine = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:label\": null,\n        \"update:opacity\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        dashStyle: String,\n        label: Object,\n        opacity: Number,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxHorizontalLine = DxHorizontalLine;\nDxHorizontalLine.$_optionName = \"horizontalLine\";\nDxHorizontalLine.$_expectedChildren = {\n    horizontalLineLabel: { isCollectionItem: false, optionName: \"label\" },\n    label: { isCollectionItem: false, optionName: \"label\" }\n};\nvar DxHorizontalLineLabel = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:backgroundColor\": null,\n        \"update:customizeText\": null,\n        \"update:font\": null,\n        \"update:format\": null,\n        \"update:visible\": null,\n    },\n    props: {\n        backgroundColor: String,\n        customizeText: Function,\n        font: Object,\n        format: [Object, Function, String],\n        visible: Boolean\n    }\n});\nexports.DxHorizontalLineLabel = DxHorizontalLineLabel;\nDxHorizontalLineLabel.$_optionName = \"label\";\nvar DxHoverStyle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:border\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:hatching\": null,\n        \"update:size\": null,\n        \"update:width\": null,\n    },\n    props: {\n        border: Object,\n        color: String,\n        dashStyle: String,\n        hatching: Object,\n        size: Number,\n        width: Number\n    }\n});\nexports.DxHoverStyle = DxHoverStyle;\nDxHoverStyle.$_optionName = \"hoverStyle\";\nvar DxImage = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:height\": null,\n        \"update:url\": null,\n        \"update:width\": null,\n    },\n    props: {\n        height: Number,\n        url: String,\n        width: Number\n    }\n});\nexports.DxImage = DxImage;\nDxImage.$_optionName = \"image\";\nvar DxLabel = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:alignment\": null,\n        \"update:argumentFormat\": null,\n        \"update:backgroundColor\": null,\n        \"update:border\": null,\n        \"update:connector\": null,\n        \"update:customizeHint\": null,\n        \"update:customizeText\": null,\n        \"update:displayMode\": null,\n        \"update:font\": null,\n        \"update:format\": null,\n        \"update:horizontalAlignment\": null,\n        \"update:horizontalOffset\": null,\n        \"update:indentFromAxis\": null,\n        \"update:overlappingBehavior\": null,\n        \"update:position\": null,\n        \"update:rotationAngle\": null,\n        \"update:showForZeroValues\": null,\n        \"update:staggeringSpacing\": null,\n        \"update:template\": null,\n        \"update:text\": null,\n        \"update:textOverflow\": null,\n        \"update:verticalAlignment\": null,\n        \"update:verticalOffset\": null,\n        \"update:visible\": null,\n        \"update:wordWrap\": null,\n    },\n    props: {\n        alignment: String,\n        argumentFormat: [Object, Function, String],\n        backgroundColor: String,\n        border: Object,\n        connector: Object,\n        customizeHint: Function,\n        customizeText: Function,\n        displayMode: String,\n        font: Object,\n        format: [Object, Function, String],\n        horizontalAlignment: String,\n        horizontalOffset: Number,\n        indentFromAxis: Number,\n        overlappingBehavior: String,\n        position: String,\n        rotationAngle: Number,\n        showForZeroValues: Boolean,\n        staggeringSpacing: Number,\n        template: {},\n        text: String,\n        textOverflow: String,\n        verticalAlignment: String,\n        verticalOffset: Number,\n        visible: Boolean,\n        wordWrap: String\n    }\n});\nexports.DxLabel = DxLabel;\nDxLabel.$_optionName = \"label\";\nvar DxLegend = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:backgroundColor\": null,\n        \"update:border\": null,\n        \"update:columnCount\": null,\n        \"update:columnItemSpacing\": null,\n        \"update:customizeHint\": null,\n        \"update:customizeItems\": null,\n        \"update:customizeText\": null,\n        \"update:font\": null,\n        \"update:horizontalAlignment\": null,\n        \"update:hoverMode\": null,\n        \"update:itemsAlignment\": null,\n        \"update:itemTextPosition\": null,\n        \"update:margin\": null,\n        \"update:markerSize\": null,\n        \"update:markerTemplate\": null,\n        \"update:orientation\": null,\n        \"update:paddingLeftRight\": null,\n        \"update:paddingTopBottom\": null,\n        \"update:position\": null,\n        \"update:rowCount\": null,\n        \"update:rowItemSpacing\": null,\n        \"update:title\": null,\n        \"update:verticalAlignment\": null,\n        \"update:visible\": null,\n    },\n    props: {\n        backgroundColor: String,\n        border: Object,\n        columnCount: Number,\n        columnItemSpacing: Number,\n        customizeHint: Function,\n        customizeItems: Function,\n        customizeText: Function,\n        font: Object,\n        horizontalAlignment: String,\n        hoverMode: String,\n        itemsAlignment: String,\n        itemTextPosition: String,\n        margin: [Number, Object],\n        markerSize: Number,\n        markerTemplate: {},\n        orientation: String,\n        paddingLeftRight: Number,\n        paddingTopBottom: Number,\n        position: String,\n        rowCount: Number,\n        rowItemSpacing: Number,\n        title: [Object, String],\n        verticalAlignment: String,\n        visible: Boolean\n    }\n});\nexports.DxLegend = DxLegend;\nDxLegend.$_optionName = \"legend\";\nDxLegend.$_expectedChildren = {\n    annotationBorder: { isCollectionItem: false, optionName: \"border\" },\n    border: { isCollectionItem: false, optionName: \"border\" },\n    font: { isCollectionItem: false, optionName: \"font\" },\n    legendTitle: { isCollectionItem: false, optionName: \"title\" },\n    margin: { isCollectionItem: false, optionName: \"margin\" },\n    title: { isCollectionItem: false, optionName: \"title\" }\n};\nvar DxLegendTitle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:font\": null,\n        \"update:horizontalAlignment\": null,\n        \"update:margin\": null,\n        \"update:placeholderSize\": null,\n        \"update:subtitle\": null,\n        \"update:text\": null,\n        \"update:verticalAlignment\": null,\n    },\n    props: {\n        font: Object,\n        horizontalAlignment: String,\n        margin: Object,\n        placeholderSize: Number,\n        subtitle: [Object, String],\n        text: String,\n        verticalAlignment: String\n    }\n});\nexports.DxLegendTitle = DxLegendTitle;\nDxLegendTitle.$_optionName = \"title\";\nDxLegendTitle.$_expectedChildren = {\n    font: { isCollectionItem: false, optionName: \"font\" },\n    legendTitleSubtitle: { isCollectionItem: false, optionName: \"subtitle\" },\n    margin: { isCollectionItem: false, optionName: \"margin\" },\n    subtitle: { isCollectionItem: false, optionName: \"subtitle\" }\n};\nvar DxLegendTitleSubtitle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:font\": null,\n        \"update:offset\": null,\n        \"update:text\": null,\n    },\n    props: {\n        font: Object,\n        offset: Number,\n        text: String\n    }\n});\nexports.DxLegendTitleSubtitle = DxLegendTitleSubtitle;\nDxLegendTitleSubtitle.$_optionName = \"subtitle\";\nDxLegendTitleSubtitle.$_expectedChildren = {\n    font: { isCollectionItem: false, optionName: \"font\" }\n};\nvar DxLength = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:days\": null,\n        \"update:hours\": null,\n        \"update:milliseconds\": null,\n        \"update:minutes\": null,\n        \"update:months\": null,\n        \"update:quarters\": null,\n        \"update:seconds\": null,\n        \"update:weeks\": null,\n        \"update:years\": null,\n    },\n    props: {\n        days: Number,\n        hours: Number,\n        milliseconds: Number,\n        minutes: Number,\n        months: Number,\n        quarters: Number,\n        seconds: Number,\n        weeks: Number,\n        years: Number\n    }\n});\nexports.DxLength = DxLength;\nDxLength.$_optionName = \"length\";\nvar DxLoadingIndicator = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:backgroundColor\": null,\n        \"update:enabled\": null,\n        \"update:font\": null,\n        \"update:show\": null,\n        \"update:text\": null,\n    },\n    props: {\n        backgroundColor: String,\n        enabled: Boolean,\n        font: Object,\n        show: Boolean,\n        text: String\n    }\n});\nexports.DxLoadingIndicator = DxLoadingIndicator;\nDxLoadingIndicator.$_optionName = \"loadingIndicator\";\nDxLoadingIndicator.$_expectedChildren = {\n    font: { isCollectionItem: false, optionName: \"font\" }\n};\nvar DxMargin = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:bottom\": null,\n        \"update:left\": null,\n        \"update:right\": null,\n        \"update:top\": null,\n    },\n    props: {\n        bottom: Number,\n        left: Number,\n        right: Number,\n        top: Number\n    }\n});\nexports.DxMargin = DxMargin;\nDxMargin.$_optionName = \"margin\";\nvar DxMinorGrid = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:opacity\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        opacity: Number,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxMinorGrid = DxMinorGrid;\nDxMinorGrid.$_optionName = \"minorGrid\";\nvar DxMinorTick = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:length\": null,\n        \"update:opacity\": null,\n        \"update:shift\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        length: Number,\n        opacity: Number,\n        shift: Number,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxMinorTick = DxMinorTick;\nDxMinorTick.$_optionName = \"minorTick\";\nvar DxMinorTickInterval = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:days\": null,\n        \"update:hours\": null,\n        \"update:milliseconds\": null,\n        \"update:minutes\": null,\n        \"update:months\": null,\n        \"update:quarters\": null,\n        \"update:seconds\": null,\n        \"update:weeks\": null,\n        \"update:years\": null,\n    },\n    props: {\n        days: Number,\n        hours: Number,\n        milliseconds: Number,\n        minutes: Number,\n        months: Number,\n        quarters: Number,\n        seconds: Number,\n        weeks: Number,\n        years: Number\n    }\n});\nexports.DxMinorTickInterval = DxMinorTickInterval;\nDxMinorTickInterval.$_optionName = \"minorTickInterval\";\nvar DxMinVisualRangeLength = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:days\": null,\n        \"update:hours\": null,\n        \"update:milliseconds\": null,\n        \"update:minutes\": null,\n        \"update:months\": null,\n        \"update:quarters\": null,\n        \"update:seconds\": null,\n        \"update:weeks\": null,\n        \"update:years\": null,\n    },\n    props: {\n        days: Number,\n        hours: Number,\n        milliseconds: Number,\n        minutes: Number,\n        months: Number,\n        quarters: Number,\n        seconds: Number,\n        weeks: Number,\n        years: Number\n    }\n});\nexports.DxMinVisualRangeLength = DxMinVisualRangeLength;\nDxMinVisualRangeLength.$_optionName = \"minVisualRangeLength\";\nvar DxPane = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:backgroundColor\": null,\n        \"update:border\": null,\n        \"update:height\": null,\n        \"update:name\": null,\n    },\n    props: {\n        backgroundColor: String,\n        border: Object,\n        height: [Number, String],\n        name: String\n    }\n});\nexports.DxPane = DxPane;\nDxPane.$_optionName = \"panes\";\nDxPane.$_isCollectionItem = true;\nvar DxPaneBorder = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:bottom\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:left\": null,\n        \"update:opacity\": null,\n        \"update:right\": null,\n        \"update:top\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        bottom: Boolean,\n        color: String,\n        dashStyle: String,\n        left: Boolean,\n        opacity: Number,\n        right: Boolean,\n        top: Boolean,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxPaneBorder = DxPaneBorder;\nDxPaneBorder.$_optionName = \"border\";\nvar DxPoint = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:border\": null,\n        \"update:color\": null,\n        \"update:hoverMode\": null,\n        \"update:hoverStyle\": null,\n        \"update:image\": null,\n        \"update:selectionMode\": null,\n        \"update:selectionStyle\": null,\n        \"update:size\": null,\n        \"update:symbol\": null,\n        \"update:visible\": null,\n    },\n    props: {\n        border: Object,\n        color: String,\n        hoverMode: String,\n        hoverStyle: Object,\n        image: [Object, String],\n        selectionMode: String,\n        selectionStyle: Object,\n        size: Number,\n        symbol: String,\n        visible: Boolean\n    }\n});\nexports.DxPoint = DxPoint;\nDxPoint.$_optionName = \"point\";\nDxPoint.$_expectedChildren = {\n    border: { isCollectionItem: false, optionName: \"border\" },\n    hoverStyle: { isCollectionItem: false, optionName: \"hoverStyle\" },\n    image: { isCollectionItem: false, optionName: \"image\" },\n    pointBorder: { isCollectionItem: false, optionName: \"border\" },\n    pointHoverStyle: { isCollectionItem: false, optionName: \"hoverStyle\" },\n    pointImage: { isCollectionItem: false, optionName: \"image\" },\n    pointSelectionStyle: { isCollectionItem: false, optionName: \"selectionStyle\" },\n    selectionStyle: { isCollectionItem: false, optionName: \"selectionStyle\" }\n};\nvar DxPointBorder = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxPointBorder = DxPointBorder;\nDxPointBorder.$_optionName = \"border\";\nvar DxPointHoverStyle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:border\": null,\n        \"update:color\": null,\n        \"update:size\": null,\n    },\n    props: {\n        border: Object,\n        color: String,\n        size: Number\n    }\n});\nexports.DxPointHoverStyle = DxPointHoverStyle;\nDxPointHoverStyle.$_optionName = \"hoverStyle\";\nDxPointHoverStyle.$_expectedChildren = {\n    border: { isCollectionItem: false, optionName: \"border\" },\n    pointBorder: { isCollectionItem: false, optionName: \"border\" }\n};\nvar DxPointImage = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:height\": null,\n        \"update:url\": null,\n        \"update:width\": null,\n    },\n    props: {\n        height: [Number, Object],\n        url: [Object, String],\n        width: [Number, Object]\n    }\n});\nexports.DxPointImage = DxPointImage;\nDxPointImage.$_optionName = \"image\";\nDxPointImage.$_expectedChildren = {\n    height: { isCollectionItem: false, optionName: \"height\" },\n    url: { isCollectionItem: false, optionName: \"url\" },\n    width: { isCollectionItem: false, optionName: \"width\" }\n};\nvar DxPointSelectionStyle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:border\": null,\n        \"update:color\": null,\n        \"update:size\": null,\n    },\n    props: {\n        border: Object,\n        color: String,\n        size: Number\n    }\n});\nexports.DxPointSelectionStyle = DxPointSelectionStyle;\nDxPointSelectionStyle.$_optionName = \"selectionStyle\";\nDxPointSelectionStyle.$_expectedChildren = {\n    border: { isCollectionItem: false, optionName: \"border\" },\n    pointBorder: { isCollectionItem: false, optionName: \"border\" }\n};\nvar DxReduction = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:level\": null,\n    },\n    props: {\n        color: String,\n        level: String\n    }\n});\nexports.DxReduction = DxReduction;\nDxReduction.$_optionName = \"reduction\";\nvar DxScrollBar = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:offset\": null,\n        \"update:opacity\": null,\n        \"update:position\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        offset: Number,\n        opacity: Number,\n        position: String,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxScrollBar = DxScrollBar;\nDxScrollBar.$_optionName = \"scrollBar\";\nvar DxSelectionStyle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:border\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:hatching\": null,\n        \"update:size\": null,\n        \"update:width\": null,\n    },\n    props: {\n        border: Object,\n        color: String,\n        dashStyle: String,\n        hatching: Object,\n        size: Number,\n        width: Number\n    }\n});\nexports.DxSelectionStyle = DxSelectionStyle;\nDxSelectionStyle.$_optionName = \"selectionStyle\";\nvar DxSeries = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:aggregation\": null,\n        \"update:argumentField\": null,\n        \"update:axis\": null,\n        \"update:barOverlapGroup\": null,\n        \"update:barPadding\": null,\n        \"update:barWidth\": null,\n        \"update:border\": null,\n        \"update:closeValueField\": null,\n        \"update:color\": null,\n        \"update:cornerRadius\": null,\n        \"update:dashStyle\": null,\n        \"update:highValueField\": null,\n        \"update:hoverMode\": null,\n        \"update:hoverStyle\": null,\n        \"update:ignoreEmptyPoints\": null,\n        \"update:innerColor\": null,\n        \"update:label\": null,\n        \"update:lowValueField\": null,\n        \"update:maxLabelCount\": null,\n        \"update:minBarSize\": null,\n        \"update:name\": null,\n        \"update:opacity\": null,\n        \"update:openValueField\": null,\n        \"update:pane\": null,\n        \"update:point\": null,\n        \"update:rangeValue1Field\": null,\n        \"update:rangeValue2Field\": null,\n        \"update:reduction\": null,\n        \"update:selectionMode\": null,\n        \"update:selectionStyle\": null,\n        \"update:showInLegend\": null,\n        \"update:sizeField\": null,\n        \"update:stack\": null,\n        \"update:tag\": null,\n        \"update:tagField\": null,\n        \"update:type\": null,\n        \"update:valueErrorBar\": null,\n        \"update:valueField\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        aggregation: Object,\n        argumentField: String,\n        axis: String,\n        barOverlapGroup: String,\n        barPadding: Number,\n        barWidth: Number,\n        border: Object,\n        closeValueField: String,\n        color: String,\n        cornerRadius: Number,\n        dashStyle: String,\n        highValueField: String,\n        hoverMode: String,\n        hoverStyle: Object,\n        ignoreEmptyPoints: Boolean,\n        innerColor: String,\n        label: Object,\n        lowValueField: String,\n        maxLabelCount: Number,\n        minBarSize: Number,\n        name: String,\n        opacity: Number,\n        openValueField: String,\n        pane: String,\n        point: Object,\n        rangeValue1Field: String,\n        rangeValue2Field: String,\n        reduction: Object,\n        selectionMode: String,\n        selectionStyle: Object,\n        showInLegend: Boolean,\n        sizeField: String,\n        stack: String,\n        tag: {},\n        tagField: String,\n        type: String,\n        valueErrorBar: Object,\n        valueField: String,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxSeries = DxSeries;\nDxSeries.$_optionName = \"series\";\nDxSeries.$_isCollectionItem = true;\nvar DxSeriesBorder = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        dashStyle: String,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxSeriesBorder = DxSeriesBorder;\nDxSeriesBorder.$_optionName = \"border\";\nvar DxSeriesTemplate = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:customizeSeries\": null,\n        \"update:nameField\": null,\n    },\n    props: {\n        customizeSeries: Function,\n        nameField: String\n    }\n});\nexports.DxSeriesTemplate = DxSeriesTemplate;\nDxSeriesTemplate.$_optionName = \"seriesTemplate\";\nvar DxShadow = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:blur\": null,\n        \"update:color\": null,\n        \"update:offsetX\": null,\n        \"update:offsetY\": null,\n        \"update:opacity\": null,\n    },\n    props: {\n        blur: Number,\n        color: String,\n        offsetX: Number,\n        offsetY: Number,\n        opacity: Number\n    }\n});\nexports.DxShadow = DxShadow;\nDxShadow.$_optionName = \"shadow\";\nvar DxSize = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:height\": null,\n        \"update:width\": null,\n    },\n    props: {\n        height: Number,\n        width: Number\n    }\n});\nexports.DxSize = DxSize;\nDxSize.$_optionName = \"size\";\nvar DxStrip = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:endValue\": null,\n        \"update:label\": null,\n        \"update:paddingLeftRight\": null,\n        \"update:paddingTopBottom\": null,\n        \"update:startValue\": null,\n    },\n    props: {\n        color: String,\n        endValue: {},\n        label: Object,\n        paddingLeftRight: Number,\n        paddingTopBottom: Number,\n        startValue: {}\n    }\n});\nexports.DxStrip = DxStrip;\nDxStrip.$_optionName = \"strips\";\nDxStrip.$_isCollectionItem = true;\nvar DxStripLabel = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:font\": null,\n        \"update:horizontalAlignment\": null,\n        \"update:text\": null,\n        \"update:verticalAlignment\": null,\n    },\n    props: {\n        font: Object,\n        horizontalAlignment: String,\n        text: String,\n        verticalAlignment: String\n    }\n});\nexports.DxStripLabel = DxStripLabel;\nDxStripLabel.$_optionName = \"label\";\nvar DxStripStyle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:label\": null,\n        \"update:paddingLeftRight\": null,\n        \"update:paddingTopBottom\": null,\n    },\n    props: {\n        label: Object,\n        paddingLeftRight: Number,\n        paddingTopBottom: Number\n    }\n});\nexports.DxStripStyle = DxStripStyle;\nDxStripStyle.$_optionName = \"stripStyle\";\nDxStripStyle.$_expectedChildren = {\n    label: { isCollectionItem: false, optionName: \"label\" },\n    stripStyleLabel: { isCollectionItem: false, optionName: \"label\" }\n};\nvar DxStripStyleLabel = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:font\": null,\n        \"update:horizontalAlignment\": null,\n        \"update:verticalAlignment\": null,\n    },\n    props: {\n        font: Object,\n        horizontalAlignment: String,\n        verticalAlignment: String\n    }\n});\nexports.DxStripStyleLabel = DxStripStyleLabel;\nDxStripStyleLabel.$_optionName = \"label\";\nvar DxSubtitle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:font\": null,\n        \"update:offset\": null,\n        \"update:text\": null,\n        \"update:textOverflow\": null,\n        \"update:wordWrap\": null,\n    },\n    props: {\n        font: Object,\n        offset: Number,\n        text: String,\n        textOverflow: String,\n        wordWrap: String\n    }\n});\nexports.DxSubtitle = DxSubtitle;\nDxSubtitle.$_optionName = \"subtitle\";\nvar DxTick = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:length\": null,\n        \"update:opacity\": null,\n        \"update:shift\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        length: Number,\n        opacity: Number,\n        shift: Number,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxTick = DxTick;\nDxTick.$_optionName = \"tick\";\nvar DxTickInterval = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:days\": null,\n        \"update:hours\": null,\n        \"update:milliseconds\": null,\n        \"update:minutes\": null,\n        \"update:months\": null,\n        \"update:quarters\": null,\n        \"update:seconds\": null,\n        \"update:weeks\": null,\n        \"update:years\": null,\n    },\n    props: {\n        days: Number,\n        hours: Number,\n        milliseconds: Number,\n        minutes: Number,\n        months: Number,\n        quarters: Number,\n        seconds: Number,\n        weeks: Number,\n        years: Number\n    }\n});\nexports.DxTickInterval = DxTickInterval;\nDxTickInterval.$_optionName = \"tickInterval\";\nvar DxTitle = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:alignment\": null,\n        \"update:font\": null,\n        \"update:horizontalAlignment\": null,\n        \"update:margin\": null,\n        \"update:placeholderSize\": null,\n        \"update:subtitle\": null,\n        \"update:text\": null,\n        \"update:textOverflow\": null,\n        \"update:verticalAlignment\": null,\n        \"update:wordWrap\": null,\n    },\n    props: {\n        alignment: String,\n        font: Object,\n        horizontalAlignment: String,\n        margin: Number,\n        placeholderSize: Number,\n        subtitle: [Object, String],\n        text: String,\n        textOverflow: String,\n        verticalAlignment: String,\n        wordWrap: String\n    }\n});\nexports.DxTitle = DxTitle;\nDxTitle.$_optionName = \"title\";\nvar DxTooltip = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:argumentFormat\": null,\n        \"update:arrowLength\": null,\n        \"update:border\": null,\n        \"update:color\": null,\n        \"update:container\": null,\n        \"update:contentTemplate\": null,\n        \"update:cornerRadius\": null,\n        \"update:customizeTooltip\": null,\n        \"update:enabled\": null,\n        \"update:font\": null,\n        \"update:format\": null,\n        \"update:interactive\": null,\n        \"update:location\": null,\n        \"update:opacity\": null,\n        \"update:paddingLeftRight\": null,\n        \"update:paddingTopBottom\": null,\n        \"update:shadow\": null,\n        \"update:shared\": null,\n        \"update:zIndex\": null,\n    },\n    props: {\n        argumentFormat: [Object, Function, String],\n        arrowLength: Number,\n        border: Object,\n        color: String,\n        container: {},\n        contentTemplate: {},\n        cornerRadius: Number,\n        customizeTooltip: Function,\n        enabled: Boolean,\n        font: Object,\n        format: [Object, Function, String],\n        interactive: Boolean,\n        location: String,\n        opacity: Number,\n        paddingLeftRight: Number,\n        paddingTopBottom: Number,\n        shadow: Object,\n        shared: Boolean,\n        zIndex: Number\n    }\n});\nexports.DxTooltip = DxTooltip;\nDxTooltip.$_optionName = \"tooltip\";\nDxTooltip.$_expectedChildren = {\n    argumentFormat: { isCollectionItem: false, optionName: \"argumentFormat\" },\n    border: { isCollectionItem: false, optionName: \"border\" },\n    font: { isCollectionItem: false, optionName: \"font\" },\n    format: { isCollectionItem: false, optionName: \"format\" },\n    shadow: { isCollectionItem: false, optionName: \"shadow\" },\n    tooltipBorder: { isCollectionItem: false, optionName: \"border\" }\n};\nvar DxTooltipBorder = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:opacity\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        dashStyle: String,\n        opacity: Number,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxTooltipBorder = DxTooltipBorder;\nDxTooltipBorder.$_optionName = \"border\";\nvar DxUrl = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:rangeMaxPoint\": null,\n        \"update:rangeMinPoint\": null,\n    },\n    props: {\n        rangeMaxPoint: String,\n        rangeMinPoint: String\n    }\n});\nexports.DxUrl = DxUrl;\nDxUrl.$_optionName = \"url\";\nvar DxValueAxis = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:aggregatedPointsPosition\": null,\n        \"update:allowDecimals\": null,\n        \"update:autoBreaksEnabled\": null,\n        \"update:axisDivisionFactor\": null,\n        \"update:breaks\": null,\n        \"update:breakStyle\": null,\n        \"update:categories\": null,\n        \"update:color\": null,\n        \"update:constantLines\": null,\n        \"update:constantLineStyle\": null,\n        \"update:customPosition\": null,\n        \"update:discreteAxisDivisionMode\": null,\n        \"update:endOnTick\": null,\n        \"update:grid\": null,\n        \"update:inverted\": null,\n        \"update:label\": null,\n        \"update:linearThreshold\": null,\n        \"update:logarithmBase\": null,\n        \"update:maxAutoBreakCount\": null,\n        \"update:maxValueMargin\": null,\n        \"update:minorGrid\": null,\n        \"update:minorTick\": null,\n        \"update:minorTickCount\": null,\n        \"update:minorTickInterval\": null,\n        \"update:minValueMargin\": null,\n        \"update:minVisualRangeLength\": null,\n        \"update:multipleAxesSpacing\": null,\n        \"update:name\": null,\n        \"update:offset\": null,\n        \"update:opacity\": null,\n        \"update:pane\": null,\n        \"update:placeholderSize\": null,\n        \"update:position\": null,\n        \"update:showZero\": null,\n        \"update:strips\": null,\n        \"update:stripStyle\": null,\n        \"update:synchronizedValue\": null,\n        \"update:tick\": null,\n        \"update:tickInterval\": null,\n        \"update:title\": null,\n        \"update:type\": null,\n        \"update:valueMarginsEnabled\": null,\n        \"update:valueType\": null,\n        \"update:visible\": null,\n        \"update:visualRange\": null,\n        \"update:visualRangeUpdateMode\": null,\n        \"update:wholeRange\": null,\n        \"update:width\": null,\n    },\n    props: {\n        aggregatedPointsPosition: String,\n        allowDecimals: Boolean,\n        autoBreaksEnabled: Boolean,\n        axisDivisionFactor: Number,\n        breaks: Array,\n        breakStyle: Object,\n        categories: Array,\n        color: String,\n        constantLines: Array,\n        constantLineStyle: Object,\n        customPosition: {},\n        discreteAxisDivisionMode: String,\n        endOnTick: Boolean,\n        grid: Object,\n        inverted: Boolean,\n        label: Object,\n        linearThreshold: Number,\n        logarithmBase: Number,\n        maxAutoBreakCount: Number,\n        maxValueMargin: Number,\n        minorGrid: Object,\n        minorTick: Object,\n        minorTickCount: Number,\n        minorTickInterval: [Number, Object, String],\n        minValueMargin: Number,\n        minVisualRangeLength: [Number, Object, String],\n        multipleAxesSpacing: Number,\n        name: String,\n        offset: Number,\n        opacity: Number,\n        pane: String,\n        placeholderSize: Number,\n        position: String,\n        showZero: Boolean,\n        strips: Array,\n        stripStyle: Object,\n        synchronizedValue: Number,\n        tick: Object,\n        tickInterval: [Number, Object, String],\n        title: [Object, String],\n        type: String,\n        valueMarginsEnabled: Boolean,\n        valueType: String,\n        visible: Boolean,\n        visualRange: [Array, Object],\n        visualRangeUpdateMode: String,\n        wholeRange: [Array, Object],\n        width: Number\n    }\n});\nexports.DxValueAxis = DxValueAxis;\nDxValueAxis.$_optionName = \"valueAxis\";\nDxValueAxis.$_isCollectionItem = true;\nDxValueAxis.$_expectedChildren = {\n    axisConstantLineStyle: { isCollectionItem: false, optionName: \"constantLineStyle\" },\n    axisLabel: { isCollectionItem: false, optionName: \"label\" },\n    axisTitle: { isCollectionItem: false, optionName: \"title\" },\n    break: { isCollectionItem: true, optionName: \"breaks\" },\n    constantLine: { isCollectionItem: true, optionName: \"constantLines\" },\n    constantLineStyle: { isCollectionItem: false, optionName: \"constantLineStyle\" },\n    label: { isCollectionItem: false, optionName: \"label\" },\n    minorTickInterval: { isCollectionItem: false, optionName: \"minorTickInterval\" },\n    minVisualRangeLength: { isCollectionItem: false, optionName: \"minVisualRangeLength\" },\n    strip: { isCollectionItem: true, optionName: \"strips\" },\n    tickInterval: { isCollectionItem: false, optionName: \"tickInterval\" },\n    title: { isCollectionItem: false, optionName: \"title\" },\n    visualRange: { isCollectionItem: false, optionName: \"visualRange\" },\n    wholeRange: { isCollectionItem: false, optionName: \"wholeRange\" }\n};\nvar DxValueErrorBar = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:displayMode\": null,\n        \"update:edgeLength\": null,\n        \"update:highValueField\": null,\n        \"update:lineWidth\": null,\n        \"update:lowValueField\": null,\n        \"update:opacity\": null,\n        \"update:type\": null,\n        \"update:value\": null,\n    },\n    props: {\n        color: String,\n        displayMode: String,\n        edgeLength: Number,\n        highValueField: String,\n        lineWidth: Number,\n        lowValueField: String,\n        opacity: Number,\n        type: String,\n        value: Number\n    }\n});\nexports.DxValueErrorBar = DxValueErrorBar;\nDxValueErrorBar.$_optionName = \"valueErrorBar\";\nvar DxVerticalLine = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:color\": null,\n        \"update:dashStyle\": null,\n        \"update:label\": null,\n        \"update:opacity\": null,\n        \"update:visible\": null,\n        \"update:width\": null,\n    },\n    props: {\n        color: String,\n        dashStyle: String,\n        label: Object,\n        opacity: Number,\n        visible: Boolean,\n        width: Number\n    }\n});\nexports.DxVerticalLine = DxVerticalLine;\nDxVerticalLine.$_optionName = \"verticalLine\";\nDxVerticalLine.$_expectedChildren = {\n    horizontalLineLabel: { isCollectionItem: false, optionName: \"label\" },\n    label: { isCollectionItem: false, optionName: \"label\" }\n};\nvar DxVisualRange = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:endValue\": null,\n        \"update:length\": null,\n        \"update:startValue\": null,\n    },\n    props: {\n        endValue: {},\n        length: [Number, Object, String],\n        startValue: {}\n    }\n});\nexports.DxVisualRange = DxVisualRange;\nDxVisualRange.$_optionName = \"visualRange\";\nvar DxWholeRange = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:endValue\": null,\n        \"update:length\": null,\n        \"update:startValue\": null,\n    },\n    props: {\n        endValue: {},\n        length: [Number, Object, String],\n        startValue: {}\n    }\n});\nexports.DxWholeRange = DxWholeRange;\nDxWholeRange.$_optionName = \"wholeRange\";\nvar DxWidth = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:rangeMaxPoint\": null,\n        \"update:rangeMinPoint\": null,\n    },\n    props: {\n        rangeMaxPoint: Number,\n        rangeMinPoint: Number\n    }\n});\nexports.DxWidth = DxWidth;\nDxWidth.$_optionName = \"width\";\nvar DxZoomAndPan = index_2.createConfigurationComponent({\n    emits: {\n        \"update:isActive\": null,\n        \"update:hoveredElement\": null,\n        \"update:allowMouseWheel\": null,\n        \"update:allowTouchGestures\": null,\n        \"update:argumentAxis\": null,\n        \"update:dragBoxStyle\": null,\n        \"update:dragToZoom\": null,\n        \"update:panKey\": null,\n        \"update:valueAxis\": null,\n    },\n    props: {\n        allowMouseWheel: Boolean,\n        allowTouchGestures: Boolean,\n        argumentAxis: String,\n        dragBoxStyle: Object,\n        dragToZoom: Boolean,\n        panKey: String,\n        valueAxis: String\n    }\n});\nexports.DxZoomAndPan = DxZoomAndPan;\nDxZoomAndPan.$_optionName = \"zoomAndPan\";\nDxZoomAndPan.$_expectedChildren = {\n    dragBoxStyle: { isCollectionItem: false, optionName: \"dragBoxStyle\" }\n};\nexports.default = DxChart;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS12dWUvY2hhcnQuanM/NTY2MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQU8sQ0FBQyx3RUFBc0I7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLGlFQUFjO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyxpRUFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQXdEO0FBQzdFLDBCQUEwQiwrQ0FBK0M7QUFDekUsWUFBWSwrQ0FBK0M7QUFDM0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQStDO0FBQ3pFLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnREFBZ0Q7QUFDdkUsYUFBYSxnREFBZ0Q7QUFDN0QsV0FBVyw4Q0FBOEM7QUFDekQsa0JBQWtCLCtDQUErQztBQUNqRSxhQUFhLGdEQUFnRDtBQUM3RCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUE4QztBQUN6RCwwQkFBMEIsa0RBQWtEO0FBQzVFLGFBQWEsZ0RBQWdEO0FBQzdELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnREFBZ0Q7QUFDN0QsaUJBQWlCLG9EQUFvRDtBQUNyRSxZQUFZLCtDQUErQztBQUMzRCxrQkFBa0IsZ0RBQWdEO0FBQ2xFLHNCQUFzQixvREFBb0Q7QUFDMUUsaUJBQWlCLCtDQUErQztBQUNoRSwwQkFBMEIsd0RBQXdEO0FBQ2xGLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnREFBZ0Q7QUFDN0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdEQUFnRDtBQUM3RCxVQUFVLDZDQUE2QztBQUN2RCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0RBQWdEO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQStDO0FBQzNELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQXdEO0FBQzdFLGFBQWEsZ0RBQWdEO0FBQzdELFdBQVcsOENBQThDO0FBQ3pELGFBQWEsZ0RBQWdEO0FBQzdELGFBQWEsZ0RBQWdEO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkRBQTJEO0FBQ3ZGLGdCQUFnQiwrQ0FBK0M7QUFDL0QsZ0JBQWdCLCtDQUErQztBQUMvRCxZQUFZLCtDQUErQztBQUMzRCxtQkFBbUIsc0RBQXNEO0FBQ3pFLHdCQUF3QiwyREFBMkQ7QUFDbkYsWUFBWSwrQ0FBK0M7QUFDM0Qsd0JBQXdCLDJEQUEyRDtBQUNuRiwyQkFBMkIsOERBQThEO0FBQ3pGLFlBQVksK0NBQStDO0FBQzNELG1CQUFtQixzREFBc0Q7QUFDekUsWUFBWSwrQ0FBK0M7QUFDM0Qsa0JBQWtCLHFEQUFxRDtBQUN2RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQ0FBK0M7QUFDekUsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS12dWUvY2hhcnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGRldmV4dHJlbWUtdnVlXG4gKiBWZXJzaW9uOiAyMS4yLjdcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXG4gKlxuICogVGhpcyBzb2Z0d2FyZSBtYXkgYmUgbW9kaWZpZWQgYW5kIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtc1xuICogb2YgdGhlIE1JVCBsaWNlbnNlLiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgcHJvamVjdCBmb3IgZGV0YWlscy5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vRGV2RXhwcmVzcy9kZXZleHRyZW1lLXZ1ZVxuICovXG5cblwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EeExlZ2VuZFRpdGxlID0gZXhwb3J0cy5EeExlZ2VuZCA9IGV4cG9ydHMuRHhMYWJlbCA9IGV4cG9ydHMuRHhJbWFnZSA9IGV4cG9ydHMuRHhIb3ZlclN0eWxlID0gZXhwb3J0cy5EeEhvcml6b250YWxMaW5lTGFiZWwgPSBleHBvcnRzLkR4SG9yaXpvbnRhbExpbmUgPSBleHBvcnRzLkR4SGVpZ2h0ID0gZXhwb3J0cy5EeEhhdGNoaW5nID0gZXhwb3J0cy5EeEdyaWQgPSBleHBvcnRzLkR4Rm9ybWF0ID0gZXhwb3J0cy5EeEZvbnQgPSBleHBvcnRzLkR4RXhwb3J0ID0gZXhwb3J0cy5EeERyYWdCb3hTdHlsZSA9IGV4cG9ydHMuRHhEYXRhUHJlcGFyZVNldHRpbmdzID0gZXhwb3J0cy5EeENyb3NzaGFpciA9IGV4cG9ydHMuRHhDb25zdGFudExpbmVTdHlsZSA9IGV4cG9ydHMuRHhDb25zdGFudExpbmVMYWJlbCA9IGV4cG9ydHMuRHhDb25zdGFudExpbmUgPSBleHBvcnRzLkR4Q29ubmVjdG9yID0gZXhwb3J0cy5EeENvbW1vblNlcmllc1NldHRpbmdzU2VsZWN0aW9uU3R5bGUgPSBleHBvcnRzLkR4Q29tbW9uU2VyaWVzU2V0dGluZ3NMYWJlbCA9IGV4cG9ydHMuRHhDb21tb25TZXJpZXNTZXR0aW5nc0hvdmVyU3R5bGUgPSBleHBvcnRzLkR4Q29tbW9uU2VyaWVzU2V0dGluZ3MgPSBleHBvcnRzLkR4Q29tbW9uUGFuZVNldHRpbmdzID0gZXhwb3J0cy5EeENvbW1vbkF4aXNTZXR0aW5nc1RpdGxlID0gZXhwb3J0cy5EeENvbW1vbkF4aXNTZXR0aW5nc0xhYmVsID0gZXhwb3J0cy5EeENvbW1vbkF4aXNTZXR0aW5nc0NvbnN0YW50TGluZVN0eWxlTGFiZWwgPSBleHBvcnRzLkR4Q29tbW9uQXhpc1NldHRpbmdzQ29uc3RhbnRMaW5lU3R5bGUgPSBleHBvcnRzLkR4Q29tbW9uQXhpc1NldHRpbmdzID0gZXhwb3J0cy5EeENvbW1vbkFubm90YXRpb25TZXR0aW5ncyA9IGV4cG9ydHMuRHhDaGFydFRpdGxlU3VidGl0bGUgPSBleHBvcnRzLkR4Q2hhcnRUaXRsZSA9IGV4cG9ydHMuRHhCcmVha1N0eWxlID0gZXhwb3J0cy5EeEJyZWFrID0gZXhwb3J0cy5EeEJvcmRlciA9IGV4cG9ydHMuRHhBeGlzVGl0bGUgPSBleHBvcnRzLkR4QXhpc0xhYmVsID0gZXhwb3J0cy5EeEF4aXNDb25zdGFudExpbmVTdHlsZUxhYmVsID0gZXhwb3J0cy5EeEF4aXNDb25zdGFudExpbmVTdHlsZSA9IGV4cG9ydHMuRHhBcmd1bWVudEZvcm1hdCA9IGV4cG9ydHMuRHhBcmd1bWVudEF4aXMgPSBleHBvcnRzLkR4QW5ub3RhdGlvbkltYWdlID0gZXhwb3J0cy5EeEFubm90YXRpb25Cb3JkZXIgPSBleHBvcnRzLkR4QW5ub3RhdGlvbiA9IGV4cG9ydHMuRHhBbmltYXRpb24gPSBleHBvcnRzLkR4QWdncmVnYXRpb25JbnRlcnZhbCA9IGV4cG9ydHMuRHhBZ2dyZWdhdGlvbiA9IGV4cG9ydHMuRHhBZGFwdGl2ZUxheW91dCA9IGV4cG9ydHMuRHhDaGFydCA9IHZvaWQgMDtcbmV4cG9ydHMuRHhab29tQW5kUGFuID0gZXhwb3J0cy5EeFdpZHRoID0gZXhwb3J0cy5EeFdob2xlUmFuZ2UgPSBleHBvcnRzLkR4VmlzdWFsUmFuZ2UgPSBleHBvcnRzLkR4VmVydGljYWxMaW5lID0gZXhwb3J0cy5EeFZhbHVlRXJyb3JCYXIgPSBleHBvcnRzLkR4VmFsdWVBeGlzID0gZXhwb3J0cy5EeFVybCA9IGV4cG9ydHMuRHhUb29sdGlwQm9yZGVyID0gZXhwb3J0cy5EeFRvb2x0aXAgPSBleHBvcnRzLkR4VGl0bGUgPSBleHBvcnRzLkR4VGlja0ludGVydmFsID0gZXhwb3J0cy5EeFRpY2sgPSBleHBvcnRzLkR4U3VidGl0bGUgPSBleHBvcnRzLkR4U3RyaXBTdHlsZUxhYmVsID0gZXhwb3J0cy5EeFN0cmlwU3R5bGUgPSBleHBvcnRzLkR4U3RyaXBMYWJlbCA9IGV4cG9ydHMuRHhTdHJpcCA9IGV4cG9ydHMuRHhTaXplID0gZXhwb3J0cy5EeFNoYWRvdyA9IGV4cG9ydHMuRHhTZXJpZXNUZW1wbGF0ZSA9IGV4cG9ydHMuRHhTZXJpZXNCb3JkZXIgPSBleHBvcnRzLkR4U2VyaWVzID0gZXhwb3J0cy5EeFNlbGVjdGlvblN0eWxlID0gZXhwb3J0cy5EeFNjcm9sbEJhciA9IGV4cG9ydHMuRHhSZWR1Y3Rpb24gPSBleHBvcnRzLkR4UG9pbnRTZWxlY3Rpb25TdHlsZSA9IGV4cG9ydHMuRHhQb2ludEltYWdlID0gZXhwb3J0cy5EeFBvaW50SG92ZXJTdHlsZSA9IGV4cG9ydHMuRHhQb2ludEJvcmRlciA9IGV4cG9ydHMuRHhQb2ludCA9IGV4cG9ydHMuRHhQYW5lQm9yZGVyID0gZXhwb3J0cy5EeFBhbmUgPSBleHBvcnRzLkR4TWluVmlzdWFsUmFuZ2VMZW5ndGggPSBleHBvcnRzLkR4TWlub3JUaWNrSW50ZXJ2YWwgPSBleHBvcnRzLkR4TWlub3JUaWNrID0gZXhwb3J0cy5EeE1pbm9yR3JpZCA9IGV4cG9ydHMuRHhNYXJnaW4gPSBleHBvcnRzLkR4TG9hZGluZ0luZGljYXRvciA9IGV4cG9ydHMuRHhMZW5ndGggPSBleHBvcnRzLkR4TGVnZW5kVGl0bGVTdWJ0aXRsZSA9IHZvaWQgMDtcbnZhciBjaGFydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZXZleHRyZW1lL3Zpei9jaGFydFwiKSk7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2NvcmUvaW5kZXhcIik7XG52YXIgaW5kZXhfMiA9IHJlcXVpcmUoXCIuL2NvcmUvaW5kZXhcIik7XG52YXIgRHhDaGFydCA9IGluZGV4XzEuY3JlYXRlQ29tcG9uZW50KHtcbiAgICBwcm9wczoge1xuICAgICAgICBhZGFwdGl2ZUxheW91dDogT2JqZWN0LFxuICAgICAgICBhZGp1c3RPblpvb206IEJvb2xlYW4sXG4gICAgICAgIGFuaW1hdGlvbjogW0Jvb2xlYW4sIE9iamVjdF0sXG4gICAgICAgIGFubm90YXRpb25zOiBBcnJheSxcbiAgICAgICAgYXJndW1lbnRBeGlzOiBPYmplY3QsXG4gICAgICAgIGF1dG9IaWRlUG9pbnRNYXJrZXJzOiBCb29sZWFuLFxuICAgICAgICBiYXJHcm91cFBhZGRpbmc6IE51bWJlcixcbiAgICAgICAgYmFyR3JvdXBXaWR0aDogTnVtYmVyLFxuICAgICAgICBjb21tb25Bbm5vdGF0aW9uU2V0dGluZ3M6IE9iamVjdCxcbiAgICAgICAgY29tbW9uQXhpc1NldHRpbmdzOiBPYmplY3QsXG4gICAgICAgIGNvbW1vblBhbmVTZXR0aW5nczogT2JqZWN0LFxuICAgICAgICBjb21tb25TZXJpZXNTZXR0aW5nczogT2JqZWN0LFxuICAgICAgICBjb250YWluZXJCYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgICAgICAgY3Jvc3NoYWlyOiBPYmplY3QsXG4gICAgICAgIGN1c3RvbWl6ZUFubm90YXRpb246IEZ1bmN0aW9uLFxuICAgICAgICBjdXN0b21pemVMYWJlbDogRnVuY3Rpb24sXG4gICAgICAgIGN1c3RvbWl6ZVBvaW50OiBGdW5jdGlvbixcbiAgICAgICAgZGF0YVByZXBhcmVTZXR0aW5nczogT2JqZWN0LFxuICAgICAgICBkYXRhU291cmNlOiBbQXJyYXksIE9iamVjdCwgU3RyaW5nXSxcbiAgICAgICAgZGVmYXVsdFBhbmU6IFN0cmluZyxcbiAgICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIGVsZW1lbnRBdHRyOiBPYmplY3QsXG4gICAgICAgIGV4cG9ydDogT2JqZWN0LFxuICAgICAgICBsZWdlbmQ6IE9iamVjdCxcbiAgICAgICAgbG9hZGluZ0luZGljYXRvcjogT2JqZWN0LFxuICAgICAgICBtYXJnaW46IE9iamVjdCxcbiAgICAgICAgbWF4QnViYmxlU2l6ZTogTnVtYmVyLFxuICAgICAgICBtaW5CdWJibGVTaXplOiBOdW1iZXIsXG4gICAgICAgIG5lZ2F0aXZlc0FzWmVyb2VzOiBCb29sZWFuLFxuICAgICAgICBvbkFyZ3VtZW50QXhpc0NsaWNrOiBGdW5jdGlvbixcbiAgICAgICAgb25EaXNwb3Npbmc6IEZ1bmN0aW9uLFxuICAgICAgICBvbkRvbmU6IEZ1bmN0aW9uLFxuICAgICAgICBvbkRyYXduOiBGdW5jdGlvbixcbiAgICAgICAgb25FeHBvcnRlZDogRnVuY3Rpb24sXG4gICAgICAgIG9uRXhwb3J0aW5nOiBGdW5jdGlvbixcbiAgICAgICAgb25GaWxlU2F2aW5nOiBGdW5jdGlvbixcbiAgICAgICAgb25JbmNpZGVudE9jY3VycmVkOiBGdW5jdGlvbixcbiAgICAgICAgb25Jbml0aWFsaXplZDogRnVuY3Rpb24sXG4gICAgICAgIG9uTGVnZW5kQ2xpY2s6IEZ1bmN0aW9uLFxuICAgICAgICBvbk9wdGlvbkNoYW5nZWQ6IEZ1bmN0aW9uLFxuICAgICAgICBvblBvaW50Q2xpY2s6IEZ1bmN0aW9uLFxuICAgICAgICBvblBvaW50SG92ZXJDaGFuZ2VkOiBGdW5jdGlvbixcbiAgICAgICAgb25Qb2ludFNlbGVjdGlvbkNoYW5nZWQ6IEZ1bmN0aW9uLFxuICAgICAgICBvblNlcmllc0NsaWNrOiBGdW5jdGlvbixcbiAgICAgICAgb25TZXJpZXNIb3ZlckNoYW5nZWQ6IEZ1bmN0aW9uLFxuICAgICAgICBvblNlcmllc1NlbGVjdGlvbkNoYW5nZWQ6IEZ1bmN0aW9uLFxuICAgICAgICBvblRvb2x0aXBIaWRkZW46IEZ1bmN0aW9uLFxuICAgICAgICBvblRvb2x0aXBTaG93bjogRnVuY3Rpb24sXG4gICAgICAgIG9uWm9vbUVuZDogRnVuY3Rpb24sXG4gICAgICAgIG9uWm9vbVN0YXJ0OiBGdW5jdGlvbixcbiAgICAgICAgcGFsZXR0ZTogW0FycmF5LCBTdHJpbmddLFxuICAgICAgICBwYWxldHRlRXh0ZW5zaW9uTW9kZTogU3RyaW5nLFxuICAgICAgICBwYW5lczogW0FycmF5LCBPYmplY3RdLFxuICAgICAgICBwYXRoTW9kaWZpZWQ6IEJvb2xlYW4sXG4gICAgICAgIHBvaW50U2VsZWN0aW9uTW9kZTogU3RyaW5nLFxuICAgICAgICByZWRyYXdPblJlc2l6ZTogQm9vbGVhbixcbiAgICAgICAgcmVzaXplUGFuZXNPblpvb206IEJvb2xlYW4sXG4gICAgICAgIHJlc29sdmVMYWJlbE92ZXJsYXBwaW5nOiBTdHJpbmcsXG4gICAgICAgIHJvdGF0ZWQ6IEJvb2xlYW4sXG4gICAgICAgIHJ0bEVuYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIHNjcm9sbEJhcjogT2JqZWN0LFxuICAgICAgICBzZXJpZXM6IFtBcnJheSwgT2JqZWN0XSxcbiAgICAgICAgc2VyaWVzU2VsZWN0aW9uTW9kZTogU3RyaW5nLFxuICAgICAgICBzZXJpZXNUZW1wbGF0ZTogT2JqZWN0LFxuICAgICAgICBzaXplOiBPYmplY3QsXG4gICAgICAgIHN0aWNreUhvdmVyaW5nOiBCb29sZWFuLFxuICAgICAgICBzeW5jaHJvbml6ZU11bHRpQXhlczogQm9vbGVhbixcbiAgICAgICAgdGhlbWU6IFN0cmluZyxcbiAgICAgICAgdGl0bGU6IFtPYmplY3QsIFN0cmluZ10sXG4gICAgICAgIHRvb2x0aXA6IE9iamVjdCxcbiAgICAgICAgdmFsdWVBeGlzOiBbQXJyYXksIE9iamVjdF0sXG4gICAgICAgIHpvb21BbmRQYW46IE9iamVjdFxuICAgIH0sXG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWRhcHRpdmVMYXlvdXRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWRqdXN0T25ab29tXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFuaW1hdGlvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphbm5vdGF0aW9uc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphcmd1bWVudEF4aXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YXV0b0hpZGVQb2ludE1hcmtlcnNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YmFyR3JvdXBQYWRkaW5nXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJhckdyb3VwV2lkdGhcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29tbW9uQW5ub3RhdGlvblNldHRpbmdzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbW1vbkF4aXNTZXR0aW5nc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb21tb25QYW5lU2V0dGluZ3NcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29tbW9uU2VyaWVzU2V0dGluZ3NcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29udGFpbmVyQmFja2dyb3VuZENvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNyb3NzaGFpclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjdXN0b21pemVBbm5vdGF0aW9uXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmN1c3RvbWl6ZUxhYmVsXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmN1c3RvbWl6ZVBvaW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRhdGFQcmVwYXJlU2V0dGluZ3NcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGF0YVNvdXJjZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkZWZhdWx0UGFuZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkaXNhYmxlZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTplbGVtZW50QXR0clwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpleHBvcnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bGVnZW5kXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmxvYWRpbmdJbmRpY2F0b3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWFyZ2luXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1heEJ1YmJsZVNpemVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWluQnViYmxlU2l6ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpuZWdhdGl2ZXNBc1plcm9lc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvbkFyZ3VtZW50QXhpc0NsaWNrXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uRGlzcG9zaW5nXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uRG9uZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvbkRyYXduXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uRXhwb3J0ZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b25FeHBvcnRpbmdcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b25GaWxlU2F2aW5nXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uSW5jaWRlbnRPY2N1cnJlZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvbkluaXRpYWxpemVkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uTGVnZW5kQ2xpY2tcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b25PcHRpb25DaGFuZ2VkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uUG9pbnRDbGlja1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvblBvaW50SG92ZXJDaGFuZ2VkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uUG9pbnRTZWxlY3Rpb25DaGFuZ2VkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uU2VyaWVzQ2xpY2tcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b25TZXJpZXNIb3ZlckNoYW5nZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b25TZXJpZXNTZWxlY3Rpb25DaGFuZ2VkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9uVG9vbHRpcEhpZGRlblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvblRvb2x0aXBTaG93blwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvblpvb21FbmRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b25ab29tU3RhcnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cGFsZXR0ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwYWxldHRlRXh0ZW5zaW9uTW9kZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwYW5lc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwYXRoTW9kaWZpZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cG9pbnRTZWxlY3Rpb25Nb2RlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnJlZHJhd09uUmVzaXplXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnJlc2l6ZVBhbmVzT25ab29tXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnJlc29sdmVMYWJlbE92ZXJsYXBwaW5nXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnJvdGF0ZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cnRsRW5hYmxlZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzY3JvbGxCYXJcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2VyaWVzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNlcmllc1NlbGVjdGlvbk1vZGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2VyaWVzVGVtcGxhdGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2l6ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzdGlja3lIb3ZlcmluZ1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzeW5jaHJvbml6ZU11bHRpQXhlc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0aGVtZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0aXRsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0b29sdGlwXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZhbHVlQXhpc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp6b29tQW5kUGFuXCI6IG51bGwsXG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBpbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9pbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYmVmb3JlQ3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuJF9XaWRnZXRDbGFzcyA9IGNoYXJ0XzEuZGVmYXVsdDtcbiAgICAgICAgdGhpcy4kX2hhc0FzeW5jVGVtcGxhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLiRfZXhwZWN0ZWRDaGlsZHJlbiA9IHtcbiAgICAgICAgICAgIGFkYXB0aXZlTGF5b3V0OiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImFkYXB0aXZlTGF5b3V0XCIgfSxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJhbmltYXRpb25cIiB9LFxuICAgICAgICAgICAgYW5ub3RhdGlvbjogeyBpc0NvbGxlY3Rpb25JdGVtOiB0cnVlLCBvcHRpb25OYW1lOiBcImFubm90YXRpb25zXCIgfSxcbiAgICAgICAgICAgIGFyZ3VtZW50QXhpczogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJhcmd1bWVudEF4aXNcIiB9LFxuICAgICAgICAgICAgY2hhcnRUaXRsZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJ0aXRsZVwiIH0sXG4gICAgICAgICAgICBjb21tb25Bbm5vdGF0aW9uU2V0dGluZ3M6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiY29tbW9uQW5ub3RhdGlvblNldHRpbmdzXCIgfSxcbiAgICAgICAgICAgIGNvbW1vbkF4aXNTZXR0aW5nczogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJjb21tb25BeGlzU2V0dGluZ3NcIiB9LFxuICAgICAgICAgICAgY29tbW9uUGFuZVNldHRpbmdzOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImNvbW1vblBhbmVTZXR0aW5nc1wiIH0sXG4gICAgICAgICAgICBjb21tb25TZXJpZXNTZXR0aW5nczogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJjb21tb25TZXJpZXNTZXR0aW5nc1wiIH0sXG4gICAgICAgICAgICBjcm9zc2hhaXI6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiY3Jvc3NoYWlyXCIgfSxcbiAgICAgICAgICAgIGRhdGFQcmVwYXJlU2V0dGluZ3M6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiZGF0YVByZXBhcmVTZXR0aW5nc1wiIH0sXG4gICAgICAgICAgICBleHBvcnQ6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiZXhwb3J0XCIgfSxcbiAgICAgICAgICAgIGxlZ2VuZDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJsZWdlbmRcIiB9LFxuICAgICAgICAgICAgbG9hZGluZ0luZGljYXRvcjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJsb2FkaW5nSW5kaWNhdG9yXCIgfSxcbiAgICAgICAgICAgIG1hcmdpbjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJtYXJnaW5cIiB9LFxuICAgICAgICAgICAgcGFuZTogeyBpc0NvbGxlY3Rpb25JdGVtOiB0cnVlLCBvcHRpb25OYW1lOiBcInBhbmVzXCIgfSxcbiAgICAgICAgICAgIHNjcm9sbEJhcjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJzY3JvbGxCYXJcIiB9LFxuICAgICAgICAgICAgc2VyaWVzOiB7IGlzQ29sbGVjdGlvbkl0ZW06IHRydWUsIG9wdGlvbk5hbWU6IFwic2VyaWVzXCIgfSxcbiAgICAgICAgICAgIHNlcmllc1RlbXBsYXRlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInNlcmllc1RlbXBsYXRlXCIgfSxcbiAgICAgICAgICAgIHNpemU6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwic2l6ZVwiIH0sXG4gICAgICAgICAgICB0aXRsZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJ0aXRsZVwiIH0sXG4gICAgICAgICAgICB0b29sdGlwOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInRvb2x0aXBcIiB9LFxuICAgICAgICAgICAgdmFsdWVBeGlzOiB7IGlzQ29sbGVjdGlvbkl0ZW06IHRydWUsIG9wdGlvbk5hbWU6IFwidmFsdWVBeGlzXCIgfSxcbiAgICAgICAgICAgIHpvb21BbmRQYW46IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiem9vbUFuZFBhblwiIH1cbiAgICAgICAgfTtcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhDaGFydCA9IER4Q2hhcnQ7XG52YXIgRHhBZGFwdGl2ZUxheW91dCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aGVpZ2h0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmtlZXBMYWJlbHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d2lkdGhcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGhlaWdodDogTnVtYmVyLFxuICAgICAgICBrZWVwTGFiZWxzOiBCb29sZWFuLFxuICAgICAgICB3aWR0aDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4QWRhcHRpdmVMYXlvdXQgPSBEeEFkYXB0aXZlTGF5b3V0O1xuRHhBZGFwdGl2ZUxheW91dC4kX29wdGlvbk5hbWUgPSBcImFkYXB0aXZlTGF5b3V0XCI7XG52YXIgRHhBZ2dyZWdhdGlvbiA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y2FsY3VsYXRlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmVuYWJsZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWV0aG9kXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBjYWxjdWxhdGU6IEZ1bmN0aW9uLFxuICAgICAgICBlbmFibGVkOiBCb29sZWFuLFxuICAgICAgICBtZXRob2Q6IFN0cmluZ1xuICAgIH1cbn0pO1xuZXhwb3J0cy5EeEFnZ3JlZ2F0aW9uID0gRHhBZ2dyZWdhdGlvbjtcbkR4QWdncmVnYXRpb24uJF9vcHRpb25OYW1lID0gXCJhZ2dyZWdhdGlvblwiO1xudmFyIER4QWdncmVnYXRpb25JbnRlcnZhbCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGF5c1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3Vyc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptaWxsaXNlY29uZHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWludXRlc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptb250aHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cXVhcnRlcnNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2Vjb25kc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3ZWVrc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp5ZWFyc1wiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZGF5czogTnVtYmVyLFxuICAgICAgICBob3VyczogTnVtYmVyLFxuICAgICAgICBtaWxsaXNlY29uZHM6IE51bWJlcixcbiAgICAgICAgbWludXRlczogTnVtYmVyLFxuICAgICAgICBtb250aHM6IE51bWJlcixcbiAgICAgICAgcXVhcnRlcnM6IE51bWJlcixcbiAgICAgICAgc2Vjb25kczogTnVtYmVyLFxuICAgICAgICB3ZWVrczogTnVtYmVyLFxuICAgICAgICB5ZWFyczogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4QWdncmVnYXRpb25JbnRlcnZhbCA9IER4QWdncmVnYXRpb25JbnRlcnZhbDtcbkR4QWdncmVnYXRpb25JbnRlcnZhbC4kX29wdGlvbk5hbWUgPSBcImFnZ3JlZ2F0aW9uSW50ZXJ2YWxcIjtcbnZhciBEeEFuaW1hdGlvbiA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZHVyYXRpb25cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZWFzaW5nXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmVuYWJsZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWF4UG9pbnRDb3VudFN1cHBvcnRlZFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZHVyYXRpb246IE51bWJlcixcbiAgICAgICAgZWFzaW5nOiBTdHJpbmcsXG4gICAgICAgIGVuYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIG1heFBvaW50Q291bnRTdXBwb3J0ZWQ6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeEFuaW1hdGlvbiA9IER4QW5pbWF0aW9uO1xuRHhBbmltYXRpb24uJF9vcHRpb25OYW1lID0gXCJhbmltYXRpb25cIjtcbnZhciBEeEFubm90YXRpb24gPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFsbG93RHJhZ2dpbmdcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YXJndW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YXJyb3dMZW5ndGhcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YXJyb3dXaWR0aFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpheGlzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJvcmRlclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjdXN0b21pemVUb29sdGlwXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRhdGFcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGVzY3JpcHRpb25cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9udFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpoZWlnaHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aW1hZ2VcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bmFtZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvZmZzZXRYXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9mZnNldFlcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b3BhY2l0eVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwYWRkaW5nTGVmdFJpZ2h0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBhZGRpbmdUb3BCb3R0b21cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2VyaWVzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNoYWRvd1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0ZW1wbGF0ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0ZXh0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRleHRPdmVyZmxvd1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0b29sdGlwRW5hYmxlZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0b29sdGlwVGVtcGxhdGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dHlwZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2YWx1ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3aWR0aFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3b3JkV3JhcFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp4XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnlcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFsbG93RHJhZ2dpbmc6IEJvb2xlYW4sXG4gICAgICAgIGFyZ3VtZW50OiB7fSxcbiAgICAgICAgYXJyb3dMZW5ndGg6IE51bWJlcixcbiAgICAgICAgYXJyb3dXaWR0aDogTnVtYmVyLFxuICAgICAgICBheGlzOiBTdHJpbmcsXG4gICAgICAgIGJvcmRlcjogT2JqZWN0LFxuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBjdXN0b21pemVUb29sdGlwOiBGdW5jdGlvbixcbiAgICAgICAgZGF0YToge30sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBTdHJpbmcsXG4gICAgICAgIGZvbnQ6IE9iamVjdCxcbiAgICAgICAgaGVpZ2h0OiBOdW1iZXIsXG4gICAgICAgIGltYWdlOiBbT2JqZWN0LCBTdHJpbmddLFxuICAgICAgICBuYW1lOiBTdHJpbmcsXG4gICAgICAgIG9mZnNldFg6IE51bWJlcixcbiAgICAgICAgb2Zmc2V0WTogTnVtYmVyLFxuICAgICAgICBvcGFjaXR5OiBOdW1iZXIsXG4gICAgICAgIHBhZGRpbmdMZWZ0UmlnaHQ6IE51bWJlcixcbiAgICAgICAgcGFkZGluZ1RvcEJvdHRvbTogTnVtYmVyLFxuICAgICAgICBzZXJpZXM6IFN0cmluZyxcbiAgICAgICAgc2hhZG93OiBPYmplY3QsXG4gICAgICAgIHRlbXBsYXRlOiB7fSxcbiAgICAgICAgdGV4dDogU3RyaW5nLFxuICAgICAgICB0ZXh0T3ZlcmZsb3c6IFN0cmluZyxcbiAgICAgICAgdG9vbHRpcEVuYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIHRvb2x0aXBUZW1wbGF0ZToge30sXG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6IHt9LFxuICAgICAgICB3aWR0aDogTnVtYmVyLFxuICAgICAgICB3b3JkV3JhcDogU3RyaW5nLFxuICAgICAgICB4OiBOdW1iZXIsXG4gICAgICAgIHk6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeEFubm90YXRpb24gPSBEeEFubm90YXRpb247XG5EeEFubm90YXRpb24uJF9vcHRpb25OYW1lID0gXCJhbm5vdGF0aW9uc1wiO1xuRHhBbm5vdGF0aW9uLiRfaXNDb2xsZWN0aW9uSXRlbSA9IHRydWU7XG5EeEFubm90YXRpb24uJF9leHBlY3RlZENoaWxkcmVuID0ge1xuICAgIGFubm90YXRpb25Cb3JkZXI6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiYm9yZGVyXCIgfSxcbiAgICBhbm5vdGF0aW9uSW1hZ2U6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiaW1hZ2VcIiB9LFxuICAgIGJvcmRlcjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJib3JkZXJcIiB9LFxuICAgIGZvbnQ6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiZm9udFwiIH0sXG4gICAgaW1hZ2U6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiaW1hZ2VcIiB9LFxuICAgIHNoYWRvdzogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJzaGFkb3dcIiB9XG59O1xudmFyIER4QW5ub3RhdGlvbkJvcmRlciA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29ybmVyUmFkaXVzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRhc2hTdHlsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvcGFjaXR5XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZpc2libGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d2lkdGhcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgICAgIGNvcm5lclJhZGl1czogTnVtYmVyLFxuICAgICAgICBkYXNoU3R5bGU6IFN0cmluZyxcbiAgICAgICAgb3BhY2l0eTogTnVtYmVyLFxuICAgICAgICB2aXNpYmxlOiBCb29sZWFuLFxuICAgICAgICB3aWR0aDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4QW5ub3RhdGlvbkJvcmRlciA9IER4QW5ub3RhdGlvbkJvcmRlcjtcbkR4QW5ub3RhdGlvbkJvcmRlci4kX29wdGlvbk5hbWUgPSBcImJvcmRlclwiO1xudmFyIER4QW5ub3RhdGlvbkltYWdlID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpoZWlnaHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dXJsXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBoZWlnaHQ6IE51bWJlcixcbiAgICAgICAgdXJsOiBTdHJpbmcsXG4gICAgICAgIHdpZHRoOiBOdW1iZXJcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhBbm5vdGF0aW9uSW1hZ2UgPSBEeEFubm90YXRpb25JbWFnZTtcbkR4QW5ub3RhdGlvbkltYWdlLiRfb3B0aW9uTmFtZSA9IFwiaW1hZ2VcIjtcbnZhciBEeEFyZ3VtZW50QXhpcyA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWdncmVnYXRlQnlDYXRlZ29yeVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphZ2dyZWdhdGVkUG9pbnRzUG9zaXRpb25cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWdncmVnYXRpb25Hcm91cFdpZHRoXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFnZ3JlZ2F0aW9uSW50ZXJ2YWxcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWxsb3dEZWNpbWFsc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphcmd1bWVudFR5cGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YXhpc0RpdmlzaW9uRmFjdG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJyZWFrc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpicmVha1N0eWxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNhdGVnb3JpZXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29uc3RhbnRMaW5lc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb25zdGFudExpbmVTdHlsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjdXN0b21Qb3NpdGlvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjdXN0b21Qb3NpdGlvbkF4aXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGlzY3JldGVBeGlzRGl2aXNpb25Nb2RlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmVuZE9uVGlja1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpncmlkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvbGlkYXlzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyTW9kZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTppbnZlcnRlZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpsYWJlbFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpsaW5lYXJUaHJlc2hvbGRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bG9nYXJpdGhtQmFzZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptYXhWYWx1ZU1hcmdpblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptaW5vckdyaWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWlub3JUaWNrXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1pbm9yVGlja0NvdW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1pbm9yVGlja0ludGVydmFsXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1pblZhbHVlTWFyZ2luXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1pblZpc3VhbFJhbmdlTGVuZ3RoXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9mZnNldFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvcGFjaXR5XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBsYWNlaG9sZGVyU2l6ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwb3NpdGlvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzaW5nbGVXb3JrZGF5c1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzdHJpcHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3RyaXBTdHlsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0aWNrXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRpY2tJbnRlcnZhbFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0aXRsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0eXBlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZhbHVlTWFyZ2luc0VuYWJsZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmlzaWJsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXN1YWxSYW5nZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXN1YWxSYW5nZVVwZGF0ZU1vZGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d2hvbGVSYW5nZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3aWR0aFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3b3JrZGF5c09ubHlcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d29ya1dlZWtcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFnZ3JlZ2F0ZUJ5Q2F0ZWdvcnk6IEJvb2xlYW4sXG4gICAgICAgIGFnZ3JlZ2F0ZWRQb2ludHNQb3NpdGlvbjogU3RyaW5nLFxuICAgICAgICBhZ2dyZWdhdGlvbkdyb3VwV2lkdGg6IE51bWJlcixcbiAgICAgICAgYWdncmVnYXRpb25JbnRlcnZhbDogW051bWJlciwgT2JqZWN0LCBTdHJpbmddLFxuICAgICAgICBhbGxvd0RlY2ltYWxzOiBCb29sZWFuLFxuICAgICAgICBhcmd1bWVudFR5cGU6IFN0cmluZyxcbiAgICAgICAgYXhpc0RpdmlzaW9uRmFjdG9yOiBOdW1iZXIsXG4gICAgICAgIGJyZWFrczogQXJyYXksXG4gICAgICAgIGJyZWFrU3R5bGU6IE9iamVjdCxcbiAgICAgICAgY2F0ZWdvcmllczogQXJyYXksXG4gICAgICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgICAgIGNvbnN0YW50TGluZXM6IEFycmF5LFxuICAgICAgICBjb25zdGFudExpbmVTdHlsZTogT2JqZWN0LFxuICAgICAgICBjdXN0b21Qb3NpdGlvbjoge30sXG4gICAgICAgIGN1c3RvbVBvc2l0aW9uQXhpczogU3RyaW5nLFxuICAgICAgICBkaXNjcmV0ZUF4aXNEaXZpc2lvbk1vZGU6IFN0cmluZyxcbiAgICAgICAgZW5kT25UaWNrOiBCb29sZWFuLFxuICAgICAgICBncmlkOiBPYmplY3QsXG4gICAgICAgIGhvbGlkYXlzOiBBcnJheSxcbiAgICAgICAgaG92ZXJNb2RlOiBTdHJpbmcsXG4gICAgICAgIGludmVydGVkOiBCb29sZWFuLFxuICAgICAgICBsYWJlbDogT2JqZWN0LFxuICAgICAgICBsaW5lYXJUaHJlc2hvbGQ6IE51bWJlcixcbiAgICAgICAgbG9nYXJpdGhtQmFzZTogTnVtYmVyLFxuICAgICAgICBtYXhWYWx1ZU1hcmdpbjogTnVtYmVyLFxuICAgICAgICBtaW5vckdyaWQ6IE9iamVjdCxcbiAgICAgICAgbWlub3JUaWNrOiBPYmplY3QsXG4gICAgICAgIG1pbm9yVGlja0NvdW50OiBOdW1iZXIsXG4gICAgICAgIG1pbm9yVGlja0ludGVydmFsOiBbTnVtYmVyLCBPYmplY3QsIFN0cmluZ10sXG4gICAgICAgIG1pblZhbHVlTWFyZ2luOiBOdW1iZXIsXG4gICAgICAgIG1pblZpc3VhbFJhbmdlTGVuZ3RoOiBbTnVtYmVyLCBPYmplY3QsIFN0cmluZ10sXG4gICAgICAgIG9mZnNldDogTnVtYmVyLFxuICAgICAgICBvcGFjaXR5OiBOdW1iZXIsXG4gICAgICAgIHBsYWNlaG9sZGVyU2l6ZTogTnVtYmVyLFxuICAgICAgICBwb3NpdGlvbjogU3RyaW5nLFxuICAgICAgICBzaW5nbGVXb3JrZGF5czogQXJyYXksXG4gICAgICAgIHN0cmlwczogQXJyYXksXG4gICAgICAgIHN0cmlwU3R5bGU6IE9iamVjdCxcbiAgICAgICAgdGljazogT2JqZWN0LFxuICAgICAgICB0aWNrSW50ZXJ2YWw6IFtOdW1iZXIsIE9iamVjdCwgU3RyaW5nXSxcbiAgICAgICAgdGl0bGU6IFtPYmplY3QsIFN0cmluZ10sXG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWVNYXJnaW5zRW5hYmxlZDogQm9vbGVhbixcbiAgICAgICAgdmlzaWJsZTogQm9vbGVhbixcbiAgICAgICAgdmlzdWFsUmFuZ2U6IFtBcnJheSwgT2JqZWN0XSxcbiAgICAgICAgdmlzdWFsUmFuZ2VVcGRhdGVNb2RlOiBTdHJpbmcsXG4gICAgICAgIHdob2xlUmFuZ2U6IFtBcnJheSwgT2JqZWN0XSxcbiAgICAgICAgd2lkdGg6IE51bWJlcixcbiAgICAgICAgd29ya2RheXNPbmx5OiBCb29sZWFuLFxuICAgICAgICB3b3JrV2VlazogQXJyYXlcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhBcmd1bWVudEF4aXMgPSBEeEFyZ3VtZW50QXhpcztcbkR4QXJndW1lbnRBeGlzLiRfb3B0aW9uTmFtZSA9IFwiYXJndW1lbnRBeGlzXCI7XG5EeEFyZ3VtZW50QXhpcy4kX2V4cGVjdGVkQ2hpbGRyZW4gPSB7XG4gICAgYWdncmVnYXRpb25JbnRlcnZhbDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJhZ2dyZWdhdGlvbkludGVydmFsXCIgfSxcbiAgICBheGlzQ29uc3RhbnRMaW5lU3R5bGU6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiY29uc3RhbnRMaW5lU3R5bGVcIiB9LFxuICAgIGF4aXNMYWJlbDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJsYWJlbFwiIH0sXG4gICAgYXhpc1RpdGxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInRpdGxlXCIgfSxcbiAgICBicmVhazogeyBpc0NvbGxlY3Rpb25JdGVtOiB0cnVlLCBvcHRpb25OYW1lOiBcImJyZWFrc1wiIH0sXG4gICAgYnJlYWtTdHlsZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJicmVha1N0eWxlXCIgfSxcbiAgICBjb25zdGFudExpbmU6IHsgaXNDb2xsZWN0aW9uSXRlbTogdHJ1ZSwgb3B0aW9uTmFtZTogXCJjb25zdGFudExpbmVzXCIgfSxcbiAgICBjb25zdGFudExpbmVTdHlsZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJjb25zdGFudExpbmVTdHlsZVwiIH0sXG4gICAgZ3JpZDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJncmlkXCIgfSxcbiAgICBsYWJlbDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJsYWJlbFwiIH0sXG4gICAgbWlub3JHcmlkOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcIm1pbm9yR3JpZFwiIH0sXG4gICAgbWlub3JUaWNrOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcIm1pbm9yVGlja1wiIH0sXG4gICAgbWlub3JUaWNrSW50ZXJ2YWw6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwibWlub3JUaWNrSW50ZXJ2YWxcIiB9LFxuICAgIG1pblZpc3VhbFJhbmdlTGVuZ3RoOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcIm1pblZpc3VhbFJhbmdlTGVuZ3RoXCIgfSxcbiAgICBzdHJpcDogeyBpc0NvbGxlY3Rpb25JdGVtOiB0cnVlLCBvcHRpb25OYW1lOiBcInN0cmlwc1wiIH0sXG4gICAgc3RyaXBTdHlsZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJzdHJpcFN0eWxlXCIgfSxcbiAgICB0aWNrOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInRpY2tcIiB9LFxuICAgIHRpY2tJbnRlcnZhbDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJ0aWNrSW50ZXJ2YWxcIiB9LFxuICAgIHRpdGxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInRpdGxlXCIgfSxcbiAgICB2aXN1YWxSYW5nZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJ2aXN1YWxSYW5nZVwiIH0sXG4gICAgd2hvbGVSYW5nZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJ3aG9sZVJhbmdlXCIgfVxufTtcbnZhciBEeEFyZ3VtZW50Rm9ybWF0ID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjdXJyZW5jeVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpmb3JtYXR0ZXJcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cGFyc2VyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnByZWNpc2lvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0eXBlXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBjdXJyZW5jeTogU3RyaW5nLFxuICAgICAgICBmb3JtYXR0ZXI6IEZ1bmN0aW9uLFxuICAgICAgICBwYXJzZXI6IEZ1bmN0aW9uLFxuICAgICAgICBwcmVjaXNpb246IE51bWJlcixcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgfVxufSk7XG5leHBvcnRzLkR4QXJndW1lbnRGb3JtYXQgPSBEeEFyZ3VtZW50Rm9ybWF0O1xuRHhBcmd1bWVudEZvcm1hdC4kX29wdGlvbk5hbWUgPSBcImFyZ3VtZW50Rm9ybWF0XCI7XG52YXIgRHhBeGlzQ29uc3RhbnRMaW5lU3R5bGUgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRhc2hTdHlsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpsYWJlbFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwYWRkaW5nTGVmdFJpZ2h0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBhZGRpbmdUb3BCb3R0b21cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d2lkdGhcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgICAgIGRhc2hTdHlsZTogU3RyaW5nLFxuICAgICAgICBsYWJlbDogT2JqZWN0LFxuICAgICAgICBwYWRkaW5nTGVmdFJpZ2h0OiBOdW1iZXIsXG4gICAgICAgIHBhZGRpbmdUb3BCb3R0b206IE51bWJlcixcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeEF4aXNDb25zdGFudExpbmVTdHlsZSA9IER4QXhpc0NvbnN0YW50TGluZVN0eWxlO1xuRHhBeGlzQ29uc3RhbnRMaW5lU3R5bGUuJF9vcHRpb25OYW1lID0gXCJjb25zdGFudExpbmVTdHlsZVwiO1xudmFyIER4QXhpc0NvbnN0YW50TGluZVN0eWxlTGFiZWwgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZvbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG9yaXpvbnRhbEFsaWdubWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwb3NpdGlvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2ZXJ0aWNhbEFsaWdubWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBmb250OiBPYmplY3QsXG4gICAgICAgIGhvcml6b250YWxBbGlnbm1lbnQ6IFN0cmluZyxcbiAgICAgICAgcG9zaXRpb246IFN0cmluZyxcbiAgICAgICAgdmVydGljYWxBbGlnbm1lbnQ6IFN0cmluZyxcbiAgICAgICAgdmlzaWJsZTogQm9vbGVhblxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeEF4aXNDb25zdGFudExpbmVTdHlsZUxhYmVsID0gRHhBeGlzQ29uc3RhbnRMaW5lU3R5bGVMYWJlbDtcbkR4QXhpc0NvbnN0YW50TGluZVN0eWxlTGFiZWwuJF9vcHRpb25OYW1lID0gXCJsYWJlbFwiO1xudmFyIER4QXhpc0xhYmVsID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphbGlnbm1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y3VzdG9taXplSGludFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjdXN0b21pemVUZXh0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRpc3BsYXlNb2RlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZvbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9ybWF0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmluZGVudEZyb21BeGlzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm92ZXJsYXBwaW5nQmVoYXZpb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cG9zaXRpb25cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cm90YXRpb25BbmdsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzdGFnZ2VyaW5nU3BhY2luZ1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0ZW1wbGF0ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0ZXh0T3ZlcmZsb3dcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmlzaWJsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3b3JkV3JhcFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWxpZ25tZW50OiBTdHJpbmcsXG4gICAgICAgIGN1c3RvbWl6ZUhpbnQ6IEZ1bmN0aW9uLFxuICAgICAgICBjdXN0b21pemVUZXh0OiBGdW5jdGlvbixcbiAgICAgICAgZGlzcGxheU1vZGU6IFN0cmluZyxcbiAgICAgICAgZm9udDogT2JqZWN0LFxuICAgICAgICBmb3JtYXQ6IFtPYmplY3QsIEZ1bmN0aW9uLCBTdHJpbmddLFxuICAgICAgICBpbmRlbnRGcm9tQXhpczogTnVtYmVyLFxuICAgICAgICBvdmVybGFwcGluZ0JlaGF2aW9yOiBTdHJpbmcsXG4gICAgICAgIHBvc2l0aW9uOiBTdHJpbmcsXG4gICAgICAgIHJvdGF0aW9uQW5nbGU6IE51bWJlcixcbiAgICAgICAgc3RhZ2dlcmluZ1NwYWNpbmc6IE51bWJlcixcbiAgICAgICAgdGVtcGxhdGU6IHt9LFxuICAgICAgICB0ZXh0T3ZlcmZsb3c6IFN0cmluZyxcbiAgICAgICAgdmlzaWJsZTogQm9vbGVhbixcbiAgICAgICAgd29yZFdyYXA6IFN0cmluZ1xuICAgIH1cbn0pO1xuZXhwb3J0cy5EeEF4aXNMYWJlbCA9IER4QXhpc0xhYmVsO1xuRHhBeGlzTGFiZWwuJF9vcHRpb25OYW1lID0gXCJsYWJlbFwiO1xudmFyIER4QXhpc1RpdGxlID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphbGlnbm1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9udFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptYXJnaW5cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGV4dFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0ZXh0T3ZlcmZsb3dcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d29yZFdyYXBcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFsaWdubWVudDogU3RyaW5nLFxuICAgICAgICBmb250OiBPYmplY3QsXG4gICAgICAgIG1hcmdpbjogTnVtYmVyLFxuICAgICAgICB0ZXh0OiBTdHJpbmcsXG4gICAgICAgIHRleHRPdmVyZmxvdzogU3RyaW5nLFxuICAgICAgICB3b3JkV3JhcDogU3RyaW5nXG4gICAgfVxufSk7XG5leHBvcnRzLkR4QXhpc1RpdGxlID0gRHhBeGlzVGl0bGU7XG5EeEF4aXNUaXRsZS4kX29wdGlvbk5hbWUgPSBcInRpdGxlXCI7XG52YXIgRHhCb3JkZXIgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJvdHRvbVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb3JuZXJSYWRpdXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGFzaFN0eWxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmxlZnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b3BhY2l0eVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpyaWdodFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0b3BcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmlzaWJsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3aWR0aFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYm90dG9tOiBCb29sZWFuLFxuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBjb3JuZXJSYWRpdXM6IE51bWJlcixcbiAgICAgICAgZGFzaFN0eWxlOiBTdHJpbmcsXG4gICAgICAgIGxlZnQ6IEJvb2xlYW4sXG4gICAgICAgIG9wYWNpdHk6IE51bWJlcixcbiAgICAgICAgcmlnaHQ6IEJvb2xlYW4sXG4gICAgICAgIHRvcDogQm9vbGVhbixcbiAgICAgICAgdmlzaWJsZTogQm9vbGVhbixcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeEJvcmRlciA9IER4Qm9yZGVyO1xuRHhCb3JkZXIuJF9vcHRpb25OYW1lID0gXCJib3JkZXJcIjtcbnZhciBEeEJyZWFrID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTplbmRWYWx1ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzdGFydFZhbHVlXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBlbmRWYWx1ZToge30sXG4gICAgICAgIHN0YXJ0VmFsdWU6IHt9XG4gICAgfVxufSk7XG5leHBvcnRzLkR4QnJlYWsgPSBEeEJyZWFrO1xuRHhCcmVhay4kX29wdGlvbk5hbWUgPSBcImJyZWFrc1wiO1xuRHhCcmVhay4kX2lzQ29sbGVjdGlvbkl0ZW0gPSB0cnVlO1xudmFyIER4QnJlYWtTdHlsZSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bGluZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3aWR0aFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IFN0cmluZyxcbiAgICAgICAgbGluZTogU3RyaW5nLFxuICAgICAgICB3aWR0aDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4QnJlYWtTdHlsZSA9IER4QnJlYWtTdHlsZTtcbkR4QnJlYWtTdHlsZS4kX29wdGlvbk5hbWUgPSBcImJyZWFrU3R5bGVcIjtcbnZhciBEeENoYXJ0VGl0bGUgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZvbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG9yaXpvbnRhbEFsaWdubWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptYXJnaW5cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cGxhY2Vob2xkZXJTaXplXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnN1YnRpdGxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRleHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGV4dE92ZXJmbG93XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZlcnRpY2FsQWxpZ25tZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndvcmRXcmFwXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBmb250OiBPYmplY3QsXG4gICAgICAgIGhvcml6b250YWxBbGlnbm1lbnQ6IFN0cmluZyxcbiAgICAgICAgbWFyZ2luOiBbTnVtYmVyLCBPYmplY3RdLFxuICAgICAgICBwbGFjZWhvbGRlclNpemU6IE51bWJlcixcbiAgICAgICAgc3VidGl0bGU6IFtPYmplY3QsIFN0cmluZ10sXG4gICAgICAgIHRleHQ6IFN0cmluZyxcbiAgICAgICAgdGV4dE92ZXJmbG93OiBTdHJpbmcsXG4gICAgICAgIHZlcnRpY2FsQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgICAgIHdvcmRXcmFwOiBTdHJpbmdcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhDaGFydFRpdGxlID0gRHhDaGFydFRpdGxlO1xuRHhDaGFydFRpdGxlLiRfb3B0aW9uTmFtZSA9IFwidGl0bGVcIjtcbkR4Q2hhcnRUaXRsZS4kX2V4cGVjdGVkQ2hpbGRyZW4gPSB7XG4gICAgY2hhcnRUaXRsZVN1YnRpdGxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInN1YnRpdGxlXCIgfSxcbiAgICBmb250OiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImZvbnRcIiB9LFxuICAgIG1hcmdpbjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJtYXJnaW5cIiB9LFxuICAgIHN1YnRpdGxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInN1YnRpdGxlXCIgfVxufTtcbnZhciBEeENoYXJ0VGl0bGVTdWJ0aXRsZSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9udFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvZmZzZXRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGV4dFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0ZXh0T3ZlcmZsb3dcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d29yZFdyYXBcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGZvbnQ6IE9iamVjdCxcbiAgICAgICAgb2Zmc2V0OiBOdW1iZXIsXG4gICAgICAgIHRleHQ6IFN0cmluZyxcbiAgICAgICAgdGV4dE92ZXJmbG93OiBTdHJpbmcsXG4gICAgICAgIHdvcmRXcmFwOiBTdHJpbmdcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhDaGFydFRpdGxlU3VidGl0bGUgPSBEeENoYXJ0VGl0bGVTdWJ0aXRsZTtcbkR4Q2hhcnRUaXRsZVN1YnRpdGxlLiRfb3B0aW9uTmFtZSA9IFwic3VidGl0bGVcIjtcbkR4Q2hhcnRUaXRsZVN1YnRpdGxlLiRfZXhwZWN0ZWRDaGlsZHJlbiA9IHtcbiAgICBmb250OiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImZvbnRcIiB9XG59O1xudmFyIER4Q29tbW9uQW5ub3RhdGlvblNldHRpbmdzID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphbGxvd0RyYWdnaW5nXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFyZ3VtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFycm93TGVuZ3RoXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFycm93V2lkdGhcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YXhpc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpib3JkZXJcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y3VzdG9taXplVG9vbHRpcFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkYXRhXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRlc2NyaXB0aW9uXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZvbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aGVpZ2h0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmltYWdlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9mZnNldFhcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b2Zmc2V0WVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvcGFjaXR5XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBhZGRpbmdMZWZ0UmlnaHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cGFkZGluZ1RvcEJvdHRvbVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzZXJpZXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2hhZG93XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRlbXBsYXRlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRleHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGV4dE92ZXJmbG93XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRvb2x0aXBFbmFibGVkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRvb2x0aXBUZW1wbGF0ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0eXBlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZhbHVlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndvcmRXcmFwXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnhcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6eVwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWxsb3dEcmFnZ2luZzogQm9vbGVhbixcbiAgICAgICAgYXJndW1lbnQ6IHt9LFxuICAgICAgICBhcnJvd0xlbmd0aDogTnVtYmVyLFxuICAgICAgICBhcnJvd1dpZHRoOiBOdW1iZXIsXG4gICAgICAgIGF4aXM6IFN0cmluZyxcbiAgICAgICAgYm9yZGVyOiBPYmplY3QsXG4gICAgICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgICAgIGN1c3RvbWl6ZVRvb2x0aXA6IEZ1bmN0aW9uLFxuICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgZGVzY3JpcHRpb246IFN0cmluZyxcbiAgICAgICAgZm9udDogT2JqZWN0LFxuICAgICAgICBoZWlnaHQ6IE51bWJlcixcbiAgICAgICAgaW1hZ2U6IFtPYmplY3QsIFN0cmluZ10sXG4gICAgICAgIG9mZnNldFg6IE51bWJlcixcbiAgICAgICAgb2Zmc2V0WTogTnVtYmVyLFxuICAgICAgICBvcGFjaXR5OiBOdW1iZXIsXG4gICAgICAgIHBhZGRpbmdMZWZ0UmlnaHQ6IE51bWJlcixcbiAgICAgICAgcGFkZGluZ1RvcEJvdHRvbTogTnVtYmVyLFxuICAgICAgICBzZXJpZXM6IFN0cmluZyxcbiAgICAgICAgc2hhZG93OiBPYmplY3QsXG4gICAgICAgIHRlbXBsYXRlOiB7fSxcbiAgICAgICAgdGV4dDogU3RyaW5nLFxuICAgICAgICB0ZXh0T3ZlcmZsb3c6IFN0cmluZyxcbiAgICAgICAgdG9vbHRpcEVuYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIHRvb2x0aXBUZW1wbGF0ZToge30sXG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6IHt9LFxuICAgICAgICB3aWR0aDogTnVtYmVyLFxuICAgICAgICB3b3JkV3JhcDogU3RyaW5nLFxuICAgICAgICB4OiBOdW1iZXIsXG4gICAgICAgIHk6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeENvbW1vbkFubm90YXRpb25TZXR0aW5ncyA9IER4Q29tbW9uQW5ub3RhdGlvblNldHRpbmdzO1xuRHhDb21tb25Bbm5vdGF0aW9uU2V0dGluZ3MuJF9vcHRpb25OYW1lID0gXCJjb21tb25Bbm5vdGF0aW9uU2V0dGluZ3NcIjtcbnZhciBEeENvbW1vbkF4aXNTZXR0aW5ncyA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWdncmVnYXRlZFBvaW50c1Bvc2l0aW9uXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFsbG93RGVjaW1hbHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YnJlYWtTdHlsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb25zdGFudExpbmVTdHlsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkaXNjcmV0ZUF4aXNEaXZpc2lvbk1vZGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZW5kT25UaWNrXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmdyaWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aW52ZXJ0ZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bGFiZWxcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWF4VmFsdWVNYXJnaW5cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWlub3JHcmlkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1pbm9yVGlja1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptaW5WYWx1ZU1hcmdpblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvcGFjaXR5XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBsYWNlaG9sZGVyU2l6ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzdHJpcFN0eWxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRpY2tcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGl0bGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmFsdWVNYXJnaW5zRW5hYmxlZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBhZ2dyZWdhdGVkUG9pbnRzUG9zaXRpb246IFN0cmluZyxcbiAgICAgICAgYWxsb3dEZWNpbWFsczogQm9vbGVhbixcbiAgICAgICAgYnJlYWtTdHlsZTogT2JqZWN0LFxuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBjb25zdGFudExpbmVTdHlsZTogT2JqZWN0LFxuICAgICAgICBkaXNjcmV0ZUF4aXNEaXZpc2lvbk1vZGU6IFN0cmluZyxcbiAgICAgICAgZW5kT25UaWNrOiBCb29sZWFuLFxuICAgICAgICBncmlkOiBPYmplY3QsXG4gICAgICAgIGludmVydGVkOiBCb29sZWFuLFxuICAgICAgICBsYWJlbDogT2JqZWN0LFxuICAgICAgICBtYXhWYWx1ZU1hcmdpbjogTnVtYmVyLFxuICAgICAgICBtaW5vckdyaWQ6IE9iamVjdCxcbiAgICAgICAgbWlub3JUaWNrOiBPYmplY3QsXG4gICAgICAgIG1pblZhbHVlTWFyZ2luOiBOdW1iZXIsXG4gICAgICAgIG9wYWNpdHk6IE51bWJlcixcbiAgICAgICAgcGxhY2Vob2xkZXJTaXplOiBOdW1iZXIsXG4gICAgICAgIHN0cmlwU3R5bGU6IE9iamVjdCxcbiAgICAgICAgdGljazogT2JqZWN0LFxuICAgICAgICB0aXRsZTogT2JqZWN0LFxuICAgICAgICB2YWx1ZU1hcmdpbnNFbmFibGVkOiBCb29sZWFuLFxuICAgICAgICB2aXNpYmxlOiBCb29sZWFuLFxuICAgICAgICB3aWR0aDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4Q29tbW9uQXhpc1NldHRpbmdzID0gRHhDb21tb25BeGlzU2V0dGluZ3M7XG5EeENvbW1vbkF4aXNTZXR0aW5ncy4kX29wdGlvbk5hbWUgPSBcImNvbW1vbkF4aXNTZXR0aW5nc1wiO1xuRHhDb21tb25BeGlzU2V0dGluZ3MuJF9leHBlY3RlZENoaWxkcmVuID0ge1xuICAgIGNvbW1vbkF4aXNTZXR0aW5nc0NvbnN0YW50TGluZVN0eWxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImNvbnN0YW50TGluZVN0eWxlXCIgfSxcbiAgICBjb21tb25BeGlzU2V0dGluZ3NMYWJlbDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJsYWJlbFwiIH0sXG4gICAgY29tbW9uQXhpc1NldHRpbmdzVGl0bGU6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwidGl0bGVcIiB9LFxuICAgIGNvbnN0YW50TGluZVN0eWxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImNvbnN0YW50TGluZVN0eWxlXCIgfSxcbiAgICBsYWJlbDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJsYWJlbFwiIH0sXG4gICAgdGl0bGU6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwidGl0bGVcIiB9XG59O1xudmFyIER4Q29tbW9uQXhpc1NldHRpbmdzQ29uc3RhbnRMaW5lU3R5bGUgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRhc2hTdHlsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpsYWJlbFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwYWRkaW5nTGVmdFJpZ2h0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBhZGRpbmdUb3BCb3R0b21cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d2lkdGhcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgICAgIGRhc2hTdHlsZTogU3RyaW5nLFxuICAgICAgICBsYWJlbDogT2JqZWN0LFxuICAgICAgICBwYWRkaW5nTGVmdFJpZ2h0OiBOdW1iZXIsXG4gICAgICAgIHBhZGRpbmdUb3BCb3R0b206IE51bWJlcixcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeENvbW1vbkF4aXNTZXR0aW5nc0NvbnN0YW50TGluZVN0eWxlID0gRHhDb21tb25BeGlzU2V0dGluZ3NDb25zdGFudExpbmVTdHlsZTtcbkR4Q29tbW9uQXhpc1NldHRpbmdzQ29uc3RhbnRMaW5lU3R5bGUuJF9vcHRpb25OYW1lID0gXCJjb25zdGFudExpbmVTdHlsZVwiO1xuRHhDb21tb25BeGlzU2V0dGluZ3NDb25zdGFudExpbmVTdHlsZS4kX2V4cGVjdGVkQ2hpbGRyZW4gPSB7XG4gICAgY29tbW9uQXhpc1NldHRpbmdzQ29uc3RhbnRMaW5lU3R5bGVMYWJlbDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJsYWJlbFwiIH0sXG4gICAgbGFiZWw6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwibGFiZWxcIiB9XG59O1xudmFyIER4Q29tbW9uQXhpc1NldHRpbmdzQ29uc3RhbnRMaW5lU3R5bGVMYWJlbCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9udFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwb3NpdGlvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBmb250OiBPYmplY3QsXG4gICAgICAgIHBvc2l0aW9uOiBTdHJpbmcsXG4gICAgICAgIHZpc2libGU6IEJvb2xlYW5cbiAgICB9XG59KTtcbmV4cG9ydHMuRHhDb21tb25BeGlzU2V0dGluZ3NDb25zdGFudExpbmVTdHlsZUxhYmVsID0gRHhDb21tb25BeGlzU2V0dGluZ3NDb25zdGFudExpbmVTdHlsZUxhYmVsO1xuRHhDb21tb25BeGlzU2V0dGluZ3NDb25zdGFudExpbmVTdHlsZUxhYmVsLiRfb3B0aW9uTmFtZSA9IFwibGFiZWxcIjtcbnZhciBEeENvbW1vbkF4aXNTZXR0aW5nc0xhYmVsID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphbGlnbm1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGlzcGxheU1vZGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9udFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTppbmRlbnRGcm9tQXhpc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvdmVybGFwcGluZ0JlaGF2aW9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBvc2l0aW9uXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnJvdGF0aW9uQW5nbGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3RhZ2dlcmluZ1NwYWNpbmdcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGVtcGxhdGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGV4dE92ZXJmbG93XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZpc2libGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d29yZFdyYXBcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFsaWdubWVudDogU3RyaW5nLFxuICAgICAgICBkaXNwbGF5TW9kZTogU3RyaW5nLFxuICAgICAgICBmb250OiBPYmplY3QsXG4gICAgICAgIGluZGVudEZyb21BeGlzOiBOdW1iZXIsXG4gICAgICAgIG92ZXJsYXBwaW5nQmVoYXZpb3I6IFN0cmluZyxcbiAgICAgICAgcG9zaXRpb246IFN0cmluZyxcbiAgICAgICAgcm90YXRpb25BbmdsZTogTnVtYmVyLFxuICAgICAgICBzdGFnZ2VyaW5nU3BhY2luZzogTnVtYmVyLFxuICAgICAgICB0ZW1wbGF0ZToge30sXG4gICAgICAgIHRleHRPdmVyZmxvdzogU3RyaW5nLFxuICAgICAgICB2aXNpYmxlOiBCb29sZWFuLFxuICAgICAgICB3b3JkV3JhcDogU3RyaW5nXG4gICAgfVxufSk7XG5leHBvcnRzLkR4Q29tbW9uQXhpc1NldHRpbmdzTGFiZWwgPSBEeENvbW1vbkF4aXNTZXR0aW5nc0xhYmVsO1xuRHhDb21tb25BeGlzU2V0dGluZ3NMYWJlbC4kX29wdGlvbk5hbWUgPSBcImxhYmVsXCI7XG52YXIgRHhDb21tb25BeGlzU2V0dGluZ3NUaXRsZSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWxpZ25tZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZvbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWFyZ2luXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRleHRPdmVyZmxvd1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3b3JkV3JhcFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWxpZ25tZW50OiBTdHJpbmcsXG4gICAgICAgIGZvbnQ6IE9iamVjdCxcbiAgICAgICAgbWFyZ2luOiBOdW1iZXIsXG4gICAgICAgIHRleHRPdmVyZmxvdzogU3RyaW5nLFxuICAgICAgICB3b3JkV3JhcDogU3RyaW5nXG4gICAgfVxufSk7XG5leHBvcnRzLkR4Q29tbW9uQXhpc1NldHRpbmdzVGl0bGUgPSBEeENvbW1vbkF4aXNTZXR0aW5nc1RpdGxlO1xuRHhDb21tb25BeGlzU2V0dGluZ3NUaXRsZS4kX29wdGlvbk5hbWUgPSBcInRpdGxlXCI7XG52YXIgRHhDb21tb25QYW5lU2V0dGluZ3MgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJhY2tncm91bmRDb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpib3JkZXJcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgICAgICBib3JkZXI6IE9iamVjdFxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeENvbW1vblBhbmVTZXR0aW5ncyA9IER4Q29tbW9uUGFuZVNldHRpbmdzO1xuRHhDb21tb25QYW5lU2V0dGluZ3MuJF9vcHRpb25OYW1lID0gXCJjb21tb25QYW5lU2V0dGluZ3NcIjtcbkR4Q29tbW9uUGFuZVNldHRpbmdzLiRfZXhwZWN0ZWRDaGlsZHJlbiA9IHtcbiAgICBib3JkZXI6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiYm9yZGVyXCIgfSxcbiAgICBwYW5lQm9yZGVyOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImJvcmRlclwiIH1cbn07XG52YXIgRHhDb21tb25TZXJpZXNTZXR0aW5ncyA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWdncmVnYXRpb25cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YXJlYVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphcmd1bWVudEZpZWxkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmF4aXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YmFyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJhck92ZXJsYXBHcm91cFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpiYXJQYWRkaW5nXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJhcldpZHRoXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJvcmRlclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpidWJibGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y2FuZGxlc3RpY2tcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y2xvc2VWYWx1ZUZpZWxkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvcm5lclJhZGl1c1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkYXNoU3R5bGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZnVsbHN0YWNrZWRhcmVhXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZ1bGxzdGFja2VkYmFyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZ1bGxzdGFja2VkbGluZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpmdWxsc3RhY2tlZHNwbGluZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpmdWxsc3RhY2tlZHNwbGluZWFyZWFcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aGlnaFZhbHVlRmllbGRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJNb2RlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyU3R5bGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aWdub3JlRW1wdHlQb2ludHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aW5uZXJDb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpsYWJlbFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpsaW5lXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmxvd1ZhbHVlRmllbGRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWF4TGFiZWxDb3VudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptaW5CYXJTaXplXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9wYWNpdHlcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b3BlblZhbHVlRmllbGRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cGFuZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwb2ludFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpyYW5nZWFyZWFcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cmFuZ2ViYXJcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cmFuZ2VWYWx1ZTFGaWVsZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpyYW5nZVZhbHVlMkZpZWxkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnJlZHVjdGlvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzY2F0dGVyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNlbGVjdGlvbk1vZGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2VsZWN0aW9uU3R5bGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2hvd0luTGVnZW5kXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNpemVGaWVsZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzcGxpbmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3BsaW5lYXJlYVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzdGFja1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzdGFja2VkYXJlYVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzdGFja2VkYmFyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnN0YWNrZWRsaW5lXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnN0YWNrZWRzcGxpbmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3RhY2tlZHNwbGluZWFyZWFcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3RlcGFyZWFcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3RlcGxpbmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3RvY2tcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGFnRmllbGRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dHlwZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2YWx1ZUVycm9yQmFyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZhbHVlRmllbGRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmlzaWJsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3aWR0aFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWdncmVnYXRpb246IE9iamVjdCxcbiAgICAgICAgYXJlYToge30sXG4gICAgICAgIGFyZ3VtZW50RmllbGQ6IFN0cmluZyxcbiAgICAgICAgYXhpczogU3RyaW5nLFxuICAgICAgICBiYXI6IHt9LFxuICAgICAgICBiYXJPdmVybGFwR3JvdXA6IFN0cmluZyxcbiAgICAgICAgYmFyUGFkZGluZzogTnVtYmVyLFxuICAgICAgICBiYXJXaWR0aDogTnVtYmVyLFxuICAgICAgICBib3JkZXI6IE9iamVjdCxcbiAgICAgICAgYnViYmxlOiB7fSxcbiAgICAgICAgY2FuZGxlc3RpY2s6IHt9LFxuICAgICAgICBjbG9zZVZhbHVlRmllbGQ6IFN0cmluZyxcbiAgICAgICAgY29sb3I6IFN0cmluZyxcbiAgICAgICAgY29ybmVyUmFkaXVzOiBOdW1iZXIsXG4gICAgICAgIGRhc2hTdHlsZTogU3RyaW5nLFxuICAgICAgICBmdWxsc3RhY2tlZGFyZWE6IHt9LFxuICAgICAgICBmdWxsc3RhY2tlZGJhcjoge30sXG4gICAgICAgIGZ1bGxzdGFja2VkbGluZToge30sXG4gICAgICAgIGZ1bGxzdGFja2Vkc3BsaW5lOiB7fSxcbiAgICAgICAgZnVsbHN0YWNrZWRzcGxpbmVhcmVhOiB7fSxcbiAgICAgICAgaGlnaFZhbHVlRmllbGQ6IFN0cmluZyxcbiAgICAgICAgaG92ZXJNb2RlOiBTdHJpbmcsXG4gICAgICAgIGhvdmVyU3R5bGU6IE9iamVjdCxcbiAgICAgICAgaWdub3JlRW1wdHlQb2ludHM6IEJvb2xlYW4sXG4gICAgICAgIGlubmVyQ29sb3I6IFN0cmluZyxcbiAgICAgICAgbGFiZWw6IE9iamVjdCxcbiAgICAgICAgbGluZToge30sXG4gICAgICAgIGxvd1ZhbHVlRmllbGQ6IFN0cmluZyxcbiAgICAgICAgbWF4TGFiZWxDb3VudDogTnVtYmVyLFxuICAgICAgICBtaW5CYXJTaXplOiBOdW1iZXIsXG4gICAgICAgIG9wYWNpdHk6IE51bWJlcixcbiAgICAgICAgb3BlblZhbHVlRmllbGQ6IFN0cmluZyxcbiAgICAgICAgcGFuZTogU3RyaW5nLFxuICAgICAgICBwb2ludDogT2JqZWN0LFxuICAgICAgICByYW5nZWFyZWE6IHt9LFxuICAgICAgICByYW5nZWJhcjoge30sXG4gICAgICAgIHJhbmdlVmFsdWUxRmllbGQ6IFN0cmluZyxcbiAgICAgICAgcmFuZ2VWYWx1ZTJGaWVsZDogU3RyaW5nLFxuICAgICAgICByZWR1Y3Rpb246IE9iamVjdCxcbiAgICAgICAgc2NhdHRlcjoge30sXG4gICAgICAgIHNlbGVjdGlvbk1vZGU6IFN0cmluZyxcbiAgICAgICAgc2VsZWN0aW9uU3R5bGU6IE9iamVjdCxcbiAgICAgICAgc2hvd0luTGVnZW5kOiBCb29sZWFuLFxuICAgICAgICBzaXplRmllbGQ6IFN0cmluZyxcbiAgICAgICAgc3BsaW5lOiB7fSxcbiAgICAgICAgc3BsaW5lYXJlYToge30sXG4gICAgICAgIHN0YWNrOiBTdHJpbmcsXG4gICAgICAgIHN0YWNrZWRhcmVhOiB7fSxcbiAgICAgICAgc3RhY2tlZGJhcjoge30sXG4gICAgICAgIHN0YWNrZWRsaW5lOiB7fSxcbiAgICAgICAgc3RhY2tlZHNwbGluZToge30sXG4gICAgICAgIHN0YWNrZWRzcGxpbmVhcmVhOiB7fSxcbiAgICAgICAgc3RlcGFyZWE6IHt9LFxuICAgICAgICBzdGVwbGluZToge30sXG4gICAgICAgIHN0b2NrOiB7fSxcbiAgICAgICAgdGFnRmllbGQ6IFN0cmluZyxcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZUVycm9yQmFyOiBPYmplY3QsXG4gICAgICAgIHZhbHVlRmllbGQ6IFN0cmluZyxcbiAgICAgICAgdmlzaWJsZTogQm9vbGVhbixcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeENvbW1vblNlcmllc1NldHRpbmdzID0gRHhDb21tb25TZXJpZXNTZXR0aW5ncztcbkR4Q29tbW9uU2VyaWVzU2V0dGluZ3MuJF9vcHRpb25OYW1lID0gXCJjb21tb25TZXJpZXNTZXR0aW5nc1wiO1xuRHhDb21tb25TZXJpZXNTZXR0aW5ncy4kX2V4cGVjdGVkQ2hpbGRyZW4gPSB7XG4gICAgYWdncmVnYXRpb246IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiYWdncmVnYXRpb25cIiB9LFxuICAgIGJvcmRlcjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJib3JkZXJcIiB9LFxuICAgIGNvbW1vblNlcmllc1NldHRpbmdzSG92ZXJTdHlsZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJob3ZlclN0eWxlXCIgfSxcbiAgICBjb21tb25TZXJpZXNTZXR0aW5nc0xhYmVsOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImxhYmVsXCIgfSxcbiAgICBjb21tb25TZXJpZXNTZXR0aW5nc1NlbGVjdGlvblN0eWxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInNlbGVjdGlvblN0eWxlXCIgfSxcbiAgICBob3ZlclN0eWxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImhvdmVyU3R5bGVcIiB9LFxuICAgIGxhYmVsOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImxhYmVsXCIgfSxcbiAgICBwb2ludDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJwb2ludFwiIH0sXG4gICAgcmVkdWN0aW9uOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInJlZHVjdGlvblwiIH0sXG4gICAgc2VsZWN0aW9uU3R5bGU6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwic2VsZWN0aW9uU3R5bGVcIiB9LFxuICAgIHNlcmllc0JvcmRlcjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJib3JkZXJcIiB9LFxuICAgIHZhbHVlRXJyb3JCYXI6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwidmFsdWVFcnJvckJhclwiIH1cbn07XG52YXIgRHhDb21tb25TZXJpZXNTZXR0aW5nc0hvdmVyU3R5bGUgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJvcmRlclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkYXNoU3R5bGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aGF0Y2hpbmdcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d2lkdGhcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGJvcmRlcjogT2JqZWN0LFxuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBkYXNoU3R5bGU6IFN0cmluZyxcbiAgICAgICAgaGF0Y2hpbmc6IE9iamVjdCxcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeENvbW1vblNlcmllc1NldHRpbmdzSG92ZXJTdHlsZSA9IER4Q29tbW9uU2VyaWVzU2V0dGluZ3NIb3ZlclN0eWxlO1xuRHhDb21tb25TZXJpZXNTZXR0aW5nc0hvdmVyU3R5bGUuJF9vcHRpb25OYW1lID0gXCJob3ZlclN0eWxlXCI7XG5EeENvbW1vblNlcmllc1NldHRpbmdzSG92ZXJTdHlsZS4kX2V4cGVjdGVkQ2hpbGRyZW4gPSB7XG4gICAgYm9yZGVyOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImJvcmRlclwiIH0sXG4gICAgaGF0Y2hpbmc6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiaGF0Y2hpbmdcIiB9LFxuICAgIHNlcmllc0JvcmRlcjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJib3JkZXJcIiB9XG59O1xudmFyIER4Q29tbW9uU2VyaWVzU2V0dGluZ3NMYWJlbCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWxpZ25tZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFyZ3VtZW50Rm9ybWF0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJhY2tncm91bmRDb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpib3JkZXJcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29ubmVjdG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmN1c3RvbWl6ZVRleHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9udFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpmb3JtYXRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG9yaXpvbnRhbE9mZnNldFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwb3NpdGlvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpyb3RhdGlvbkFuZ2xlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNob3dGb3JaZXJvVmFsdWVzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZlcnRpY2FsT2Zmc2V0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZpc2libGVcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFsaWdubWVudDogU3RyaW5nLFxuICAgICAgICBhcmd1bWVudEZvcm1hdDogW09iamVjdCwgRnVuY3Rpb24sIFN0cmluZ10sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgICAgICBib3JkZXI6IE9iamVjdCxcbiAgICAgICAgY29ubmVjdG9yOiBPYmplY3QsXG4gICAgICAgIGN1c3RvbWl6ZVRleHQ6IEZ1bmN0aW9uLFxuICAgICAgICBmb250OiBPYmplY3QsXG4gICAgICAgIGZvcm1hdDogW09iamVjdCwgRnVuY3Rpb24sIFN0cmluZ10sXG4gICAgICAgIGhvcml6b250YWxPZmZzZXQ6IE51bWJlcixcbiAgICAgICAgcG9zaXRpb246IFN0cmluZyxcbiAgICAgICAgcm90YXRpb25BbmdsZTogTnVtYmVyLFxuICAgICAgICBzaG93Rm9yWmVyb1ZhbHVlczogQm9vbGVhbixcbiAgICAgICAgdmVydGljYWxPZmZzZXQ6IE51bWJlcixcbiAgICAgICAgdmlzaWJsZTogQm9vbGVhblxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeENvbW1vblNlcmllc1NldHRpbmdzTGFiZWwgPSBEeENvbW1vblNlcmllc1NldHRpbmdzTGFiZWw7XG5EeENvbW1vblNlcmllc1NldHRpbmdzTGFiZWwuJF9vcHRpb25OYW1lID0gXCJsYWJlbFwiO1xuRHhDb21tb25TZXJpZXNTZXR0aW5nc0xhYmVsLiRfZXhwZWN0ZWRDaGlsZHJlbiA9IHtcbiAgICBhcmd1bWVudEZvcm1hdDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJhcmd1bWVudEZvcm1hdFwiIH0sXG4gICAgYm9yZGVyOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImJvcmRlclwiIH0sXG4gICAgY29ubmVjdG9yOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImNvbm5lY3RvclwiIH0sXG4gICAgZm9udDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJmb250XCIgfSxcbiAgICBmb3JtYXQ6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiZm9ybWF0XCIgfSxcbiAgICBzZXJpZXNCb3JkZXI6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiYm9yZGVyXCIgfVxufTtcbnZhciBEeENvbW1vblNlcmllc1NldHRpbmdzU2VsZWN0aW9uU3R5bGUgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJvcmRlclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkYXNoU3R5bGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aGF0Y2hpbmdcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d2lkdGhcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGJvcmRlcjogT2JqZWN0LFxuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBkYXNoU3R5bGU6IFN0cmluZyxcbiAgICAgICAgaGF0Y2hpbmc6IE9iamVjdCxcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeENvbW1vblNlcmllc1NldHRpbmdzU2VsZWN0aW9uU3R5bGUgPSBEeENvbW1vblNlcmllc1NldHRpbmdzU2VsZWN0aW9uU3R5bGU7XG5EeENvbW1vblNlcmllc1NldHRpbmdzU2VsZWN0aW9uU3R5bGUuJF9vcHRpb25OYW1lID0gXCJzZWxlY3Rpb25TdHlsZVwiO1xuRHhDb21tb25TZXJpZXNTZXR0aW5nc1NlbGVjdGlvblN0eWxlLiRfZXhwZWN0ZWRDaGlsZHJlbiA9IHtcbiAgICBib3JkZXI6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiYm9yZGVyXCIgfSxcbiAgICBoYXRjaGluZzogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJoYXRjaGluZ1wiIH0sXG4gICAgc2VyaWVzQm9yZGVyOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImJvcmRlclwiIH1cbn07XG52YXIgRHhDb25uZWN0b3IgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZpc2libGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d2lkdGhcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgICAgIHZpc2libGU6IEJvb2xlYW4sXG4gICAgICAgIHdpZHRoOiBOdW1iZXJcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhDb25uZWN0b3IgPSBEeENvbm5lY3RvcjtcbkR4Q29ubmVjdG9yLiRfb3B0aW9uTmFtZSA9IFwiY29ubmVjdG9yXCI7XG52YXIgRHhDb25zdGFudExpbmUgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRhc2hTdHlsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkaXNwbGF5QmVoaW5kU2VyaWVzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmV4dGVuZEF4aXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bGFiZWxcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cGFkZGluZ0xlZnRSaWdodFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwYWRkaW5nVG9wQm90dG9tXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZhbHVlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBkYXNoU3R5bGU6IFN0cmluZyxcbiAgICAgICAgZGlzcGxheUJlaGluZFNlcmllczogQm9vbGVhbixcbiAgICAgICAgZXh0ZW5kQXhpczogQm9vbGVhbixcbiAgICAgICAgbGFiZWw6IE9iamVjdCxcbiAgICAgICAgcGFkZGluZ0xlZnRSaWdodDogTnVtYmVyLFxuICAgICAgICBwYWRkaW5nVG9wQm90dG9tOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiB7fSxcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeENvbnN0YW50TGluZSA9IER4Q29uc3RhbnRMaW5lO1xuRHhDb25zdGFudExpbmUuJF9vcHRpb25OYW1lID0gXCJjb25zdGFudExpbmVzXCI7XG5EeENvbnN0YW50TGluZS4kX2lzQ29sbGVjdGlvbkl0ZW0gPSB0cnVlO1xudmFyIER4Q29uc3RhbnRMaW5lTGFiZWwgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZvbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG9yaXpvbnRhbEFsaWdubWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwb3NpdGlvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0ZXh0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZlcnRpY2FsQWxpZ25tZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZpc2libGVcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGZvbnQ6IE9iamVjdCxcbiAgICAgICAgaG9yaXpvbnRhbEFsaWdubWVudDogU3RyaW5nLFxuICAgICAgICBwb3NpdGlvbjogU3RyaW5nLFxuICAgICAgICB0ZXh0OiBTdHJpbmcsXG4gICAgICAgIHZlcnRpY2FsQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgICAgIHZpc2libGU6IEJvb2xlYW5cbiAgICB9XG59KTtcbmV4cG9ydHMuRHhDb25zdGFudExpbmVMYWJlbCA9IER4Q29uc3RhbnRMaW5lTGFiZWw7XG5EeENvbnN0YW50TGluZUxhYmVsLiRfb3B0aW9uTmFtZSA9IFwibGFiZWxcIjtcbnZhciBEeENvbnN0YW50TGluZVN0eWxlID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkYXNoU3R5bGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bGFiZWxcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cGFkZGluZ0xlZnRSaWdodFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwYWRkaW5nVG9wQm90dG9tXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBkYXNoU3R5bGU6IFN0cmluZyxcbiAgICAgICAgbGFiZWw6IE9iamVjdCxcbiAgICAgICAgcGFkZGluZ0xlZnRSaWdodDogTnVtYmVyLFxuICAgICAgICBwYWRkaW5nVG9wQm90dG9tOiBOdW1iZXIsXG4gICAgICAgIHdpZHRoOiBOdW1iZXJcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhDb25zdGFudExpbmVTdHlsZSA9IER4Q29uc3RhbnRMaW5lU3R5bGU7XG5EeENvbnN0YW50TGluZVN0eWxlLiRfb3B0aW9uTmFtZSA9IFwiY29uc3RhbnRMaW5lU3R5bGVcIjtcbnZhciBEeENyb3NzaGFpciA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGFzaFN0eWxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmVuYWJsZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG9yaXpvbnRhbExpbmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bGFiZWxcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b3BhY2l0eVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2ZXJ0aWNhbExpbmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d2lkdGhcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgICAgIGRhc2hTdHlsZTogU3RyaW5nLFxuICAgICAgICBlbmFibGVkOiBCb29sZWFuLFxuICAgICAgICBob3Jpem9udGFsTGluZTogW0Jvb2xlYW4sIE9iamVjdF0sXG4gICAgICAgIGxhYmVsOiBPYmplY3QsXG4gICAgICAgIG9wYWNpdHk6IE51bWJlcixcbiAgICAgICAgdmVydGljYWxMaW5lOiBbQm9vbGVhbiwgT2JqZWN0XSxcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeENyb3NzaGFpciA9IER4Q3Jvc3NoYWlyO1xuRHhDcm9zc2hhaXIuJF9vcHRpb25OYW1lID0gXCJjcm9zc2hhaXJcIjtcbkR4Q3Jvc3NoYWlyLiRfZXhwZWN0ZWRDaGlsZHJlbiA9IHtcbiAgICBob3Jpem9udGFsTGluZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJob3Jpem9udGFsTGluZVwiIH0sXG4gICAgaG9yaXpvbnRhbExpbmVMYWJlbDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJsYWJlbFwiIH0sXG4gICAgbGFiZWw6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwibGFiZWxcIiB9LFxuICAgIHZlcnRpY2FsTGluZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJ2ZXJ0aWNhbExpbmVcIiB9XG59O1xudmFyIER4RGF0YVByZXBhcmVTZXR0aW5ncyA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y2hlY2tUeXBlRm9yQWxsRGF0YVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb252ZXJ0VG9BeGlzRGF0YVR5cGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c29ydGluZ01ldGhvZFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY2hlY2tUeXBlRm9yQWxsRGF0YTogQm9vbGVhbixcbiAgICAgICAgY29udmVydFRvQXhpc0RhdGFUeXBlOiBCb29sZWFuLFxuICAgICAgICBzb3J0aW5nTWV0aG9kOiBbQm9vbGVhbiwgRnVuY3Rpb25dXG4gICAgfVxufSk7XG5leHBvcnRzLkR4RGF0YVByZXBhcmVTZXR0aW5ncyA9IER4RGF0YVByZXBhcmVTZXR0aW5ncztcbkR4RGF0YVByZXBhcmVTZXR0aW5ncy4kX29wdGlvbk5hbWUgPSBcImRhdGFQcmVwYXJlU2V0dGluZ3NcIjtcbnZhciBEeERyYWdCb3hTdHlsZSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b3BhY2l0eVwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IFN0cmluZyxcbiAgICAgICAgb3BhY2l0eTogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4RHJhZ0JveFN0eWxlID0gRHhEcmFnQm94U3R5bGU7XG5EeERyYWdCb3hTdHlsZS4kX29wdGlvbk5hbWUgPSBcImRyYWdCb3hTdHlsZVwiO1xudmFyIER4RXhwb3J0ID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpiYWNrZ3JvdW5kQ29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZW5hYmxlZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpmaWxlTmFtZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpmb3JtYXRzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1hcmdpblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwcmludGluZ0VuYWJsZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cHJveHlVcmxcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3ZnVG9DYW52YXNcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgICAgICBlbmFibGVkOiBCb29sZWFuLFxuICAgICAgICBmaWxlTmFtZTogU3RyaW5nLFxuICAgICAgICBmb3JtYXRzOiBBcnJheSxcbiAgICAgICAgbWFyZ2luOiBOdW1iZXIsXG4gICAgICAgIHByaW50aW5nRW5hYmxlZDogQm9vbGVhbixcbiAgICAgICAgcHJveHlVcmw6IFN0cmluZyxcbiAgICAgICAgc3ZnVG9DYW52YXM6IEZ1bmN0aW9uXG4gICAgfVxufSk7XG5leHBvcnRzLkR4RXhwb3J0ID0gRHhFeHBvcnQ7XG5EeEV4cG9ydC4kX29wdGlvbk5hbWUgPSBcImV4cG9ydFwiO1xudmFyIER4Rm9udCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZmFtaWx5XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9wYWNpdHlcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2l6ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3ZWlnaHRcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgICAgIGZhbWlseTogU3RyaW5nLFxuICAgICAgICBvcGFjaXR5OiBOdW1iZXIsXG4gICAgICAgIHNpemU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIHdlaWdodDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4Rm9udCA9IER4Rm9udDtcbkR4Rm9udC4kX29wdGlvbk5hbWUgPSBcImZvbnRcIjtcbnZhciBEeEZvcm1hdCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y3VycmVuY3lcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9ybWF0dGVyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBhcnNlclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwcmVjaXNpb25cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dHlwZVwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY3VycmVuY3k6IFN0cmluZyxcbiAgICAgICAgZm9ybWF0dGVyOiBGdW5jdGlvbixcbiAgICAgICAgcGFyc2VyOiBGdW5jdGlvbixcbiAgICAgICAgcHJlY2lzaW9uOiBOdW1iZXIsXG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH1cbn0pO1xuZXhwb3J0cy5EeEZvcm1hdCA9IER4Rm9ybWF0O1xuRHhGb3JtYXQuJF9vcHRpb25OYW1lID0gXCJmb3JtYXRcIjtcbnZhciBEeEdyaWQgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9wYWNpdHlcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmlzaWJsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3aWR0aFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IFN0cmluZyxcbiAgICAgICAgb3BhY2l0eTogTnVtYmVyLFxuICAgICAgICB2aXNpYmxlOiBCb29sZWFuLFxuICAgICAgICB3aWR0aDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4R3JpZCA9IER4R3JpZDtcbkR4R3JpZC4kX29wdGlvbk5hbWUgPSBcImdyaWRcIjtcbnZhciBEeEhhdGNoaW5nID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkaXJlY3Rpb25cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b3BhY2l0eVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzdGVwXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBkaXJlY3Rpb246IFN0cmluZyxcbiAgICAgICAgb3BhY2l0eTogTnVtYmVyLFxuICAgICAgICBzdGVwOiBOdW1iZXIsXG4gICAgICAgIHdpZHRoOiBOdW1iZXJcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhIYXRjaGluZyA9IER4SGF0Y2hpbmc7XG5EeEhhdGNoaW5nLiRfb3B0aW9uTmFtZSA9IFwiaGF0Y2hpbmdcIjtcbnZhciBEeEhlaWdodCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cmFuZ2VNYXhQb2ludFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpyYW5nZU1pblBvaW50XCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICByYW5nZU1heFBvaW50OiBOdW1iZXIsXG4gICAgICAgIHJhbmdlTWluUG9pbnQ6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeEhlaWdodCA9IER4SGVpZ2h0O1xuRHhIZWlnaHQuJF9vcHRpb25OYW1lID0gXCJoZWlnaHRcIjtcbnZhciBEeEhvcml6b250YWxMaW5lID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkYXNoU3R5bGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bGFiZWxcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b3BhY2l0eVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBkYXNoU3R5bGU6IFN0cmluZyxcbiAgICAgICAgbGFiZWw6IE9iamVjdCxcbiAgICAgICAgb3BhY2l0eTogTnVtYmVyLFxuICAgICAgICB2aXNpYmxlOiBCb29sZWFuLFxuICAgICAgICB3aWR0aDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4SG9yaXpvbnRhbExpbmUgPSBEeEhvcml6b250YWxMaW5lO1xuRHhIb3Jpem9udGFsTGluZS4kX29wdGlvbk5hbWUgPSBcImhvcml6b250YWxMaW5lXCI7XG5EeEhvcml6b250YWxMaW5lLiRfZXhwZWN0ZWRDaGlsZHJlbiA9IHtcbiAgICBob3Jpem9udGFsTGluZUxhYmVsOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImxhYmVsXCIgfSxcbiAgICBsYWJlbDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJsYWJlbFwiIH1cbn07XG52YXIgRHhIb3Jpem9udGFsTGluZUxhYmVsID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpiYWNrZ3JvdW5kQ29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y3VzdG9taXplVGV4dFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpmb250XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZvcm1hdFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgICAgICAgY3VzdG9taXplVGV4dDogRnVuY3Rpb24sXG4gICAgICAgIGZvbnQ6IE9iamVjdCxcbiAgICAgICAgZm9ybWF0OiBbT2JqZWN0LCBGdW5jdGlvbiwgU3RyaW5nXSxcbiAgICAgICAgdmlzaWJsZTogQm9vbGVhblxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeEhvcml6b250YWxMaW5lTGFiZWwgPSBEeEhvcml6b250YWxMaW5lTGFiZWw7XG5EeEhvcml6b250YWxMaW5lTGFiZWwuJF9vcHRpb25OYW1lID0gXCJsYWJlbFwiO1xudmFyIER4SG92ZXJTdHlsZSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Ym9yZGVyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRhc2hTdHlsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpoYXRjaGluZ1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzaXplXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBib3JkZXI6IE9iamVjdCxcbiAgICAgICAgY29sb3I6IFN0cmluZyxcbiAgICAgICAgZGFzaFN0eWxlOiBTdHJpbmcsXG4gICAgICAgIGhhdGNoaW5nOiBPYmplY3QsXG4gICAgICAgIHNpemU6IE51bWJlcixcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeEhvdmVyU3R5bGUgPSBEeEhvdmVyU3R5bGU7XG5EeEhvdmVyU3R5bGUuJF9vcHRpb25OYW1lID0gXCJob3ZlclN0eWxlXCI7XG52YXIgRHhJbWFnZSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aGVpZ2h0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnVybFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3aWR0aFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgaGVpZ2h0OiBOdW1iZXIsXG4gICAgICAgIHVybDogU3RyaW5nLFxuICAgICAgICB3aWR0aDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4SW1hZ2UgPSBEeEltYWdlO1xuRHhJbWFnZS4kX29wdGlvbk5hbWUgPSBcImltYWdlXCI7XG52YXIgRHhMYWJlbCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWxpZ25tZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFyZ3VtZW50Rm9ybWF0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJhY2tncm91bmRDb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpib3JkZXJcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29ubmVjdG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmN1c3RvbWl6ZUhpbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y3VzdG9taXplVGV4dFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkaXNwbGF5TW9kZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpmb250XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZvcm1hdFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3Jpem9udGFsQWxpZ25tZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvcml6b250YWxPZmZzZXRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aW5kZW50RnJvbUF4aXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b3ZlcmxhcHBpbmdCZWhhdmlvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwb3NpdGlvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpyb3RhdGlvbkFuZ2xlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNob3dGb3JaZXJvVmFsdWVzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnN0YWdnZXJpbmdTcGFjaW5nXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRlbXBsYXRlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRleHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGV4dE92ZXJmbG93XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZlcnRpY2FsQWxpZ25tZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZlcnRpY2FsT2Zmc2V0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZpc2libGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d29yZFdyYXBcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFsaWdubWVudDogU3RyaW5nLFxuICAgICAgICBhcmd1bWVudEZvcm1hdDogW09iamVjdCwgRnVuY3Rpb24sIFN0cmluZ10sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgICAgICBib3JkZXI6IE9iamVjdCxcbiAgICAgICAgY29ubmVjdG9yOiBPYmplY3QsXG4gICAgICAgIGN1c3RvbWl6ZUhpbnQ6IEZ1bmN0aW9uLFxuICAgICAgICBjdXN0b21pemVUZXh0OiBGdW5jdGlvbixcbiAgICAgICAgZGlzcGxheU1vZGU6IFN0cmluZyxcbiAgICAgICAgZm9udDogT2JqZWN0LFxuICAgICAgICBmb3JtYXQ6IFtPYmplY3QsIEZ1bmN0aW9uLCBTdHJpbmddLFxuICAgICAgICBob3Jpem9udGFsQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgICAgIGhvcml6b250YWxPZmZzZXQ6IE51bWJlcixcbiAgICAgICAgaW5kZW50RnJvbUF4aXM6IE51bWJlcixcbiAgICAgICAgb3ZlcmxhcHBpbmdCZWhhdmlvcjogU3RyaW5nLFxuICAgICAgICBwb3NpdGlvbjogU3RyaW5nLFxuICAgICAgICByb3RhdGlvbkFuZ2xlOiBOdW1iZXIsXG4gICAgICAgIHNob3dGb3JaZXJvVmFsdWVzOiBCb29sZWFuLFxuICAgICAgICBzdGFnZ2VyaW5nU3BhY2luZzogTnVtYmVyLFxuICAgICAgICB0ZW1wbGF0ZToge30sXG4gICAgICAgIHRleHQ6IFN0cmluZyxcbiAgICAgICAgdGV4dE92ZXJmbG93OiBTdHJpbmcsXG4gICAgICAgIHZlcnRpY2FsQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgICAgIHZlcnRpY2FsT2Zmc2V0OiBOdW1iZXIsXG4gICAgICAgIHZpc2libGU6IEJvb2xlYW4sXG4gICAgICAgIHdvcmRXcmFwOiBTdHJpbmdcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhMYWJlbCA9IER4TGFiZWw7XG5EeExhYmVsLiRfb3B0aW9uTmFtZSA9IFwibGFiZWxcIjtcbnZhciBEeExlZ2VuZCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YmFja2dyb3VuZENvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJvcmRlclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2x1bW5Db3VudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2x1bW5JdGVtU3BhY2luZ1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjdXN0b21pemVIaW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmN1c3RvbWl6ZUl0ZW1zXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmN1c3RvbWl6ZVRleHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9udFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3Jpem9udGFsQWxpZ25tZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyTW9kZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTppdGVtc0FsaWdubWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTppdGVtVGV4dFBvc2l0aW9uXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1hcmdpblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptYXJrZXJTaXplXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1hcmtlclRlbXBsYXRlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9yaWVudGF0aW9uXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBhZGRpbmdMZWZ0UmlnaHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cGFkZGluZ1RvcEJvdHRvbVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwb3NpdGlvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpyb3dDb3VudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpyb3dJdGVtU3BhY2luZ1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0aXRsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2ZXJ0aWNhbEFsaWdubWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgICAgICAgYm9yZGVyOiBPYmplY3QsXG4gICAgICAgIGNvbHVtbkNvdW50OiBOdW1iZXIsXG4gICAgICAgIGNvbHVtbkl0ZW1TcGFjaW5nOiBOdW1iZXIsXG4gICAgICAgIGN1c3RvbWl6ZUhpbnQ6IEZ1bmN0aW9uLFxuICAgICAgICBjdXN0b21pemVJdGVtczogRnVuY3Rpb24sXG4gICAgICAgIGN1c3RvbWl6ZVRleHQ6IEZ1bmN0aW9uLFxuICAgICAgICBmb250OiBPYmplY3QsXG4gICAgICAgIGhvcml6b250YWxBbGlnbm1lbnQ6IFN0cmluZyxcbiAgICAgICAgaG92ZXJNb2RlOiBTdHJpbmcsXG4gICAgICAgIGl0ZW1zQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgICAgIGl0ZW1UZXh0UG9zaXRpb246IFN0cmluZyxcbiAgICAgICAgbWFyZ2luOiBbTnVtYmVyLCBPYmplY3RdLFxuICAgICAgICBtYXJrZXJTaXplOiBOdW1iZXIsXG4gICAgICAgIG1hcmtlclRlbXBsYXRlOiB7fSxcbiAgICAgICAgb3JpZW50YXRpb246IFN0cmluZyxcbiAgICAgICAgcGFkZGluZ0xlZnRSaWdodDogTnVtYmVyLFxuICAgICAgICBwYWRkaW5nVG9wQm90dG9tOiBOdW1iZXIsXG4gICAgICAgIHBvc2l0aW9uOiBTdHJpbmcsXG4gICAgICAgIHJvd0NvdW50OiBOdW1iZXIsXG4gICAgICAgIHJvd0l0ZW1TcGFjaW5nOiBOdW1iZXIsXG4gICAgICAgIHRpdGxlOiBbT2JqZWN0LCBTdHJpbmddLFxuICAgICAgICB2ZXJ0aWNhbEFsaWdubWVudDogU3RyaW5nLFxuICAgICAgICB2aXNpYmxlOiBCb29sZWFuXG4gICAgfVxufSk7XG5leHBvcnRzLkR4TGVnZW5kID0gRHhMZWdlbmQ7XG5EeExlZ2VuZC4kX29wdGlvbk5hbWUgPSBcImxlZ2VuZFwiO1xuRHhMZWdlbmQuJF9leHBlY3RlZENoaWxkcmVuID0ge1xuICAgIGFubm90YXRpb25Cb3JkZXI6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiYm9yZGVyXCIgfSxcbiAgICBib3JkZXI6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiYm9yZGVyXCIgfSxcbiAgICBmb250OiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImZvbnRcIiB9LFxuICAgIGxlZ2VuZFRpdGxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInRpdGxlXCIgfSxcbiAgICBtYXJnaW46IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwibWFyZ2luXCIgfSxcbiAgICB0aXRsZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJ0aXRsZVwiIH1cbn07XG52YXIgRHhMZWdlbmRUaXRsZSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9udFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3Jpem9udGFsQWxpZ25tZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1hcmdpblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwbGFjZWhvbGRlclNpemVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3VidGl0bGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGV4dFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2ZXJ0aWNhbEFsaWdubWVudFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZm9udDogT2JqZWN0LFxuICAgICAgICBob3Jpem9udGFsQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgICAgIG1hcmdpbjogT2JqZWN0LFxuICAgICAgICBwbGFjZWhvbGRlclNpemU6IE51bWJlcixcbiAgICAgICAgc3VidGl0bGU6IFtPYmplY3QsIFN0cmluZ10sXG4gICAgICAgIHRleHQ6IFN0cmluZyxcbiAgICAgICAgdmVydGljYWxBbGlnbm1lbnQ6IFN0cmluZ1xuICAgIH1cbn0pO1xuZXhwb3J0cy5EeExlZ2VuZFRpdGxlID0gRHhMZWdlbmRUaXRsZTtcbkR4TGVnZW5kVGl0bGUuJF9vcHRpb25OYW1lID0gXCJ0aXRsZVwiO1xuRHhMZWdlbmRUaXRsZS4kX2V4cGVjdGVkQ2hpbGRyZW4gPSB7XG4gICAgZm9udDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJmb250XCIgfSxcbiAgICBsZWdlbmRUaXRsZVN1YnRpdGxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInN1YnRpdGxlXCIgfSxcbiAgICBtYXJnaW46IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwibWFyZ2luXCIgfSxcbiAgICBzdWJ0aXRsZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJzdWJ0aXRsZVwiIH1cbn07XG52YXIgRHhMZWdlbmRUaXRsZVN1YnRpdGxlID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpmb250XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9mZnNldFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0ZXh0XCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBmb250OiBPYmplY3QsXG4gICAgICAgIG9mZnNldDogTnVtYmVyLFxuICAgICAgICB0ZXh0OiBTdHJpbmdcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhMZWdlbmRUaXRsZVN1YnRpdGxlID0gRHhMZWdlbmRUaXRsZVN1YnRpdGxlO1xuRHhMZWdlbmRUaXRsZVN1YnRpdGxlLiRfb3B0aW9uTmFtZSA9IFwic3VidGl0bGVcIjtcbkR4TGVnZW5kVGl0bGVTdWJ0aXRsZS4kX2V4cGVjdGVkQ2hpbGRyZW4gPSB7XG4gICAgZm9udDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJmb250XCIgfVxufTtcbnZhciBEeExlbmd0aCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGF5c1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3Vyc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptaWxsaXNlY29uZHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWludXRlc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptb250aHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cXVhcnRlcnNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2Vjb25kc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3ZWVrc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp5ZWFyc1wiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZGF5czogTnVtYmVyLFxuICAgICAgICBob3VyczogTnVtYmVyLFxuICAgICAgICBtaWxsaXNlY29uZHM6IE51bWJlcixcbiAgICAgICAgbWludXRlczogTnVtYmVyLFxuICAgICAgICBtb250aHM6IE51bWJlcixcbiAgICAgICAgcXVhcnRlcnM6IE51bWJlcixcbiAgICAgICAgc2Vjb25kczogTnVtYmVyLFxuICAgICAgICB3ZWVrczogTnVtYmVyLFxuICAgICAgICB5ZWFyczogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4TGVuZ3RoID0gRHhMZW5ndGg7XG5EeExlbmd0aC4kX29wdGlvbk5hbWUgPSBcImxlbmd0aFwiO1xudmFyIER4TG9hZGluZ0luZGljYXRvciA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YmFja2dyb3VuZENvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmVuYWJsZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9udFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzaG93XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRleHRcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgICAgICBlbmFibGVkOiBCb29sZWFuLFxuICAgICAgICBmb250OiBPYmplY3QsXG4gICAgICAgIHNob3c6IEJvb2xlYW4sXG4gICAgICAgIHRleHQ6IFN0cmluZ1xuICAgIH1cbn0pO1xuZXhwb3J0cy5EeExvYWRpbmdJbmRpY2F0b3IgPSBEeExvYWRpbmdJbmRpY2F0b3I7XG5EeExvYWRpbmdJbmRpY2F0b3IuJF9vcHRpb25OYW1lID0gXCJsb2FkaW5nSW5kaWNhdG9yXCI7XG5EeExvYWRpbmdJbmRpY2F0b3IuJF9leHBlY3RlZENoaWxkcmVuID0ge1xuICAgIGZvbnQ6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiZm9udFwiIH1cbn07XG52YXIgRHhNYXJnaW4gPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJvdHRvbVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpsZWZ0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnJpZ2h0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRvcFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYm90dG9tOiBOdW1iZXIsXG4gICAgICAgIGxlZnQ6IE51bWJlcixcbiAgICAgICAgcmlnaHQ6IE51bWJlcixcbiAgICAgICAgdG9wOiBOdW1iZXJcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhNYXJnaW4gPSBEeE1hcmdpbjtcbkR4TWFyZ2luLiRfb3B0aW9uTmFtZSA9IFwibWFyZ2luXCI7XG52YXIgRHhNaW5vckdyaWQgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9wYWNpdHlcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmlzaWJsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3aWR0aFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IFN0cmluZyxcbiAgICAgICAgb3BhY2l0eTogTnVtYmVyLFxuICAgICAgICB2aXNpYmxlOiBCb29sZWFuLFxuICAgICAgICB3aWR0aDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4TWlub3JHcmlkID0gRHhNaW5vckdyaWQ7XG5EeE1pbm9yR3JpZC4kX29wdGlvbk5hbWUgPSBcIm1pbm9yR3JpZFwiO1xudmFyIER4TWlub3JUaWNrID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpsZW5ndGhcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b3BhY2l0eVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzaGlmdFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBsZW5ndGg6IE51bWJlcixcbiAgICAgICAgb3BhY2l0eTogTnVtYmVyLFxuICAgICAgICBzaGlmdDogTnVtYmVyLFxuICAgICAgICB2aXNpYmxlOiBCb29sZWFuLFxuICAgICAgICB3aWR0aDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4TWlub3JUaWNrID0gRHhNaW5vclRpY2s7XG5EeE1pbm9yVGljay4kX29wdGlvbk5hbWUgPSBcIm1pbm9yVGlja1wiO1xudmFyIER4TWlub3JUaWNrSW50ZXJ2YWwgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRheXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG91cnNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWlsbGlzZWNvbmRzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1pbnV0ZXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bW9udGhzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnF1YXJ0ZXJzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNlY29uZHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d2Vla3NcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6eWVhcnNcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGRheXM6IE51bWJlcixcbiAgICAgICAgaG91cnM6IE51bWJlcixcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBOdW1iZXIsXG4gICAgICAgIG1pbnV0ZXM6IE51bWJlcixcbiAgICAgICAgbW9udGhzOiBOdW1iZXIsXG4gICAgICAgIHF1YXJ0ZXJzOiBOdW1iZXIsXG4gICAgICAgIHNlY29uZHM6IE51bWJlcixcbiAgICAgICAgd2Vla3M6IE51bWJlcixcbiAgICAgICAgeWVhcnM6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeE1pbm9yVGlja0ludGVydmFsID0gRHhNaW5vclRpY2tJbnRlcnZhbDtcbkR4TWlub3JUaWNrSW50ZXJ2YWwuJF9vcHRpb25OYW1lID0gXCJtaW5vclRpY2tJbnRlcnZhbFwiO1xudmFyIER4TWluVmlzdWFsUmFuZ2VMZW5ndGggPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRheXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG91cnNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWlsbGlzZWNvbmRzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1pbnV0ZXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bW9udGhzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnF1YXJ0ZXJzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNlY29uZHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d2Vla3NcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6eWVhcnNcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGRheXM6IE51bWJlcixcbiAgICAgICAgaG91cnM6IE51bWJlcixcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBOdW1iZXIsXG4gICAgICAgIG1pbnV0ZXM6IE51bWJlcixcbiAgICAgICAgbW9udGhzOiBOdW1iZXIsXG4gICAgICAgIHF1YXJ0ZXJzOiBOdW1iZXIsXG4gICAgICAgIHNlY29uZHM6IE51bWJlcixcbiAgICAgICAgd2Vla3M6IE51bWJlcixcbiAgICAgICAgeWVhcnM6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeE1pblZpc3VhbFJhbmdlTGVuZ3RoID0gRHhNaW5WaXN1YWxSYW5nZUxlbmd0aDtcbkR4TWluVmlzdWFsUmFuZ2VMZW5ndGguJF9vcHRpb25OYW1lID0gXCJtaW5WaXN1YWxSYW5nZUxlbmd0aFwiO1xudmFyIER4UGFuZSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YmFja2dyb3VuZENvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJvcmRlclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpoZWlnaHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bmFtZVwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBTdHJpbmcsXG4gICAgICAgIGJvcmRlcjogT2JqZWN0LFxuICAgICAgICBoZWlnaHQ6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIG5hbWU6IFN0cmluZ1xuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFBhbmUgPSBEeFBhbmU7XG5EeFBhbmUuJF9vcHRpb25OYW1lID0gXCJwYW5lc1wiO1xuRHhQYW5lLiRfaXNDb2xsZWN0aW9uSXRlbSA9IHRydWU7XG52YXIgRHhQYW5lQm9yZGVyID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpib3R0b21cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGFzaFN0eWxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmxlZnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b3BhY2l0eVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpyaWdodFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0b3BcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmlzaWJsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3aWR0aFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYm90dG9tOiBCb29sZWFuLFxuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBkYXNoU3R5bGU6IFN0cmluZyxcbiAgICAgICAgbGVmdDogQm9vbGVhbixcbiAgICAgICAgb3BhY2l0eTogTnVtYmVyLFxuICAgICAgICByaWdodDogQm9vbGVhbixcbiAgICAgICAgdG9wOiBCb29sZWFuLFxuICAgICAgICB2aXNpYmxlOiBCb29sZWFuLFxuICAgICAgICB3aWR0aDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4UGFuZUJvcmRlciA9IER4UGFuZUJvcmRlcjtcbkR4UGFuZUJvcmRlci4kX29wdGlvbk5hbWUgPSBcImJvcmRlclwiO1xudmFyIER4UG9pbnQgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJvcmRlclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3Zlck1vZGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJTdHlsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTppbWFnZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzZWxlY3Rpb25Nb2RlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNlbGVjdGlvblN0eWxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNpemVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3ltYm9sXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZpc2libGVcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGJvcmRlcjogT2JqZWN0LFxuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBob3Zlck1vZGU6IFN0cmluZyxcbiAgICAgICAgaG92ZXJTdHlsZTogT2JqZWN0LFxuICAgICAgICBpbWFnZTogW09iamVjdCwgU3RyaW5nXSxcbiAgICAgICAgc2VsZWN0aW9uTW9kZTogU3RyaW5nLFxuICAgICAgICBzZWxlY3Rpb25TdHlsZTogT2JqZWN0LFxuICAgICAgICBzaXplOiBOdW1iZXIsXG4gICAgICAgIHN5bWJvbDogU3RyaW5nLFxuICAgICAgICB2aXNpYmxlOiBCb29sZWFuXG4gICAgfVxufSk7XG5leHBvcnRzLkR4UG9pbnQgPSBEeFBvaW50O1xuRHhQb2ludC4kX29wdGlvbk5hbWUgPSBcInBvaW50XCI7XG5EeFBvaW50LiRfZXhwZWN0ZWRDaGlsZHJlbiA9IHtcbiAgICBib3JkZXI6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiYm9yZGVyXCIgfSxcbiAgICBob3ZlclN0eWxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImhvdmVyU3R5bGVcIiB9LFxuICAgIGltYWdlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImltYWdlXCIgfSxcbiAgICBwb2ludEJvcmRlcjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJib3JkZXJcIiB9LFxuICAgIHBvaW50SG92ZXJTdHlsZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJob3ZlclN0eWxlXCIgfSxcbiAgICBwb2ludEltYWdlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImltYWdlXCIgfSxcbiAgICBwb2ludFNlbGVjdGlvblN0eWxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInNlbGVjdGlvblN0eWxlXCIgfSxcbiAgICBzZWxlY3Rpb25TdHlsZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJzZWxlY3Rpb25TdHlsZVwiIH1cbn07XG52YXIgRHhQb2ludEJvcmRlciA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmlzaWJsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3aWR0aFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IFN0cmluZyxcbiAgICAgICAgdmlzaWJsZTogQm9vbGVhbixcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFBvaW50Qm9yZGVyID0gRHhQb2ludEJvcmRlcjtcbkR4UG9pbnRCb3JkZXIuJF9vcHRpb25OYW1lID0gXCJib3JkZXJcIjtcbnZhciBEeFBvaW50SG92ZXJTdHlsZSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Ym9yZGVyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNpemVcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGJvcmRlcjogT2JqZWN0LFxuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBzaXplOiBOdW1iZXJcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhQb2ludEhvdmVyU3R5bGUgPSBEeFBvaW50SG92ZXJTdHlsZTtcbkR4UG9pbnRIb3ZlclN0eWxlLiRfb3B0aW9uTmFtZSA9IFwiaG92ZXJTdHlsZVwiO1xuRHhQb2ludEhvdmVyU3R5bGUuJF9leHBlY3RlZENoaWxkcmVuID0ge1xuICAgIGJvcmRlcjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJib3JkZXJcIiB9LFxuICAgIHBvaW50Qm9yZGVyOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImJvcmRlclwiIH1cbn07XG52YXIgRHhQb2ludEltYWdlID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpoZWlnaHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dXJsXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBoZWlnaHQ6IFtOdW1iZXIsIE9iamVjdF0sXG4gICAgICAgIHVybDogW09iamVjdCwgU3RyaW5nXSxcbiAgICAgICAgd2lkdGg6IFtOdW1iZXIsIE9iamVjdF1cbiAgICB9XG59KTtcbmV4cG9ydHMuRHhQb2ludEltYWdlID0gRHhQb2ludEltYWdlO1xuRHhQb2ludEltYWdlLiRfb3B0aW9uTmFtZSA9IFwiaW1hZ2VcIjtcbkR4UG9pbnRJbWFnZS4kX2V4cGVjdGVkQ2hpbGRyZW4gPSB7XG4gICAgaGVpZ2h0OiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImhlaWdodFwiIH0sXG4gICAgdXJsOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInVybFwiIH0sXG4gICAgd2lkdGg6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwid2lkdGhcIiB9XG59O1xudmFyIER4UG9pbnRTZWxlY3Rpb25TdHlsZSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Ym9yZGVyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNpemVcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGJvcmRlcjogT2JqZWN0LFxuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBzaXplOiBOdW1iZXJcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhQb2ludFNlbGVjdGlvblN0eWxlID0gRHhQb2ludFNlbGVjdGlvblN0eWxlO1xuRHhQb2ludFNlbGVjdGlvblN0eWxlLiRfb3B0aW9uTmFtZSA9IFwic2VsZWN0aW9uU3R5bGVcIjtcbkR4UG9pbnRTZWxlY3Rpb25TdHlsZS4kX2V4cGVjdGVkQ2hpbGRyZW4gPSB7XG4gICAgYm9yZGVyOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImJvcmRlclwiIH0sXG4gICAgcG9pbnRCb3JkZXI6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiYm9yZGVyXCIgfVxufTtcbnZhciBEeFJlZHVjdGlvbiA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bGV2ZWxcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgICAgIGxldmVsOiBTdHJpbmdcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhSZWR1Y3Rpb24gPSBEeFJlZHVjdGlvbjtcbkR4UmVkdWN0aW9uLiRfb3B0aW9uTmFtZSA9IFwicmVkdWN0aW9uXCI7XG52YXIgRHhTY3JvbGxCYXIgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9mZnNldFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvcGFjaXR5XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBvc2l0aW9uXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZpc2libGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d2lkdGhcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgICAgIG9mZnNldDogTnVtYmVyLFxuICAgICAgICBvcGFjaXR5OiBOdW1iZXIsXG4gICAgICAgIHBvc2l0aW9uOiBTdHJpbmcsXG4gICAgICAgIHZpc2libGU6IEJvb2xlYW4sXG4gICAgICAgIHdpZHRoOiBOdW1iZXJcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhTY3JvbGxCYXIgPSBEeFNjcm9sbEJhcjtcbkR4U2Nyb2xsQmFyLiRfb3B0aW9uTmFtZSA9IFwic2Nyb2xsQmFyXCI7XG52YXIgRHhTZWxlY3Rpb25TdHlsZSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Ym9yZGVyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRhc2hTdHlsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpoYXRjaGluZ1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzaXplXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBib3JkZXI6IE9iamVjdCxcbiAgICAgICAgY29sb3I6IFN0cmluZyxcbiAgICAgICAgZGFzaFN0eWxlOiBTdHJpbmcsXG4gICAgICAgIGhhdGNoaW5nOiBPYmplY3QsXG4gICAgICAgIHNpemU6IE51bWJlcixcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFNlbGVjdGlvblN0eWxlID0gRHhTZWxlY3Rpb25TdHlsZTtcbkR4U2VsZWN0aW9uU3R5bGUuJF9vcHRpb25OYW1lID0gXCJzZWxlY3Rpb25TdHlsZVwiO1xudmFyIER4U2VyaWVzID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphZ2dyZWdhdGlvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphcmd1bWVudEZpZWxkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmF4aXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YmFyT3ZlcmxhcEdyb3VwXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJhclBhZGRpbmdcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YmFyV2lkdGhcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Ym9yZGVyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNsb3NlVmFsdWVGaWVsZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb3JuZXJSYWRpdXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGFzaFN0eWxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhpZ2hWYWx1ZUZpZWxkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyTW9kZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlclN0eWxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmlnbm9yZUVtcHR5UG9pbnRzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmlubmVyQ29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bGFiZWxcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bG93VmFsdWVGaWVsZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptYXhMYWJlbENvdW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1pbkJhclNpemVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bmFtZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvcGFjaXR5XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9wZW5WYWx1ZUZpZWxkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBhbmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cG9pbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cmFuZ2VWYWx1ZTFGaWVsZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpyYW5nZVZhbHVlMkZpZWxkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnJlZHVjdGlvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzZWxlY3Rpb25Nb2RlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNlbGVjdGlvblN0eWxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNob3dJbkxlZ2VuZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzaXplRmllbGRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3RhY2tcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGFnXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRhZ0ZpZWxkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnR5cGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmFsdWVFcnJvckJhclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2YWx1ZUZpZWxkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZpc2libGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6d2lkdGhcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFnZ3JlZ2F0aW9uOiBPYmplY3QsXG4gICAgICAgIGFyZ3VtZW50RmllbGQ6IFN0cmluZyxcbiAgICAgICAgYXhpczogU3RyaW5nLFxuICAgICAgICBiYXJPdmVybGFwR3JvdXA6IFN0cmluZyxcbiAgICAgICAgYmFyUGFkZGluZzogTnVtYmVyLFxuICAgICAgICBiYXJXaWR0aDogTnVtYmVyLFxuICAgICAgICBib3JkZXI6IE9iamVjdCxcbiAgICAgICAgY2xvc2VWYWx1ZUZpZWxkOiBTdHJpbmcsXG4gICAgICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgICAgIGNvcm5lclJhZGl1czogTnVtYmVyLFxuICAgICAgICBkYXNoU3R5bGU6IFN0cmluZyxcbiAgICAgICAgaGlnaFZhbHVlRmllbGQ6IFN0cmluZyxcbiAgICAgICAgaG92ZXJNb2RlOiBTdHJpbmcsXG4gICAgICAgIGhvdmVyU3R5bGU6IE9iamVjdCxcbiAgICAgICAgaWdub3JlRW1wdHlQb2ludHM6IEJvb2xlYW4sXG4gICAgICAgIGlubmVyQ29sb3I6IFN0cmluZyxcbiAgICAgICAgbGFiZWw6IE9iamVjdCxcbiAgICAgICAgbG93VmFsdWVGaWVsZDogU3RyaW5nLFxuICAgICAgICBtYXhMYWJlbENvdW50OiBOdW1iZXIsXG4gICAgICAgIG1pbkJhclNpemU6IE51bWJlcixcbiAgICAgICAgbmFtZTogU3RyaW5nLFxuICAgICAgICBvcGFjaXR5OiBOdW1iZXIsXG4gICAgICAgIG9wZW5WYWx1ZUZpZWxkOiBTdHJpbmcsXG4gICAgICAgIHBhbmU6IFN0cmluZyxcbiAgICAgICAgcG9pbnQ6IE9iamVjdCxcbiAgICAgICAgcmFuZ2VWYWx1ZTFGaWVsZDogU3RyaW5nLFxuICAgICAgICByYW5nZVZhbHVlMkZpZWxkOiBTdHJpbmcsXG4gICAgICAgIHJlZHVjdGlvbjogT2JqZWN0LFxuICAgICAgICBzZWxlY3Rpb25Nb2RlOiBTdHJpbmcsXG4gICAgICAgIHNlbGVjdGlvblN0eWxlOiBPYmplY3QsXG4gICAgICAgIHNob3dJbkxlZ2VuZDogQm9vbGVhbixcbiAgICAgICAgc2l6ZUZpZWxkOiBTdHJpbmcsXG4gICAgICAgIHN0YWNrOiBTdHJpbmcsXG4gICAgICAgIHRhZzoge30sXG4gICAgICAgIHRhZ0ZpZWxkOiBTdHJpbmcsXG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWVFcnJvckJhcjogT2JqZWN0LFxuICAgICAgICB2YWx1ZUZpZWxkOiBTdHJpbmcsXG4gICAgICAgIHZpc2libGU6IEJvb2xlYW4sXG4gICAgICAgIHdpZHRoOiBOdW1iZXJcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhTZXJpZXMgPSBEeFNlcmllcztcbkR4U2VyaWVzLiRfb3B0aW9uTmFtZSA9IFwic2VyaWVzXCI7XG5EeFNlcmllcy4kX2lzQ29sbGVjdGlvbkl0ZW0gPSB0cnVlO1xudmFyIER4U2VyaWVzQm9yZGVyID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkYXNoU3R5bGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmlzaWJsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3aWR0aFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IFN0cmluZyxcbiAgICAgICAgZGFzaFN0eWxlOiBTdHJpbmcsXG4gICAgICAgIHZpc2libGU6IEJvb2xlYW4sXG4gICAgICAgIHdpZHRoOiBOdW1iZXJcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhTZXJpZXNCb3JkZXIgPSBEeFNlcmllc0JvcmRlcjtcbkR4U2VyaWVzQm9yZGVyLiRfb3B0aW9uTmFtZSA9IFwiYm9yZGVyXCI7XG52YXIgRHhTZXJpZXNUZW1wbGF0ZSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y3VzdG9taXplU2VyaWVzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm5hbWVGaWVsZFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY3VzdG9taXplU2VyaWVzOiBGdW5jdGlvbixcbiAgICAgICAgbmFtZUZpZWxkOiBTdHJpbmdcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhTZXJpZXNUZW1wbGF0ZSA9IER4U2VyaWVzVGVtcGxhdGU7XG5EeFNlcmllc1RlbXBsYXRlLiRfb3B0aW9uTmFtZSA9IFwic2VyaWVzVGVtcGxhdGVcIjtcbnZhciBEeFNoYWRvdyA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Ymx1clwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvZmZzZXRYXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9mZnNldFlcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b3BhY2l0eVwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYmx1cjogTnVtYmVyLFxuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBvZmZzZXRYOiBOdW1iZXIsXG4gICAgICAgIG9mZnNldFk6IE51bWJlcixcbiAgICAgICAgb3BhY2l0eTogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4U2hhZG93ID0gRHhTaGFkb3c7XG5EeFNoYWRvdy4kX29wdGlvbk5hbWUgPSBcInNoYWRvd1wiO1xudmFyIER4U2l6ZSA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aGVpZ2h0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBoZWlnaHQ6IE51bWJlcixcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFNpemUgPSBEeFNpemU7XG5EeFNpemUuJF9vcHRpb25OYW1lID0gXCJzaXplXCI7XG52YXIgRHhTdHJpcCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZW5kVmFsdWVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bGFiZWxcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cGFkZGluZ0xlZnRSaWdodFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwYWRkaW5nVG9wQm90dG9tXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnN0YXJ0VmFsdWVcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgICAgIGVuZFZhbHVlOiB7fSxcbiAgICAgICAgbGFiZWw6IE9iamVjdCxcbiAgICAgICAgcGFkZGluZ0xlZnRSaWdodDogTnVtYmVyLFxuICAgICAgICBwYWRkaW5nVG9wQm90dG9tOiBOdW1iZXIsXG4gICAgICAgIHN0YXJ0VmFsdWU6IHt9XG4gICAgfVxufSk7XG5leHBvcnRzLkR4U3RyaXAgPSBEeFN0cmlwO1xuRHhTdHJpcC4kX29wdGlvbk5hbWUgPSBcInN0cmlwc1wiO1xuRHhTdHJpcC4kX2lzQ29sbGVjdGlvbkl0ZW0gPSB0cnVlO1xudmFyIER4U3RyaXBMYWJlbCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9udFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3Jpem9udGFsQWxpZ25tZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRleHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmVydGljYWxBbGlnbm1lbnRcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGZvbnQ6IE9iamVjdCxcbiAgICAgICAgaG9yaXpvbnRhbEFsaWdubWVudDogU3RyaW5nLFxuICAgICAgICB0ZXh0OiBTdHJpbmcsXG4gICAgICAgIHZlcnRpY2FsQWxpZ25tZW50OiBTdHJpbmdcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhTdHJpcExhYmVsID0gRHhTdHJpcExhYmVsO1xuRHhTdHJpcExhYmVsLiRfb3B0aW9uTmFtZSA9IFwibGFiZWxcIjtcbnZhciBEeFN0cmlwU3R5bGUgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmxhYmVsXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBhZGRpbmdMZWZ0UmlnaHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cGFkZGluZ1RvcEJvdHRvbVwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgbGFiZWw6IE9iamVjdCxcbiAgICAgICAgcGFkZGluZ0xlZnRSaWdodDogTnVtYmVyLFxuICAgICAgICBwYWRkaW5nVG9wQm90dG9tOiBOdW1iZXJcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhTdHJpcFN0eWxlID0gRHhTdHJpcFN0eWxlO1xuRHhTdHJpcFN0eWxlLiRfb3B0aW9uTmFtZSA9IFwic3RyaXBTdHlsZVwiO1xuRHhTdHJpcFN0eWxlLiRfZXhwZWN0ZWRDaGlsZHJlbiA9IHtcbiAgICBsYWJlbDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJsYWJlbFwiIH0sXG4gICAgc3RyaXBTdHlsZUxhYmVsOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImxhYmVsXCIgfVxufTtcbnZhciBEeFN0cmlwU3R5bGVMYWJlbCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9udFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3Jpem9udGFsQWxpZ25tZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZlcnRpY2FsQWxpZ25tZW50XCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBmb250OiBPYmplY3QsXG4gICAgICAgIGhvcml6b250YWxBbGlnbm1lbnQ6IFN0cmluZyxcbiAgICAgICAgdmVydGljYWxBbGlnbm1lbnQ6IFN0cmluZ1xuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFN0cmlwU3R5bGVMYWJlbCA9IER4U3RyaXBTdHlsZUxhYmVsO1xuRHhTdHJpcFN0eWxlTGFiZWwuJF9vcHRpb25OYW1lID0gXCJsYWJlbFwiO1xudmFyIER4U3VidGl0bGUgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZvbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b2Zmc2V0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRleHRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGV4dE92ZXJmbG93XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndvcmRXcmFwXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBmb250OiBPYmplY3QsXG4gICAgICAgIG9mZnNldDogTnVtYmVyLFxuICAgICAgICB0ZXh0OiBTdHJpbmcsXG4gICAgICAgIHRleHRPdmVyZmxvdzogU3RyaW5nLFxuICAgICAgICB3b3JkV3JhcDogU3RyaW5nXG4gICAgfVxufSk7XG5leHBvcnRzLkR4U3VidGl0bGUgPSBEeFN1YnRpdGxlO1xuRHhTdWJ0aXRsZS4kX29wdGlvbk5hbWUgPSBcInN1YnRpdGxlXCI7XG52YXIgRHhUaWNrID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpsZW5ndGhcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b3BhY2l0eVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzaGlmdFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBsZW5ndGg6IE51bWJlcixcbiAgICAgICAgb3BhY2l0eTogTnVtYmVyLFxuICAgICAgICBzaGlmdDogTnVtYmVyLFxuICAgICAgICB2aXNpYmxlOiBCb29sZWFuLFxuICAgICAgICB3aWR0aDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4VGljayA9IER4VGljaztcbkR4VGljay4kX29wdGlvbk5hbWUgPSBcInRpY2tcIjtcbnZhciBEeFRpY2tJbnRlcnZhbCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGF5c1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3Vyc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptaWxsaXNlY29uZHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWludXRlc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptb250aHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cXVhcnRlcnNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2Vjb25kc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3ZWVrc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp5ZWFyc1wiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZGF5czogTnVtYmVyLFxuICAgICAgICBob3VyczogTnVtYmVyLFxuICAgICAgICBtaWxsaXNlY29uZHM6IE51bWJlcixcbiAgICAgICAgbWludXRlczogTnVtYmVyLFxuICAgICAgICBtb250aHM6IE51bWJlcixcbiAgICAgICAgcXVhcnRlcnM6IE51bWJlcixcbiAgICAgICAgc2Vjb25kczogTnVtYmVyLFxuICAgICAgICB3ZWVrczogTnVtYmVyLFxuICAgICAgICB5ZWFyczogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4VGlja0ludGVydmFsID0gRHhUaWNrSW50ZXJ2YWw7XG5EeFRpY2tJbnRlcnZhbC4kX29wdGlvbk5hbWUgPSBcInRpY2tJbnRlcnZhbFwiO1xudmFyIER4VGl0bGUgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFsaWdubWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpmb250XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvcml6b250YWxBbGlnbm1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWFyZ2luXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnBsYWNlaG9sZGVyU2l6ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzdWJ0aXRsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0ZXh0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnRleHRPdmVyZmxvd1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2ZXJ0aWNhbEFsaWdubWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3b3JkV3JhcFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWxpZ25tZW50OiBTdHJpbmcsXG4gICAgICAgIGZvbnQ6IE9iamVjdCxcbiAgICAgICAgaG9yaXpvbnRhbEFsaWdubWVudDogU3RyaW5nLFxuICAgICAgICBtYXJnaW46IE51bWJlcixcbiAgICAgICAgcGxhY2Vob2xkZXJTaXplOiBOdW1iZXIsXG4gICAgICAgIHN1YnRpdGxlOiBbT2JqZWN0LCBTdHJpbmddLFxuICAgICAgICB0ZXh0OiBTdHJpbmcsXG4gICAgICAgIHRleHRPdmVyZmxvdzogU3RyaW5nLFxuICAgICAgICB2ZXJ0aWNhbEFsaWdubWVudDogU3RyaW5nLFxuICAgICAgICB3b3JkV3JhcDogU3RyaW5nXG4gICAgfVxufSk7XG5leHBvcnRzLkR4VGl0bGUgPSBEeFRpdGxlO1xuRHhUaXRsZS4kX29wdGlvbk5hbWUgPSBcInRpdGxlXCI7XG52YXIgRHhUb29sdGlwID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphcmd1bWVudEZvcm1hdFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphcnJvd0xlbmd0aFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpib3JkZXJcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29udGFpbmVyXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNvbnRlbnRUZW1wbGF0ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb3JuZXJSYWRpdXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y3VzdG9taXplVG9vbHRpcFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTplbmFibGVkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmZvbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Zm9ybWF0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmludGVyYWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmxvY2F0aW9uXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9wYWNpdHlcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cGFkZGluZ0xlZnRSaWdodFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwYWRkaW5nVG9wQm90dG9tXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnNoYWRvd1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzaGFyZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ekluZGV4XCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBhcmd1bWVudEZvcm1hdDogW09iamVjdCwgRnVuY3Rpb24sIFN0cmluZ10sXG4gICAgICAgIGFycm93TGVuZ3RoOiBOdW1iZXIsXG4gICAgICAgIGJvcmRlcjogT2JqZWN0LFxuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBjb250YWluZXI6IHt9LFxuICAgICAgICBjb250ZW50VGVtcGxhdGU6IHt9LFxuICAgICAgICBjb3JuZXJSYWRpdXM6IE51bWJlcixcbiAgICAgICAgY3VzdG9taXplVG9vbHRpcDogRnVuY3Rpb24sXG4gICAgICAgIGVuYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIGZvbnQ6IE9iamVjdCxcbiAgICAgICAgZm9ybWF0OiBbT2JqZWN0LCBGdW5jdGlvbiwgU3RyaW5nXSxcbiAgICAgICAgaW50ZXJhY3RpdmU6IEJvb2xlYW4sXG4gICAgICAgIGxvY2F0aW9uOiBTdHJpbmcsXG4gICAgICAgIG9wYWNpdHk6IE51bWJlcixcbiAgICAgICAgcGFkZGluZ0xlZnRSaWdodDogTnVtYmVyLFxuICAgICAgICBwYWRkaW5nVG9wQm90dG9tOiBOdW1iZXIsXG4gICAgICAgIHNoYWRvdzogT2JqZWN0LFxuICAgICAgICBzaGFyZWQ6IEJvb2xlYW4sXG4gICAgICAgIHpJbmRleDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4VG9vbHRpcCA9IER4VG9vbHRpcDtcbkR4VG9vbHRpcC4kX29wdGlvbk5hbWUgPSBcInRvb2x0aXBcIjtcbkR4VG9vbHRpcC4kX2V4cGVjdGVkQ2hpbGRyZW4gPSB7XG4gICAgYXJndW1lbnRGb3JtYXQ6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiYXJndW1lbnRGb3JtYXRcIiB9LFxuICAgIGJvcmRlcjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJib3JkZXJcIiB9LFxuICAgIGZvbnQ6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwiZm9udFwiIH0sXG4gICAgZm9ybWF0OiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImZvcm1hdFwiIH0sXG4gICAgc2hhZG93OiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInNoYWRvd1wiIH0sXG4gICAgdG9vbHRpcEJvcmRlcjogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJib3JkZXJcIiB9XG59O1xudmFyIER4VG9vbHRpcEJvcmRlciA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGFzaFN0eWxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9wYWNpdHlcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmlzaWJsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3aWR0aFwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IFN0cmluZyxcbiAgICAgICAgZGFzaFN0eWxlOiBTdHJpbmcsXG4gICAgICAgIG9wYWNpdHk6IE51bWJlcixcbiAgICAgICAgdmlzaWJsZTogQm9vbGVhbixcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFRvb2x0aXBCb3JkZXIgPSBEeFRvb2x0aXBCb3JkZXI7XG5EeFRvb2x0aXBCb3JkZXIuJF9vcHRpb25OYW1lID0gXCJib3JkZXJcIjtcbnZhciBEeFVybCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cmFuZ2VNYXhQb2ludFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpyYW5nZU1pblBvaW50XCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICByYW5nZU1heFBvaW50OiBTdHJpbmcsXG4gICAgICAgIHJhbmdlTWluUG9pbnQ6IFN0cmluZ1xuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFVybCA9IER4VXJsO1xuRHhVcmwuJF9vcHRpb25OYW1lID0gXCJ1cmxcIjtcbnZhciBEeFZhbHVlQXhpcyA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWdncmVnYXRlZFBvaW50c1Bvc2l0aW9uXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFsbG93RGVjaW1hbHNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YXV0b0JyZWFrc0VuYWJsZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YXhpc0RpdmlzaW9uRmFjdG9yXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmJyZWFrc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpicmVha1N0eWxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmNhdGVnb3JpZXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29uc3RhbnRMaW5lc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb25zdGFudExpbmVTdHlsZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjdXN0b21Qb3NpdGlvblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkaXNjcmV0ZUF4aXNEaXZpc2lvbk1vZGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZW5kT25UaWNrXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmdyaWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aW52ZXJ0ZWRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bGFiZWxcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bGluZWFyVGhyZXNob2xkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmxvZ2FyaXRobUJhc2VcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWF4QXV0b0JyZWFrQ291bnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWF4VmFsdWVNYXJnaW5cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bWlub3JHcmlkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm1pbm9yVGlja1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptaW5vclRpY2tDb3VudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptaW5vclRpY2tJbnRlcnZhbFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptaW5WYWx1ZU1hcmdpblwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptaW5WaXN1YWxSYW5nZUxlbmd0aFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTptdWx0aXBsZUF4ZXNTcGFjaW5nXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm5hbWVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b2Zmc2V0XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOm9wYWNpdHlcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cGFuZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpwbGFjZWhvbGRlclNpemVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cG9zaXRpb25cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c2hvd1plcm9cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3RyaXBzXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnN0cmlwU3R5bGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3luY2hyb25pemVkVmFsdWVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGlja1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp0aWNrSW50ZXJ2YWxcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dGl0bGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dHlwZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2YWx1ZU1hcmdpbnNFbmFibGVkXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZhbHVlVHlwZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZpc3VhbFJhbmdlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZpc3VhbFJhbmdlVXBkYXRlTW9kZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp3aG9sZVJhbmdlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBhZ2dyZWdhdGVkUG9pbnRzUG9zaXRpb246IFN0cmluZyxcbiAgICAgICAgYWxsb3dEZWNpbWFsczogQm9vbGVhbixcbiAgICAgICAgYXV0b0JyZWFrc0VuYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIGF4aXNEaXZpc2lvbkZhY3RvcjogTnVtYmVyLFxuICAgICAgICBicmVha3M6IEFycmF5LFxuICAgICAgICBicmVha1N0eWxlOiBPYmplY3QsXG4gICAgICAgIGNhdGVnb3JpZXM6IEFycmF5LFxuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBjb25zdGFudExpbmVzOiBBcnJheSxcbiAgICAgICAgY29uc3RhbnRMaW5lU3R5bGU6IE9iamVjdCxcbiAgICAgICAgY3VzdG9tUG9zaXRpb246IHt9LFxuICAgICAgICBkaXNjcmV0ZUF4aXNEaXZpc2lvbk1vZGU6IFN0cmluZyxcbiAgICAgICAgZW5kT25UaWNrOiBCb29sZWFuLFxuICAgICAgICBncmlkOiBPYmplY3QsXG4gICAgICAgIGludmVydGVkOiBCb29sZWFuLFxuICAgICAgICBsYWJlbDogT2JqZWN0LFxuICAgICAgICBsaW5lYXJUaHJlc2hvbGQ6IE51bWJlcixcbiAgICAgICAgbG9nYXJpdGhtQmFzZTogTnVtYmVyLFxuICAgICAgICBtYXhBdXRvQnJlYWtDb3VudDogTnVtYmVyLFxuICAgICAgICBtYXhWYWx1ZU1hcmdpbjogTnVtYmVyLFxuICAgICAgICBtaW5vckdyaWQ6IE9iamVjdCxcbiAgICAgICAgbWlub3JUaWNrOiBPYmplY3QsXG4gICAgICAgIG1pbm9yVGlja0NvdW50OiBOdW1iZXIsXG4gICAgICAgIG1pbm9yVGlja0ludGVydmFsOiBbTnVtYmVyLCBPYmplY3QsIFN0cmluZ10sXG4gICAgICAgIG1pblZhbHVlTWFyZ2luOiBOdW1iZXIsXG4gICAgICAgIG1pblZpc3VhbFJhbmdlTGVuZ3RoOiBbTnVtYmVyLCBPYmplY3QsIFN0cmluZ10sXG4gICAgICAgIG11bHRpcGxlQXhlc1NwYWNpbmc6IE51bWJlcixcbiAgICAgICAgbmFtZTogU3RyaW5nLFxuICAgICAgICBvZmZzZXQ6IE51bWJlcixcbiAgICAgICAgb3BhY2l0eTogTnVtYmVyLFxuICAgICAgICBwYW5lOiBTdHJpbmcsXG4gICAgICAgIHBsYWNlaG9sZGVyU2l6ZTogTnVtYmVyLFxuICAgICAgICBwb3NpdGlvbjogU3RyaW5nLFxuICAgICAgICBzaG93WmVybzogQm9vbGVhbixcbiAgICAgICAgc3RyaXBzOiBBcnJheSxcbiAgICAgICAgc3RyaXBTdHlsZTogT2JqZWN0LFxuICAgICAgICBzeW5jaHJvbml6ZWRWYWx1ZTogTnVtYmVyLFxuICAgICAgICB0aWNrOiBPYmplY3QsXG4gICAgICAgIHRpY2tJbnRlcnZhbDogW051bWJlciwgT2JqZWN0LCBTdHJpbmddLFxuICAgICAgICB0aXRsZTogW09iamVjdCwgU3RyaW5nXSxcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZU1hcmdpbnNFbmFibGVkOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZVR5cGU6IFN0cmluZyxcbiAgICAgICAgdmlzaWJsZTogQm9vbGVhbixcbiAgICAgICAgdmlzdWFsUmFuZ2U6IFtBcnJheSwgT2JqZWN0XSxcbiAgICAgICAgdmlzdWFsUmFuZ2VVcGRhdGVNb2RlOiBTdHJpbmcsXG4gICAgICAgIHdob2xlUmFuZ2U6IFtBcnJheSwgT2JqZWN0XSxcbiAgICAgICAgd2lkdGg6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFZhbHVlQXhpcyA9IER4VmFsdWVBeGlzO1xuRHhWYWx1ZUF4aXMuJF9vcHRpb25OYW1lID0gXCJ2YWx1ZUF4aXNcIjtcbkR4VmFsdWVBeGlzLiRfaXNDb2xsZWN0aW9uSXRlbSA9IHRydWU7XG5EeFZhbHVlQXhpcy4kX2V4cGVjdGVkQ2hpbGRyZW4gPSB7XG4gICAgYXhpc0NvbnN0YW50TGluZVN0eWxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImNvbnN0YW50TGluZVN0eWxlXCIgfSxcbiAgICBheGlzTGFiZWw6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwibGFiZWxcIiB9LFxuICAgIGF4aXNUaXRsZTogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJ0aXRsZVwiIH0sXG4gICAgYnJlYWs6IHsgaXNDb2xsZWN0aW9uSXRlbTogdHJ1ZSwgb3B0aW9uTmFtZTogXCJicmVha3NcIiB9LFxuICAgIGNvbnN0YW50TGluZTogeyBpc0NvbGxlY3Rpb25JdGVtOiB0cnVlLCBvcHRpb25OYW1lOiBcImNvbnN0YW50TGluZXNcIiB9LFxuICAgIGNvbnN0YW50TGluZVN0eWxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImNvbnN0YW50TGluZVN0eWxlXCIgfSxcbiAgICBsYWJlbDogeyBpc0NvbGxlY3Rpb25JdGVtOiBmYWxzZSwgb3B0aW9uTmFtZTogXCJsYWJlbFwiIH0sXG4gICAgbWlub3JUaWNrSW50ZXJ2YWw6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwibWlub3JUaWNrSW50ZXJ2YWxcIiB9LFxuICAgIG1pblZpc3VhbFJhbmdlTGVuZ3RoOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcIm1pblZpc3VhbFJhbmdlTGVuZ3RoXCIgfSxcbiAgICBzdHJpcDogeyBpc0NvbGxlY3Rpb25JdGVtOiB0cnVlLCBvcHRpb25OYW1lOiBcInN0cmlwc1wiIH0sXG4gICAgdGlja0ludGVydmFsOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInRpY2tJbnRlcnZhbFwiIH0sXG4gICAgdGl0bGU6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwidGl0bGVcIiB9LFxuICAgIHZpc3VhbFJhbmdlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcInZpc3VhbFJhbmdlXCIgfSxcbiAgICB3aG9sZVJhbmdlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcIndob2xlUmFuZ2VcIiB9XG59O1xudmFyIER4VmFsdWVFcnJvckJhciA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6Y29sb3JcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZGlzcGxheU1vZGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZWRnZUxlbmd0aFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpoaWdoVmFsdWVGaWVsZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpsaW5lV2lkdGhcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bG93VmFsdWVGaWVsZFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpvcGFjaXR5XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnR5cGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6dmFsdWVcIjogbnVsbCxcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgICAgIGRpc3BsYXlNb2RlOiBTdHJpbmcsXG4gICAgICAgIGVkZ2VMZW5ndGg6IE51bWJlcixcbiAgICAgICAgaGlnaFZhbHVlRmllbGQ6IFN0cmluZyxcbiAgICAgICAgbGluZVdpZHRoOiBOdW1iZXIsXG4gICAgICAgIGxvd1ZhbHVlRmllbGQ6IFN0cmluZyxcbiAgICAgICAgb3BhY2l0eTogTnVtYmVyLFxuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiBOdW1iZXJcbiAgICB9XG59KTtcbmV4cG9ydHMuRHhWYWx1ZUVycm9yQmFyID0gRHhWYWx1ZUVycm9yQmFyO1xuRHhWYWx1ZUVycm9yQmFyLiRfb3B0aW9uTmFtZSA9IFwidmFsdWVFcnJvckJhclwiO1xudmFyIER4VmVydGljYWxMaW5lID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpjb2xvclwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpkYXNoU3R5bGVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6bGFiZWxcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6b3BhY2l0eVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTp2aXNpYmxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOndpZHRoXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBkYXNoU3R5bGU6IFN0cmluZyxcbiAgICAgICAgbGFiZWw6IE9iamVjdCxcbiAgICAgICAgb3BhY2l0eTogTnVtYmVyLFxuICAgICAgICB2aXNpYmxlOiBCb29sZWFuLFxuICAgICAgICB3aWR0aDogTnVtYmVyXG4gICAgfVxufSk7XG5leHBvcnRzLkR4VmVydGljYWxMaW5lID0gRHhWZXJ0aWNhbExpbmU7XG5EeFZlcnRpY2FsTGluZS4kX29wdGlvbk5hbWUgPSBcInZlcnRpY2FsTGluZVwiO1xuRHhWZXJ0aWNhbExpbmUuJF9leHBlY3RlZENoaWxkcmVuID0ge1xuICAgIGhvcml6b250YWxMaW5lTGFiZWw6IHsgaXNDb2xsZWN0aW9uSXRlbTogZmFsc2UsIG9wdGlvbk5hbWU6IFwibGFiZWxcIiB9LFxuICAgIGxhYmVsOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImxhYmVsXCIgfVxufTtcbnZhciBEeFZpc3VhbFJhbmdlID0gaW5kZXhfMi5jcmVhdGVDb25maWd1cmF0aW9uQ29tcG9uZW50KHtcbiAgICBlbWl0czoge1xuICAgICAgICBcInVwZGF0ZTppc0FjdGl2ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpob3ZlcmVkRWxlbWVudFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTplbmRWYWx1ZVwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpsZW5ndGhcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6c3RhcnRWYWx1ZVwiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZW5kVmFsdWU6IHt9LFxuICAgICAgICBsZW5ndGg6IFtOdW1iZXIsIE9iamVjdCwgU3RyaW5nXSxcbiAgICAgICAgc3RhcnRWYWx1ZToge31cbiAgICB9XG59KTtcbmV4cG9ydHMuRHhWaXN1YWxSYW5nZSA9IER4VmlzdWFsUmFuZ2U7XG5EeFZpc3VhbFJhbmdlLiRfb3B0aW9uTmFtZSA9IFwidmlzdWFsUmFuZ2VcIjtcbnZhciBEeFdob2xlUmFuZ2UgPSBpbmRleF8yLmNyZWF0ZUNvbmZpZ3VyYXRpb25Db21wb25lbnQoe1xuICAgIGVtaXRzOiB7XG4gICAgICAgIFwidXBkYXRlOmlzQWN0aXZlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmhvdmVyZWRFbGVtZW50XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmVuZFZhbHVlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmxlbmd0aFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpzdGFydFZhbHVlXCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBlbmRWYWx1ZToge30sXG4gICAgICAgIGxlbmd0aDogW051bWJlciwgT2JqZWN0LCBTdHJpbmddLFxuICAgICAgICBzdGFydFZhbHVlOiB7fVxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFdob2xlUmFuZ2UgPSBEeFdob2xlUmFuZ2U7XG5EeFdob2xlUmFuZ2UuJF9vcHRpb25OYW1lID0gXCJ3aG9sZVJhbmdlXCI7XG52YXIgRHhXaWR0aCA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cmFuZ2VNYXhQb2ludFwiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTpyYW5nZU1pblBvaW50XCI6IG51bGwsXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICByYW5nZU1heFBvaW50OiBOdW1iZXIsXG4gICAgICAgIHJhbmdlTWluUG9pbnQ6IE51bWJlclxuICAgIH1cbn0pO1xuZXhwb3J0cy5EeFdpZHRoID0gRHhXaWR0aDtcbkR4V2lkdGguJF9vcHRpb25OYW1lID0gXCJ3aWR0aFwiO1xudmFyIER4Wm9vbUFuZFBhbiA9IGluZGV4XzIuY3JlYXRlQ29uZmlndXJhdGlvbkNvbXBvbmVudCh7XG4gICAgZW1pdHM6IHtcbiAgICAgICAgXCJ1cGRhdGU6aXNBY3RpdmVcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6aG92ZXJlZEVsZW1lbnRcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6YWxsb3dNb3VzZVdoZWVsXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmFsbG93VG91Y2hHZXN0dXJlc1wiOiBudWxsLFxuICAgICAgICBcInVwZGF0ZTphcmd1bWVudEF4aXNcIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6ZHJhZ0JveFN0eWxlXCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOmRyYWdUb1pvb21cIjogbnVsbCxcbiAgICAgICAgXCJ1cGRhdGU6cGFuS2V5XCI6IG51bGwsXG4gICAgICAgIFwidXBkYXRlOnZhbHVlQXhpc1wiOiBudWxsLFxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWxsb3dNb3VzZVdoZWVsOiBCb29sZWFuLFxuICAgICAgICBhbGxvd1RvdWNoR2VzdHVyZXM6IEJvb2xlYW4sXG4gICAgICAgIGFyZ3VtZW50QXhpczogU3RyaW5nLFxuICAgICAgICBkcmFnQm94U3R5bGU6IE9iamVjdCxcbiAgICAgICAgZHJhZ1RvWm9vbTogQm9vbGVhbixcbiAgICAgICAgcGFuS2V5OiBTdHJpbmcsXG4gICAgICAgIHZhbHVlQXhpczogU3RyaW5nXG4gICAgfVxufSk7XG5leHBvcnRzLkR4Wm9vbUFuZFBhbiA9IER4Wm9vbUFuZFBhbjtcbkR4Wm9vbUFuZFBhbi4kX29wdGlvbk5hbWUgPSBcInpvb21BbmRQYW5cIjtcbkR4Wm9vbUFuZFBhbi4kX2V4cGVjdGVkQ2hpbGRyZW4gPSB7XG4gICAgZHJhZ0JveFN0eWxlOiB7IGlzQ29sbGVjdGlvbkl0ZW06IGZhbHNlLCBvcHRpb25OYW1lOiBcImRyYWdCb3hTdHlsZVwiIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBEeENoYXJ0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme-vue/chart.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/events/transform.js":
/*!*********************************************************!*\
  !*** ./node_modules/devextreme/esm/events/transform.js ***!
  \*********************************************************/
/*! exports provided: transformstart, transform, transformend, translatestart, translate, translateend, zoomstart, zoom, zoomend, pinchstart, pinch, pinchend, rotatestart, rotate, rotateend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformstart\", function() { return transformstart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transform\", function() { return transform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformend\", function() { return transformend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translatestart\", function() { return translatestart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translateend\", function() { return translateend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zoomstart\", function() { return zoomstart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zoom\", function() { return zoom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zoomend\", function() { return zoomend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pinchstart\", function() { return pinchstart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pinch\", function() { return pinch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pinchend\", function() { return pinchend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotatestart\", function() { return rotatestart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateend\", function() { return rotateend; });\n/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils/math */ \"./node_modules/devextreme/esm/core/utils/math.js\");\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/* harmony import */ var _utils_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/index */ \"./node_modules/devextreme/esm/events/utils/index.js\");\n/* harmony import */ var _core_emitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/emitter */ \"./node_modules/devextreme/esm/events/core/emitter.js\");\n/* harmony import */ var _core_emitter_registrator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/emitter_registrator */ \"./node_modules/devextreme/esm/events/core/emitter_registrator.js\");\n/**\r\n * DevExtreme (esm/events/transform.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\nvar DX_PREFIX = \"dx\";\r\nvar TRANSFORM = \"transform\";\r\nvar TRANSLATE = \"translate\";\r\nvar PINCH = \"pinch\";\r\nvar ROTATE = \"rotate\";\r\nvar START_POSTFIX = \"start\";\r\nvar UPDATE_POSTFIX = \"\";\r\nvar END_POSTFIX = \"end\";\r\nvar eventAliases = [];\r\nvar addAlias = function(eventName, eventArgs) {\r\n    eventAliases.push({\r\n        name: eventName,\r\n        args: eventArgs\r\n    })\r\n};\r\naddAlias(TRANSFORM, {\r\n    scale: true,\r\n    deltaScale: true,\r\n    rotation: true,\r\n    deltaRotation: true,\r\n    translation: true,\r\n    deltaTranslation: true\r\n});\r\naddAlias(TRANSLATE, {\r\n    translation: true,\r\n    deltaTranslation: true\r\n});\r\naddAlias(PINCH, {\r\n    scale: true,\r\n    deltaScale: true\r\n});\r\naddAlias(ROTATE, {\r\n    rotation: true,\r\n    deltaRotation: true\r\n});\r\nvar getVector = function(first, second) {\r\n    return {\r\n        x: second.pageX - first.pageX,\r\n        y: -second.pageY + first.pageY,\r\n        centerX: .5 * (second.pageX + first.pageX),\r\n        centerY: .5 * (second.pageY + first.pageY)\r\n    }\r\n};\r\nvar getEventVector = function(e) {\r\n    var pointers = e.pointers;\r\n    return getVector(pointers[0], pointers[1])\r\n};\r\nvar getDistance = function(vector) {\r\n    return Math.sqrt(vector.x * vector.x + vector.y * vector.y)\r\n};\r\nvar getScale = function(firstVector, secondVector) {\r\n    return getDistance(firstVector) / getDistance(secondVector)\r\n};\r\nvar getRotation = function(firstVector, secondVector) {\r\n    var scalarProduct = firstVector.x * secondVector.x + firstVector.y * secondVector.y;\r\n    var distanceProduct = getDistance(firstVector) * getDistance(secondVector);\r\n    if (0 === distanceProduct) {\r\n        return 0\r\n    }\r\n    var sign = Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_0__[\"sign\"])(firstVector.x * secondVector.y - secondVector.x * firstVector.y);\r\n    var angle = Math.acos(Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_0__[\"fitIntoRange\"])(scalarProduct / distanceProduct, -1, 1));\r\n    return sign * angle\r\n};\r\nvar getTranslation = function(firstVector, secondVector) {\r\n    return {\r\n        x: firstVector.centerX - secondVector.centerX,\r\n        y: firstVector.centerY - secondVector.centerY\r\n    }\r\n};\r\nvar TransformEmitter = _core_emitter__WEBPACK_IMPORTED_MODULE_3__[\"default\"].inherit({\r\n    validatePointers: function(e) {\r\n        return Object(_utils_index__WEBPACK_IMPORTED_MODULE_2__[\"hasTouches\"])(e) > 1\r\n    },\r\n    start: function(e) {\r\n        this._accept(e);\r\n        var startVector = getEventVector(e);\r\n        this._startVector = startVector;\r\n        this._prevVector = startVector;\r\n        this._fireEventAliases(START_POSTFIX, e)\r\n    },\r\n    move: function(e) {\r\n        var currentVector = getEventVector(e);\r\n        var eventArgs = this._getEventArgs(currentVector);\r\n        this._fireEventAliases(UPDATE_POSTFIX, e, eventArgs);\r\n        this._prevVector = currentVector\r\n    },\r\n    end: function(e) {\r\n        var eventArgs = this._getEventArgs(this._prevVector);\r\n        this._fireEventAliases(END_POSTFIX, e, eventArgs)\r\n    },\r\n    _getEventArgs: function(vector) {\r\n        return {\r\n            scale: getScale(vector, this._startVector),\r\n            deltaScale: getScale(vector, this._prevVector),\r\n            rotation: getRotation(vector, this._startVector),\r\n            deltaRotation: getRotation(vector, this._prevVector),\r\n            translation: getTranslation(vector, this._startVector),\r\n            deltaTranslation: getTranslation(vector, this._prevVector)\r\n        }\r\n    },\r\n    _fireEventAliases: function(eventPostfix, originalEvent, eventArgs) {\r\n        eventArgs = eventArgs || {};\r\n        _core_utils_iterator__WEBPACK_IMPORTED_MODULE_1__[\"each\"](eventAliases, function(_, eventAlias) {\r\n            var args = {};\r\n            _core_utils_iterator__WEBPACK_IMPORTED_MODULE_1__[\"each\"](eventAlias.args, (function(name) {\r\n                if (name in eventArgs) {\r\n                    args[name] = eventArgs[name]\r\n                }\r\n            }));\r\n            this._fireEvent(DX_PREFIX + eventAlias.name + eventPostfix, originalEvent, args)\r\n        }.bind(this))\r\n    }\r\n});\r\nvar eventNames = eventAliases.reduce((result, eventAlias) => {\r\n    [START_POSTFIX, UPDATE_POSTFIX, END_POSTFIX].forEach(eventPostfix => {\r\n        result.push(DX_PREFIX + eventAlias.name + eventPostfix)\r\n    });\r\n    return result\r\n}, []);\r\nObject(_core_emitter_registrator__WEBPACK_IMPORTED_MODULE_4__[\"default\"])({\r\n    emitter: TransformEmitter,\r\n    events: eventNames\r\n});\r\nvar exportNames = {};\r\n_core_utils_iterator__WEBPACK_IMPORTED_MODULE_1__[\"each\"](eventNames, (function(_, eventName) {\r\n    exportNames[eventName.substring(DX_PREFIX.length)] = eventName\r\n}));\r\nvar {\r\n    transformstart: transformstart,\r\n    transform: transform,\r\n    transformend: transformend,\r\n    translatestart: translatestart,\r\n    translate: translate,\r\n    translateend: translateend,\r\n    zoomstart: zoomstart,\r\n    zoom: zoom,\r\n    zoomend: zoomend,\r\n    pinchstart: pinchstart,\r\n    pinch: pinch,\r\n    pinchend: pinchend,\r\n    rotatestart: rotatestart,\r\n    rotate: rotate,\r\n    rotateend: rotateend\r\n} = exportNames;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vZXZlbnRzL3RyYW5zZm9ybS5qcz9kZjg0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJNEI7QUFDNEI7QUFHakM7QUFDYztBQUNvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkRBQVE7QUFDdkIsMEJBQTBCLHFFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscURBQU87QUFDOUI7QUFDQSxlQUFlLCtEQUFVO0FBQ3pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRLHlEQUFrQjtBQUMxQjtBQUNBLFlBQVkseURBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0QseUVBQWU7QUFDZjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EseURBQWtCO0FBQ2xCO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS9ldmVudHMvdHJhbnNmb3JtLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS9ldmVudHMvdHJhbnNmb3JtLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQge1xyXG4gICAgc2lnbiBhcyBtYXRoU2lnbixcclxuICAgIGZpdEludG9SYW5nZVxyXG59IGZyb20gXCIuLi9jb3JlL3V0aWxzL21hdGhcIjtcclxuaW1wb3J0ICogYXMgaXRlcmF0b3JVdGlscyBmcm9tIFwiLi4vY29yZS91dGlscy9pdGVyYXRvclwiO1xyXG5pbXBvcnQge1xyXG4gICAgaGFzVG91Y2hlc1xyXG59IGZyb20gXCIuL3V0aWxzL2luZGV4XCI7XHJcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuL2NvcmUvZW1pdHRlclwiO1xyXG5pbXBvcnQgcmVnaXN0ZXJFbWl0dGVyIGZyb20gXCIuL2NvcmUvZW1pdHRlcl9yZWdpc3RyYXRvclwiO1xyXG52YXIgRFhfUFJFRklYID0gXCJkeFwiO1xyXG52YXIgVFJBTlNGT1JNID0gXCJ0cmFuc2Zvcm1cIjtcclxudmFyIFRSQU5TTEFURSA9IFwidHJhbnNsYXRlXCI7XHJcbnZhciBQSU5DSCA9IFwicGluY2hcIjtcclxudmFyIFJPVEFURSA9IFwicm90YXRlXCI7XHJcbnZhciBTVEFSVF9QT1NURklYID0gXCJzdGFydFwiO1xyXG52YXIgVVBEQVRFX1BPU1RGSVggPSBcIlwiO1xyXG52YXIgRU5EX1BPU1RGSVggPSBcImVuZFwiO1xyXG52YXIgZXZlbnRBbGlhc2VzID0gW107XHJcbnZhciBhZGRBbGlhcyA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZXZlbnRBcmdzKSB7XHJcbiAgICBldmVudEFsaWFzZXMucHVzaCh7XHJcbiAgICAgICAgbmFtZTogZXZlbnROYW1lLFxyXG4gICAgICAgIGFyZ3M6IGV2ZW50QXJnc1xyXG4gICAgfSlcclxufTtcclxuYWRkQWxpYXMoVFJBTlNGT1JNLCB7XHJcbiAgICBzY2FsZTogdHJ1ZSxcclxuICAgIGRlbHRhU2NhbGU6IHRydWUsXHJcbiAgICByb3RhdGlvbjogdHJ1ZSxcclxuICAgIGRlbHRhUm90YXRpb246IHRydWUsXHJcbiAgICB0cmFuc2xhdGlvbjogdHJ1ZSxcclxuICAgIGRlbHRhVHJhbnNsYXRpb246IHRydWVcclxufSk7XHJcbmFkZEFsaWFzKFRSQU5TTEFURSwge1xyXG4gICAgdHJhbnNsYXRpb246IHRydWUsXHJcbiAgICBkZWx0YVRyYW5zbGF0aW9uOiB0cnVlXHJcbn0pO1xyXG5hZGRBbGlhcyhQSU5DSCwge1xyXG4gICAgc2NhbGU6IHRydWUsXHJcbiAgICBkZWx0YVNjYWxlOiB0cnVlXHJcbn0pO1xyXG5hZGRBbGlhcyhST1RBVEUsIHtcclxuICAgIHJvdGF0aW9uOiB0cnVlLFxyXG4gICAgZGVsdGFSb3RhdGlvbjogdHJ1ZVxyXG59KTtcclxudmFyIGdldFZlY3RvciA9IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogc2Vjb25kLnBhZ2VYIC0gZmlyc3QucGFnZVgsXHJcbiAgICAgICAgeTogLXNlY29uZC5wYWdlWSArIGZpcnN0LnBhZ2VZLFxyXG4gICAgICAgIGNlbnRlclg6IC41ICogKHNlY29uZC5wYWdlWCArIGZpcnN0LnBhZ2VYKSxcclxuICAgICAgICBjZW50ZXJZOiAuNSAqIChzZWNvbmQucGFnZVkgKyBmaXJzdC5wYWdlWSlcclxuICAgIH1cclxufTtcclxudmFyIGdldEV2ZW50VmVjdG9yID0gZnVuY3Rpb24oZSkge1xyXG4gICAgdmFyIHBvaW50ZXJzID0gZS5wb2ludGVycztcclxuICAgIHJldHVybiBnZXRWZWN0b3IocG9pbnRlcnNbMF0sIHBvaW50ZXJzWzFdKVxyXG59O1xyXG52YXIgZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbih2ZWN0b3IpIHtcclxuICAgIHJldHVybiBNYXRoLnNxcnQodmVjdG9yLnggKiB2ZWN0b3IueCArIHZlY3Rvci55ICogdmVjdG9yLnkpXHJcbn07XHJcbnZhciBnZXRTY2FsZSA9IGZ1bmN0aW9uKGZpcnN0VmVjdG9yLCBzZWNvbmRWZWN0b3IpIHtcclxuICAgIHJldHVybiBnZXREaXN0YW5jZShmaXJzdFZlY3RvcikgLyBnZXREaXN0YW5jZShzZWNvbmRWZWN0b3IpXHJcbn07XHJcbnZhciBnZXRSb3RhdGlvbiA9IGZ1bmN0aW9uKGZpcnN0VmVjdG9yLCBzZWNvbmRWZWN0b3IpIHtcclxuICAgIHZhciBzY2FsYXJQcm9kdWN0ID0gZmlyc3RWZWN0b3IueCAqIHNlY29uZFZlY3Rvci54ICsgZmlyc3RWZWN0b3IueSAqIHNlY29uZFZlY3Rvci55O1xyXG4gICAgdmFyIGRpc3RhbmNlUHJvZHVjdCA9IGdldERpc3RhbmNlKGZpcnN0VmVjdG9yKSAqIGdldERpc3RhbmNlKHNlY29uZFZlY3Rvcik7XHJcbiAgICBpZiAoMCA9PT0gZGlzdGFuY2VQcm9kdWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIDBcclxuICAgIH1cclxuICAgIHZhciBzaWduID0gbWF0aFNpZ24oZmlyc3RWZWN0b3IueCAqIHNlY29uZFZlY3Rvci55IC0gc2Vjb25kVmVjdG9yLnggKiBmaXJzdFZlY3Rvci55KTtcclxuICAgIHZhciBhbmdsZSA9IE1hdGguYWNvcyhmaXRJbnRvUmFuZ2Uoc2NhbGFyUHJvZHVjdCAvIGRpc3RhbmNlUHJvZHVjdCwgLTEsIDEpKTtcclxuICAgIHJldHVybiBzaWduICogYW5nbGVcclxufTtcclxudmFyIGdldFRyYW5zbGF0aW9uID0gZnVuY3Rpb24oZmlyc3RWZWN0b3IsIHNlY29uZFZlY3Rvcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBmaXJzdFZlY3Rvci5jZW50ZXJYIC0gc2Vjb25kVmVjdG9yLmNlbnRlclgsXHJcbiAgICAgICAgeTogZmlyc3RWZWN0b3IuY2VudGVyWSAtIHNlY29uZFZlY3Rvci5jZW50ZXJZXHJcbiAgICB9XHJcbn07XHJcbnZhciBUcmFuc2Zvcm1FbWl0dGVyID0gRW1pdHRlci5pbmhlcml0KHtcclxuICAgIHZhbGlkYXRlUG9pbnRlcnM6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICByZXR1cm4gaGFzVG91Y2hlcyhlKSA+IDFcclxuICAgIH0sXHJcbiAgICBzdGFydDogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIHRoaXMuX2FjY2VwdChlKTtcclxuICAgICAgICB2YXIgc3RhcnRWZWN0b3IgPSBnZXRFdmVudFZlY3RvcihlKTtcclxuICAgICAgICB0aGlzLl9zdGFydFZlY3RvciA9IHN0YXJ0VmVjdG9yO1xyXG4gICAgICAgIHRoaXMuX3ByZXZWZWN0b3IgPSBzdGFydFZlY3RvcjtcclxuICAgICAgICB0aGlzLl9maXJlRXZlbnRBbGlhc2VzKFNUQVJUX1BPU1RGSVgsIGUpXHJcbiAgICB9LFxyXG4gICAgbW92ZTogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50VmVjdG9yID0gZ2V0RXZlbnRWZWN0b3IoZSk7XHJcbiAgICAgICAgdmFyIGV2ZW50QXJncyA9IHRoaXMuX2dldEV2ZW50QXJncyhjdXJyZW50VmVjdG9yKTtcclxuICAgICAgICB0aGlzLl9maXJlRXZlbnRBbGlhc2VzKFVQREFURV9QT1NURklYLCBlLCBldmVudEFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX3ByZXZWZWN0b3IgPSBjdXJyZW50VmVjdG9yXHJcbiAgICB9LFxyXG4gICAgZW5kOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50QXJncyA9IHRoaXMuX2dldEV2ZW50QXJncyh0aGlzLl9wcmV2VmVjdG9yKTtcclxuICAgICAgICB0aGlzLl9maXJlRXZlbnRBbGlhc2VzKEVORF9QT1NURklYLCBlLCBldmVudEFyZ3MpXHJcbiAgICB9LFxyXG4gICAgX2dldEV2ZW50QXJnczogZnVuY3Rpb24odmVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2NhbGU6IGdldFNjYWxlKHZlY3RvciwgdGhpcy5fc3RhcnRWZWN0b3IpLFxyXG4gICAgICAgICAgICBkZWx0YVNjYWxlOiBnZXRTY2FsZSh2ZWN0b3IsIHRoaXMuX3ByZXZWZWN0b3IpLFxyXG4gICAgICAgICAgICByb3RhdGlvbjogZ2V0Um90YXRpb24odmVjdG9yLCB0aGlzLl9zdGFydFZlY3RvciksXHJcbiAgICAgICAgICAgIGRlbHRhUm90YXRpb246IGdldFJvdGF0aW9uKHZlY3RvciwgdGhpcy5fcHJldlZlY3RvciksXHJcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uOiBnZXRUcmFuc2xhdGlvbih2ZWN0b3IsIHRoaXMuX3N0YXJ0VmVjdG9yKSxcclxuICAgICAgICAgICAgZGVsdGFUcmFuc2xhdGlvbjogZ2V0VHJhbnNsYXRpb24odmVjdG9yLCB0aGlzLl9wcmV2VmVjdG9yKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZmlyZUV2ZW50QWxpYXNlczogZnVuY3Rpb24oZXZlbnRQb3N0Zml4LCBvcmlnaW5hbEV2ZW50LCBldmVudEFyZ3MpIHtcclxuICAgICAgICBldmVudEFyZ3MgPSBldmVudEFyZ3MgfHwge307XHJcbiAgICAgICAgaXRlcmF0b3JVdGlscy5lYWNoKGV2ZW50QWxpYXNlcywgZnVuY3Rpb24oXywgZXZlbnRBbGlhcykge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IHt9O1xyXG4gICAgICAgICAgICBpdGVyYXRvclV0aWxzLmVhY2goZXZlbnRBbGlhcy5hcmdzLCAoZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gZXZlbnRBcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tuYW1lXSA9IGV2ZW50QXJnc1tuYW1lXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudChEWF9QUkVGSVggKyBldmVudEFsaWFzLm5hbWUgKyBldmVudFBvc3RmaXgsIG9yaWdpbmFsRXZlbnQsIGFyZ3MpXHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxyXG4gICAgfVxyXG59KTtcclxudmFyIGV2ZW50TmFtZXMgPSBldmVudEFsaWFzZXMucmVkdWNlKChyZXN1bHQsIGV2ZW50QWxpYXMpID0+IHtcclxuICAgIFtTVEFSVF9QT1NURklYLCBVUERBVEVfUE9TVEZJWCwgRU5EX1BPU1RGSVhdLmZvckVhY2goZXZlbnRQb3N0Zml4ID0+IHtcclxuICAgICAgICByZXN1bHQucHVzaChEWF9QUkVGSVggKyBldmVudEFsaWFzLm5hbWUgKyBldmVudFBvc3RmaXgpXHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHRcclxufSwgW10pO1xyXG5yZWdpc3RlckVtaXR0ZXIoe1xyXG4gICAgZW1pdHRlcjogVHJhbnNmb3JtRW1pdHRlcixcclxuICAgIGV2ZW50czogZXZlbnROYW1lc1xyXG59KTtcclxudmFyIGV4cG9ydE5hbWVzID0ge307XHJcbml0ZXJhdG9yVXRpbHMuZWFjaChldmVudE5hbWVzLCAoZnVuY3Rpb24oXywgZXZlbnROYW1lKSB7XHJcbiAgICBleHBvcnROYW1lc1tldmVudE5hbWUuc3Vic3RyaW5nKERYX1BSRUZJWC5sZW5ndGgpXSA9IGV2ZW50TmFtZVxyXG59KSk7XHJcbmV4cG9ydCB2YXIge1xyXG4gICAgdHJhbnNmb3Jtc3RhcnQ6IHRyYW5zZm9ybXN0YXJ0LFxyXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXHJcbiAgICB0cmFuc2Zvcm1lbmQ6IHRyYW5zZm9ybWVuZCxcclxuICAgIHRyYW5zbGF0ZXN0YXJ0OiB0cmFuc2xhdGVzdGFydCxcclxuICAgIHRyYW5zbGF0ZTogdHJhbnNsYXRlLFxyXG4gICAgdHJhbnNsYXRlZW5kOiB0cmFuc2xhdGVlbmQsXHJcbiAgICB6b29tc3RhcnQ6IHpvb21zdGFydCxcclxuICAgIHpvb206IHpvb20sXHJcbiAgICB6b29tZW5kOiB6b29tZW5kLFxyXG4gICAgcGluY2hzdGFydDogcGluY2hzdGFydCxcclxuICAgIHBpbmNoOiBwaW5jaCxcclxuICAgIHBpbmNoZW5kOiBwaW5jaGVuZCxcclxuICAgIHJvdGF0ZXN0YXJ0OiByb3RhdGVzdGFydCxcclxuICAgIHJvdGF0ZTogcm90YXRlLFxyXG4gICAgcm90YXRlZW5kOiByb3RhdGVlbmRcclxufSA9IGV4cG9ydE5hbWVzO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/events/transform.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/axes/axes_constants.js":
/*!****************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/axes/axes_constants.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/**\r\n * DevExtreme (esm/viz/axes/axes_constants.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    logarithmic: \"logarithmic\",\r\n    discrete: \"discrete\",\r\n    numeric: \"numeric\",\r\n    left: \"left\",\r\n    right: \"right\",\r\n    top: \"top\",\r\n    bottom: \"bottom\",\r\n    center: \"center\",\r\n    horizontal: \"horizontal\",\r\n    vertical: \"vertical\",\r\n    convertTicksToValues: function(ticks) {\r\n        return Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(ticks || [], (function(item) {\r\n            return item.value\r\n        }))\r\n    },\r\n    validateOverlappingMode: function(mode) {\r\n        return \"ignore\" === mode || \"none\" === mode ? mode : \"hide\"\r\n    },\r\n    getTicksCountInRange: function(ticks, valueKey, range) {\r\n        var i = 1;\r\n        if (ticks.length > 1) {\r\n            for (; i < ticks.length; i++) {\r\n                if (Math.abs(ticks[i].coords[valueKey] - ticks[0].coords[valueKey]) >= range) {\r\n                    break\r\n                }\r\n            }\r\n        }\r\n        return i\r\n    },\r\n    areLabelsOverlap: function(bBox1, bBox2, spacing, alignment) {\r\n        var horizontalInverted = bBox1.x > bBox2.x;\r\n        var verticalInverted = bBox1.y > bBox2.y;\r\n        var x1 = bBox1.x;\r\n        var x2 = bBox2.x;\r\n        var width1 = bBox1.width;\r\n        var width2 = bBox2.width;\r\n        if (\"left\" === alignment) {\r\n            x1 += width1 / 2;\r\n            x2 += width2 / 2\r\n        } else if (\"right\" === alignment) {\r\n            x1 -= width1 / 2;\r\n            x2 -= width2 / 2\r\n        }\r\n        var hasHorizontalOverlapping = horizontalInverted ? x2 + width2 + spacing > x1 : x1 + width1 + spacing > x2;\r\n        var hasVerticalOverlapping = verticalInverted ? bBox2.y + bBox2.height > bBox1.y : bBox1.y + bBox1.height > bBox2.y;\r\n        return hasHorizontalOverlapping && hasVerticalOverlapping\r\n    }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2F4ZXMvYXhlc19jb25zdGFudHMuanM/NTZjOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUd1QjtBQUNSO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQUk7QUFDbkI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2F4ZXMvYXhlc19jb25zdGFudHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3Zpei9heGVzL2F4ZXNfY29uc3RhbnRzLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQge1xyXG4gICAgbWFwIGFzIF9tYXBcclxufSBmcm9tIFwiLi4vY29yZS91dGlsc1wiO1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBsb2dhcml0aG1pYzogXCJsb2dhcml0aG1pY1wiLFxyXG4gICAgZGlzY3JldGU6IFwiZGlzY3JldGVcIixcclxuICAgIG51bWVyaWM6IFwibnVtZXJpY1wiLFxyXG4gICAgbGVmdDogXCJsZWZ0XCIsXHJcbiAgICByaWdodDogXCJyaWdodFwiLFxyXG4gICAgdG9wOiBcInRvcFwiLFxyXG4gICAgYm90dG9tOiBcImJvdHRvbVwiLFxyXG4gICAgY2VudGVyOiBcImNlbnRlclwiLFxyXG4gICAgaG9yaXpvbnRhbDogXCJob3Jpem9udGFsXCIsXHJcbiAgICB2ZXJ0aWNhbDogXCJ2ZXJ0aWNhbFwiLFxyXG4gICAgY29udmVydFRpY2tzVG9WYWx1ZXM6IGZ1bmN0aW9uKHRpY2tzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9tYXAodGlja3MgfHwgW10sIChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnZhbHVlXHJcbiAgICAgICAgfSkpXHJcbiAgICB9LFxyXG4gICAgdmFsaWRhdGVPdmVybGFwcGluZ01vZGU6IGZ1bmN0aW9uKG1vZGUpIHtcclxuICAgICAgICByZXR1cm4gXCJpZ25vcmVcIiA9PT0gbW9kZSB8fCBcIm5vbmVcIiA9PT0gbW9kZSA/IG1vZGUgOiBcImhpZGVcIlxyXG4gICAgfSxcclxuICAgIGdldFRpY2tzQ291bnRJblJhbmdlOiBmdW5jdGlvbih0aWNrcywgdmFsdWVLZXksIHJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGkgPSAxO1xyXG4gICAgICAgIGlmICh0aWNrcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aWNrc1tpXS5jb29yZHNbdmFsdWVLZXldIC0gdGlja3NbMF0uY29vcmRzW3ZhbHVlS2V5XSkgPj0gcmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpXHJcbiAgICB9LFxyXG4gICAgYXJlTGFiZWxzT3ZlcmxhcDogZnVuY3Rpb24oYkJveDEsIGJCb3gyLCBzcGFjaW5nLCBhbGlnbm1lbnQpIHtcclxuICAgICAgICB2YXIgaG9yaXpvbnRhbEludmVydGVkID0gYkJveDEueCA+IGJCb3gyLng7XHJcbiAgICAgICAgdmFyIHZlcnRpY2FsSW52ZXJ0ZWQgPSBiQm94MS55ID4gYkJveDIueTtcclxuICAgICAgICB2YXIgeDEgPSBiQm94MS54O1xyXG4gICAgICAgIHZhciB4MiA9IGJCb3gyLng7XHJcbiAgICAgICAgdmFyIHdpZHRoMSA9IGJCb3gxLndpZHRoO1xyXG4gICAgICAgIHZhciB3aWR0aDIgPSBiQm94Mi53aWR0aDtcclxuICAgICAgICBpZiAoXCJsZWZ0XCIgPT09IGFsaWdubWVudCkge1xyXG4gICAgICAgICAgICB4MSArPSB3aWR0aDEgLyAyO1xyXG4gICAgICAgICAgICB4MiArPSB3aWR0aDIgLyAyXHJcbiAgICAgICAgfSBlbHNlIGlmIChcInJpZ2h0XCIgPT09IGFsaWdubWVudCkge1xyXG4gICAgICAgICAgICB4MSAtPSB3aWR0aDEgLyAyO1xyXG4gICAgICAgICAgICB4MiAtPSB3aWR0aDIgLyAyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoYXNIb3Jpem9udGFsT3ZlcmxhcHBpbmcgPSBob3Jpem9udGFsSW52ZXJ0ZWQgPyB4MiArIHdpZHRoMiArIHNwYWNpbmcgPiB4MSA6IHgxICsgd2lkdGgxICsgc3BhY2luZyA+IHgyO1xyXG4gICAgICAgIHZhciBoYXNWZXJ0aWNhbE92ZXJsYXBwaW5nID0gdmVydGljYWxJbnZlcnRlZCA/IGJCb3gyLnkgKyBiQm94Mi5oZWlnaHQgPiBiQm94MS55IDogYkJveDEueSArIGJCb3gxLmhlaWdodCA+IGJCb3gyLnk7XHJcbiAgICAgICAgcmV0dXJuIGhhc0hvcml6b250YWxPdmVybGFwcGluZyAmJiBoYXNWZXJ0aWNhbE92ZXJsYXBwaW5nXHJcbiAgICB9XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/axes/axes_constants.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/axes/axes_utils.js":
/*!************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/axes/axes_utils.js ***!
  \************************************************************/
/*! exports provided: calculateCanvasMargins, measureLabels */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calculateCanvasMargins\", function() { return calculateCanvasMargins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"measureLabels\", function() { return measureLabels; });\n/**\r\n * DevExtreme (esm/viz/axes/axes_utils.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nvar _max = Math.max;\r\nvar calculateCanvasMargins = function(bBoxes, canvas) {\r\n    var cLeft = canvas.left;\r\n    var cTop = canvas.top;\r\n    var cRight = canvas.width - canvas.right;\r\n    var cBottom = canvas.height - canvas.bottom;\r\n    return bBoxes.reduce((function(margins, bBox) {\r\n        if (!bBox || bBox.isEmpty) {\r\n            return margins\r\n        }\r\n        return {\r\n            left: _max(margins.left, cLeft - bBox.x),\r\n            top: _max(margins.top, cTop - bBox.y),\r\n            right: _max(margins.right, bBox.x + bBox.width - cRight),\r\n            bottom: _max(margins.bottom, bBox.y + bBox.height - cBottom)\r\n        }\r\n    }), {\r\n        left: 0,\r\n        right: 0,\r\n        top: 0,\r\n        bottom: 0\r\n    })\r\n};\r\nvar measureLabels = function(items) {\r\n    items.forEach((function(item) {\r\n        var label = item.getContentContainer();\r\n        item.labelBBox = label ? label.getBBox() : {\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        }\r\n    }))\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2F4ZXMvYXhlc191dGlscy5qcz83MzExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS92aXovYXhlcy9heGVzX3V0aWxzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS92aXovYXhlcy9heGVzX3V0aWxzLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG52YXIgX21heCA9IE1hdGgubWF4O1xyXG5leHBvcnQgdmFyIGNhbGN1bGF0ZUNhbnZhc01hcmdpbnMgPSBmdW5jdGlvbihiQm94ZXMsIGNhbnZhcykge1xyXG4gICAgdmFyIGNMZWZ0ID0gY2FudmFzLmxlZnQ7XHJcbiAgICB2YXIgY1RvcCA9IGNhbnZhcy50b3A7XHJcbiAgICB2YXIgY1JpZ2h0ID0gY2FudmFzLndpZHRoIC0gY2FudmFzLnJpZ2h0O1xyXG4gICAgdmFyIGNCb3R0b20gPSBjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmJvdHRvbTtcclxuICAgIHJldHVybiBiQm94ZXMucmVkdWNlKChmdW5jdGlvbihtYXJnaW5zLCBiQm94KSB7XHJcbiAgICAgICAgaWYgKCFiQm94IHx8IGJCb3guaXNFbXB0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFyZ2luc1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiBfbWF4KG1hcmdpbnMubGVmdCwgY0xlZnQgLSBiQm94LngpLFxyXG4gICAgICAgICAgICB0b3A6IF9tYXgobWFyZ2lucy50b3AsIGNUb3AgLSBiQm94LnkpLFxyXG4gICAgICAgICAgICByaWdodDogX21heChtYXJnaW5zLnJpZ2h0LCBiQm94LnggKyBiQm94LndpZHRoIC0gY1JpZ2h0KSxcclxuICAgICAgICAgICAgYm90dG9tOiBfbWF4KG1hcmdpbnMuYm90dG9tLCBiQm94LnkgKyBiQm94LmhlaWdodCAtIGNCb3R0b20pXHJcbiAgICAgICAgfVxyXG4gICAgfSksIHtcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBib3R0b206IDBcclxuICAgIH0pXHJcbn07XHJcbmV4cG9ydCB2YXIgbWVhc3VyZUxhYmVscyA9IGZ1bmN0aW9uKGl0ZW1zKSB7XHJcbiAgICBpdGVtcy5mb3JFYWNoKChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsID0gaXRlbS5nZXRDb250ZW50Q29udGFpbmVyKCk7XHJcbiAgICAgICAgaXRlbS5sYWJlbEJCb3ggPSBsYWJlbCA/IGxhYmVsLmdldEJCb3goKSA6IHtcclxuICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH1cclxuICAgIH0pKVxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/axes/axes_utils.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/axes/base_axis.js":
/*!***********************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/axes/base_axis.js ***!
  \***********************************************************/
/*! exports provided: Axis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Axis\", function() { return Axis; });\n/* harmony import */ var _smart_formatter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./smart_formatter */ \"./node_modules/devextreme/esm/viz/axes/smart_formatter.js\");\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _axes_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./axes_constants */ \"./node_modules/devextreme/esm/viz/axes/axes_constants.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _core_utils_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/utils/array */ \"./node_modules/devextreme/esm/core/utils/array.js\");\n/* harmony import */ var _format_helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../format_helper */ \"./node_modules/devextreme/esm/format_helper.js\");\n/* harmony import */ var _components_parse_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/parse_utils */ \"./node_modules/devextreme/esm/viz/components/parse_utils.js\");\n/* harmony import */ var _tick_generator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tick_generator */ \"./node_modules/devextreme/esm/viz/axes/tick_generator.js\");\n/* harmony import */ var _translators_translator2d__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../translators/translator2d */ \"./node_modules/devextreme/esm/viz/translators/translator2d.js\");\n/* harmony import */ var _translators_range__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../translators/range */ \"./node_modules/devextreme/esm/viz/translators/range.js\");\n/* harmony import */ var _tick__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tick */ \"./node_modules/devextreme/esm/viz/axes/tick.js\");\n/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/utils/math */ \"./node_modules/devextreme/esm/core/utils/math.js\");\n/* harmony import */ var _core_utils_date__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../core/utils/date */ \"./node_modules/devextreme/esm/core/utils/date.js\");\n/* harmony import */ var _core_utils_common__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../core/utils/common */ \"./node_modules/devextreme/esm/core/utils/common.js\");\n/* harmony import */ var _xy_axes__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./xy_axes */ \"./node_modules/devextreme/esm/viz/axes/xy_axes.js\");\n/* harmony import */ var _polar_axes__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./polar_axes */ \"./node_modules/devextreme/esm/viz/axes/polar_axes.js\");\n/* harmony import */ var _constant_line__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./constant_line */ \"./node_modules/devextreme/esm/viz/axes/constant_line.js\");\n/* harmony import */ var _strip__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./strip */ \"./node_modules/devextreme/esm/viz/axes/strip.js\");\n/* harmony import */ var _core_utils_deferred__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../core/utils/deferred */ \"./node_modules/devextreme/esm/core/utils/deferred.js\");\n/* harmony import */ var _axes_utils__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./axes_utils */ \"./node_modules/devextreme/esm/viz/axes/axes_utils.js\");\n/**\r\n * DevExtreme (esm/viz/axes/base_axis.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar convertTicksToValues = _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].convertTicksToValues;\r\nvar _math = Math;\r\nvar _abs = _math.abs;\r\nvar _max = _math.max;\r\nvar _min = _math.min;\r\nvar _isArray = Array.isArray;\r\nvar DEFAULT_AXIS_LABEL_SPACING = 5;\r\nvar MAX_GRID_BORDER_ADHENSION = 4;\r\nvar TOP = _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].top;\r\nvar BOTTOM = _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].bottom;\r\nvar LEFT = _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].left;\r\nvar RIGHT = _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].right;\r\nvar CENTER = _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].center;\r\nvar KEEP = \"keep\";\r\nvar SHIFT = \"shift\";\r\nvar RESET = \"reset\";\r\nvar ROTATE = \"rotate\";\r\nvar DEFAULT_AXIS_DIVISION_FACTOR = 50;\r\nvar DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;\r\nvar SCROLL_THRESHOLD = 5;\r\nvar MIN_BAR_MARGIN = 5;\r\nvar MAX_MARGIN_VALUE = .8;\r\nvar dateIntervals = {\r\n    day: 864e5,\r\n    week: 6048e5\r\n};\r\n\r\nfunction getTickGenerator(options, incidentOccurred, skipTickGeneration, rangeIsEmpty, adjustDivisionFactor, _ref) {\r\n    var _options$workWeek;\r\n    var {\r\n        allowNegatives: allowNegatives,\r\n        linearThreshold: linearThreshold\r\n    } = _ref;\r\n    return Object(_tick_generator__WEBPACK_IMPORTED_MODULE_8__[\"tickGenerator\"])({\r\n        axisType: options.type,\r\n        dataType: options.dataType,\r\n        logBase: options.logarithmBase,\r\n        allowNegatives: allowNegatives,\r\n        linearThreshold: linearThreshold,\r\n        axisDivisionFactor: adjustDivisionFactor(options.axisDivisionFactor || DEFAULT_AXIS_DIVISION_FACTOR),\r\n        minorAxisDivisionFactor: adjustDivisionFactor(options.minorAxisDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR),\r\n        numberMultipliers: options.numberMultipliers,\r\n        calculateMinors: options.minorTick.visible || options.minorGrid.visible || options.calculateMinors,\r\n        allowDecimals: options.allowDecimals,\r\n        endOnTick: options.endOnTick,\r\n        incidentOccurred: incidentOccurred,\r\n        firstDayOfWeek: null === (_options$workWeek = options.workWeek) || void 0 === _options$workWeek ? void 0 : _options$workWeek[0],\r\n        skipTickGeneration: skipTickGeneration,\r\n        skipCalculationLimits: options.skipCalculationLimits,\r\n        generateExtraTick: options.generateExtraTick,\r\n        minTickInterval: options.minTickInterval,\r\n        rangeIsEmpty: rangeIsEmpty\r\n    })\r\n}\r\n\r\nfunction createMajorTick(axis, renderer, skippedCategory) {\r\n    var options = axis.getOptions();\r\n    return Object(_tick__WEBPACK_IMPORTED_MODULE_11__[\"tick\"])(axis, renderer, options.tick, options.grid, skippedCategory, false)\r\n}\r\n\r\nfunction createMinorTick(axis, renderer) {\r\n    var options = axis.getOptions();\r\n    return Object(_tick__WEBPACK_IMPORTED_MODULE_11__[\"tick\"])(axis, renderer, options.minorTick, options.minorGrid)\r\n}\r\n\r\nfunction createBoundaryTick(axis, renderer, isFirst) {\r\n    var options = axis.getOptions();\r\n    return Object(_tick__WEBPACK_IMPORTED_MODULE_11__[\"tick\"])(axis, renderer, Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])({}, options.tick, {\r\n        visible: options.showCustomBoundaryTicks\r\n    }), options.grid, void 0, false, isFirst ? -1 : 1)\r\n}\r\n\r\nfunction callAction(elements, action, actionArgument1, actionArgument2) {\r\n    (elements || []).forEach(e => e[action](actionArgument1, actionArgument2))\r\n}\r\n\r\nfunction initTickCoords(ticks) {\r\n    callAction(ticks, \"initCoords\")\r\n}\r\n\r\nfunction drawTickMarks(ticks, options) {\r\n    callAction(ticks, \"drawMark\", options)\r\n}\r\n\r\nfunction drawGrids(ticks, drawLine) {\r\n    callAction(ticks, \"drawGrid\", drawLine)\r\n}\r\n\r\nfunction updateTicksPosition(ticks, options, animate) {\r\n    callAction(ticks, \"updateTickPosition\", options, animate)\r\n}\r\n\r\nfunction updateGridsPosition(ticks, animate) {\r\n    callAction(ticks, \"updateGridPosition\", animate)\r\n}\r\n\r\nfunction cleanUpInvalidTicks(ticks) {\r\n    var i = ticks.length - 1;\r\n    for (i; i >= 0; i--) {\r\n        if (!removeInvalidTick(ticks, i)) {\r\n            break\r\n        }\r\n    }\r\n    for (i = 0; i < ticks.length; i++) {\r\n        if (removeInvalidTick(ticks, i)) {\r\n            i--\r\n        } else {\r\n            break\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeInvalidTick(ticks, i) {\r\n    if (null === ticks[i].coords.x || null === ticks[i].coords.y) {\r\n        ticks.splice(i, 1);\r\n        return true\r\n    }\r\n    return false\r\n}\r\n\r\nfunction validateAxisOptions(options) {\r\n    var _labelOptions$minSpac;\r\n    var labelOptions = options.label;\r\n    var position = options.position;\r\n    var defaultPosition = options.isHorizontal ? BOTTOM : LEFT;\r\n    var secondaryPosition = options.isHorizontal ? TOP : RIGHT;\r\n    var labelPosition = labelOptions.position;\r\n    if (position !== defaultPosition && position !== secondaryPosition) {\r\n        position = defaultPosition\r\n    }\r\n    if (!labelPosition || \"outside\" === labelPosition) {\r\n        labelPosition = position\r\n    } else if (\"inside\" === labelPosition) {\r\n        labelPosition = {\r\n            [TOP]: BOTTOM,\r\n            [BOTTOM]: TOP,\r\n            [LEFT]: RIGHT,\r\n            [RIGHT]: LEFT\r\n        } [position]\r\n    }\r\n    if (labelPosition !== defaultPosition && labelPosition !== secondaryPosition) {\r\n        labelPosition = position\r\n    }\r\n    if (labelOptions.alignment !== CENTER && !labelOptions.userAlignment) {\r\n        labelOptions.alignment = {\r\n            [TOP]: CENTER,\r\n            [BOTTOM]: CENTER,\r\n            [LEFT]: RIGHT,\r\n            [RIGHT]: LEFT\r\n        } [labelPosition]\r\n    }\r\n    options.position = position;\r\n    labelOptions.position = labelPosition;\r\n    options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : \"none\";\r\n    labelOptions.minSpacing = null !== (_labelOptions$minSpac = labelOptions.minSpacing) && void 0 !== _labelOptions$minSpac ? _labelOptions$minSpac : DEFAULT_AXIS_LABEL_SPACING;\r\n    options.type && (options.type = options.type.toLowerCase());\r\n    options.argumentType && (options.argumentType = options.argumentType.toLowerCase());\r\n    options.valueType && (options.valueType = options.valueType.toLowerCase())\r\n}\r\n\r\nfunction getOptimalAngle(boxes, labelOpt) {\r\n    var angle = 180 * _math.asin((boxes[0].height + labelOpt.minSpacing) / (boxes[1].x - boxes[0].x)) / _math.PI;\r\n    return angle < 45 ? -45 : -90\r\n}\r\n\r\nfunction updateLabels(ticks, step, func) {\r\n    ticks.forEach((function(tick, index) {\r\n        if (tick.getContentContainer()) {\r\n            if (index % step !== 0) {\r\n                tick.removeLabel()\r\n            } else if (func) {\r\n                func(tick, index)\r\n            }\r\n        }\r\n    }))\r\n}\r\n\r\nfunction getZoomBoundValue(optionValue, dataValue) {\r\n    if (void 0 === optionValue) {\r\n        return dataValue\r\n    } else if (null === optionValue) {\r\n        return\r\n    } else {\r\n        return optionValue\r\n    }\r\n}\r\n\r\nfunction configureGenerator(options, axisDivisionFactor, viewPort, screenDelta, minTickInterval) {\r\n    var tickGeneratorOptions = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])({}, options, {\r\n        endOnTick: true,\r\n        axisDivisionFactor: axisDivisionFactor,\r\n        skipCalculationLimits: true,\r\n        generateExtraTick: true,\r\n        minTickInterval: minTickInterval\r\n    });\r\n    return function(tickInterval, skipTickGeneration, min, max, breaks) {\r\n        return getTickGenerator(tickGeneratorOptions, _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"], skipTickGeneration, viewPort.isEmpty(), v => v, viewPort)({\r\n            min: min,\r\n            max: max,\r\n            categories: viewPort.categories,\r\n            isSpacedMargin: viewPort.isSpacedMargin\r\n        }, screenDelta, tickInterval, Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(tickInterval), void 0, void 0, void 0, breaks)\r\n    }\r\n}\r\n\r\nfunction getConstantLineSharpDirection(coord, axisCanvas) {\r\n    return Math.max(axisCanvas.start, axisCanvas.end) !== coord ? 1 : -1\r\n}\r\nvar Axis = function(renderSettings) {\r\n    this._renderer = renderSettings.renderer;\r\n    this._incidentOccurred = renderSettings.incidentOccurred;\r\n    this._eventTrigger = renderSettings.eventTrigger;\r\n    this._stripsGroup = renderSettings.stripsGroup;\r\n    this._stripLabelAxesGroup = renderSettings.stripLabelAxesGroup;\r\n    this._labelsAxesGroup = renderSettings.labelsAxesGroup;\r\n    this._constantLinesGroup = renderSettings.constantLinesGroup;\r\n    this._scaleBreaksGroup = renderSettings.scaleBreaksGroup;\r\n    this._axesContainerGroup = renderSettings.axesContainerGroup;\r\n    this._gridContainerGroup = renderSettings.gridGroup;\r\n    this._axisCssPrefix = renderSettings.widgetClass + \"-\" + (renderSettings.axisClass ? renderSettings.axisClass + \"-\" : \"\");\r\n    this._setType(renderSettings.axisType, renderSettings.drawingType);\r\n    this._createAxisGroups();\r\n    this._translator = this._createTranslator();\r\n    this.isArgumentAxis = renderSettings.isArgumentAxis;\r\n    this._viewport = {};\r\n    this._prevDataInfo = {};\r\n    this._firstDrawing = true;\r\n    this._initRange = {};\r\n    this._getTemplate = renderSettings.getTemplate\r\n};\r\nAxis.prototype = {\r\n    constructor: Axis,\r\n    _drawAxis() {\r\n        var options = this._options;\r\n        if (!options.visible) {\r\n            return\r\n        }\r\n        this._axisElement = this._createAxisElement();\r\n        this._updateAxisElementPosition();\r\n        this._axisElement.attr({\r\n            \"stroke-width\": options.width,\r\n            stroke: options.color,\r\n            \"stroke-opacity\": options.opacity\r\n        }).sharp(this._getSharpParam(true), this.getAxisSharpDirection()).append(this._axisLineGroup)\r\n    },\r\n    _createPathElement(points, attr, sharpDirection) {\r\n        return this.sharp(this._renderer.path(points, \"line\").attr(attr), sharpDirection)\r\n    },\r\n    sharp(svgElement) {\r\n        var sharpDirection = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\r\n        return svgElement.sharp(this._getSharpParam(), sharpDirection)\r\n    },\r\n    customPositionIsAvailable: () => false,\r\n    getOrthogonalAxis: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    getCustomPosition: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    getCustomBoundaryPosition: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    resolveOverlappingForCustomPositioning: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    hasNonBoundaryPosition: () => false,\r\n    customPositionIsBoundaryOrthogonalAxis: () => false,\r\n    getResolvedBoundaryPosition() {\r\n        return this.getOptions().position\r\n    },\r\n    getAxisSharpDirection() {\r\n        var position = this.getResolvedBoundaryPosition();\r\n        return this.hasNonBoundaryPosition() || position !== BOTTOM && position !== RIGHT ? 1 : -1\r\n    },\r\n    getSharpDirectionByCoords(coords) {\r\n        var canvas = this._getCanvasStartEnd();\r\n        var maxCoord = Math.max(canvas.start, canvas.end);\r\n        return this.getRadius ? 0 : maxCoord !== coords[this._isHorizontal ? \"x\" : \"y\"] ? 1 : -1\r\n    },\r\n    _getGridLineDrawer: function() {\r\n        var that = this;\r\n        return function(tick, gridStyle) {\r\n            var grid = that._getGridPoints(tick.coords);\r\n            if (grid.points) {\r\n                return that._createPathElement(grid.points, gridStyle, that.getSharpDirectionByCoords(tick.coords))\r\n            }\r\n            return null\r\n        }\r\n    },\r\n    _getGridPoints: function(coords) {\r\n        var isHorizontal = this._isHorizontal;\r\n        var tickPositionField = isHorizontal ? \"x\" : \"y\";\r\n        var orthogonalPositions = this._orthogonalPositions;\r\n        var positionFrom = orthogonalPositions.start;\r\n        var positionTo = orthogonalPositions.end;\r\n        var borderOptions = this.borderOptions;\r\n        var canvasStart = isHorizontal ? LEFT : TOP;\r\n        var canvasEnd = isHorizontal ? RIGHT : BOTTOM;\r\n        var axisCanvas = this.getCanvas();\r\n        var canvas = {\r\n            left: axisCanvas.left,\r\n            right: axisCanvas.width - axisCanvas.right,\r\n            top: axisCanvas.top,\r\n            bottom: axisCanvas.height - axisCanvas.bottom\r\n        };\r\n        var firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? canvas[canvasStart] : void 0;\r\n        var lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? canvas[canvasEnd] : void 0;\r\n        var minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition;\r\n        var maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;\r\n        if (this.areCoordsOutsideAxis(coords) || void 0 === coords[tickPositionField] || coords[tickPositionField] < minDelta || coords[tickPositionField] > maxDelta) {\r\n            return {\r\n                points: null\r\n            }\r\n        }\r\n        return {\r\n            points: isHorizontal ? null !== coords[tickPositionField] ? [coords[tickPositionField], positionFrom, coords[tickPositionField], positionTo] : null : null !== coords[tickPositionField] ? [positionFrom, coords[tickPositionField], positionTo, coords[tickPositionField]] : null\r\n        }\r\n    },\r\n    _getConstantLinePos: function(parsedValue, canvasStart, canvasEnd) {\r\n        var value = this._getTranslatedCoord(parsedValue);\r\n        if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(value) || value < _min(canvasStart, canvasEnd) || value > _max(canvasStart, canvasEnd)) {\r\n            return\r\n        }\r\n        return value\r\n    },\r\n    _getConstantLineGraphicAttributes: function(value) {\r\n        var positionFrom = this._orthogonalPositions.start;\r\n        var positionTo = this._orthogonalPositions.end;\r\n        return {\r\n            points: this._isHorizontal ? [value, positionFrom, value, positionTo] : [positionFrom, value, positionTo, value]\r\n        }\r\n    },\r\n    _createConstantLine: function(value, attr) {\r\n        return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr, getConstantLineSharpDirection(value, this._getCanvasStartEnd()))\r\n    },\r\n    _drawConstantLineLabelText: function(text, x, y, _ref2, group) {\r\n        var {\r\n            font: font,\r\n            cssClass: cssClass\r\n        } = _ref2;\r\n        return this._renderer.text(text, x, y).css(Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"patchFontOptions\"])(Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])({}, this._options.label.font, font))).attr({\r\n            align: \"center\",\r\n            class: cssClass\r\n        }).append(group)\r\n    },\r\n    _drawConstantLineLabels: function(parsedValue, lineLabelOptions, value, group) {\r\n        var _text;\r\n        var text = lineLabelOptions.text;\r\n        var options = this._options;\r\n        var labelOptions = options.label;\r\n        this._checkAlignmentConstantLineLabels(lineLabelOptions);\r\n        text = null !== (_text = text) && void 0 !== _text ? _text : this.formatLabel(parsedValue, labelOptions);\r\n        var coords = this._getConstantLineLabelsCoords(value, lineLabelOptions);\r\n        return this._drawConstantLineLabelText(text, coords.x, coords.y, lineLabelOptions, group)\r\n    },\r\n    _getStripPos: function(startValue, endValue, canvasStart, canvasEnd, range) {\r\n        var isContinuous = !!(range.minVisible || range.maxVisible);\r\n        var categories = (range.categories || []).reduce((function(result, cat) {\r\n            result.push(cat.valueOf());\r\n            return result\r\n        }), []);\r\n        var start;\r\n        var end;\r\n        var swap;\r\n        var startCategoryIndex;\r\n        var endCategoryIndex;\r\n        if (!isContinuous) {\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(startValue) && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(endValue)) {\r\n                var parsedStartValue = this.parser(startValue);\r\n                var parsedEndValue = this.parser(endValue);\r\n                startCategoryIndex = Object(_core_utils_array__WEBPACK_IMPORTED_MODULE_5__[\"inArray\"])(Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(parsedStartValue) ? parsedStartValue.valueOf() : void 0, categories);\r\n                endCategoryIndex = Object(_core_utils_array__WEBPACK_IMPORTED_MODULE_5__[\"inArray\"])(Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(parsedEndValue) ? parsedEndValue.valueOf() : void 0, categories);\r\n                if (-1 === startCategoryIndex || -1 === endCategoryIndex) {\r\n                    return {\r\n                        from: 0,\r\n                        to: 0,\r\n                        outOfCanvas: true\r\n                    }\r\n                }\r\n                if (startCategoryIndex > endCategoryIndex) {\r\n                    swap = endValue;\r\n                    endValue = startValue;\r\n                    startValue = swap\r\n                }\r\n            }\r\n        }\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(startValue)) {\r\n            startValue = this.validateUnit(startValue, \"E2105\", \"strip\");\r\n            start = this._getTranslatedCoord(startValue, -1)\r\n        } else {\r\n            start = canvasStart\r\n        }\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(endValue)) {\r\n            endValue = this.validateUnit(endValue, \"E2105\", \"strip\");\r\n            end = this._getTranslatedCoord(endValue, 1)\r\n        } else {\r\n            end = canvasEnd\r\n        }\r\n        var stripPosition = start < end ? {\r\n            from: start,\r\n            to: end\r\n        } : {\r\n            from: end,\r\n            to: start\r\n        };\r\n        var visibleArea = this.getVisibleArea();\r\n        if (stripPosition.from <= visibleArea[0] && stripPosition.to <= visibleArea[0] || stripPosition.from >= visibleArea[1] && stripPosition.to >= visibleArea[1]) {\r\n            stripPosition.outOfCanvas = true\r\n        }\r\n        return stripPosition\r\n    },\r\n    _getStripGraphicAttributes: function(fromPoint, toPoint) {\r\n        var x;\r\n        var y;\r\n        var width;\r\n        var height;\r\n        var orthogonalPositions = this._orthogonalPositions;\r\n        var positionFrom = orthogonalPositions.start;\r\n        var positionTo = orthogonalPositions.end;\r\n        if (this._isHorizontal) {\r\n            x = fromPoint;\r\n            y = _min(positionFrom, positionTo);\r\n            width = toPoint - fromPoint;\r\n            height = _abs(positionFrom - positionTo)\r\n        } else {\r\n            x = _min(positionFrom, positionTo);\r\n            y = fromPoint;\r\n            width = _abs(positionFrom - positionTo);\r\n            height = _abs(fromPoint - toPoint)\r\n        }\r\n        return {\r\n            x: x,\r\n            y: y,\r\n            width: width,\r\n            height: height\r\n        }\r\n    },\r\n    _createStrip: function(attrs) {\r\n        return this._renderer.rect(attrs.x, attrs.y, attrs.width, attrs.height)\r\n    },\r\n    _adjustStripLabels: function() {\r\n        var that = this;\r\n        this._strips.forEach((function(strip) {\r\n            if (strip.label) {\r\n                strip.label.attr(that._getAdjustedStripLabelCoords(strip))\r\n            }\r\n        }))\r\n    },\r\n    _adjustLabelsCoord(offset, maxWidth, checkCanvas) {\r\n        var getContainerAttrs = tick => this._getLabelAdjustedCoord(tick, offset + (tick.labelOffset || 0), maxWidth, checkCanvas);\r\n        this._majorTicks.forEach((function(tick) {\r\n            if (tick.label) {\r\n                tick.updateMultilineTextAlignment();\r\n                tick.label.attr(getContainerAttrs(tick))\r\n            } else {\r\n                tick.templateContainer && tick.templateContainer.attr(getContainerAttrs(tick))\r\n            }\r\n        }))\r\n    },\r\n    _adjustLabels: function(offset) {\r\n        var options = this.getOptions();\r\n        var positionsAreConsistent = options.position === options.label.position;\r\n        var maxSize = this._majorTicks.reduce((function(size, tick) {\r\n            if (!tick.getContentContainer()) {\r\n                return size\r\n            }\r\n            var bBox = tick.labelRotationAngle ? Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"rotateBBox\"])(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle) : tick.labelBBox;\r\n            return {\r\n                width: _max(size.width || 0, bBox.width),\r\n                height: _max(size.height || 0, bBox.height),\r\n                offset: _max(size.offset || 0, tick.labelOffset || 0)\r\n            }\r\n        }), {});\r\n        var additionalOffset = positionsAreConsistent ? this._isHorizontal ? maxSize.height : maxSize.width : 0;\r\n        this._adjustLabelsCoord(offset, maxSize.width);\r\n        return offset + additionalOffset + (additionalOffset && this._options.label.indentFromAxis) + (positionsAreConsistent ? maxSize.offset : 0)\r\n    },\r\n    _getLabelAdjustedCoord: function(tick, offset, maxWidth) {\r\n        offset = offset || 0;\r\n        var options = this._options;\r\n        var templateBox = tick.templateContainer && tick.templateContainer.getBBox();\r\n        var box = templateBox || Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"rotateBBox\"])(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle || 0);\r\n        var textAlign = tick.labelAlignment || options.label.alignment;\r\n        var isDiscrete = \"discrete\" === this._options.type;\r\n        var isFlatLabel = tick.labelRotationAngle % 90 === 0;\r\n        var indentFromAxis = options.label.indentFromAxis;\r\n        var labelPosition = options.label.position;\r\n        var axisPosition = this._axisPosition;\r\n        var labelCoords = tick.labelCoords;\r\n        var labelX = labelCoords.x;\r\n        var translateX;\r\n        var translateY;\r\n        if (this._isHorizontal) {\r\n            if (labelPosition === BOTTOM) {\r\n                translateY = axisPosition + indentFromAxis - box.y + offset\r\n            } else {\r\n                translateY = axisPosition - indentFromAxis - (box.y + box.height) - offset\r\n            }\r\n            if (textAlign === RIGHT) {\r\n                translateX = isDiscrete && isFlatLabel ? tick.coords.x - (box.x + box.width) : labelX - box.x - box.width\r\n            } else if (textAlign === LEFT) {\r\n                translateX = isDiscrete && isFlatLabel ? labelX - box.x - (tick.coords.x - labelX) : labelX - box.x\r\n            } else {\r\n                translateX = labelX - box.x - box.width / 2\r\n            }\r\n        } else {\r\n            translateY = labelCoords.y - box.y - box.height / 2;\r\n            if (labelPosition === LEFT) {\r\n                if (textAlign === LEFT) {\r\n                    translateX = axisPosition - indentFromAxis - maxWidth - box.x\r\n                } else if (textAlign === CENTER) {\r\n                    translateX = axisPosition - indentFromAxis - maxWidth / 2 - box.x - box.width / 2\r\n                } else {\r\n                    translateX = axisPosition - indentFromAxis - box.x - box.width\r\n                }\r\n                translateX -= offset\r\n            } else {\r\n                if (textAlign === RIGHT) {\r\n                    translateX = axisPosition + indentFromAxis + maxWidth - box.x - box.width\r\n                } else if (textAlign === CENTER) {\r\n                    translateX = axisPosition + indentFromAxis + maxWidth / 2 - box.x - box.width / 2\r\n                } else {\r\n                    translateX = axisPosition + indentFromAxis - box.x\r\n                }\r\n                translateX += offset\r\n            }\r\n        }\r\n        return {\r\n            translateX: translateX,\r\n            translateY: translateY\r\n        }\r\n    },\r\n    _createAxisConstantLineGroups: function() {\r\n        var renderer = this._renderer;\r\n        var classSelector = this._axisCssPrefix;\r\n        var constantLinesClass = classSelector + \"constant-lines\";\r\n        var insideGroup = renderer.g().attr({\r\n            class: constantLinesClass\r\n        });\r\n        var outsideGroup1 = renderer.g().attr({\r\n            class: constantLinesClass\r\n        });\r\n        var outsideGroup2 = renderer.g().attr({\r\n            class: constantLinesClass\r\n        });\r\n        return {\r\n            inside: insideGroup,\r\n            outside1: outsideGroup1,\r\n            left: outsideGroup1,\r\n            top: outsideGroup1,\r\n            outside2: outsideGroup2,\r\n            right: outsideGroup2,\r\n            bottom: outsideGroup2,\r\n            remove: function() {\r\n                this.inside.remove();\r\n                this.outside1.remove();\r\n                this.outside2.remove()\r\n            },\r\n            clear: function() {\r\n                this.inside.clear();\r\n                this.outside1.clear();\r\n                this.outside2.clear()\r\n            }\r\n        }\r\n    },\r\n    _createAxisGroups: function() {\r\n        var renderer = this._renderer;\r\n        var classSelector = this._axisCssPrefix;\r\n        this._axisGroup = renderer.g().attr({\r\n            class: classSelector + \"axis\"\r\n        }).enableLinks();\r\n        this._axisStripGroup = renderer.g().attr({\r\n            class: classSelector + \"strips\"\r\n        });\r\n        this._axisGridGroup = renderer.g().attr({\r\n            class: classSelector + \"grid\"\r\n        });\r\n        this._axisElementsGroup = renderer.g().attr({\r\n            class: classSelector + \"elements\"\r\n        });\r\n        this._axisLineGroup = renderer.g().attr({\r\n            class: classSelector + \"line\"\r\n        }).linkOn(this._axisGroup, \"axisLine\").linkAppend();\r\n        this._axisTitleGroup = renderer.g().attr({\r\n            class: classSelector + \"title\"\r\n        }).append(this._axisGroup);\r\n        this._axisConstantLineGroups = {\r\n            above: this._createAxisConstantLineGroups(),\r\n            under: this._createAxisConstantLineGroups()\r\n        };\r\n        this._axisStripLabelGroup = renderer.g().attr({\r\n            class: classSelector + \"axis-labels\"\r\n        })\r\n    },\r\n    _clearAxisGroups: function() {\r\n        this._axisGroup.remove();\r\n        this._axisStripGroup.remove();\r\n        this._axisStripLabelGroup.remove();\r\n        this._axisConstantLineGroups.above.remove();\r\n        this._axisConstantLineGroups.under.remove();\r\n        this._axisGridGroup.remove();\r\n        this._axisTitleGroup.clear();\r\n        if (!this._options.label.template || !this.isRendered()) {\r\n            this._axisElementsGroup.remove();\r\n            this._axisElementsGroup.clear()\r\n        }\r\n        this._axisLineGroup && this._axisLineGroup.clear();\r\n        this._axisStripGroup && this._axisStripGroup.clear();\r\n        this._axisGridGroup && this._axisGridGroup.clear();\r\n        this._axisConstantLineGroups.above.clear();\r\n        this._axisConstantLineGroups.under.clear();\r\n        this._axisStripLabelGroup && this._axisStripLabelGroup.clear()\r\n    },\r\n    _getLabelFormatObject: function(value, labelOptions, range, point, tickInterval, ticks) {\r\n        range = range || this._getViewportRange();\r\n        var formatObject = {\r\n            value: value,\r\n            valueText: Object(_smart_formatter__WEBPACK_IMPORTED_MODULE_0__[\"smartFormatter\"])(value, {\r\n                labelOptions: labelOptions,\r\n                ticks: ticks || convertTicksToValues(this._majorTicks),\r\n                tickInterval: null !== tickInterval && void 0 !== tickInterval ? tickInterval : this._tickInterval,\r\n                dataType: this._options.dataType,\r\n                logarithmBase: this._options.logarithmBase,\r\n                type: this._options.type,\r\n                showTransition: !this._options.marker.visible,\r\n                point: point\r\n            }) || \"\",\r\n            min: range.minVisible,\r\n            max: range.maxVisible\r\n        };\r\n        if (point) {\r\n            formatObject.point = point\r\n        }\r\n        return formatObject\r\n    },\r\n    formatLabel: function(value, labelOptions, range, point, tickInterval, ticks) {\r\n        var formatObject = this._getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks);\r\n        return Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(labelOptions.customizeText) ? labelOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText\r\n    },\r\n    formatHint: function(value, labelOptions, range) {\r\n        var formatObject = this._getLabelFormatObject(value, labelOptions, range);\r\n        return Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(labelOptions.customizeHint) ? labelOptions.customizeHint.call(formatObject, formatObject) : void 0\r\n    },\r\n    formatRange(startValue, endValue, interval, argumentFormat) {\r\n        return Object(_smart_formatter__WEBPACK_IMPORTED_MODULE_0__[\"formatRange\"])({\r\n            startValue: startValue,\r\n            endValue: endValue,\r\n            tickInterval: interval,\r\n            argumentFormat: argumentFormat,\r\n            axisOptions: this.getOptions()\r\n        })\r\n    },\r\n    _setTickOffset: function() {\r\n        var options = this._options;\r\n        var discreteAxisDivisionMode = options.discreteAxisDivisionMode;\r\n        this._tickOffset = +(\"crossLabels\" !== discreteAxisDivisionMode || !discreteAxisDivisionMode)\r\n    },\r\n    aggregatedPointBetweenTicks() {\r\n        return \"crossTicks\" === this._options.aggregatedPointsPosition\r\n    },\r\n    resetApplyingAnimation: function(isFirstDrawing) {\r\n        this._resetApplyingAnimation = true;\r\n        if (isFirstDrawing) {\r\n            this._firstDrawing = true\r\n        }\r\n    },\r\n    isFirstDrawing() {\r\n        return this._firstDrawing\r\n    },\r\n    getMargins: function() {\r\n        var that = this;\r\n        var {\r\n            position: position,\r\n            offset: offset,\r\n            customPosition: customPosition,\r\n            placeholderSize: placeholderSize,\r\n            grid: grid,\r\n            tick: tick,\r\n            crosshairMargin: crosshairMargin\r\n        } = that._options;\r\n        var isDefinedCustomPositionOption = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(customPosition);\r\n        var boundaryPosition = that.getResolvedBoundaryPosition();\r\n        var canvas = that.getCanvas();\r\n        var cLeft = canvas.left;\r\n        var cTop = canvas.top;\r\n        var cRight = canvas.width - canvas.right;\r\n        var cBottom = canvas.height - canvas.bottom;\r\n        var edgeMarginCorrection = _max(grid.visible && grid.width || 0, tick.visible && tick.width || 0);\r\n        var constantLineAboveSeries = that._axisConstantLineGroups.above;\r\n        var constantLineUnderSeries = that._axisConstantLineGroups.under;\r\n        var boxes = [that._axisElementsGroup, constantLineAboveSeries.outside1, constantLineAboveSeries.outside2, constantLineUnderSeries.outside1, constantLineUnderSeries.outside2, that._axisLineGroup].map(group => group && group.getBBox()).concat(function(group) {\r\n            var box = group && group.getBBox();\r\n            if (!box || box.isEmpty) {\r\n                return box\r\n            }\r\n            if (that._isHorizontal) {\r\n                box.x = cLeft;\r\n                box.width = cRight - cLeft\r\n            } else {\r\n                box.y = cTop;\r\n                box.height = cBottom - cTop\r\n            }\r\n            return box\r\n        }(that._axisTitleGroup));\r\n        var margins = Object(_axes_utils__WEBPACK_IMPORTED_MODULE_20__[\"calculateCanvasMargins\"])(boxes, canvas);\r\n        margins[position] += crosshairMargin;\r\n        if (that.hasNonBoundaryPosition() && isDefinedCustomPositionOption) {\r\n            margins[boundaryPosition] = 0\r\n        }\r\n        if (placeholderSize) {\r\n            margins[position] = placeholderSize\r\n        }\r\n        if (edgeMarginCorrection) {\r\n            if (that._isHorizontal && canvas.right < edgeMarginCorrection && margins.right < edgeMarginCorrection) {\r\n                margins.right = edgeMarginCorrection\r\n            }\r\n            if (!that._isHorizontal && canvas.bottom < edgeMarginCorrection && margins.bottom < edgeMarginCorrection) {\r\n                margins.bottom = edgeMarginCorrection\r\n            }\r\n        }\r\n        if (!isDefinedCustomPositionOption && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(offset)) {\r\n            var moveByOffset = that.customPositionIsBoundary() && (offset > 0 && (boundaryPosition === LEFT || boundaryPosition === TOP) || offset < 0 && (boundaryPosition === RIGHT || boundaryPosition === BOTTOM));\r\n            margins[boundaryPosition] -= moveByOffset ? offset : 0\r\n        }\r\n        return margins\r\n    },\r\n    validateUnit: function(unit, idError, parameters) {\r\n        unit = this.parser(unit);\r\n        if (void 0 === unit && idError) {\r\n            this._incidentOccurred(idError, [parameters])\r\n        }\r\n        return unit\r\n    },\r\n    _setType: function(axisType, drawingType) {\r\n        var axisTypeMethods;\r\n        switch (axisType) {\r\n            case \"xyAxes\":\r\n                axisTypeMethods = _xy_axes__WEBPACK_IMPORTED_MODULE_15__[\"default\"];\r\n                break;\r\n            case \"polarAxes\":\r\n                axisTypeMethods = _polar_axes__WEBPACK_IMPORTED_MODULE_16__\r\n        }\r\n        Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])(this, axisTypeMethods[drawingType])\r\n    },\r\n    _getSharpParam: function() {\r\n        return true\r\n    },\r\n    _disposeBreaksGroup: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    dispose: function() {\r\n        [this._axisElementsGroup, this._axisStripGroup, this._axisGroup].forEach((function(g) {\r\n            g.dispose()\r\n        }));\r\n        this._strips = this._title = null;\r\n        this._axisStripGroup = this._axisConstantLineGroups = this._axisStripLabelGroup = this._axisBreaksGroup = null;\r\n        this._axisLineGroup = this._axisElementsGroup = this._axisGridGroup = null;\r\n        this._axisGroup = this._axisTitleGroup = null;\r\n        this._axesContainerGroup = this._stripsGroup = this._constantLinesGroup = this._labelsAxesGroup = null;\r\n        this._renderer = this._options = this._textOptions = this._textFontStyles = null;\r\n        this._translator = null;\r\n        this._majorTicks = this._minorTicks = null;\r\n        this._disposeBreaksGroup();\r\n        this._templatesRendered && this._templatesRendered.reject()\r\n    },\r\n    getOptions: function() {\r\n        return this._options\r\n    },\r\n    setPane: function(pane) {\r\n        this.pane = pane;\r\n        this._options.pane = pane\r\n    },\r\n    setTypes: function(type, axisType, typeSelector) {\r\n        this._options.type = type || this._options.type;\r\n        this._options[typeSelector] = axisType || this._options[typeSelector];\r\n        this._updateTranslator()\r\n    },\r\n    resetTypes: function(typeSelector) {\r\n        this._options.type = this._initTypes.type;\r\n        this._options[typeSelector] = this._initTypes[typeSelector]\r\n    },\r\n    getTranslator: function() {\r\n        return this._translator\r\n    },\r\n    updateOptions: function(options) {\r\n        var that = this;\r\n        var labelOpt = options.label;\r\n        validateAxisOptions(options);\r\n        that._options = options;\r\n        options.tick = options.tick || {};\r\n        options.minorTick = options.minorTick || {};\r\n        options.grid = options.grid || {};\r\n        options.minorGrid = options.minorGrid || {};\r\n        options.title = options.title || {};\r\n        options.marker = options.marker || {};\r\n        that._initTypes = {\r\n            type: options.type,\r\n            argumentType: options.argumentType,\r\n            valueType: options.valueType\r\n        };\r\n        that._setTickOffset();\r\n        that._isHorizontal = options.isHorizontal;\r\n        that.pane = options.pane;\r\n        that.name = options.name;\r\n        that.priority = options.priority;\r\n        that._hasLabelFormat = \"\" !== labelOpt.format && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(labelOpt.format);\r\n        that._textOptions = {\r\n            opacity: labelOpt.opacity,\r\n            align: \"center\",\r\n            class: labelOpt.cssClass\r\n        };\r\n        that._textFontStyles = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"patchFontOptions\"])(labelOpt.font);\r\n        if (options.type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].logarithmic) {\r\n            if (options.logarithmBaseError) {\r\n                that._incidentOccurred(\"E2104\");\r\n                delete options.logarithmBaseError\r\n            }\r\n        }\r\n        that._updateTranslator();\r\n        that._createConstantLines();\r\n        that._strips = (options.strips || []).map(o => Object(_strip__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(that, o));\r\n        that._majorTicks = that._minorTicks = null;\r\n        that._firstDrawing = true\r\n    },\r\n    calculateInterval: function(value, prevValue) {\r\n        var options = this._options;\r\n        if (!options || options.type !== _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].logarithmic) {\r\n            return _abs(value - prevValue)\r\n        }\r\n        var {\r\n            allowNegatives: allowNegatives,\r\n            linearThreshold: linearThreshold\r\n        } = new _translators_range__WEBPACK_IMPORTED_MODULE_10__[\"Range\"](this.getTranslator().getBusinessRange());\r\n        return _abs(Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getLogExt\"])(value, options.logarithmBase, allowNegatives, linearThreshold) - Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getLogExt\"])(prevValue, options.logarithmBase, allowNegatives, linearThreshold))\r\n    },\r\n    getCanvasRange() {\r\n        var translator = this._translator;\r\n        return {\r\n            startValue: translator.from(translator.translate(\"canvas_position_start\")),\r\n            endValue: translator.from(translator.translate(\"canvas_position_end\"))\r\n        }\r\n    },\r\n    _processCanvas: function(canvas) {\r\n        return canvas\r\n    },\r\n    updateCanvas: function(canvas, canvasRedesign) {\r\n        if (!canvasRedesign) {\r\n            var positions = this._orthogonalPositions = {\r\n                start: !this._isHorizontal ? canvas.left : canvas.top,\r\n                end: !this._isHorizontal ? canvas.width - canvas.right : canvas.height - canvas.bottom\r\n            };\r\n            positions.center = positions.start + (positions.end - positions.start) / 2\r\n        } else {\r\n            this._orthogonalPositions = null\r\n        }\r\n        this._canvas = canvas;\r\n        this._translator.updateCanvas(this._processCanvas(canvas));\r\n        this._initAxisPositions()\r\n    },\r\n    getCanvas: function() {\r\n        return this._canvas\r\n    },\r\n    getAxisShift() {\r\n        return this._axisShift || 0\r\n    },\r\n    hideTitle: function() {\r\n        if (this._options.title.text) {\r\n            this._incidentOccurred(\"W2105\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\r\n            this._axisTitleGroup.clear()\r\n        }\r\n    },\r\n    getTitle: function() {\r\n        return this._title\r\n    },\r\n    hideOuterElements: function() {\r\n        var options = this._options;\r\n        if ((options.label.visible || this._outsideConstantLines.length) && !this._translator.getBusinessRange().isEmpty()) {\r\n            this._incidentOccurred(\"W2106\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\r\n            this._axisElementsGroup.clear();\r\n            callAction(this._outsideConstantLines, \"removeLabel\")\r\n        }\r\n    },\r\n    _resolveLogarithmicOptionsForRange(range) {\r\n        var options = this._options;\r\n        if (options.type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].logarithmic) {\r\n            range.addRange({\r\n                allowNegatives: void 0 !== options.allowNegatives ? options.allowNegatives : range.min <= 0\r\n            });\r\n            if (!isNaN(options.linearThreshold)) {\r\n                range.linearThreshold = options.linearThreshold\r\n            }\r\n        }\r\n    },\r\n    adjustViewport(businessRange) {\r\n        var options = this._options;\r\n        var isDiscrete = options.type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete;\r\n        var categories = this._seriesData && this._seriesData.categories || [];\r\n        var wholeRange = this.adjustRange(Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getVizRangeObject\"])(options.wholeRange));\r\n        var visualRange = this.getViewport() || {};\r\n        var result = new _translators_range__WEBPACK_IMPORTED_MODULE_10__[\"Range\"](businessRange);\r\n        this._addConstantLinesToRange(result, \"minVisible\", \"maxVisible\");\r\n        var minDefined = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(visualRange.startValue);\r\n        var maxDefined = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(visualRange.endValue);\r\n        if (!isDiscrete) {\r\n            minDefined = minDefined && (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(wholeRange.endValue) || visualRange.startValue < wholeRange.endValue);\r\n            maxDefined = maxDefined && (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(wholeRange.startValue) || visualRange.endValue > wholeRange.startValue)\r\n        }\r\n        var minVisible = minDefined ? visualRange.startValue : result.minVisible;\r\n        var maxVisible = maxDefined ? visualRange.endValue : result.maxVisible;\r\n        if (!isDiscrete) {\r\n            var _wholeRange$startValu, _wholeRange$endValue;\r\n            result.min = null !== (_wholeRange$startValu = wholeRange.startValue) && void 0 !== _wholeRange$startValu ? _wholeRange$startValu : result.min;\r\n            result.max = null !== (_wholeRange$endValue = wholeRange.endValue) && void 0 !== _wholeRange$endValue ? _wholeRange$endValue : result.max\r\n        } else {\r\n            var categoriesInfo = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getCategoriesInfo\"])(categories, wholeRange.startValue, wholeRange.endValue);\r\n            categories = categoriesInfo.categories;\r\n            result.categories = categories\r\n        }\r\n        var adjustedVisualRange = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"adjustVisualRange\"])({\r\n            axisType: options.type,\r\n            dataType: options.dataType,\r\n            base: options.logarithmBase\r\n        }, {\r\n            startValue: minDefined ? visualRange.startValue : void 0,\r\n            endValue: maxDefined ? visualRange.endValue : void 0,\r\n            length: visualRange.length\r\n        }, {\r\n            categories: categories,\r\n            min: wholeRange.startValue,\r\n            max: wholeRange.endValue\r\n        }, {\r\n            categories: categories,\r\n            min: minVisible,\r\n            max: maxVisible\r\n        });\r\n        result.minVisible = adjustedVisualRange.startValue;\r\n        result.maxVisible = adjustedVisualRange.endValue;\r\n        !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(result.min) && (result.min = result.minVisible);\r\n        !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(result.max) && (result.max = result.maxVisible);\r\n        result.addRange({});\r\n        this._resolveLogarithmicOptionsForRange(result);\r\n        return result\r\n    },\r\n    adjustRange(range) {\r\n        range = range || {};\r\n        var isDiscrete = this._options.type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete;\r\n        var isLogarithmic = this._options.type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].logarithmic;\r\n        var disabledNegatives = false === this._options.allowNegatives;\r\n        if (isLogarithmic) {\r\n            range.startValue = disabledNegatives && range.startValue <= 0 ? null : range.startValue;\r\n            range.endValue = disabledNegatives && range.endValue <= 0 ? null : range.endValue\r\n        }\r\n        if (!isDiscrete && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(range.startValue) && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(range.endValue) && range.startValue > range.endValue) {\r\n            var tmp = range.endValue;\r\n            range.endValue = range.startValue;\r\n            range.startValue = tmp\r\n        }\r\n        return range\r\n    },\r\n    _getVisualRangeUpdateMode(viewport, newRange, oppositeValue) {\r\n        var value = this._options.visualRangeUpdateMode;\r\n        var translator = this._translator;\r\n        var range = this._seriesData;\r\n        var prevDataInfo = this._prevDataInfo;\r\n        if (prevDataInfo.isEmpty && !prevDataInfo.containsConstantLine) {\r\n            return KEEP\r\n        }\r\n        if (!this.isArgumentAxis) {\r\n            var _viewport = this.getViewport();\r\n            if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(_viewport.startValue) && !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(_viewport.endValue) && !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(_viewport.length)) {\r\n                return RESET\r\n            }\r\n        }\r\n        if (this.isArgumentAxis) {\r\n            if (-1 === [SHIFT, KEEP, RESET].indexOf(value)) {\r\n                if (range.axisType === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete) {\r\n                    var categories = range.categories;\r\n                    var newCategories = newRange.categories;\r\n                    var visualRange = this.visualRange();\r\n                    if (categories && newCategories && categories.length && -1 !== newCategories.map(c => c.valueOf()).join(\",\").indexOf(categories.map(c => c.valueOf()).join(\",\")) && (visualRange.startValue.valueOf() !== categories[0].valueOf() || visualRange.endValue.valueOf() !== categories[categories.length - 1].valueOf())) {\r\n                        value = KEEP\r\n                    } else {\r\n                        value = RESET\r\n                    }\r\n                } else {\r\n                    var minPoint = translator.translate(range.min);\r\n                    var minVisiblePoint = translator.translate(viewport.startValue);\r\n                    var maxPoint = translator.translate(range.max);\r\n                    var maxVisiblePoint = translator.translate(viewport.endValue);\r\n                    if (minPoint === minVisiblePoint && maxPoint === maxVisiblePoint) {\r\n                        value = RESET\r\n                    } else if (minPoint !== minVisiblePoint && maxPoint === maxVisiblePoint) {\r\n                        value = SHIFT\r\n                    } else {\r\n                        value = KEEP\r\n                    }\r\n                }\r\n                if (value === KEEP && prevDataInfo.isEmpty && prevDataInfo.containsConstantLine) {\r\n                    value = RESET\r\n                }\r\n            }\r\n        } else if (-1 === [KEEP, RESET].indexOf(value)) {\r\n            if (oppositeValue === KEEP) {\r\n                value = KEEP\r\n            } else {\r\n                value = RESET\r\n            }\r\n        }\r\n        return value\r\n    },\r\n    _handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, newRange) {\r\n        var visualRange = this.visualRange();\r\n        if (axisReinitialized || this._translator.getBusinessRange().isEmpty()) {\r\n            return\r\n        }\r\n        var visualRangeUpdateMode = this._lastVisualRangeUpdateMode = this._getVisualRangeUpdateMode(visualRange, newRange, oppositeVisualRangeUpdateMode);\r\n        if (visualRangeUpdateMode === KEEP) {\r\n            this._setVisualRange([visualRange.startValue, visualRange.endValue])\r\n        } else if (visualRangeUpdateMode === RESET) {\r\n            this._setVisualRange([null, null])\r\n        } else if (visualRangeUpdateMode === SHIFT) {\r\n            this._setVisualRange({\r\n                length: this.getVisualRangeLength()\r\n            })\r\n        }\r\n    },\r\n    getVisualRangeLength(range) {\r\n        var currentBusinessRange = range || this._translator.getBusinessRange();\r\n        var {\r\n            type: type\r\n        } = this._options;\r\n        var length;\r\n        if (type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].logarithmic) {\r\n            length = Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_12__[\"adjust\"])(this.calculateInterval(currentBusinessRange.maxVisible, currentBusinessRange.minVisible))\r\n        } else if (type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete) {\r\n            var categoriesInfo = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getCategoriesInfo\"])(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\r\n            length = categoriesInfo.categories.length\r\n        } else {\r\n            length = currentBusinessRange.maxVisible - currentBusinessRange.minVisible\r\n        }\r\n        return length\r\n    },\r\n    getVisualRangeCenter(range, useMerge) {\r\n        var translator = this.getTranslator();\r\n        var businessRange = translator.getBusinessRange();\r\n        var currentBusinessRange = useMerge ? Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])(true, {}, businessRange, range || {}) : range || businessRange;\r\n        var {\r\n            type: type,\r\n            logarithmBase: logarithmBase\r\n        } = this._options;\r\n        var center;\r\n        if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(currentBusinessRange.minVisible) || !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(currentBusinessRange.maxVisible)) {\r\n            return\r\n        }\r\n        if (type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].logarithmic) {\r\n            var {\r\n                allowNegatives: allowNegatives,\r\n                linearThreshold: linearThreshold,\r\n                minVisible: minVisible,\r\n                maxVisible: maxVisible\r\n            } = currentBusinessRange;\r\n            center = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"raiseToExt\"])(Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_12__[\"adjust\"])(Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getLogExt\"])(maxVisible, logarithmBase, allowNegatives, linearThreshold) + Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getLogExt\"])(minVisible, logarithmBase, allowNegatives, linearThreshold)) / 2, logarithmBase, allowNegatives, linearThreshold)\r\n        } else if (type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete) {\r\n            var categoriesInfo = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getCategoriesInfo\"])(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\r\n            var index = Math.ceil(categoriesInfo.categories.length / 2) - 1;\r\n            center = businessRange.categories.indexOf(categoriesInfo.categories[index])\r\n        } else {\r\n            center = translator.toValue((currentBusinessRange.maxVisible.valueOf() + currentBusinessRange.minVisible.valueOf()) / 2)\r\n        }\r\n        return center\r\n    },\r\n    setBusinessRange(range, axisReinitialized, oppositeVisualRangeUpdateMode, argCategories) {\r\n        var _that$_seriesData$min, _that$_seriesData$max;\r\n        var options = this._options;\r\n        var isDiscrete = options.type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete;\r\n        this._handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, range);\r\n        this._seriesData = new _translators_range__WEBPACK_IMPORTED_MODULE_10__[\"Range\"](range);\r\n        var dataIsEmpty = this._seriesData.isEmpty();\r\n        var rangeWithConstantLines = new _translators_range__WEBPACK_IMPORTED_MODULE_10__[\"Range\"](this._seriesData);\r\n        this._addConstantLinesToRange(rangeWithConstantLines, \"minVisible\", \"maxVisible\");\r\n        this._prevDataInfo = {\r\n            isEmpty: dataIsEmpty,\r\n            containsConstantLine: rangeWithConstantLines.containsConstantLine\r\n        };\r\n        this._seriesData.addRange({\r\n            categories: options.categories,\r\n            dataType: options.dataType,\r\n            axisType: options.type,\r\n            base: options.logarithmBase,\r\n            invert: options.inverted\r\n        });\r\n        this._resolveLogarithmicOptionsForRange(this._seriesData);\r\n        if (!isDiscrete) {\r\n            if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(this._seriesData.min) && !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(this._seriesData.max)) {\r\n                var visualRange = this.getViewport();\r\n                visualRange && this._seriesData.addRange({\r\n                    min: visualRange.startValue,\r\n                    max: visualRange.endValue\r\n                })\r\n            }\r\n            var synchronizedValue = options.synchronizedValue;\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(synchronizedValue)) {\r\n                this._seriesData.addRange({\r\n                    min: synchronizedValue,\r\n                    max: synchronizedValue\r\n                })\r\n            }\r\n        }\r\n        this._seriesData.minVisible = null !== (_that$_seriesData$min = this._seriesData.minVisible) && void 0 !== _that$_seriesData$min ? _that$_seriesData$min : this._seriesData.min;\r\n        this._seriesData.maxVisible = null !== (_that$_seriesData$max = this._seriesData.maxVisible) && void 0 !== _that$_seriesData$max ? _that$_seriesData$max : this._seriesData.max;\r\n        if (!this.isArgumentAxis && options.showZero) {\r\n            this._seriesData.correctValueZeroLevel()\r\n        }\r\n        this._seriesData.sortCategories(this.getCategoriesSorter(argCategories));\r\n        this._seriesData.userBreaks = this._seriesData.isEmpty() ? [] : this._getScaleBreaks(options, this._seriesData, this._series, this.isArgumentAxis);\r\n        this._translator.updateBusinessRange(this._getViewportRange())\r\n    },\r\n    _addConstantLinesToRange(dataRange, minValueField, maxValueField) {\r\n        this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(cl => {\r\n            if (cl.options.extendAxis) {\r\n                var value = cl.getParsedValue();\r\n                dataRange.addRange({\r\n                    containsConstantLine: true,\r\n                    [minValueField]: value,\r\n                    [maxValueField]: value\r\n                })\r\n            }\r\n        })\r\n    },\r\n    setGroupSeries: function(series) {\r\n        this._series = series\r\n    },\r\n    getLabelsPosition: function() {\r\n        var options = this._options;\r\n        var position = options.position;\r\n        var labelShift = options.label.indentFromAxis + (this._axisShift || 0) + this._constantLabelOffset;\r\n        var axisPosition = this._axisPosition;\r\n        return position === TOP || position === LEFT ? axisPosition - labelShift : axisPosition + labelShift\r\n    },\r\n    getFormattedValue: function(value, options, point) {\r\n        var labelOptions = this._options.label;\r\n        return Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(value) ? this.formatLabel(value, Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])(true, {}, labelOptions, options), void 0, point) : null\r\n    },\r\n    _getBoundaryTicks: function(majors, viewPort) {\r\n        var length = majors.length;\r\n        var options = this._options;\r\n        var customBounds = options.customBoundTicks;\r\n        var min = viewPort.minVisible;\r\n        var max = viewPort.maxVisible;\r\n        var addMinMax = options.showCustomBoundaryTicks ? this._boundaryTicksVisibility : {};\r\n        var boundaryTicks = [];\r\n        if (options.type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete) {\r\n            if (this._tickOffset && 0 !== majors.length) {\r\n                boundaryTicks = [majors[0], majors[majors.length - 1]]\r\n            }\r\n        } else if (customBounds) {\r\n            if (addMinMax.min && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(customBounds[0])) {\r\n                boundaryTicks.push(customBounds[0])\r\n            }\r\n            if (addMinMax.max && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(customBounds[1])) {\r\n                boundaryTicks.push(customBounds[1])\r\n            }\r\n        } else {\r\n            if (addMinMax.min && (0 === length || majors[0] > min)) {\r\n                boundaryTicks.push(min)\r\n            }\r\n            if (addMinMax.max && (0 === length || majors[length - 1] < max)) {\r\n                boundaryTicks.push(max)\r\n            }\r\n        }\r\n        return boundaryTicks\r\n    },\r\n    setPercentLabelFormat: function() {\r\n        if (!this._hasLabelFormat) {\r\n            this._options.label.format = \"percent\"\r\n        }\r\n    },\r\n    resetAutoLabelFormat: function() {\r\n        if (!this._hasLabelFormat) {\r\n            delete this._options.label.format\r\n        }\r\n    },\r\n    getMultipleAxesSpacing: function() {\r\n        return this._options.multipleAxesSpacing || 0\r\n    },\r\n    getTicksValues: function() {\r\n        return {\r\n            majorTicksValues: convertTicksToValues(this._majorTicks),\r\n            minorTicksValues: convertTicksToValues(this._minorTicks)\r\n        }\r\n    },\r\n    estimateTickInterval: function(canvas) {\r\n        this.updateCanvas(canvas);\r\n        return this._tickInterval !== this._getTicks(this._getViewportRange(), _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"], true).tickInterval\r\n    },\r\n    setTicks: function(ticks) {\r\n        var majors = ticks.majorTicks || [];\r\n        this._majorTicks = majors.map(createMajorTick(this, this._renderer, this._getSkippedCategory(majors)));\r\n        this._minorTicks = (ticks.minorTicks || []).map(createMinorTick(this, this._renderer));\r\n        this._isSynchronized = true\r\n    },\r\n    _adjustDivisionFactor: function(val) {\r\n        return val\r\n    },\r\n    _getTicks: function(viewPort, incidentOccurred, skipTickGeneration) {\r\n        var options = this._options;\r\n        var customTicks = options.customTicks;\r\n        var customMinorTicks = options.customMinorTicks;\r\n        return getTickGenerator(options, incidentOccurred || this._incidentOccurred, skipTickGeneration, this._translator.getBusinessRange().isEmpty(), this._adjustDivisionFactor.bind(this), viewPort)({\r\n            min: viewPort.minVisible,\r\n            max: viewPort.maxVisible,\r\n            categories: viewPort.categories,\r\n            isSpacedMargin: viewPort.isSpacedMargin\r\n        }, this._getScreenDelta(), options.tickInterval, \"ignore\" === options.label.overlappingBehavior || options.forceUserTickInterval, {\r\n            majors: customTicks,\r\n            minors: customMinorTicks\r\n        }, options.minorTickInterval, options.minorTickCount, this._initialBreaks)\r\n    },\r\n    _createTicksAndLabelFormat: function(range, incidentOccurred) {\r\n        var options = this._options;\r\n        var ticks = this._getTicks(range, incidentOccurred, false);\r\n        if (!range.isEmpty() && options.type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete && \"datetime\" === options.dataType && !this._hasLabelFormat && ticks.ticks.length) {\r\n            options.label.format = _format_helper__WEBPACK_IMPORTED_MODULE_6__[\"default\"].getDateFormatByTicks(ticks.ticks)\r\n        }\r\n        return ticks\r\n    },\r\n    getAggregationInfo(useAllAggregatedPoints, range) {\r\n        var _visualRange$startVal, _visualRange$endValue, _that$_seriesData;\r\n        var options = this._options;\r\n        var marginOptions = this._marginOptions;\r\n        var businessRange = new _translators_range__WEBPACK_IMPORTED_MODULE_10__[\"Range\"](this.getTranslator().getBusinessRange()).addRange(range);\r\n        var visualRange = this.getViewport();\r\n        var minVisible = null !== (_visualRange$startVal = null === visualRange || void 0 === visualRange ? void 0 : visualRange.startValue) && void 0 !== _visualRange$startVal ? _visualRange$startVal : businessRange.minVisible;\r\n        var maxVisible = null !== (_visualRange$endValue = null === visualRange || void 0 === visualRange ? void 0 : visualRange.endValue) && void 0 !== _visualRange$endValue ? _visualRange$endValue : businessRange.maxVisible;\r\n        var ticks = [];\r\n        if (options.type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete && options.aggregateByCategory) {\r\n            return {\r\n                aggregateByCategory: true\r\n            }\r\n        }\r\n        var aggregationInterval = options.aggregationInterval;\r\n        var aggregationGroupWidth = options.aggregationGroupWidth;\r\n        if (!aggregationGroupWidth && marginOptions) {\r\n            if (marginOptions.checkInterval) {\r\n                aggregationGroupWidth = options.axisDivisionFactor\r\n            }\r\n            if (marginOptions.sizePointNormalState) {\r\n                aggregationGroupWidth = Math.min(marginOptions.sizePointNormalState, options.axisDivisionFactor)\r\n            }\r\n        }\r\n        var minInterval = !options.aggregationGroupWidth && !aggregationInterval && range.interval;\r\n        var generateTicks = configureGenerator(options, aggregationGroupWidth, businessRange, this._getScreenDelta(), minInterval);\r\n        var tickInterval = generateTicks(aggregationInterval, true, minVisible, maxVisible, null === (_that$_seriesData = this._seriesData) || void 0 === _that$_seriesData ? void 0 : _that$_seriesData.breaks).tickInterval;\r\n        if (options.type !== _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete) {\r\n            var min = useAllAggregatedPoints ? businessRange.min : minVisible;\r\n            var max = useAllAggregatedPoints ? businessRange.max : maxVisible;\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(min) && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(max)) {\r\n                var add = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getAddFunction\"])({\r\n                    base: options.logarithmBase,\r\n                    axisType: options.type,\r\n                    dataType: options.dataType\r\n                }, false);\r\n                var start = min;\r\n                var end = max;\r\n                if (!useAllAggregatedPoints) {\r\n                    var maxMinDistance = Math.max(this.calculateInterval(max, min), \"datetime\" === options.dataType ? _core_utils_date__WEBPACK_IMPORTED_MODULE_13__[\"default\"].dateToMilliseconds(tickInterval) : tickInterval);\r\n                    start = add(min, maxMinDistance, -1);\r\n                    end = add(max, maxMinDistance)\r\n                }\r\n                start = start < businessRange.min ? businessRange.min : start;\r\n                end = end > businessRange.max ? businessRange.max : end;\r\n                var breaks = this._getScaleBreaks(options, {\r\n                    minVisible: start,\r\n                    maxVisible: end\r\n                }, this._series, this.isArgumentAxis);\r\n                var filteredBreaks = this._filterBreaks(breaks, {\r\n                    minVisible: start,\r\n                    maxVisible: end\r\n                }, options.breakStyle);\r\n                ticks = generateTicks(tickInterval, false, start, end, filteredBreaks).ticks\r\n            }\r\n        }\r\n        this._aggregationInterval = tickInterval;\r\n        return {\r\n            interval: tickInterval,\r\n            ticks: ticks\r\n        }\r\n    },\r\n    getTickInterval() {\r\n        return this._tickInterval\r\n    },\r\n    getAggregationInterval() {\r\n        return this._aggregationInterval\r\n    },\r\n    createTicks: function(canvas) {\r\n        var that = this;\r\n        var renderer = that._renderer;\r\n        var options = that._options;\r\n        if (!canvas) {\r\n            return\r\n        }\r\n        that._isSynchronized = false;\r\n        that.updateCanvas(canvas);\r\n        var range = that._getViewportRange();\r\n        that._initialBreaks = range.breaks = this._seriesData.breaks = that._filterBreaks(this._seriesData.userBreaks, range, options.breakStyle);\r\n        that._estimatedTickInterval = that._getTicks(that.adjustViewport(this._seriesData), _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"], true).tickInterval;\r\n        var margins = this._calculateValueMargins();\r\n        range.addRange({\r\n            minVisible: margins.minValue,\r\n            maxVisible: margins.maxValue,\r\n            isSpacedMargin: margins.isSpacedMargin\r\n        });\r\n        var ticks = that._createTicksAndLabelFormat(range);\r\n        var boundaryTicks = that._getBoundaryTicks(ticks.ticks, that._getViewportRange());\r\n        if (options.showCustomBoundaryTicks && boundaryTicks.length) {\r\n            that._boundaryTicks = [boundaryTicks[0]].map(createBoundaryTick(that, renderer, true));\r\n            if (boundaryTicks.length > 1) {\r\n                that._boundaryTicks = that._boundaryTicks.concat([boundaryTicks[1]].map(createBoundaryTick(that, renderer, false)))\r\n            }\r\n        } else {\r\n            that._boundaryTicks = []\r\n        }\r\n        var minors = (ticks.minorTicks || []).filter((function(minor) {\r\n            return !boundaryTicks.some((function(boundary) {\r\n                return Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"valueOf\"])(boundary) === Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"valueOf\"])(minor)\r\n            }))\r\n        }));\r\n        that._tickInterval = ticks.tickInterval;\r\n        that._minorTickInterval = ticks.minorTickInterval;\r\n        var oldMajorTicks = that._majorTicks || [];\r\n        var majorTicksByValues = oldMajorTicks.reduce((r, t) => {\r\n            r[t.value.valueOf()] = t;\r\n            return r\r\n        }, {});\r\n        var sameType = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"type\"])(ticks.ticks[0]) === Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"type\"])(oldMajorTicks[0] && oldMajorTicks[0].value);\r\n        var skippedCategory = that._getSkippedCategory(ticks.ticks);\r\n        var majorTicks = ticks.ticks.map(v => {\r\n            var tick = majorTicksByValues[v.valueOf()];\r\n            if (tick && sameType) {\r\n                delete majorTicksByValues[v.valueOf()];\r\n                tick.setSkippedCategory(skippedCategory);\r\n                return tick\r\n            } else {\r\n                return createMajorTick(that, renderer, skippedCategory)(v)\r\n            }\r\n        });\r\n        that._majorTicks = majorTicks;\r\n        var oldMinorTicks = that._minorTicks || [];\r\n        that._minorTicks = minors.map((v, i) => {\r\n            var minorTick = oldMinorTicks[i];\r\n            if (minorTick) {\r\n                minorTick.updateValue(v);\r\n                return minorTick\r\n            }\r\n            return createMinorTick(that, renderer)(v)\r\n        });\r\n        that._ticksToRemove = Object.keys(majorTicksByValues).map(k => majorTicksByValues[k]).concat(oldMinorTicks.slice(that._minorTicks.length, oldMinorTicks.length));\r\n        that._ticksToRemove.forEach(t => {\r\n            var _t$label;\r\n            return null === (_t$label = t.label) || void 0 === _t$label ? void 0 : _t$label.removeTitle()\r\n        });\r\n        if (ticks.breaks) {\r\n            that._seriesData.breaks = ticks.breaks\r\n        }\r\n        that._reinitTranslator(that._getViewportRange())\r\n    },\r\n    _reinitTranslator: function(range) {\r\n        var translator = this._translator;\r\n        if (this._isSynchronized) {\r\n            return\r\n        }\r\n        translator.updateBusinessRange(range)\r\n    },\r\n    _getViewportRange() {\r\n        return this.adjustViewport(this._seriesData)\r\n    },\r\n    setMarginOptions: function(options) {\r\n        this._marginOptions = options\r\n    },\r\n    getMarginOptions() {\r\n        var _this$_marginOptions;\r\n        return null !== (_this$_marginOptions = this._marginOptions) && void 0 !== _this$_marginOptions ? _this$_marginOptions : {}\r\n    },\r\n    _calculateRangeInterval: function(interval) {\r\n        var isDateTime = \"datetime\" === this._options.dataType;\r\n        var minArgs = [];\r\n        var addToArgs = function(value) {\r\n            Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(value) && minArgs.push(isDateTime ? _core_utils_date__WEBPACK_IMPORTED_MODULE_13__[\"default\"].dateToMilliseconds(value) : value)\r\n        };\r\n        addToArgs(this._tickInterval);\r\n        addToArgs(this._estimatedTickInterval);\r\n        Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(interval) && minArgs.push(interval);\r\n        addToArgs(this._aggregationInterval);\r\n        return this._calculateWorkWeekInterval(_min.apply(this, minArgs))\r\n    },\r\n    _calculateWorkWeekInterval(businessInterval) {\r\n        var options = this._options;\r\n        if (\"datetime\" === options.dataType && options.workdaysOnly && businessInterval) {\r\n            var workWeek = options.workWeek.length * dateIntervals.day;\r\n            var weekend = dateIntervals.week - workWeek;\r\n            if (workWeek !== businessInterval && weekend < businessInterval) {\r\n                var weekendsCount = Math.ceil(businessInterval / dateIntervals.week);\r\n                businessInterval -= weekend * weekendsCount\r\n            } else if (weekend >= businessInterval && businessInterval > dateIntervals.day) {\r\n                businessInterval = dateIntervals.day\r\n            }\r\n        }\r\n        return businessInterval\r\n    },\r\n    _getConvertIntervalCoefficient(intervalInPx, screenDelta) {\r\n        var ratioOfCanvasRange = this._translator.ratioOfCanvasRange();\r\n        return ratioOfCanvasRange / (ratioOfCanvasRange * screenDelta / (intervalInPx + screenDelta))\r\n    },\r\n    _calculateValueMargins(ticks) {\r\n        this._resetMargins();\r\n        var margins = this.getMarginOptions();\r\n        var marginSize = (margins.size || 0) / 2;\r\n        var options = this._options;\r\n        var dataRange = this._getViewportRange();\r\n        var viewPort = this.getViewport();\r\n        var screenDelta = this._getScreenDelta();\r\n        var isDiscrete = -1 !== (options.type || \"\").indexOf(_axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete);\r\n        var valueMarginsEnabled = options.valueMarginsEnabled && !isDiscrete && !this.customPositionIsBoundaryOrthogonalAxis();\r\n        var translator = this._translator;\r\n        var minValueMargin = options.minValueMargin;\r\n        var maxValueMargin = options.maxValueMargin;\r\n        var minPadding = 0;\r\n        var maxPadding = 0;\r\n        var interval = 0;\r\n        var rangeInterval;\r\n        if (dataRange.stubData || !screenDelta) {\r\n            return {\r\n                startPadding: 0,\r\n                endPadding: 0\r\n            }\r\n        }\r\n        if (this.isArgumentAxis && margins.checkInterval) {\r\n            rangeInterval = this._calculateRangeInterval(dataRange.interval);\r\n            var pxInterval = translator.getInterval(rangeInterval);\r\n            if (isFinite(pxInterval)) {\r\n                interval = Math.ceil(pxInterval / (2 * this._getConvertIntervalCoefficient(pxInterval, screenDelta)))\r\n            } else {\r\n                rangeInterval = 0\r\n            }\r\n        }\r\n        var minPercentPadding;\r\n        var maxPercentPadding;\r\n        var maxPaddingValue = screenDelta * MAX_MARGIN_VALUE / 2;\r\n        if (valueMarginsEnabled) {\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(minValueMargin)) {\r\n                minPercentPadding = isFinite(minValueMargin) ? minValueMargin : 0\r\n            } else if (!this.isArgumentAxis && margins.checkInterval && Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"valueOf\"])(dataRange.minVisible) > 0 && Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"valueOf\"])(dataRange.minVisible) === Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"valueOf\"])(dataRange.min)) {\r\n                minPadding = MIN_BAR_MARGIN\r\n            } else {\r\n                minPadding = Math.max(marginSize, interval);\r\n                minPadding = Math.min(maxPaddingValue, minPadding)\r\n            }\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(maxValueMargin)) {\r\n                maxPercentPadding = isFinite(maxValueMargin) ? maxValueMargin : 0\r\n            } else if (!this.isArgumentAxis && margins.checkInterval && Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"valueOf\"])(dataRange.maxVisible) < 0 && Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"valueOf\"])(dataRange.maxVisible) === Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"valueOf\"])(dataRange.max)) {\r\n                maxPadding = MIN_BAR_MARGIN\r\n            } else {\r\n                maxPadding = Math.max(marginSize, interval);\r\n                maxPadding = Math.min(maxPaddingValue, maxPadding)\r\n            }\r\n        }\r\n        var percentStick = margins.percentStick && !this.isArgumentAxis;\r\n        if (percentStick) {\r\n            if (1 === _abs(dataRange.max)) {\r\n                maxPadding = 0\r\n            }\r\n            if (1 === _abs(dataRange.min)) {\r\n                minPadding = 0\r\n            }\r\n        }\r\n        var canvasStartEnd = this._getCanvasStartEnd();\r\n        var commonMargin = 1 + (minPercentPadding || 0) + (maxPercentPadding || 0);\r\n        var screenDeltaWithMargins = (screenDelta - minPadding - maxPadding) / commonMargin || screenDelta;\r\n        if (void 0 !== minPercentPadding || void 0 !== maxPercentPadding) {\r\n            if (void 0 !== minPercentPadding) {\r\n                minPadding = screenDeltaWithMargins * minPercentPadding\r\n            }\r\n            if (void 0 !== maxPercentPadding) {\r\n                maxPadding = screenDeltaWithMargins * maxPercentPadding\r\n            }\r\n        }\r\n        var minValue;\r\n        var maxValue;\r\n        if (options.type !== _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete && ticks && ticks.length > 1 && !options.skipViewportExtending && !viewPort.action && false !== options.endOnTick) {\r\n            var length = ticks.length;\r\n            var firstTickPosition = translator.translate(ticks[0].value);\r\n            var lastTickPosition = translator.translate(ticks[length - 1].value);\r\n            var invertMultiplier = firstTickPosition > lastTickPosition ? -1 : 1;\r\n            var minTickPadding = _max(invertMultiplier * (canvasStartEnd.start - firstTickPosition), 0);\r\n            var maxTickPadding = _max(invertMultiplier * (lastTickPosition - canvasStartEnd.end), 0);\r\n            if (minTickPadding > minPadding || maxTickPadding > maxPadding) {\r\n                var commonPadding = maxTickPadding + minTickPadding;\r\n                var coeff = this._getConvertIntervalCoefficient(commonPadding, screenDelta);\r\n                if (minTickPadding >= minPadding) {\r\n                    minValue = ticks[0].value\r\n                }\r\n                if (maxTickPadding >= maxPadding) {\r\n                    maxValue = ticks[length - 1].value\r\n                }\r\n                minPadding = _max(minTickPadding, minPadding) / coeff;\r\n                maxPadding = _max(maxTickPadding, maxPadding) / coeff\r\n            }\r\n        }\r\n        minPercentPadding = void 0 === minPercentPadding ? minPadding / screenDeltaWithMargins : minPercentPadding;\r\n        maxPercentPadding = void 0 === maxPercentPadding ? maxPadding / screenDeltaWithMargins : maxPercentPadding;\r\n        if (!isDiscrete) {\r\n            if (this._translator.isInverted()) {\r\n                var _minValue, _maxValue;\r\n                minValue = null !== (_minValue = minValue) && void 0 !== _minValue ? _minValue : translator.from(canvasStartEnd.start + screenDelta * minPercentPadding, -1);\r\n                maxValue = null !== (_maxValue = maxValue) && void 0 !== _maxValue ? _maxValue : translator.from(canvasStartEnd.end - screenDelta * maxPercentPadding, 1)\r\n            } else {\r\n                var _minValue2, _maxValue2;\r\n                minValue = null !== (_minValue2 = minValue) && void 0 !== _minValue2 ? _minValue2 : translator.from(canvasStartEnd.start - screenDelta * minPercentPadding, -1);\r\n                maxValue = null !== (_maxValue2 = maxValue) && void 0 !== _maxValue2 ? _maxValue2 : translator.from(canvasStartEnd.end + screenDelta * maxPercentPadding, 1)\r\n            }\r\n        }\r\n        var {\r\n            correctedMin: correctedMin,\r\n            correctedMax: correctedMax,\r\n            start: start,\r\n            end: end\r\n        } = this.getCorrectedValuesToZero(minValue, maxValue);\r\n        minPadding = null !== start && void 0 !== start ? start : minPadding;\r\n        maxPadding = null !== end && void 0 !== end ? end : maxPadding;\r\n        return {\r\n            startPadding: translator.isInverted() ? maxPadding : minPadding,\r\n            endPadding: translator.isInverted() ? minPadding : maxPadding,\r\n            minValue: null !== correctedMin && void 0 !== correctedMin ? correctedMin : minValue,\r\n            maxValue: null !== correctedMax && void 0 !== correctedMax ? correctedMax : maxValue,\r\n            interval: rangeInterval,\r\n            isSpacedMargin: minPadding === maxPadding && 0 !== minPadding\r\n        }\r\n    },\r\n    getCorrectedValuesToZero(minValue, maxValue) {\r\n        var that = this;\r\n        var translator = that._translator;\r\n        var canvasStartEnd = that._getCanvasStartEnd();\r\n        var dataRange = that._getViewportRange();\r\n        var screenDelta = that._getScreenDelta();\r\n        var options = that._options;\r\n        var start;\r\n        var end;\r\n        var correctedMin;\r\n        var correctedMax;\r\n        var correctZeroLevel = (minPoint, maxPoint) => {\r\n            var minExpectedPadding = _abs(canvasStartEnd.start - minPoint);\r\n            var maxExpectedPadding = _abs(canvasStartEnd.end - maxPoint);\r\n            var coeff = that._getConvertIntervalCoefficient(minExpectedPadding + maxExpectedPadding, screenDelta);\r\n            start = minExpectedPadding / coeff;\r\n            end = maxExpectedPadding / coeff\r\n        };\r\n        if (!that.isArgumentAxis && \"datetime\" !== options.dataType) {\r\n            if (minValue * dataRange.min <= 0 && minValue * dataRange.minVisible <= 0) {\r\n                correctZeroLevel(translator.translate(0), translator.translate(maxValue));\r\n                correctedMin = 0\r\n            }\r\n            if (maxValue * dataRange.max <= 0 && maxValue * dataRange.maxVisible <= 0) {\r\n                correctZeroLevel(translator.translate(minValue), translator.translate(0));\r\n                correctedMax = 0\r\n            }\r\n        }\r\n        return {\r\n            start: isFinite(start) ? start : null,\r\n            end: isFinite(end) ? end : null,\r\n            correctedMin: correctedMin,\r\n            correctedMax: correctedMax\r\n        }\r\n    },\r\n    applyMargins() {\r\n        if (this._isSynchronized) {\r\n            return\r\n        }\r\n        var margins = this._calculateValueMargins(this._majorTicks);\r\n        var canvas = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])({}, this._canvas, {\r\n            startPadding: margins.startPadding,\r\n            endPadding: margins.endPadding\r\n        });\r\n        this._translator.updateCanvas(this._processCanvas(canvas));\r\n        if (isFinite(margins.interval)) {\r\n            var br = this._translator.getBusinessRange();\r\n            br.addRange({\r\n                interval: margins.interval\r\n            });\r\n            this._translator.updateBusinessRange(br)\r\n        }\r\n    },\r\n    _resetMargins: function() {\r\n        this._reinitTranslator(this._getViewportRange());\r\n        if (this._canvas) {\r\n            this._translator.updateCanvas(this._processCanvas(this._canvas))\r\n        }\r\n    },\r\n    _createConstantLines() {\r\n        var constantLines = (this._options.constantLines || []).map(o => Object(_constant_line__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(this, o));\r\n        this._outsideConstantLines = constantLines.filter(l => \"outside\" === l.labelPosition);\r\n        this._insideConstantLines = constantLines.filter(l => \"inside\" === l.labelPosition)\r\n    },\r\n    draw: function(canvas, borderOptions) {\r\n        var that = this;\r\n        var options = this._options;\r\n        that.borderOptions = borderOptions || {\r\n            visible: false\r\n        };\r\n        that._resetMargins();\r\n        that.createTicks(canvas);\r\n        that.applyMargins();\r\n        that._clearAxisGroups();\r\n        initTickCoords(that._majorTicks);\r\n        initTickCoords(that._minorTicks);\r\n        initTickCoords(that._boundaryTicks);\r\n        that._axisGroup.append(that._axesContainerGroup);\r\n        that._drawAxis();\r\n        that._drawTitle();\r\n        drawTickMarks(that._majorTicks, options.tick);\r\n        drawTickMarks(that._minorTicks, options.minorTick);\r\n        drawTickMarks(that._boundaryTicks, options.tick);\r\n        var drawGridLine = that._getGridLineDrawer();\r\n        drawGrids(that._majorTicks, drawGridLine);\r\n        drawGrids(that._minorTicks, drawGridLine);\r\n        callAction(that._majorTicks, \"drawLabel\", that._getViewportRange(), that._getTemplate(options.label.template));\r\n        that._templatesRendered && that._templatesRendered.reject();\r\n        that._templatesRendered = new _core_utils_deferred__WEBPACK_IMPORTED_MODULE_19__[\"Deferred\"];\r\n        that._majorTicks.forEach((function(tick) {\r\n            tick.labelRotationAngle = 0;\r\n            tick.labelAlignment = void 0;\r\n            tick.labelOffset = 0\r\n        }));\r\n        callAction(that._outsideConstantLines.concat(that._insideConstantLines), \"draw\");\r\n        callAction(that._strips, \"draw\");\r\n        that._dateMarkers = that._drawDateMarkers() || [];\r\n        that._stripLabelAxesGroup && that._axisStripLabelGroup.append(that._stripLabelAxesGroup);\r\n        that._gridContainerGroup && that._axisGridGroup.append(that._gridContainerGroup);\r\n        that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);\r\n        that._labelsAxesGroup && that._axisElementsGroup.append(that._labelsAxesGroup);\r\n        if (that._constantLinesGroup) {\r\n            that._axisConstantLineGroups.above.inside.append(that._constantLinesGroup.above);\r\n            that._axisConstantLineGroups.above.outside1.append(that._constantLinesGroup.above);\r\n            that._axisConstantLineGroups.above.outside2.append(that._constantLinesGroup.above);\r\n            that._axisConstantLineGroups.under.inside.append(that._constantLinesGroup.under);\r\n            that._axisConstantLineGroups.under.outside1.append(that._constantLinesGroup.under);\r\n            that._axisConstantLineGroups.under.outside2.append(that._constantLinesGroup.under)\r\n        }\r\n        that._measureTitle();\r\n        Object(_axes_utils__WEBPACK_IMPORTED_MODULE_20__[\"measureLabels\"])(that._majorTicks);\r\n        !options.label.template && that._applyWordWrap();\r\n        Object(_axes_utils__WEBPACK_IMPORTED_MODULE_20__[\"measureLabels\"])(that._outsideConstantLines);\r\n        Object(_axes_utils__WEBPACK_IMPORTED_MODULE_20__[\"measureLabels\"])(that._insideConstantLines);\r\n        Object(_axes_utils__WEBPACK_IMPORTED_MODULE_20__[\"measureLabels\"])(that._strips);\r\n        Object(_axes_utils__WEBPACK_IMPORTED_MODULE_20__[\"measureLabels\"])(that._dateMarkers);\r\n        that._adjustConstantLineLabels(that._insideConstantLines);\r\n        that._adjustStripLabels();\r\n        var offset = that._constantLabelOffset = that._adjustConstantLineLabels(that._outsideConstantLines);\r\n        if (!that._translator.getBusinessRange().isEmpty()) {\r\n            that._setLabelsPlacement();\r\n            offset = that._adjustLabels(offset)\r\n        }\r\n        _core_utils_deferred__WEBPACK_IMPORTED_MODULE_19__[\"when\"].apply(this, that._majorTicks.map(tick => tick.getTemplateDeferred())).done(() => {\r\n            that._templatesRendered.resolve()\r\n        });\r\n        offset = that._adjustDateMarkers(offset);\r\n        that._adjustTitle(offset)\r\n    },\r\n    getTemplatesDef() {\r\n        return this._templatesRendered\r\n    },\r\n    setRenderedState(state) {\r\n        this._drawn = state\r\n    },\r\n    isRendered() {\r\n        return this._drawn\r\n    },\r\n    _applyWordWrap() {\r\n        var convertedTickInterval;\r\n        var textWidth;\r\n        var textHeight;\r\n        var options = this._options;\r\n        var tickInterval = this._tickInterval;\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(tickInterval)) {\r\n            convertedTickInterval = this.getTranslator().getInterval(\"datetime\" === options.dataType ? _core_utils_date__WEBPACK_IMPORTED_MODULE_13__[\"default\"].dateToMilliseconds(tickInterval) : tickInterval)\r\n        }\r\n        var displayMode = this._validateDisplayMode(options.label.displayMode);\r\n        var overlappingMode = this._validateOverlappingMode(options.label.overlappingBehavior, displayMode);\r\n        var wordWrapMode = options.label.wordWrap || \"none\";\r\n        var overflowMode = options.label.textOverflow || \"none\";\r\n        if ((\"none\" !== wordWrapMode || \"none\" !== overflowMode) && displayMode !== ROTATE && overlappingMode !== ROTATE && \"auto\" !== overlappingMode) {\r\n            var usefulSpace = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(options.placeholderSize) ? options.placeholderSize - options.label.indentFromAxis : void 0;\r\n            if (this._isHorizontal) {\r\n                textWidth = convertedTickInterval;\r\n                textHeight = usefulSpace\r\n            } else {\r\n                textWidth = usefulSpace;\r\n                textHeight = convertedTickInterval\r\n            }\r\n            var correctByWidth = false;\r\n            var correctByHeight = false;\r\n            if (textWidth) {\r\n                if (this._majorTicks.some(tick => tick.labelBBox.width > textWidth)) {\r\n                    correctByWidth = true\r\n                }\r\n            }\r\n            if (textHeight) {\r\n                if (this._majorTicks.some(tick => tick.labelBBox.height > textHeight)) {\r\n                    correctByHeight = true\r\n                }\r\n            }\r\n            if (correctByWidth || correctByHeight) {\r\n                this._majorTicks.forEach(tick => {\r\n                    tick.label && tick.label.setMaxSize(textWidth, textHeight, options.label)\r\n                });\r\n                Object(_axes_utils__WEBPACK_IMPORTED_MODULE_20__[\"measureLabels\"])(this._majorTicks)\r\n            }\r\n        }\r\n    },\r\n    _measureTitle: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    animate() {\r\n        callAction(this._majorTicks, \"animateLabels\")\r\n    },\r\n    updateSize(canvas, animate) {\r\n        var updateTitle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;\r\n        this.updateCanvas(canvas);\r\n        if (updateTitle) {\r\n            this._checkTitleOverflow();\r\n            this._measureTitle();\r\n            this._updateTitleCoords()\r\n        }\r\n        this._reinitTranslator(this._getViewportRange());\r\n        this.applyMargins();\r\n        var animationEnabled = !this._firstDrawing && animate;\r\n        var options = this._options;\r\n        initTickCoords(this._majorTicks);\r\n        initTickCoords(this._minorTicks);\r\n        initTickCoords(this._boundaryTicks);\r\n        if (this._resetApplyingAnimation && !this._firstDrawing) {\r\n            this._resetStartCoordinates()\r\n        }\r\n        cleanUpInvalidTicks(this._majorTicks);\r\n        cleanUpInvalidTicks(this._minorTicks);\r\n        cleanUpInvalidTicks(this._boundaryTicks);\r\n        if (this._axisElement) {\r\n            this._updateAxisElementPosition()\r\n        }\r\n        updateTicksPosition(this._majorTicks, options.tick, animationEnabled);\r\n        updateTicksPosition(this._minorTicks, options.minorTick, animationEnabled);\r\n        updateTicksPosition(this._boundaryTicks, options.tick);\r\n        callAction(this._majorTicks, \"updateLabelPosition\", animationEnabled);\r\n        this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(l => l.updatePosition(animationEnabled));\r\n        callAction(this._strips, \"updatePosition\", animationEnabled);\r\n        updateGridsPosition(this._majorTicks, animationEnabled);\r\n        updateGridsPosition(this._minorTicks, animationEnabled);\r\n        if (animationEnabled) {\r\n            callAction(this._ticksToRemove || [], \"fadeOutElements\")\r\n        }\r\n        this.prepareAnimation();\r\n        this._ticksToRemove = null;\r\n        if (!this._translator.getBusinessRange().isEmpty()) {\r\n            this._firstDrawing = false\r\n        }\r\n        this._resetApplyingAnimation = false;\r\n        this._updateLabelsPosition()\r\n    },\r\n    _updateLabelsPosition: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    prepareAnimation() {\r\n        var action = \"saveCoords\";\r\n        callAction(this._majorTicks, action);\r\n        callAction(this._minorTicks, action);\r\n        callAction(this._insideConstantLines, action);\r\n        callAction(this._outsideConstantLines, action);\r\n        callAction(this._strips, action)\r\n    },\r\n    _resetStartCoordinates() {\r\n        var action = \"resetCoordinates\";\r\n        callAction(this._majorTicks, action);\r\n        callAction(this._minorTicks, action);\r\n        callAction(this._insideConstantLines, action);\r\n        callAction(this._outsideConstantLines, action);\r\n        callAction(this._strips, action)\r\n    },\r\n    applyClipRects: function(elementsClipID, canvasClipID) {\r\n        this._axisGroup.attr({\r\n            \"clip-path\": canvasClipID\r\n        });\r\n        this._axisStripGroup.attr({\r\n            \"clip-path\": elementsClipID\r\n        });\r\n        this._axisElementsGroup.attr({\r\n            \"clip-path\": canvasClipID\r\n        })\r\n    },\r\n    _validateVisualRange(optionValue) {\r\n        var range = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getVizRangeObject\"])(optionValue);\r\n        if (void 0 !== range.startValue) {\r\n            range.startValue = this.validateUnit(range.startValue)\r\n        }\r\n        if (void 0 !== range.endValue) {\r\n            range.endValue = this.validateUnit(range.endValue)\r\n        }\r\n        return Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"convertVisualRangeObject\"])(range, !_isArray(optionValue))\r\n    },\r\n    _validateOptions(options) {\r\n        options.wholeRange = this._validateVisualRange(options.wholeRange);\r\n        options.visualRange = options._customVisualRange = this._validateVisualRange(options._customVisualRange);\r\n        this._setVisualRange(options._customVisualRange)\r\n    },\r\n    validate() {\r\n        var options = this._options;\r\n        var dataType = this.isArgumentAxis ? options.argumentType : options.valueType;\r\n        var parser = dataType ? Object(_components_parse_utils__WEBPACK_IMPORTED_MODULE_7__[\"getParser\"])(dataType) : function(unit) {\r\n            return unit\r\n        };\r\n        this.parser = parser;\r\n        options.dataType = dataType;\r\n        this._validateOptions(options)\r\n    },\r\n    resetVisualRange(isSilent) {\r\n        this._seriesData.minVisible = this._seriesData.min;\r\n        this._seriesData.maxVisible = this._seriesData.max;\r\n        this.handleZooming([null, null], {\r\n            start: !!isSilent,\r\n            end: !!isSilent\r\n        })\r\n    },\r\n    _setVisualRange(visualRange, allowPartialUpdate) {\r\n        var range = this.adjustRange(Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getVizRangeObject\"])(visualRange));\r\n        if (allowPartialUpdate) {\r\n            Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(range.startValue) && (this._viewport.startValue = range.startValue);\r\n            Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(range.endValue) && (this._viewport.endValue = range.endValue)\r\n        } else {\r\n            this._viewport = range\r\n        }\r\n    },\r\n    _applyZooming(visualRange, allowPartialUpdate) {\r\n        this._resetVisualRangeOption();\r\n        this._setVisualRange(visualRange, allowPartialUpdate);\r\n        var viewPort = this.getViewport();\r\n        this._seriesData.userBreaks = this._getScaleBreaks(this._options, {\r\n            minVisible: viewPort.startValue,\r\n            maxVisible: viewPort.endValue\r\n        }, this._series, this.isArgumentAxis);\r\n        this._translator.updateBusinessRange(this._getViewportRange())\r\n    },\r\n    getZoomStartEventArg(event, actionType) {\r\n        return {\r\n            axis: this,\r\n            range: this.visualRange(),\r\n            cancel: false,\r\n            event: event,\r\n            actionType: actionType\r\n        }\r\n    },\r\n    _getZoomEndEventArg(previousRange, event, actionType, zoomFactor, shift) {\r\n        var newRange = this.visualRange();\r\n        return {\r\n            axis: this,\r\n            previousRange: previousRange,\r\n            range: newRange,\r\n            cancel: false,\r\n            event: event,\r\n            actionType: actionType,\r\n            zoomFactor: zoomFactor,\r\n            shift: shift,\r\n            rangeStart: newRange.startValue,\r\n            rangeEnd: newRange.endValue\r\n        }\r\n    },\r\n    getZoomBounds() {\r\n        var wholeRange = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getVizRangeObject\"])(this._options.wholeRange);\r\n        var range = this.getTranslator().getBusinessRange();\r\n        var secondPriorityRange = {\r\n            startValue: getZoomBoundValue(this._initRange.startValue, range.min),\r\n            endValue: getZoomBoundValue(this._initRange.endValue, range.max)\r\n        };\r\n        return {\r\n            startValue: getZoomBoundValue(wholeRange.startValue, secondPriorityRange.startValue),\r\n            endValue: getZoomBoundValue(wholeRange.endValue, secondPriorityRange.endValue)\r\n        }\r\n    },\r\n    setInitRange() {\r\n        this._initRange = {};\r\n        if (0 === Object.keys(this._options.wholeRange || {}).length) {\r\n            this._initRange = this.getZoomBounds()\r\n        }\r\n    },\r\n    _resetVisualRangeOption() {\r\n        this._options._customVisualRange = {}\r\n    },\r\n    getTemplatesGroups() {\r\n        var ticks = this._majorTicks;\r\n        if (ticks) {\r\n            return this._majorTicks.map(tick => tick.templateContainer).filter(item => Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(item))\r\n        } else {\r\n            return []\r\n        }\r\n    },\r\n    setCustomVisualRange(range) {\r\n        this._options._customVisualRange = range\r\n    },\r\n    visualRange() {\r\n        var args = arguments;\r\n        var visualRange;\r\n        if (0 === args.length) {\r\n            var adjustedRange = this._getAdjustedBusinessRange();\r\n            var startValue = adjustedRange.minVisible;\r\n            var endValue = adjustedRange.maxVisible;\r\n            if (this._options.type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete) {\r\n                var _startValue, _endValue;\r\n                startValue = null !== (_startValue = startValue) && void 0 !== _startValue ? _startValue : adjustedRange.categories[0];\r\n                endValue = null !== (_endValue = endValue) && void 0 !== _endValue ? _endValue : adjustedRange.categories[adjustedRange.categories.length - 1];\r\n                return {\r\n                    startValue: startValue,\r\n                    endValue: endValue,\r\n                    categories: Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getCategoriesInfo\"])(adjustedRange.categories, startValue, endValue).categories\r\n                }\r\n            }\r\n            return {\r\n                startValue: startValue,\r\n                endValue: endValue\r\n            }\r\n        } else if (_isArray(args[0])) {\r\n            visualRange = args[0]\r\n        } else if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isPlainObject\"])(args[0])) {\r\n            visualRange = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])({}, args[0])\r\n        } else {\r\n            visualRange = [args[0], args[1]]\r\n        }\r\n        var zoomResults = this.handleZooming(visualRange, args[1]);\r\n        if (!zoomResults.isPrevented) {\r\n            this._visualRange(this, zoomResults)\r\n        }\r\n    },\r\n    handleZooming(visualRange, preventEvents, domEvent, action) {\r\n        preventEvents = preventEvents || {};\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(visualRange)) {\r\n            visualRange = this._validateVisualRange(visualRange);\r\n            visualRange.action = action\r\n        }\r\n        var zoomStartEvent = this.getZoomStartEventArg(domEvent, action);\r\n        var previousRange = zoomStartEvent.range;\r\n        !preventEvents.start && this._eventTrigger(\"zoomStart\", zoomStartEvent);\r\n        var zoomResults = {\r\n            isPrevented: zoomStartEvent.cancel,\r\n            skipEventRising: preventEvents.skipEventRising,\r\n            range: visualRange || zoomStartEvent.range\r\n        };\r\n        if (!zoomStartEvent.cancel) {\r\n            Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(visualRange) && this._applyZooming(visualRange, preventEvents.allowPartialUpdate);\r\n            if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(this._storedZoomEndParams)) {\r\n                this._storedZoomEndParams = {\r\n                    startRange: previousRange,\r\n                    type: this.getOptions().type\r\n                }\r\n            }\r\n            this._storedZoomEndParams.event = domEvent;\r\n            this._storedZoomEndParams.action = action;\r\n            this._storedZoomEndParams.prevent = !!preventEvents.end\r\n        }\r\n        return zoomResults\r\n    },\r\n    handleZoomEnd() {\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(this._storedZoomEndParams) && !this._storedZoomEndParams.prevent) {\r\n            var previousRange = this._storedZoomEndParams.startRange;\r\n            var domEvent = this._storedZoomEndParams.event;\r\n            var action = this._storedZoomEndParams.action;\r\n            var previousBusinessRange = {\r\n                minVisible: previousRange.startValue,\r\n                maxVisible: previousRange.endValue,\r\n                categories: previousRange.categories\r\n            };\r\n            var typeIsNotChanged = this.getOptions().type === this._storedZoomEndParams.type;\r\n            var shift = typeIsNotChanged ? Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_12__[\"adjust\"])(this.getVisualRangeCenter() - this.getVisualRangeCenter(previousBusinessRange, false)) : NaN;\r\n            var zoomFactor = typeIsNotChanged ? +(Math.round(this.getVisualRangeLength(previousBusinessRange) / (this.getVisualRangeLength() || 1) + \"e+2\") + \"e-2\") : NaN;\r\n            var zoomEndEvent = this._getZoomEndEventArg(previousRange, domEvent, action, zoomFactor, shift);\r\n            zoomEndEvent.cancel = this.checkZoomingLowerLimitOvercome(1 === zoomFactor ? \"pan\" : \"zoom\", zoomFactor).stopInteraction;\r\n            this._eventTrigger(\"zoomEnd\", zoomEndEvent);\r\n            if (zoomEndEvent.cancel) {\r\n                this._restorePreviousVisualRange(previousRange)\r\n            }\r\n            this._storedZoomEndParams = null\r\n        }\r\n    },\r\n    _restorePreviousVisualRange(previousRange) {\r\n        this._storedZoomEndParams = null;\r\n        this._applyZooming(previousRange);\r\n        this._visualRange(this, previousRange)\r\n    },\r\n    checkZoomingLowerLimitOvercome(actionType, zoomFactor, range) {\r\n        var options = this._options;\r\n        var translator = this._translator;\r\n        var minZoom = options.minVisualRangeLength;\r\n        var correctedRange = range;\r\n        var visualRange;\r\n        var isOvercoming = \"zoom\" === actionType && zoomFactor >= 1;\r\n        var businessRange = translator.getBusinessRange();\r\n        if (range) {\r\n            visualRange = this.adjustRange(Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getVizRangeObject\"])(range));\r\n            visualRange = {\r\n                minVisible: visualRange.startValue,\r\n                maxVisible: visualRange.endValue,\r\n                categories: businessRange.categories\r\n            }\r\n        }\r\n        var beforeVisualRangeLength = this.getVisualRangeLength(businessRange);\r\n        var afterVisualRangeLength = this.getVisualRangeLength(visualRange);\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(minZoom) || \"discrete\" === options.type) {\r\n            minZoom = translator.convert(minZoom);\r\n            if (visualRange && minZoom < beforeVisualRangeLength && minZoom >= afterVisualRangeLength) {\r\n                correctedRange = Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"getVizRangeObject\"])(translator.getRangeByMinZoomValue(minZoom, visualRange));\r\n                isOvercoming = false\r\n            } else {\r\n                isOvercoming &= minZoom > afterVisualRangeLength\r\n            }\r\n        } else {\r\n            var canvasLength = this._translator.canvasLength;\r\n            var fullRange = {\r\n                minVisible: businessRange.min,\r\n                maxVisible: businessRange.max,\r\n                categories: businessRange.categories\r\n            };\r\n            isOvercoming &= this.getVisualRangeLength(fullRange) / canvasLength >= afterVisualRangeLength\r\n        }\r\n        return {\r\n            stopInteraction: !!isOvercoming,\r\n            correctedRange: correctedRange\r\n        }\r\n    },\r\n    isExtremePosition(isMax) {\r\n        var extremeDataValue;\r\n        var seriesData;\r\n        if (\"discrete\" === this._options.type) {\r\n            seriesData = this._translator.getBusinessRange();\r\n            extremeDataValue = isMax ? seriesData.categories[seriesData.categories.length - 1] : seriesData.categories[0]\r\n        } else {\r\n            seriesData = this.getZoomBounds();\r\n            extremeDataValue = isMax ? seriesData.endValue : seriesData.startValue\r\n        }\r\n        var translator = this.getTranslator();\r\n        var extremePoint = translator.translate(extremeDataValue);\r\n        var visualRange = this.visualRange();\r\n        var visualRangePoint = isMax ? translator.translate(visualRange.endValue) : translator.translate(visualRange.startValue);\r\n        return _abs(visualRangePoint - extremePoint) < SCROLL_THRESHOLD\r\n    },\r\n    getViewport() {\r\n        return this._viewport\r\n    },\r\n    getFullTicks: function() {\r\n        var majors = this._majorTicks || [];\r\n        if (this._options.type === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete) {\r\n            return convertTicksToValues(majors)\r\n        } else {\r\n            return convertTicksToValues(majors.concat(this._minorTicks, this._boundaryTicks)).sort((function(a, b) {\r\n                return Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"valueOf\"])(a) - Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"valueOf\"])(b)\r\n            }))\r\n        }\r\n    },\r\n    measureLabels: function(canvas, withIndents) {\r\n        var that = this;\r\n        var options = that._options;\r\n        var widthAxis = options.visible ? options.width : 0;\r\n        var ticks;\r\n        var indent = withIndents ? options.label.indentFromAxis + .5 * options.tick.length : 0;\r\n        var tickInterval;\r\n        var viewportRange = that._getViewportRange();\r\n        if (viewportRange.isEmpty() || !options.label.visible || !that._axisElementsGroup) {\r\n            return {\r\n                height: widthAxis,\r\n                width: widthAxis,\r\n                x: 0,\r\n                y: 0\r\n            }\r\n        }\r\n        if (that._majorTicks) {\r\n            ticks = convertTicksToValues(that._majorTicks)\r\n        } else {\r\n            that.updateCanvas(canvas);\r\n            ticks = that._createTicksAndLabelFormat(viewportRange, _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"]);\r\n            tickInterval = ticks.tickInterval;\r\n            ticks = ticks.ticks\r\n        }\r\n        var maxText = ticks.reduce((function(prevLabel, tick, index) {\r\n            var label = that.formatLabel(tick, options.label, viewportRange, void 0, tickInterval, ticks);\r\n            if (prevLabel.length < label.length) {\r\n                return label\r\n            } else {\r\n                return prevLabel\r\n            }\r\n        }), that.formatLabel(ticks[0], options.label, viewportRange, void 0, tickInterval, ticks));\r\n        var text = that._renderer.text(maxText, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(that._renderer.root);\r\n        var box = text.getBBox();\r\n        text.remove();\r\n        return {\r\n            x: box.x,\r\n            y: box.y,\r\n            width: box.width + indent,\r\n            height: box.height + indent\r\n        }\r\n    },\r\n    _setLabelsPlacement: function() {\r\n        if (!this._options.label.visible) {\r\n            return\r\n        }\r\n        var labelOpt = this._options.label;\r\n        var displayMode = this._validateDisplayMode(labelOpt.displayMode);\r\n        var overlappingMode = this._validateOverlappingMode(labelOpt.overlappingBehavior, displayMode);\r\n        var ignoreOverlapping = \"none\" === overlappingMode || \"ignore\" === overlappingMode;\r\n        var behavior = {\r\n            rotationAngle: labelOpt.rotationAngle,\r\n            staggeringSpacing: labelOpt.staggeringSpacing\r\n        };\r\n        var notRecastStep;\r\n        var boxes = this._majorTicks.map((function(tick) {\r\n            return tick.labelBBox\r\n        }));\r\n        var step = this._getStep(boxes);\r\n        switch (displayMode) {\r\n            case ROTATE:\r\n                if (ignoreOverlapping) {\r\n                    notRecastStep = true;\r\n                    step = 1\r\n                }\r\n                this._applyLabelMode(displayMode, step, boxes, labelOpt, notRecastStep);\r\n                break;\r\n            case \"stagger\":\r\n                if (ignoreOverlapping) {\r\n                    step = 2\r\n                }\r\n                this._applyLabelMode(displayMode, _max(step, 2), boxes, labelOpt);\r\n                break;\r\n            default:\r\n                this._applyLabelOverlapping(boxes, overlappingMode, step, behavior)\r\n        }\r\n    },\r\n    _applyLabelOverlapping: function(boxes, mode, step, behavior) {\r\n        var labelOpt = this._options.label;\r\n        var majorTicks = this._majorTicks;\r\n        if (\"none\" === mode || \"ignore\" === mode) {\r\n            return\r\n        }\r\n        if (step > 1 && boxes.some((function(box, index, array) {\r\n                if (0 === index) {\r\n                    return false\r\n                }\r\n                return _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].areLabelsOverlap(box, array[index - 1], labelOpt.minSpacing, labelOpt.alignment)\r\n            }))) {\r\n            this._applyLabelMode(mode, step, boxes, behavior)\r\n        }\r\n        this._checkBoundedLabelsOverlapping(majorTicks, boxes, mode);\r\n        this._checkShiftedLabels(majorTicks, boxes, labelOpt.minSpacing, labelOpt.alignment)\r\n    },\r\n    _applyLabelMode: function(mode, step, boxes, behavior, notRecastStep) {\r\n        var majorTicks = this._majorTicks;\r\n        var labelOpt = this._options.label;\r\n        var angle = behavior.rotationAngle;\r\n        var labelHeight;\r\n        var alignment;\r\n        var func;\r\n        switch (mode) {\r\n            case ROTATE:\r\n                if (!labelOpt.userAlignment) {\r\n                    alignment = angle < 0 ? RIGHT : LEFT;\r\n                    if (angle % 90 === 0) {\r\n                        alignment = CENTER\r\n                    }\r\n                }\r\n                step = notRecastStep ? step : this._getStep(boxes, angle);\r\n                func = function(tick) {\r\n                    var contentContainer = tick.getContentContainer();\r\n                    if (!contentContainer) {\r\n                        return\r\n                    }\r\n                    contentContainer.rotate(angle);\r\n                    tick.labelRotationAngle = angle;\r\n                    alignment && (tick.labelAlignment = alignment)\r\n                };\r\n                updateLabels(majorTicks, step, func);\r\n                break;\r\n            case \"stagger\":\r\n                labelHeight = this._getMaxLabelHeight(boxes, behavior.staggeringSpacing);\r\n                func = function(tick, index) {\r\n                    if (index / (step - 1) % 2 !== 0) {\r\n                        tick.labelOffset = labelHeight\r\n                    }\r\n                };\r\n                updateLabels(majorTicks, step - 1, func);\r\n                break;\r\n            case \"auto\":\r\n            case \"_auto\":\r\n                if (2 === step) {\r\n                    this._applyLabelMode(\"stagger\", step, boxes, behavior)\r\n                } else {\r\n                    this._applyLabelMode(ROTATE, step, boxes, {\r\n                        rotationAngle: getOptimalAngle(boxes, labelOpt)\r\n                    })\r\n                }\r\n                break;\r\n            default:\r\n                updateLabels(majorTicks, step)\r\n        }\r\n    },\r\n    getMarkerTrackers: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    _drawDateMarkers: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    _adjustDateMarkers: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    coordsIn: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    areCoordsOutsideAxis: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    _getSkippedCategory: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    _initAxisPositions: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    _drawTitle: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    _updateTitleCoords: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    _adjustConstantLineLabels: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    _createTranslator: function() {\r\n        return new _translators_translator2d__WEBPACK_IMPORTED_MODULE_9__[\"Translator2D\"]({}, {}, {})\r\n    },\r\n    _updateTranslator: function() {\r\n        var translator = this._translator;\r\n        translator.update(translator.getBusinessRange(), this._canvas || {}, this._getTranslatorOptions())\r\n    },\r\n    _getTranslatorOptions: function() {\r\n        var _options$workWeek2, _options$breakStyle$w, _options$breakStyle;\r\n        var options = this._options;\r\n        return {\r\n            isHorizontal: this._isHorizontal,\r\n            shiftZeroValue: !this.isArgumentAxis,\r\n            interval: options.semiDiscreteInterval,\r\n            firstDayOfWeek: null === (_options$workWeek2 = options.workWeek) || void 0 === _options$workWeek2 ? void 0 : _options$workWeek2[0],\r\n            stick: this._getStick(),\r\n            breaksSize: null !== (_options$breakStyle$w = null === (_options$breakStyle = options.breakStyle) || void 0 === _options$breakStyle ? void 0 : _options$breakStyle.width) && void 0 !== _options$breakStyle$w ? _options$breakStyle$w : 0\r\n        }\r\n    },\r\n    getVisibleArea() {\r\n        var canvas = this._getCanvasStartEnd();\r\n        return [canvas.start, canvas.end].sort((a, b) => a - b)\r\n    },\r\n    _getCanvasStartEnd: function() {\r\n        var isHorizontal = this._isHorizontal;\r\n        var canvas = this._canvas || {};\r\n        var invert = this._translator.getBusinessRange().invert;\r\n        var coords = isHorizontal ? [canvas.left, canvas.width - canvas.right] : [canvas.height - canvas.bottom, canvas.top];\r\n        invert && coords.reverse();\r\n        return {\r\n            start: coords[0],\r\n            end: coords[1]\r\n        }\r\n    },\r\n    _getScreenDelta: function() {\r\n        var canvas = this._getCanvasStartEnd();\r\n        var breaks = this._seriesData ? this._seriesData.breaks || [] : [];\r\n        var breaksLength = breaks.length;\r\n        var screenDelta = _abs(canvas.start - canvas.end);\r\n        return screenDelta - (breaksLength ? breaks[breaksLength - 1].cumulativeWidth : 0)\r\n    },\r\n    _getScaleBreaks: function() {\r\n        return []\r\n    },\r\n    _filterBreaks: function() {\r\n        return []\r\n    },\r\n    _adjustTitle: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    _checkTitleOverflow: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    getSpiderTicks: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    setSpiderTicks: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    _checkBoundedLabelsOverlapping: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    _checkShiftedLabels: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    drawScaleBreaks: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    _visualRange: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    _rotateConstantLine: _core_utils_common__WEBPACK_IMPORTED_MODULE_14__[\"noop\"],\r\n    applyVisualRangeSetter(visualRangeSetter) {\r\n        this._visualRange = visualRangeSetter\r\n    },\r\n    getCategoriesSorter(argCategories) {\r\n        var sort;\r\n        if (this.isArgumentAxis) {\r\n            sort = argCategories\r\n        } else {\r\n            var categoriesSortingMethod = this._options.categoriesSortingMethod;\r\n            sort = null !== categoriesSortingMethod && void 0 !== categoriesSortingMethod ? categoriesSortingMethod : this._options.categories\r\n        }\r\n        return sort\r\n    },\r\n    _getAdjustedBusinessRange() {\r\n        return this.adjustViewport(this._translator.getBusinessRange())\r\n    }\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2F4ZXMvYmFzZV9heGlzLmpzP2NkNTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJMkI7QUFZSjtBQU1RO0FBQ1U7QUFHUjtBQUdEO0FBQ2U7QUFHWjtBQUdUO0FBR1c7QUFHUDtBQUdkO0FBR2U7QUFDZTtBQUdiO0FBQ0M7QUFDVztBQUNJO0FBQ2Y7QUFJQztBQUliO0FBQ3RCLDJCQUEyQix1REFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdURBQVM7QUFDbkIsYUFBYSx1REFBUztBQUN0QixXQUFXLHVEQUFTO0FBQ3BCLFlBQVksdURBQVM7QUFDckIsYUFBYSx1REFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcscUVBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG1EQUFJO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLFdBQVcsbURBQUk7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtREFBSSxpQkFBaUIsaUVBQU0sR0FBRztBQUN6QztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0Isd0RBQUs7QUFDdkIseUJBQXlCLHdEQUFLO0FBQzlCLG9CQUFvQix3REFBSztBQUN6QixvQkFBb0Isd0RBQUs7QUFDekIsb0NBQW9DLHdEQUFLO0FBQ3pDLHlCQUF5Qix3REFBSztBQUM5QixxQkFBcUIsd0RBQUs7QUFDMUIsa0JBQWtCLHdEQUFLO0FBQ3ZCLHlCQUF5Qix3REFBSztBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3Zpei9heGVzL2Jhc2VfYXhpcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdml6L2F4ZXMvYmFzZV9heGlzLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQge1xyXG4gICAgc21hcnRGb3JtYXR0ZXIgYXMgX2Zvcm1hdCxcclxuICAgIGZvcm1hdFJhbmdlXHJcbn0gZnJvbSBcIi4vc21hcnRfZm9ybWF0dGVyXCI7XHJcbmltcG9ydCB7XHJcbiAgICBwYXRjaEZvbnRPcHRpb25zLFxyXG4gICAgZ2V0Vml6UmFuZ2VPYmplY3QsXHJcbiAgICBnZXRMb2dFeHQgYXMgZ2V0TG9nLFxyXG4gICAgcmFpc2VUb0V4dCBhcyByYWlzZVRvLFxyXG4gICAgdmFsdWVPZixcclxuICAgIHJvdGF0ZUJCb3gsXHJcbiAgICBnZXRDYXRlZ29yaWVzSW5mbyxcclxuICAgIGFkanVzdFZpc3VhbFJhbmdlLFxyXG4gICAgZ2V0QWRkRnVuY3Rpb24sXHJcbiAgICBjb252ZXJ0VmlzdWFsUmFuZ2VPYmplY3RcclxufSBmcm9tIFwiLi4vY29yZS91dGlsc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgaXNEZWZpbmVkLFxyXG4gICAgaXNGdW5jdGlvbixcclxuICAgIGlzUGxhaW5PYmplY3QsXHJcbiAgICB0eXBlXHJcbn0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvdHlwZVwiO1xyXG5pbXBvcnQgY29uc3RhbnRzIGZyb20gXCIuL2F4ZXNfY29uc3RhbnRzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBleHRlbmRcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9leHRlbmRcIjtcclxuaW1wb3J0IHtcclxuICAgIGluQXJyYXlcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9hcnJheVwiO1xyXG5pbXBvcnQgZm9ybWF0SGVscGVyIGZyb20gXCIuLi8uLi9mb3JtYXRfaGVscGVyXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRQYXJzZXJcclxufSBmcm9tIFwiLi4vY29tcG9uZW50cy9wYXJzZV91dGlsc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgdGlja0dlbmVyYXRvclxyXG59IGZyb20gXCIuL3RpY2tfZ2VuZXJhdG9yXCI7XHJcbmltcG9ydCB7XHJcbiAgICBUcmFuc2xhdG9yMkRcclxufSBmcm9tIFwiLi4vdHJhbnNsYXRvcnMvdHJhbnNsYXRvcjJkXCI7XHJcbmltcG9ydCB7XHJcbiAgICBSYW5nZVxyXG59IGZyb20gXCIuLi90cmFuc2xhdG9ycy9yYW5nZVwiO1xyXG5pbXBvcnQge1xyXG4gICAgdGlja1xyXG59IGZyb20gXCIuL3RpY2tcIjtcclxuaW1wb3J0IHtcclxuICAgIGFkanVzdFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL21hdGhcIjtcclxuaW1wb3J0IGRhdGVVdGlscyBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9kYXRlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBub29wIGFzIF9ub29wXHJcbn0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvY29tbW9uXCI7XHJcbmltcG9ydCB4eU1ldGhvZHMgZnJvbSBcIi4veHlfYXhlc1wiO1xyXG5pbXBvcnQgKiBhcyBwb2xhck1ldGhvZHMgZnJvbSBcIi4vcG9sYXJfYXhlc1wiO1xyXG5pbXBvcnQgY3JlYXRlQ29uc3RhbnRMaW5lIGZyb20gXCIuL2NvbnN0YW50X2xpbmVcIjtcclxuaW1wb3J0IGNyZWF0ZVN0cmlwIGZyb20gXCIuL3N0cmlwXCI7XHJcbmltcG9ydCB7XHJcbiAgICBEZWZlcnJlZCxcclxuICAgIHdoZW5cclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9kZWZlcnJlZFwiO1xyXG5pbXBvcnQge1xyXG4gICAgY2FsY3VsYXRlQ2FudmFzTWFyZ2lucyxcclxuICAgIG1lYXN1cmVMYWJlbHNcclxufSBmcm9tIFwiLi9heGVzX3V0aWxzXCI7XHJcbnZhciBjb252ZXJ0VGlja3NUb1ZhbHVlcyA9IGNvbnN0YW50cy5jb252ZXJ0VGlja3NUb1ZhbHVlcztcclxudmFyIF9tYXRoID0gTWF0aDtcclxudmFyIF9hYnMgPSBfbWF0aC5hYnM7XHJcbnZhciBfbWF4ID0gX21hdGgubWF4O1xyXG52YXIgX21pbiA9IF9tYXRoLm1pbjtcclxudmFyIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxudmFyIERFRkFVTFRfQVhJU19MQUJFTF9TUEFDSU5HID0gNTtcclxudmFyIE1BWF9HUklEX0JPUkRFUl9BREhFTlNJT04gPSA0O1xyXG52YXIgVE9QID0gY29uc3RhbnRzLnRvcDtcclxudmFyIEJPVFRPTSA9IGNvbnN0YW50cy5ib3R0b207XHJcbnZhciBMRUZUID0gY29uc3RhbnRzLmxlZnQ7XHJcbnZhciBSSUdIVCA9IGNvbnN0YW50cy5yaWdodDtcclxudmFyIENFTlRFUiA9IGNvbnN0YW50cy5jZW50ZXI7XHJcbnZhciBLRUVQID0gXCJrZWVwXCI7XHJcbnZhciBTSElGVCA9IFwic2hpZnRcIjtcclxudmFyIFJFU0VUID0gXCJyZXNldFwiO1xyXG52YXIgUk9UQVRFID0gXCJyb3RhdGVcIjtcclxudmFyIERFRkFVTFRfQVhJU19ESVZJU0lPTl9GQUNUT1IgPSA1MDtcclxudmFyIERFRkFVTFRfTUlOT1JfQVhJU19ESVZJU0lPTl9GQUNUT1IgPSAxNTtcclxudmFyIFNDUk9MTF9USFJFU0hPTEQgPSA1O1xyXG52YXIgTUlOX0JBUl9NQVJHSU4gPSA1O1xyXG52YXIgTUFYX01BUkdJTl9WQUxVRSA9IC44O1xyXG52YXIgZGF0ZUludGVydmFscyA9IHtcclxuICAgIGRheTogODY0ZTUsXHJcbiAgICB3ZWVrOiA2MDQ4ZTVcclxufTtcclxuXHJcbmZ1bmN0aW9uIGdldFRpY2tHZW5lcmF0b3Iob3B0aW9ucywgaW5jaWRlbnRPY2N1cnJlZCwgc2tpcFRpY2tHZW5lcmF0aW9uLCByYW5nZUlzRW1wdHksIGFkanVzdERpdmlzaW9uRmFjdG9yLCBfcmVmKSB7XHJcbiAgICB2YXIgX29wdGlvbnMkd29ya1dlZWs7XHJcbiAgICB2YXIge1xyXG4gICAgICAgIGFsbG93TmVnYXRpdmVzOiBhbGxvd05lZ2F0aXZlcyxcclxuICAgICAgICBsaW5lYXJUaHJlc2hvbGQ6IGxpbmVhclRocmVzaG9sZFxyXG4gICAgfSA9IF9yZWY7XHJcbiAgICByZXR1cm4gdGlja0dlbmVyYXRvcih7XHJcbiAgICAgICAgYXhpc1R5cGU6IG9wdGlvbnMudHlwZSxcclxuICAgICAgICBkYXRhVHlwZTogb3B0aW9ucy5kYXRhVHlwZSxcclxuICAgICAgICBsb2dCYXNlOiBvcHRpb25zLmxvZ2FyaXRobUJhc2UsXHJcbiAgICAgICAgYWxsb3dOZWdhdGl2ZXM6IGFsbG93TmVnYXRpdmVzLFxyXG4gICAgICAgIGxpbmVhclRocmVzaG9sZDogbGluZWFyVGhyZXNob2xkLFxyXG4gICAgICAgIGF4aXNEaXZpc2lvbkZhY3RvcjogYWRqdXN0RGl2aXNpb25GYWN0b3Iob3B0aW9ucy5heGlzRGl2aXNpb25GYWN0b3IgfHwgREVGQVVMVF9BWElTX0RJVklTSU9OX0ZBQ1RPUiksXHJcbiAgICAgICAgbWlub3JBeGlzRGl2aXNpb25GYWN0b3I6IGFkanVzdERpdmlzaW9uRmFjdG9yKG9wdGlvbnMubWlub3JBeGlzRGl2aXNpb25GYWN0b3IgfHwgREVGQVVMVF9NSU5PUl9BWElTX0RJVklTSU9OX0ZBQ1RPUiksXHJcbiAgICAgICAgbnVtYmVyTXVsdGlwbGllcnM6IG9wdGlvbnMubnVtYmVyTXVsdGlwbGllcnMsXHJcbiAgICAgICAgY2FsY3VsYXRlTWlub3JzOiBvcHRpb25zLm1pbm9yVGljay52aXNpYmxlIHx8IG9wdGlvbnMubWlub3JHcmlkLnZpc2libGUgfHwgb3B0aW9ucy5jYWxjdWxhdGVNaW5vcnMsXHJcbiAgICAgICAgYWxsb3dEZWNpbWFsczogb3B0aW9ucy5hbGxvd0RlY2ltYWxzLFxyXG4gICAgICAgIGVuZE9uVGljazogb3B0aW9ucy5lbmRPblRpY2ssXHJcbiAgICAgICAgaW5jaWRlbnRPY2N1cnJlZDogaW5jaWRlbnRPY2N1cnJlZCxcclxuICAgICAgICBmaXJzdERheU9mV2VlazogbnVsbCA9PT0gKF9vcHRpb25zJHdvcmtXZWVrID0gb3B0aW9ucy53b3JrV2VlaykgfHwgdm9pZCAwID09PSBfb3B0aW9ucyR3b3JrV2VlayA/IHZvaWQgMCA6IF9vcHRpb25zJHdvcmtXZWVrWzBdLFxyXG4gICAgICAgIHNraXBUaWNrR2VuZXJhdGlvbjogc2tpcFRpY2tHZW5lcmF0aW9uLFxyXG4gICAgICAgIHNraXBDYWxjdWxhdGlvbkxpbWl0czogb3B0aW9ucy5za2lwQ2FsY3VsYXRpb25MaW1pdHMsXHJcbiAgICAgICAgZ2VuZXJhdGVFeHRyYVRpY2s6IG9wdGlvbnMuZ2VuZXJhdGVFeHRyYVRpY2ssXHJcbiAgICAgICAgbWluVGlja0ludGVydmFsOiBvcHRpb25zLm1pblRpY2tJbnRlcnZhbCxcclxuICAgICAgICByYW5nZUlzRW1wdHk6IHJhbmdlSXNFbXB0eVxyXG4gICAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTWFqb3JUaWNrKGF4aXMsIHJlbmRlcmVyLCBza2lwcGVkQ2F0ZWdvcnkpIHtcclxuICAgIHZhciBvcHRpb25zID0gYXhpcy5nZXRPcHRpb25zKCk7XHJcbiAgICByZXR1cm4gdGljayhheGlzLCByZW5kZXJlciwgb3B0aW9ucy50aWNrLCBvcHRpb25zLmdyaWQsIHNraXBwZWRDYXRlZ29yeSwgZmFsc2UpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU1pbm9yVGljayhheGlzLCByZW5kZXJlcikge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBheGlzLmdldE9wdGlvbnMoKTtcclxuICAgIHJldHVybiB0aWNrKGF4aXMsIHJlbmRlcmVyLCBvcHRpb25zLm1pbm9yVGljaywgb3B0aW9ucy5taW5vckdyaWQpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUJvdW5kYXJ5VGljayhheGlzLCByZW5kZXJlciwgaXNGaXJzdCkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBheGlzLmdldE9wdGlvbnMoKTtcclxuICAgIHJldHVybiB0aWNrKGF4aXMsIHJlbmRlcmVyLCBleHRlbmQoe30sIG9wdGlvbnMudGljaywge1xyXG4gICAgICAgIHZpc2libGU6IG9wdGlvbnMuc2hvd0N1c3RvbUJvdW5kYXJ5VGlja3NcclxuICAgIH0pLCBvcHRpb25zLmdyaWQsIHZvaWQgMCwgZmFsc2UsIGlzRmlyc3QgPyAtMSA6IDEpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGxBY3Rpb24oZWxlbWVudHMsIGFjdGlvbiwgYWN0aW9uQXJndW1lbnQxLCBhY3Rpb25Bcmd1bWVudDIpIHtcclxuICAgIChlbGVtZW50cyB8fCBbXSkuZm9yRWFjaChlID0+IGVbYWN0aW9uXShhY3Rpb25Bcmd1bWVudDEsIGFjdGlvbkFyZ3VtZW50MikpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluaXRUaWNrQ29vcmRzKHRpY2tzKSB7XHJcbiAgICBjYWxsQWN0aW9uKHRpY2tzLCBcImluaXRDb29yZHNcIilcclxufVxyXG5cclxuZnVuY3Rpb24gZHJhd1RpY2tNYXJrcyh0aWNrcywgb3B0aW9ucykge1xyXG4gICAgY2FsbEFjdGlvbih0aWNrcywgXCJkcmF3TWFya1wiLCBvcHRpb25zKVxyXG59XHJcblxyXG5mdW5jdGlvbiBkcmF3R3JpZHModGlja3MsIGRyYXdMaW5lKSB7XHJcbiAgICBjYWxsQWN0aW9uKHRpY2tzLCBcImRyYXdHcmlkXCIsIGRyYXdMaW5lKVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVUaWNrc1Bvc2l0aW9uKHRpY2tzLCBvcHRpb25zLCBhbmltYXRlKSB7XHJcbiAgICBjYWxsQWN0aW9uKHRpY2tzLCBcInVwZGF0ZVRpY2tQb3NpdGlvblwiLCBvcHRpb25zLCBhbmltYXRlKVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVHcmlkc1Bvc2l0aW9uKHRpY2tzLCBhbmltYXRlKSB7XHJcbiAgICBjYWxsQWN0aW9uKHRpY2tzLCBcInVwZGF0ZUdyaWRQb3NpdGlvblwiLCBhbmltYXRlKVxyXG59XHJcblxyXG5mdW5jdGlvbiBjbGVhblVwSW52YWxpZFRpY2tzKHRpY2tzKSB7XHJcbiAgICB2YXIgaSA9IHRpY2tzLmxlbmd0aCAtIDE7XHJcbiAgICBmb3IgKGk7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgaWYgKCFyZW1vdmVJbnZhbGlkVGljayh0aWNrcywgaSkpIHtcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocmVtb3ZlSW52YWxpZFRpY2sodGlja3MsIGkpKSB7XHJcbiAgICAgICAgICAgIGktLVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVJbnZhbGlkVGljayh0aWNrcywgaSkge1xyXG4gICAgaWYgKG51bGwgPT09IHRpY2tzW2ldLmNvb3Jkcy54IHx8IG51bGwgPT09IHRpY2tzW2ldLmNvb3Jkcy55KSB7XHJcbiAgICAgICAgdGlja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVBeGlzT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICB2YXIgX2xhYmVsT3B0aW9ucyRtaW5TcGFjO1xyXG4gICAgdmFyIGxhYmVsT3B0aW9ucyA9IG9wdGlvbnMubGFiZWw7XHJcbiAgICB2YXIgcG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xyXG4gICAgdmFyIGRlZmF1bHRQb3NpdGlvbiA9IG9wdGlvbnMuaXNIb3Jpem9udGFsID8gQk9UVE9NIDogTEVGVDtcclxuICAgIHZhciBzZWNvbmRhcnlQb3NpdGlvbiA9IG9wdGlvbnMuaXNIb3Jpem9udGFsID8gVE9QIDogUklHSFQ7XHJcbiAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsT3B0aW9ucy5wb3NpdGlvbjtcclxuICAgIGlmIChwb3NpdGlvbiAhPT0gZGVmYXVsdFBvc2l0aW9uICYmIHBvc2l0aW9uICE9PSBzZWNvbmRhcnlQb3NpdGlvbikge1xyXG4gICAgICAgIHBvc2l0aW9uID0gZGVmYXVsdFBvc2l0aW9uXHJcbiAgICB9XHJcbiAgICBpZiAoIWxhYmVsUG9zaXRpb24gfHwgXCJvdXRzaWRlXCIgPT09IGxhYmVsUG9zaXRpb24pIHtcclxuICAgICAgICBsYWJlbFBvc2l0aW9uID0gcG9zaXRpb25cclxuICAgIH0gZWxzZSBpZiAoXCJpbnNpZGVcIiA9PT0gbGFiZWxQb3NpdGlvbikge1xyXG4gICAgICAgIGxhYmVsUG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIFtUT1BdOiBCT1RUT00sXHJcbiAgICAgICAgICAgIFtCT1RUT01dOiBUT1AsXHJcbiAgICAgICAgICAgIFtMRUZUXTogUklHSFQsXHJcbiAgICAgICAgICAgIFtSSUdIVF06IExFRlRcclxuICAgICAgICB9IFtwb3NpdGlvbl1cclxuICAgIH1cclxuICAgIGlmIChsYWJlbFBvc2l0aW9uICE9PSBkZWZhdWx0UG9zaXRpb24gJiYgbGFiZWxQb3NpdGlvbiAhPT0gc2Vjb25kYXJ5UG9zaXRpb24pIHtcclxuICAgICAgICBsYWJlbFBvc2l0aW9uID0gcG9zaXRpb25cclxuICAgIH1cclxuICAgIGlmIChsYWJlbE9wdGlvbnMuYWxpZ25tZW50ICE9PSBDRU5URVIgJiYgIWxhYmVsT3B0aW9ucy51c2VyQWxpZ25tZW50KSB7XHJcbiAgICAgICAgbGFiZWxPcHRpb25zLmFsaWdubWVudCA9IHtcclxuICAgICAgICAgICAgW1RPUF06IENFTlRFUixcclxuICAgICAgICAgICAgW0JPVFRPTV06IENFTlRFUixcclxuICAgICAgICAgICAgW0xFRlRdOiBSSUdIVCxcclxuICAgICAgICAgICAgW1JJR0hUXTogTEVGVFxyXG4gICAgICAgIH0gW2xhYmVsUG9zaXRpb25dXHJcbiAgICB9XHJcbiAgICBvcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICBsYWJlbE9wdGlvbnMucG9zaXRpb24gPSBsYWJlbFBvc2l0aW9uO1xyXG4gICAgb3B0aW9ucy5ob3Zlck1vZGUgPSBvcHRpb25zLmhvdmVyTW9kZSA/IG9wdGlvbnMuaG92ZXJNb2RlLnRvTG93ZXJDYXNlKCkgOiBcIm5vbmVcIjtcclxuICAgIGxhYmVsT3B0aW9ucy5taW5TcGFjaW5nID0gbnVsbCAhPT0gKF9sYWJlbE9wdGlvbnMkbWluU3BhYyA9IGxhYmVsT3B0aW9ucy5taW5TcGFjaW5nKSAmJiB2b2lkIDAgIT09IF9sYWJlbE9wdGlvbnMkbWluU3BhYyA/IF9sYWJlbE9wdGlvbnMkbWluU3BhYyA6IERFRkFVTFRfQVhJU19MQUJFTF9TUEFDSU5HO1xyXG4gICAgb3B0aW9ucy50eXBlICYmIChvcHRpb25zLnR5cGUgPSBvcHRpb25zLnR5cGUudG9Mb3dlckNhc2UoKSk7XHJcbiAgICBvcHRpb25zLmFyZ3VtZW50VHlwZSAmJiAob3B0aW9ucy5hcmd1bWVudFR5cGUgPSBvcHRpb25zLmFyZ3VtZW50VHlwZS50b0xvd2VyQ2FzZSgpKTtcclxuICAgIG9wdGlvbnMudmFsdWVUeXBlICYmIChvcHRpb25zLnZhbHVlVHlwZSA9IG9wdGlvbnMudmFsdWVUeXBlLnRvTG93ZXJDYXNlKCkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE9wdGltYWxBbmdsZShib3hlcywgbGFiZWxPcHQpIHtcclxuICAgIHZhciBhbmdsZSA9IDE4MCAqIF9tYXRoLmFzaW4oKGJveGVzWzBdLmhlaWdodCArIGxhYmVsT3B0Lm1pblNwYWNpbmcpIC8gKGJveGVzWzFdLnggLSBib3hlc1swXS54KSkgLyBfbWF0aC5QSTtcclxuICAgIHJldHVybiBhbmdsZSA8IDQ1ID8gLTQ1IDogLTkwXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxhYmVscyh0aWNrcywgc3RlcCwgZnVuYykge1xyXG4gICAgdGlja3MuZm9yRWFjaCgoZnVuY3Rpb24odGljaywgaW5kZXgpIHtcclxuICAgICAgICBpZiAodGljay5nZXRDb250ZW50Q29udGFpbmVyKCkpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ICUgc3RlcCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGljay5yZW1vdmVMYWJlbCgpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnVuYykge1xyXG4gICAgICAgICAgICAgICAgZnVuYyh0aWNrLCBpbmRleClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRab29tQm91bmRWYWx1ZShvcHRpb25WYWx1ZSwgZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodm9pZCAwID09PSBvcHRpb25WYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhVmFsdWVcclxuICAgIH0gZWxzZSBpZiAobnVsbCA9PT0gb3B0aW9uVmFsdWUpIHtcclxuICAgICAgICByZXR1cm5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvblZhbHVlXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbmZpZ3VyZUdlbmVyYXRvcihvcHRpb25zLCBheGlzRGl2aXNpb25GYWN0b3IsIHZpZXdQb3J0LCBzY3JlZW5EZWx0YSwgbWluVGlja0ludGVydmFsKSB7XHJcbiAgICB2YXIgdGlja0dlbmVyYXRvck9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMsIHtcclxuICAgICAgICBlbmRPblRpY2s6IHRydWUsXHJcbiAgICAgICAgYXhpc0RpdmlzaW9uRmFjdG9yOiBheGlzRGl2aXNpb25GYWN0b3IsXHJcbiAgICAgICAgc2tpcENhbGN1bGF0aW9uTGltaXRzOiB0cnVlLFxyXG4gICAgICAgIGdlbmVyYXRlRXh0cmFUaWNrOiB0cnVlLFxyXG4gICAgICAgIG1pblRpY2tJbnRlcnZhbDogbWluVGlja0ludGVydmFsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBmdW5jdGlvbih0aWNrSW50ZXJ2YWwsIHNraXBUaWNrR2VuZXJhdGlvbiwgbWluLCBtYXgsIGJyZWFrcykge1xyXG4gICAgICAgIHJldHVybiBnZXRUaWNrR2VuZXJhdG9yKHRpY2tHZW5lcmF0b3JPcHRpb25zLCBfbm9vcCwgc2tpcFRpY2tHZW5lcmF0aW9uLCB2aWV3UG9ydC5pc0VtcHR5KCksIHYgPT4gdiwgdmlld1BvcnQpKHtcclxuICAgICAgICAgICAgbWluOiBtaW4sXHJcbiAgICAgICAgICAgIG1heDogbWF4LFxyXG4gICAgICAgICAgICBjYXRlZ29yaWVzOiB2aWV3UG9ydC5jYXRlZ29yaWVzLFxyXG4gICAgICAgICAgICBpc1NwYWNlZE1hcmdpbjogdmlld1BvcnQuaXNTcGFjZWRNYXJnaW5cclxuICAgICAgICB9LCBzY3JlZW5EZWx0YSwgdGlja0ludGVydmFsLCBpc0RlZmluZWQodGlja0ludGVydmFsKSwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgYnJlYWtzKVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb25zdGFudExpbmVTaGFycERpcmVjdGlvbihjb29yZCwgYXhpc0NhbnZhcykge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KGF4aXNDYW52YXMuc3RhcnQsIGF4aXNDYW52YXMuZW5kKSAhPT0gY29vcmQgPyAxIDogLTFcclxufVxyXG5leHBvcnQgdmFyIEF4aXMgPSBmdW5jdGlvbihyZW5kZXJTZXR0aW5ncykge1xyXG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJTZXR0aW5ncy5yZW5kZXJlcjtcclxuICAgIHRoaXMuX2luY2lkZW50T2NjdXJyZWQgPSByZW5kZXJTZXR0aW5ncy5pbmNpZGVudE9jY3VycmVkO1xyXG4gICAgdGhpcy5fZXZlbnRUcmlnZ2VyID0gcmVuZGVyU2V0dGluZ3MuZXZlbnRUcmlnZ2VyO1xyXG4gICAgdGhpcy5fc3RyaXBzR3JvdXAgPSByZW5kZXJTZXR0aW5ncy5zdHJpcHNHcm91cDtcclxuICAgIHRoaXMuX3N0cmlwTGFiZWxBeGVzR3JvdXAgPSByZW5kZXJTZXR0aW5ncy5zdHJpcExhYmVsQXhlc0dyb3VwO1xyXG4gICAgdGhpcy5fbGFiZWxzQXhlc0dyb3VwID0gcmVuZGVyU2V0dGluZ3MubGFiZWxzQXhlc0dyb3VwO1xyXG4gICAgdGhpcy5fY29uc3RhbnRMaW5lc0dyb3VwID0gcmVuZGVyU2V0dGluZ3MuY29uc3RhbnRMaW5lc0dyb3VwO1xyXG4gICAgdGhpcy5fc2NhbGVCcmVha3NHcm91cCA9IHJlbmRlclNldHRpbmdzLnNjYWxlQnJlYWtzR3JvdXA7XHJcbiAgICB0aGlzLl9heGVzQ29udGFpbmVyR3JvdXAgPSByZW5kZXJTZXR0aW5ncy5heGVzQ29udGFpbmVyR3JvdXA7XHJcbiAgICB0aGlzLl9ncmlkQ29udGFpbmVyR3JvdXAgPSByZW5kZXJTZXR0aW5ncy5ncmlkR3JvdXA7XHJcbiAgICB0aGlzLl9heGlzQ3NzUHJlZml4ID0gcmVuZGVyU2V0dGluZ3Mud2lkZ2V0Q2xhc3MgKyBcIi1cIiArIChyZW5kZXJTZXR0aW5ncy5heGlzQ2xhc3MgPyByZW5kZXJTZXR0aW5ncy5heGlzQ2xhc3MgKyBcIi1cIiA6IFwiXCIpO1xyXG4gICAgdGhpcy5fc2V0VHlwZShyZW5kZXJTZXR0aW5ncy5heGlzVHlwZSwgcmVuZGVyU2V0dGluZ3MuZHJhd2luZ1R5cGUpO1xyXG4gICAgdGhpcy5fY3JlYXRlQXhpc0dyb3VwcygpO1xyXG4gICAgdGhpcy5fdHJhbnNsYXRvciA9IHRoaXMuX2NyZWF0ZVRyYW5zbGF0b3IoKTtcclxuICAgIHRoaXMuaXNBcmd1bWVudEF4aXMgPSByZW5kZXJTZXR0aW5ncy5pc0FyZ3VtZW50QXhpcztcclxuICAgIHRoaXMuX3ZpZXdwb3J0ID0ge307XHJcbiAgICB0aGlzLl9wcmV2RGF0YUluZm8gPSB7fTtcclxuICAgIHRoaXMuX2ZpcnN0RHJhd2luZyA9IHRydWU7XHJcbiAgICB0aGlzLl9pbml0UmFuZ2UgPSB7fTtcclxuICAgIHRoaXMuX2dldFRlbXBsYXRlID0gcmVuZGVyU2V0dGluZ3MuZ2V0VGVtcGxhdGVcclxufTtcclxuQXhpcy5wcm90b3R5cGUgPSB7XHJcbiAgICBjb25zdHJ1Y3RvcjogQXhpcyxcclxuICAgIF9kcmF3QXhpcygpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnM7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zLnZpc2libGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2F4aXNFbGVtZW50ID0gdGhpcy5fY3JlYXRlQXhpc0VsZW1lbnQoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVBeGlzRWxlbWVudFBvc2l0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5fYXhpc0VsZW1lbnQuYXR0cih7XHJcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IG9wdGlvbnMud2lkdGgsXHJcbiAgICAgICAgICAgIHN0cm9rZTogb3B0aW9ucy5jb2xvcixcclxuICAgICAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiBvcHRpb25zLm9wYWNpdHlcclxuICAgICAgICB9KS5zaGFycCh0aGlzLl9nZXRTaGFycFBhcmFtKHRydWUpLCB0aGlzLmdldEF4aXNTaGFycERpcmVjdGlvbigpKS5hcHBlbmQodGhpcy5fYXhpc0xpbmVHcm91cClcclxuICAgIH0sXHJcbiAgICBfY3JlYXRlUGF0aEVsZW1lbnQocG9pbnRzLCBhdHRyLCBzaGFycERpcmVjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNoYXJwKHRoaXMuX3JlbmRlcmVyLnBhdGgocG9pbnRzLCBcImxpbmVcIikuYXR0cihhdHRyKSwgc2hhcnBEaXJlY3Rpb24pXHJcbiAgICB9LFxyXG4gICAgc2hhcnAoc3ZnRWxlbWVudCkge1xyXG4gICAgICAgIHZhciBzaGFycERpcmVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogMTtcclxuICAgICAgICByZXR1cm4gc3ZnRWxlbWVudC5zaGFycCh0aGlzLl9nZXRTaGFycFBhcmFtKCksIHNoYXJwRGlyZWN0aW9uKVxyXG4gICAgfSxcclxuICAgIGN1c3RvbVBvc2l0aW9uSXNBdmFpbGFibGU6ICgpID0+IGZhbHNlLFxyXG4gICAgZ2V0T3J0aG9nb25hbEF4aXM6IF9ub29wLFxyXG4gICAgZ2V0Q3VzdG9tUG9zaXRpb246IF9ub29wLFxyXG4gICAgZ2V0Q3VzdG9tQm91bmRhcnlQb3NpdGlvbjogX25vb3AsXHJcbiAgICByZXNvbHZlT3ZlcmxhcHBpbmdGb3JDdXN0b21Qb3NpdGlvbmluZzogX25vb3AsXHJcbiAgICBoYXNOb25Cb3VuZGFyeVBvc2l0aW9uOiAoKSA9PiBmYWxzZSxcclxuICAgIGN1c3RvbVBvc2l0aW9uSXNCb3VuZGFyeU9ydGhvZ29uYWxBeGlzOiAoKSA9PiBmYWxzZSxcclxuICAgIGdldFJlc29sdmVkQm91bmRhcnlQb3NpdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKCkucG9zaXRpb25cclxuICAgIH0sXHJcbiAgICBnZXRBeGlzU2hhcnBEaXJlY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXRSZXNvbHZlZEJvdW5kYXJ5UG9zaXRpb24oKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYXNOb25Cb3VuZGFyeVBvc2l0aW9uKCkgfHwgcG9zaXRpb24gIT09IEJPVFRPTSAmJiBwb3NpdGlvbiAhPT0gUklHSFQgPyAxIDogLTFcclxuICAgIH0sXHJcbiAgICBnZXRTaGFycERpcmVjdGlvbkJ5Q29vcmRzKGNvb3Jkcykge1xyXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9nZXRDYW52YXNTdGFydEVuZCgpO1xyXG4gICAgICAgIHZhciBtYXhDb29yZCA9IE1hdGgubWF4KGNhbnZhcy5zdGFydCwgY2FudmFzLmVuZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzID8gMCA6IG1heENvb3JkICE9PSBjb29yZHNbdGhpcy5faXNIb3Jpem9udGFsID8gXCJ4XCIgOiBcInlcIl0gPyAxIDogLTFcclxuICAgIH0sXHJcbiAgICBfZ2V0R3JpZExpbmVEcmF3ZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGljaywgZ3JpZFN0eWxlKSB7XHJcbiAgICAgICAgICAgIHZhciBncmlkID0gdGhhdC5fZ2V0R3JpZFBvaW50cyh0aWNrLmNvb3Jkcyk7XHJcbiAgICAgICAgICAgIGlmIChncmlkLnBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuX2NyZWF0ZVBhdGhFbGVtZW50KGdyaWQucG9pbnRzLCBncmlkU3R5bGUsIHRoYXQuZ2V0U2hhcnBEaXJlY3Rpb25CeUNvb3Jkcyh0aWNrLmNvb3JkcykpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2dldEdyaWRQb2ludHM6IGZ1bmN0aW9uKGNvb3Jkcykge1xyXG4gICAgICAgIHZhciBpc0hvcml6b250YWwgPSB0aGlzLl9pc0hvcml6b250YWw7XHJcbiAgICAgICAgdmFyIHRpY2tQb3NpdGlvbkZpZWxkID0gaXNIb3Jpem9udGFsID8gXCJ4XCIgOiBcInlcIjtcclxuICAgICAgICB2YXIgb3J0aG9nb25hbFBvc2l0aW9ucyA9IHRoaXMuX29ydGhvZ29uYWxQb3NpdGlvbnM7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uRnJvbSA9IG9ydGhvZ29uYWxQb3NpdGlvbnMuc3RhcnQ7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uVG8gPSBvcnRob2dvbmFsUG9zaXRpb25zLmVuZDtcclxuICAgICAgICB2YXIgYm9yZGVyT3B0aW9ucyA9IHRoaXMuYm9yZGVyT3B0aW9ucztcclxuICAgICAgICB2YXIgY2FudmFzU3RhcnQgPSBpc0hvcml6b250YWwgPyBMRUZUIDogVE9QO1xyXG4gICAgICAgIHZhciBjYW52YXNFbmQgPSBpc0hvcml6b250YWwgPyBSSUdIVCA6IEJPVFRPTTtcclxuICAgICAgICB2YXIgYXhpc0NhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IHtcclxuICAgICAgICAgICAgbGVmdDogYXhpc0NhbnZhcy5sZWZ0LFxyXG4gICAgICAgICAgICByaWdodDogYXhpc0NhbnZhcy53aWR0aCAtIGF4aXNDYW52YXMucmlnaHQsXHJcbiAgICAgICAgICAgIHRvcDogYXhpc0NhbnZhcy50b3AsXHJcbiAgICAgICAgICAgIGJvdHRvbTogYXhpc0NhbnZhcy5oZWlnaHQgLSBheGlzQ2FudmFzLmJvdHRvbVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGZpcnN0Qm9yZGVyTGluZVBvc2l0aW9uID0gYm9yZGVyT3B0aW9ucy52aXNpYmxlICYmIGJvcmRlck9wdGlvbnNbY2FudmFzU3RhcnRdID8gY2FudmFzW2NhbnZhc1N0YXJ0XSA6IHZvaWQgMDtcclxuICAgICAgICB2YXIgbGFzdEJvcmRlckxpbmVQb3NpdGlvbiA9IGJvcmRlck9wdGlvbnMudmlzaWJsZSAmJiBib3JkZXJPcHRpb25zW2NhbnZhc0VuZF0gPyBjYW52YXNbY2FudmFzRW5kXSA6IHZvaWQgMDtcclxuICAgICAgICB2YXIgbWluRGVsdGEgPSBNQVhfR1JJRF9CT1JERVJfQURIRU5TSU9OICsgZmlyc3RCb3JkZXJMaW5lUG9zaXRpb247XHJcbiAgICAgICAgdmFyIG1heERlbHRhID0gbGFzdEJvcmRlckxpbmVQb3NpdGlvbiAtIE1BWF9HUklEX0JPUkRFUl9BREhFTlNJT047XHJcbiAgICAgICAgaWYgKHRoaXMuYXJlQ29vcmRzT3V0c2lkZUF4aXMoY29vcmRzKSB8fCB2b2lkIDAgPT09IGNvb3Jkc1t0aWNrUG9zaXRpb25GaWVsZF0gfHwgY29vcmRzW3RpY2tQb3NpdGlvbkZpZWxkXSA8IG1pbkRlbHRhIHx8IGNvb3Jkc1t0aWNrUG9zaXRpb25GaWVsZF0gPiBtYXhEZWx0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBudWxsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcG9pbnRzOiBpc0hvcml6b250YWwgPyBudWxsICE9PSBjb29yZHNbdGlja1Bvc2l0aW9uRmllbGRdID8gW2Nvb3Jkc1t0aWNrUG9zaXRpb25GaWVsZF0sIHBvc2l0aW9uRnJvbSwgY29vcmRzW3RpY2tQb3NpdGlvbkZpZWxkXSwgcG9zaXRpb25Ub10gOiBudWxsIDogbnVsbCAhPT0gY29vcmRzW3RpY2tQb3NpdGlvbkZpZWxkXSA/IFtwb3NpdGlvbkZyb20sIGNvb3Jkc1t0aWNrUG9zaXRpb25GaWVsZF0sIHBvc2l0aW9uVG8sIGNvb3Jkc1t0aWNrUG9zaXRpb25GaWVsZF1dIDogbnVsbFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0Q29uc3RhbnRMaW5lUG9zOiBmdW5jdGlvbihwYXJzZWRWYWx1ZSwgY2FudmFzU3RhcnQsIGNhbnZhc0VuZCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldFRyYW5zbGF0ZWRDb29yZChwYXJzZWRWYWx1ZSk7XHJcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpIHx8IHZhbHVlIDwgX21pbihjYW52YXNTdGFydCwgY2FudmFzRW5kKSB8fCB2YWx1ZSA+IF9tYXgoY2FudmFzU3RhcnQsIGNhbnZhc0VuZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgfSxcclxuICAgIF9nZXRDb25zdGFudExpbmVHcmFwaGljQXR0cmlidXRlczogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB2YXIgcG9zaXRpb25Gcm9tID0gdGhpcy5fb3J0aG9nb25hbFBvc2l0aW9ucy5zdGFydDtcclxuICAgICAgICB2YXIgcG9zaXRpb25UbyA9IHRoaXMuX29ydGhvZ29uYWxQb3NpdGlvbnMuZW5kO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBvaW50czogdGhpcy5faXNIb3Jpem9udGFsID8gW3ZhbHVlLCBwb3NpdGlvbkZyb20sIHZhbHVlLCBwb3NpdGlvblRvXSA6IFtwb3NpdGlvbkZyb20sIHZhbHVlLCBwb3NpdGlvblRvLCB2YWx1ZV1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2NyZWF0ZUNvbnN0YW50TGluZTogZnVuY3Rpb24odmFsdWUsIGF0dHIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlUGF0aEVsZW1lbnQodGhpcy5fZ2V0Q29uc3RhbnRMaW5lR3JhcGhpY0F0dHJpYnV0ZXModmFsdWUpLnBvaW50cywgYXR0ciwgZ2V0Q29uc3RhbnRMaW5lU2hhcnBEaXJlY3Rpb24odmFsdWUsIHRoaXMuX2dldENhbnZhc1N0YXJ0RW5kKCkpKVxyXG4gICAgfSxcclxuICAgIF9kcmF3Q29uc3RhbnRMaW5lTGFiZWxUZXh0OiBmdW5jdGlvbih0ZXh0LCB4LCB5LCBfcmVmMiwgZ3JvdXApIHtcclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICBmb250OiBmb250LFxyXG4gICAgICAgICAgICBjc3NDbGFzczogY3NzQ2xhc3NcclxuICAgICAgICB9ID0gX3JlZjI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLnRleHQodGV4dCwgeCwgeSkuY3NzKHBhdGNoRm9udE9wdGlvbnMoZXh0ZW5kKHt9LCB0aGlzLl9vcHRpb25zLmxhYmVsLmZvbnQsIGZvbnQpKSkuYXR0cih7XHJcbiAgICAgICAgICAgIGFsaWduOiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICBjbGFzczogY3NzQ2xhc3NcclxuICAgICAgICB9KS5hcHBlbmQoZ3JvdXApXHJcbiAgICB9LFxyXG4gICAgX2RyYXdDb25zdGFudExpbmVMYWJlbHM6IGZ1bmN0aW9uKHBhcnNlZFZhbHVlLCBsaW5lTGFiZWxPcHRpb25zLCB2YWx1ZSwgZ3JvdXApIHtcclxuICAgICAgICB2YXIgX3RleHQ7XHJcbiAgICAgICAgdmFyIHRleHQgPSBsaW5lTGFiZWxPcHRpb25zLnRleHQ7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xyXG4gICAgICAgIHZhciBsYWJlbE9wdGlvbnMgPSBvcHRpb25zLmxhYmVsO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrQWxpZ25tZW50Q29uc3RhbnRMaW5lTGFiZWxzKGxpbmVMYWJlbE9wdGlvbnMpO1xyXG4gICAgICAgIHRleHQgPSBudWxsICE9PSAoX3RleHQgPSB0ZXh0KSAmJiB2b2lkIDAgIT09IF90ZXh0ID8gX3RleHQgOiB0aGlzLmZvcm1hdExhYmVsKHBhcnNlZFZhbHVlLCBsYWJlbE9wdGlvbnMpO1xyXG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9nZXRDb25zdGFudExpbmVMYWJlbHNDb29yZHModmFsdWUsIGxpbmVMYWJlbE9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kcmF3Q29uc3RhbnRMaW5lTGFiZWxUZXh0KHRleHQsIGNvb3Jkcy54LCBjb29yZHMueSwgbGluZUxhYmVsT3B0aW9ucywgZ3JvdXApXHJcbiAgICB9LFxyXG4gICAgX2dldFN0cmlwUG9zOiBmdW5jdGlvbihzdGFydFZhbHVlLCBlbmRWYWx1ZSwgY2FudmFzU3RhcnQsIGNhbnZhc0VuZCwgcmFuZ2UpIHtcclxuICAgICAgICB2YXIgaXNDb250aW51b3VzID0gISEocmFuZ2UubWluVmlzaWJsZSB8fCByYW5nZS5tYXhWaXNpYmxlKTtcclxuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IChyYW5nZS5jYXRlZ29yaWVzIHx8IFtdKS5yZWR1Y2UoKGZ1bmN0aW9uKHJlc3VsdCwgY2F0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNhdC52YWx1ZU9mKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICAgICAgfSksIFtdKTtcclxuICAgICAgICB2YXIgc3RhcnQ7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICB2YXIgc3dhcDtcclxuICAgICAgICB2YXIgc3RhcnRDYXRlZ29yeUluZGV4O1xyXG4gICAgICAgIHZhciBlbmRDYXRlZ29yeUluZGV4O1xyXG4gICAgICAgIGlmICghaXNDb250aW51b3VzKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQoc3RhcnRWYWx1ZSkgJiYgaXNEZWZpbmVkKGVuZFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZFN0YXJ0VmFsdWUgPSB0aGlzLnBhcnNlcihzdGFydFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJzZWRFbmRWYWx1ZSA9IHRoaXMucGFyc2VyKGVuZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0Q2F0ZWdvcnlJbmRleCA9IGluQXJyYXkoaXNEZWZpbmVkKHBhcnNlZFN0YXJ0VmFsdWUpID8gcGFyc2VkU3RhcnRWYWx1ZS52YWx1ZU9mKCkgOiB2b2lkIDAsIGNhdGVnb3JpZXMpO1xyXG4gICAgICAgICAgICAgICAgZW5kQ2F0ZWdvcnlJbmRleCA9IGluQXJyYXkoaXNEZWZpbmVkKHBhcnNlZEVuZFZhbHVlKSA/IHBhcnNlZEVuZFZhbHVlLnZhbHVlT2YoKSA6IHZvaWQgMCwgY2F0ZWdvcmllcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoLTEgPT09IHN0YXJ0Q2F0ZWdvcnlJbmRleCB8fCAtMSA9PT0gZW5kQ2F0ZWdvcnlJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRPZkNhbnZhczogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydENhdGVnb3J5SW5kZXggPiBlbmRDYXRlZ29yeUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dhcCA9IGVuZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZFZhbHVlID0gc3RhcnRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlID0gc3dhcFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZmluZWQoc3RhcnRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgc3RhcnRWYWx1ZSA9IHRoaXMudmFsaWRhdGVVbml0KHN0YXJ0VmFsdWUsIFwiRTIxMDVcIiwgXCJzdHJpcFwiKTtcclxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9nZXRUcmFuc2xhdGVkQ29vcmQoc3RhcnRWYWx1ZSwgLTEpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBjYW52YXNTdGFydFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEZWZpbmVkKGVuZFZhbHVlKSkge1xyXG4gICAgICAgICAgICBlbmRWYWx1ZSA9IHRoaXMudmFsaWRhdGVVbml0KGVuZFZhbHVlLCBcIkUyMTA1XCIsIFwic3RyaXBcIik7XHJcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuX2dldFRyYW5zbGF0ZWRDb29yZChlbmRWYWx1ZSwgMSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbmQgPSBjYW52YXNFbmRcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0cmlwUG9zaXRpb24gPSBzdGFydCA8IGVuZCA/IHtcclxuICAgICAgICAgICAgZnJvbTogc3RhcnQsXHJcbiAgICAgICAgICAgIHRvOiBlbmRcclxuICAgICAgICB9IDoge1xyXG4gICAgICAgICAgICBmcm9tOiBlbmQsXHJcbiAgICAgICAgICAgIHRvOiBzdGFydFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHZpc2libGVBcmVhID0gdGhpcy5nZXRWaXNpYmxlQXJlYSgpO1xyXG4gICAgICAgIGlmIChzdHJpcFBvc2l0aW9uLmZyb20gPD0gdmlzaWJsZUFyZWFbMF0gJiYgc3RyaXBQb3NpdGlvbi50byA8PSB2aXNpYmxlQXJlYVswXSB8fCBzdHJpcFBvc2l0aW9uLmZyb20gPj0gdmlzaWJsZUFyZWFbMV0gJiYgc3RyaXBQb3NpdGlvbi50byA+PSB2aXNpYmxlQXJlYVsxXSkge1xyXG4gICAgICAgICAgICBzdHJpcFBvc2l0aW9uLm91dE9mQ2FudmFzID0gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyaXBQb3NpdGlvblxyXG4gICAgfSxcclxuICAgIF9nZXRTdHJpcEdyYXBoaWNBdHRyaWJ1dGVzOiBmdW5jdGlvbihmcm9tUG9pbnQsIHRvUG9pbnQpIHtcclxuICAgICAgICB2YXIgeDtcclxuICAgICAgICB2YXIgeTtcclxuICAgICAgICB2YXIgd2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodDtcclxuICAgICAgICB2YXIgb3J0aG9nb25hbFBvc2l0aW9ucyA9IHRoaXMuX29ydGhvZ29uYWxQb3NpdGlvbnM7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uRnJvbSA9IG9ydGhvZ29uYWxQb3NpdGlvbnMuc3RhcnQ7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uVG8gPSBvcnRob2dvbmFsUG9zaXRpb25zLmVuZDtcclxuICAgICAgICBpZiAodGhpcy5faXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgIHggPSBmcm9tUG9pbnQ7XHJcbiAgICAgICAgICAgIHkgPSBfbWluKHBvc2l0aW9uRnJvbSwgcG9zaXRpb25Ubyk7XHJcbiAgICAgICAgICAgIHdpZHRoID0gdG9Qb2ludCAtIGZyb21Qb2ludDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gX2Ficyhwb3NpdGlvbkZyb20gLSBwb3NpdGlvblRvKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHggPSBfbWluKHBvc2l0aW9uRnJvbSwgcG9zaXRpb25Ubyk7XHJcbiAgICAgICAgICAgIHkgPSBmcm9tUG9pbnQ7XHJcbiAgICAgICAgICAgIHdpZHRoID0gX2Ficyhwb3NpdGlvbkZyb20gLSBwb3NpdGlvblRvKTtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gX2Ficyhmcm9tUG9pbnQgLSB0b1BvaW50KVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICB5OiB5LFxyXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9jcmVhdGVTdHJpcDogZnVuY3Rpb24oYXR0cnMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIucmVjdChhdHRycy54LCBhdHRycy55LCBhdHRycy53aWR0aCwgYXR0cnMuaGVpZ2h0KVxyXG4gICAgfSxcclxuICAgIF9hZGp1c3RTdHJpcExhYmVsczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX3N0cmlwcy5mb3JFYWNoKChmdW5jdGlvbihzdHJpcCkge1xyXG4gICAgICAgICAgICBpZiAoc3RyaXAubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHN0cmlwLmxhYmVsLmF0dHIodGhhdC5fZ2V0QWRqdXN0ZWRTdHJpcExhYmVsQ29vcmRzKHN0cmlwKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSxcclxuICAgIF9hZGp1c3RMYWJlbHNDb29yZChvZmZzZXQsIG1heFdpZHRoLCBjaGVja0NhbnZhcykge1xyXG4gICAgICAgIHZhciBnZXRDb250YWluZXJBdHRycyA9IHRpY2sgPT4gdGhpcy5fZ2V0TGFiZWxBZGp1c3RlZENvb3JkKHRpY2ssIG9mZnNldCArICh0aWNrLmxhYmVsT2Zmc2V0IHx8IDApLCBtYXhXaWR0aCwgY2hlY2tDYW52YXMpO1xyXG4gICAgICAgIHRoaXMuX21ham9yVGlja3MuZm9yRWFjaCgoZnVuY3Rpb24odGljaykge1xyXG4gICAgICAgICAgICBpZiAodGljay5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgdGljay51cGRhdGVNdWx0aWxpbmVUZXh0QWxpZ25tZW50KCk7XHJcbiAgICAgICAgICAgICAgICB0aWNrLmxhYmVsLmF0dHIoZ2V0Q29udGFpbmVyQXR0cnModGljaykpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aWNrLnRlbXBsYXRlQ29udGFpbmVyICYmIHRpY2sudGVtcGxhdGVDb250YWluZXIuYXR0cihnZXRDb250YWluZXJBdHRycyh0aWNrKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSxcclxuICAgIF9hZGp1c3RMYWJlbHM6IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uc0FyZUNvbnNpc3RlbnQgPSBvcHRpb25zLnBvc2l0aW9uID09PSBvcHRpb25zLmxhYmVsLnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBtYXhTaXplID0gdGhpcy5fbWFqb3JUaWNrcy5yZWR1Y2UoKGZ1bmN0aW9uKHNpemUsIHRpY2spIHtcclxuICAgICAgICAgICAgaWYgKCF0aWNrLmdldENvbnRlbnRDb250YWluZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYkJveCA9IHRpY2subGFiZWxSb3RhdGlvbkFuZ2xlID8gcm90YXRlQkJveCh0aWNrLmxhYmVsQkJveCwgW3RpY2subGFiZWxDb29yZHMueCwgdGljay5sYWJlbENvb3Jkcy55XSwgLXRpY2subGFiZWxSb3RhdGlvbkFuZ2xlKSA6IHRpY2subGFiZWxCQm94O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IF9tYXgoc2l6ZS53aWR0aCB8fCAwLCBiQm94LndpZHRoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogX21heChzaXplLmhlaWdodCB8fCAwLCBiQm94LmhlaWdodCksXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IF9tYXgoc2l6ZS5vZmZzZXQgfHwgMCwgdGljay5sYWJlbE9mZnNldCB8fCAwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIHt9KTtcclxuICAgICAgICB2YXIgYWRkaXRpb25hbE9mZnNldCA9IHBvc2l0aW9uc0FyZUNvbnNpc3RlbnQgPyB0aGlzLl9pc0hvcml6b250YWwgPyBtYXhTaXplLmhlaWdodCA6IG1heFNpemUud2lkdGggOiAwO1xyXG4gICAgICAgIHRoaXMuX2FkanVzdExhYmVsc0Nvb3JkKG9mZnNldCwgbWF4U2l6ZS53aWR0aCk7XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIGFkZGl0aW9uYWxPZmZzZXQgKyAoYWRkaXRpb25hbE9mZnNldCAmJiB0aGlzLl9vcHRpb25zLmxhYmVsLmluZGVudEZyb21BeGlzKSArIChwb3NpdGlvbnNBcmVDb25zaXN0ZW50ID8gbWF4U2l6ZS5vZmZzZXQgOiAwKVxyXG4gICAgfSxcclxuICAgIF9nZXRMYWJlbEFkanVzdGVkQ29vcmQ6IGZ1bmN0aW9uKHRpY2ssIG9mZnNldCwgbWF4V2lkdGgpIHtcclxuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnM7XHJcbiAgICAgICAgdmFyIHRlbXBsYXRlQm94ID0gdGljay50ZW1wbGF0ZUNvbnRhaW5lciAmJiB0aWNrLnRlbXBsYXRlQ29udGFpbmVyLmdldEJCb3goKTtcclxuICAgICAgICB2YXIgYm94ID0gdGVtcGxhdGVCb3ggfHwgcm90YXRlQkJveCh0aWNrLmxhYmVsQkJveCwgW3RpY2subGFiZWxDb29yZHMueCwgdGljay5sYWJlbENvb3Jkcy55XSwgLXRpY2subGFiZWxSb3RhdGlvbkFuZ2xlIHx8IDApO1xyXG4gICAgICAgIHZhciB0ZXh0QWxpZ24gPSB0aWNrLmxhYmVsQWxpZ25tZW50IHx8IG9wdGlvbnMubGFiZWwuYWxpZ25tZW50O1xyXG4gICAgICAgIHZhciBpc0Rpc2NyZXRlID0gXCJkaXNjcmV0ZVwiID09PSB0aGlzLl9vcHRpb25zLnR5cGU7XHJcbiAgICAgICAgdmFyIGlzRmxhdExhYmVsID0gdGljay5sYWJlbFJvdGF0aW9uQW5nbGUgJSA5MCA9PT0gMDtcclxuICAgICAgICB2YXIgaW5kZW50RnJvbUF4aXMgPSBvcHRpb25zLmxhYmVsLmluZGVudEZyb21BeGlzO1xyXG4gICAgICAgIHZhciBsYWJlbFBvc2l0aW9uID0gb3B0aW9ucy5sYWJlbC5wb3NpdGlvbjtcclxuICAgICAgICB2YXIgYXhpc1Bvc2l0aW9uID0gdGhpcy5fYXhpc1Bvc2l0aW9uO1xyXG4gICAgICAgIHZhciBsYWJlbENvb3JkcyA9IHRpY2subGFiZWxDb29yZHM7XHJcbiAgICAgICAgdmFyIGxhYmVsWCA9IGxhYmVsQ29vcmRzLng7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVg7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICBpZiAobGFiZWxQb3NpdGlvbiA9PT0gQk9UVE9NKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVZID0gYXhpc1Bvc2l0aW9uICsgaW5kZW50RnJvbUF4aXMgLSBib3gueSArIG9mZnNldFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWSA9IGF4aXNQb3NpdGlvbiAtIGluZGVudEZyb21BeGlzIC0gKGJveC55ICsgYm94LmhlaWdodCkgLSBvZmZzZXRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGV4dEFsaWduID09PSBSSUdIVCkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWCA9IGlzRGlzY3JldGUgJiYgaXNGbGF0TGFiZWwgPyB0aWNrLmNvb3Jkcy54IC0gKGJveC54ICsgYm94LndpZHRoKSA6IGxhYmVsWCAtIGJveC54IC0gYm94LndpZHRoXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSBMRUZUKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYID0gaXNEaXNjcmV0ZSAmJiBpc0ZsYXRMYWJlbCA/IGxhYmVsWCAtIGJveC54IC0gKHRpY2suY29vcmRzLnggLSBsYWJlbFgpIDogbGFiZWxYIC0gYm94LnhcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSBsYWJlbFggLSBib3gueCAtIGJveC53aWR0aCAvIDJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZVkgPSBsYWJlbENvb3Jkcy55IC0gYm94LnkgLSBib3guaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT09IExFRlQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0QWxpZ24gPT09IExFRlQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYID0gYXhpc1Bvc2l0aW9uIC0gaW5kZW50RnJvbUF4aXMgLSBtYXhXaWR0aCAtIGJveC54XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gQ0VOVEVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWCA9IGF4aXNQb3NpdGlvbiAtIGluZGVudEZyb21BeGlzIC0gbWF4V2lkdGggLyAyIC0gYm94LnggLSBib3gud2lkdGggLyAyXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSBheGlzUG9zaXRpb24gLSBpbmRlbnRGcm9tQXhpcyAtIGJveC54IC0gYm94LndpZHRoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYIC09IG9mZnNldFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gUklHSFQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYID0gYXhpc1Bvc2l0aW9uICsgaW5kZW50RnJvbUF4aXMgKyBtYXhXaWR0aCAtIGJveC54IC0gYm94LndpZHRoXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gQ0VOVEVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWCA9IGF4aXNQb3NpdGlvbiArIGluZGVudEZyb21BeGlzICsgbWF4V2lkdGggLyAyIC0gYm94LnggLSBib3gud2lkdGggLyAyXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSBheGlzUG9zaXRpb24gKyBpbmRlbnRGcm9tQXhpcyAtIGJveC54XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVYICs9IG9mZnNldFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6IHRyYW5zbGF0ZVgsXHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IHRyYW5zbGF0ZVlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2NyZWF0ZUF4aXNDb25zdGFudExpbmVHcm91cHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xyXG4gICAgICAgIHZhciBjbGFzc1NlbGVjdG9yID0gdGhpcy5fYXhpc0Nzc1ByZWZpeDtcclxuICAgICAgICB2YXIgY29uc3RhbnRMaW5lc0NsYXNzID0gY2xhc3NTZWxlY3RvciArIFwiY29uc3RhbnQtbGluZXNcIjtcclxuICAgICAgICB2YXIgaW5zaWRlR3JvdXAgPSByZW5kZXJlci5nKCkuYXR0cih7XHJcbiAgICAgICAgICAgIGNsYXNzOiBjb25zdGFudExpbmVzQ2xhc3NcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgb3V0c2lkZUdyb3VwMSA9IHJlbmRlcmVyLmcoKS5hdHRyKHtcclxuICAgICAgICAgICAgY2xhc3M6IGNvbnN0YW50TGluZXNDbGFzc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBvdXRzaWRlR3JvdXAyID0gcmVuZGVyZXIuZygpLmF0dHIoe1xyXG4gICAgICAgICAgICBjbGFzczogY29uc3RhbnRMaW5lc0NsYXNzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaW5zaWRlOiBpbnNpZGVHcm91cCxcclxuICAgICAgICAgICAgb3V0c2lkZTE6IG91dHNpZGVHcm91cDEsXHJcbiAgICAgICAgICAgIGxlZnQ6IG91dHNpZGVHcm91cDEsXHJcbiAgICAgICAgICAgIHRvcDogb3V0c2lkZUdyb3VwMSxcclxuICAgICAgICAgICAgb3V0c2lkZTI6IG91dHNpZGVHcm91cDIsXHJcbiAgICAgICAgICAgIHJpZ2h0OiBvdXRzaWRlR3JvdXAyLFxyXG4gICAgICAgICAgICBib3R0b206IG91dHNpZGVHcm91cDIsXHJcbiAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc2lkZS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3V0c2lkZTEucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHNpZGUyLnJlbW92ZSgpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zaWRlLmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHNpZGUxLmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHNpZGUyLmNsZWFyKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfY3JlYXRlQXhpc0dyb3VwczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XHJcbiAgICAgICAgdmFyIGNsYXNzU2VsZWN0b3IgPSB0aGlzLl9heGlzQ3NzUHJlZml4O1xyXG4gICAgICAgIHRoaXMuX2F4aXNHcm91cCA9IHJlbmRlcmVyLmcoKS5hdHRyKHtcclxuICAgICAgICAgICAgY2xhc3M6IGNsYXNzU2VsZWN0b3IgKyBcImF4aXNcIlxyXG4gICAgICAgIH0pLmVuYWJsZUxpbmtzKCk7XHJcbiAgICAgICAgdGhpcy5fYXhpc1N0cmlwR3JvdXAgPSByZW5kZXJlci5nKCkuYXR0cih7XHJcbiAgICAgICAgICAgIGNsYXNzOiBjbGFzc1NlbGVjdG9yICsgXCJzdHJpcHNcIlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2F4aXNHcmlkR3JvdXAgPSByZW5kZXJlci5nKCkuYXR0cih7XHJcbiAgICAgICAgICAgIGNsYXNzOiBjbGFzc1NlbGVjdG9yICsgXCJncmlkXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9heGlzRWxlbWVudHNHcm91cCA9IHJlbmRlcmVyLmcoKS5hdHRyKHtcclxuICAgICAgICAgICAgY2xhc3M6IGNsYXNzU2VsZWN0b3IgKyBcImVsZW1lbnRzXCJcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9heGlzTGluZUdyb3VwID0gcmVuZGVyZXIuZygpLmF0dHIoe1xyXG4gICAgICAgICAgICBjbGFzczogY2xhc3NTZWxlY3RvciArIFwibGluZVwiXHJcbiAgICAgICAgfSkubGlua09uKHRoaXMuX2F4aXNHcm91cCwgXCJheGlzTGluZVwiKS5saW5rQXBwZW5kKCk7XHJcbiAgICAgICAgdGhpcy5fYXhpc1RpdGxlR3JvdXAgPSByZW5kZXJlci5nKCkuYXR0cih7XHJcbiAgICAgICAgICAgIGNsYXNzOiBjbGFzc1NlbGVjdG9yICsgXCJ0aXRsZVwiXHJcbiAgICAgICAgfSkuYXBwZW5kKHRoaXMuX2F4aXNHcm91cCk7XHJcbiAgICAgICAgdGhpcy5fYXhpc0NvbnN0YW50TGluZUdyb3VwcyA9IHtcclxuICAgICAgICAgICAgYWJvdmU6IHRoaXMuX2NyZWF0ZUF4aXNDb25zdGFudExpbmVHcm91cHMoKSxcclxuICAgICAgICAgICAgdW5kZXI6IHRoaXMuX2NyZWF0ZUF4aXNDb25zdGFudExpbmVHcm91cHMoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fYXhpc1N0cmlwTGFiZWxHcm91cCA9IHJlbmRlcmVyLmcoKS5hdHRyKHtcclxuICAgICAgICAgICAgY2xhc3M6IGNsYXNzU2VsZWN0b3IgKyBcImF4aXMtbGFiZWxzXCJcclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuICAgIF9jbGVhckF4aXNHcm91cHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2F4aXNHcm91cC5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLl9heGlzU3RyaXBHcm91cC5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLl9heGlzU3RyaXBMYWJlbEdyb3VwLnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMuX2F4aXNDb25zdGFudExpbmVHcm91cHMuYWJvdmUucmVtb3ZlKCk7XHJcbiAgICAgICAgdGhpcy5fYXhpc0NvbnN0YW50TGluZUdyb3Vwcy51bmRlci5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLl9heGlzR3JpZEdyb3VwLnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMuX2F4aXNUaXRsZUdyb3VwLmNsZWFyKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmxhYmVsLnRlbXBsYXRlIHx8ICF0aGlzLmlzUmVuZGVyZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9heGlzRWxlbWVudHNHcm91cC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5fYXhpc0VsZW1lbnRzR3JvdXAuY2xlYXIoKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9heGlzTGluZUdyb3VwICYmIHRoaXMuX2F4aXNMaW5lR3JvdXAuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLl9heGlzU3RyaXBHcm91cCAmJiB0aGlzLl9heGlzU3RyaXBHcm91cC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX2F4aXNHcmlkR3JvdXAgJiYgdGhpcy5fYXhpc0dyaWRHcm91cC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX2F4aXNDb25zdGFudExpbmVHcm91cHMuYWJvdmUuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLl9heGlzQ29uc3RhbnRMaW5lR3JvdXBzLnVuZGVyLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5fYXhpc1N0cmlwTGFiZWxHcm91cCAmJiB0aGlzLl9heGlzU3RyaXBMYWJlbEdyb3VwLmNsZWFyKClcclxuICAgIH0sXHJcbiAgICBfZ2V0TGFiZWxGb3JtYXRPYmplY3Q6IGZ1bmN0aW9uKHZhbHVlLCBsYWJlbE9wdGlvbnMsIHJhbmdlLCBwb2ludCwgdGlja0ludGVydmFsLCB0aWNrcykge1xyXG4gICAgICAgIHJhbmdlID0gcmFuZ2UgfHwgdGhpcy5fZ2V0Vmlld3BvcnRSYW5nZSgpO1xyXG4gICAgICAgIHZhciBmb3JtYXRPYmplY3QgPSB7XHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgdmFsdWVUZXh0OiBfZm9ybWF0KHZhbHVlLCB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbE9wdGlvbnM6IGxhYmVsT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHRpY2tzOiB0aWNrcyB8fCBjb252ZXJ0VGlja3NUb1ZhbHVlcyh0aGlzLl9tYWpvclRpY2tzKSxcclxuICAgICAgICAgICAgICAgIHRpY2tJbnRlcnZhbDogbnVsbCAhPT0gdGlja0ludGVydmFsICYmIHZvaWQgMCAhPT0gdGlja0ludGVydmFsID8gdGlja0ludGVydmFsIDogdGhpcy5fdGlja0ludGVydmFsLFxyXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IHRoaXMuX29wdGlvbnMuZGF0YVR5cGUsXHJcbiAgICAgICAgICAgICAgICBsb2dhcml0aG1CYXNlOiB0aGlzLl9vcHRpb25zLmxvZ2FyaXRobUJhc2UsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLl9vcHRpb25zLnR5cGUsXHJcbiAgICAgICAgICAgICAgICBzaG93VHJhbnNpdGlvbjogIXRoaXMuX29wdGlvbnMubWFya2VyLnZpc2libGUsXHJcbiAgICAgICAgICAgICAgICBwb2ludDogcG9pbnRcclxuICAgICAgICAgICAgfSkgfHwgXCJcIixcclxuICAgICAgICAgICAgbWluOiByYW5nZS5taW5WaXNpYmxlLFxyXG4gICAgICAgICAgICBtYXg6IHJhbmdlLm1heFZpc2libGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChwb2ludCkge1xyXG4gICAgICAgICAgICBmb3JtYXRPYmplY3QucG9pbnQgPSBwb2ludFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9ybWF0T2JqZWN0XHJcbiAgICB9LFxyXG4gICAgZm9ybWF0TGFiZWw6IGZ1bmN0aW9uKHZhbHVlLCBsYWJlbE9wdGlvbnMsIHJhbmdlLCBwb2ludCwgdGlja0ludGVydmFsLCB0aWNrcykge1xyXG4gICAgICAgIHZhciBmb3JtYXRPYmplY3QgPSB0aGlzLl9nZXRMYWJlbEZvcm1hdE9iamVjdCh2YWx1ZSwgbGFiZWxPcHRpb25zLCByYW5nZSwgcG9pbnQsIHRpY2tJbnRlcnZhbCwgdGlja3MpO1xyXG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGxhYmVsT3B0aW9ucy5jdXN0b21pemVUZXh0KSA/IGxhYmVsT3B0aW9ucy5jdXN0b21pemVUZXh0LmNhbGwoZm9ybWF0T2JqZWN0LCBmb3JtYXRPYmplY3QpIDogZm9ybWF0T2JqZWN0LnZhbHVlVGV4dFxyXG4gICAgfSxcclxuICAgIGZvcm1hdEhpbnQ6IGZ1bmN0aW9uKHZhbHVlLCBsYWJlbE9wdGlvbnMsIHJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGZvcm1hdE9iamVjdCA9IHRoaXMuX2dldExhYmVsRm9ybWF0T2JqZWN0KHZhbHVlLCBsYWJlbE9wdGlvbnMsIHJhbmdlKTtcclxuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihsYWJlbE9wdGlvbnMuY3VzdG9taXplSGludCkgPyBsYWJlbE9wdGlvbnMuY3VzdG9taXplSGludC5jYWxsKGZvcm1hdE9iamVjdCwgZm9ybWF0T2JqZWN0KSA6IHZvaWQgMFxyXG4gICAgfSxcclxuICAgIGZvcm1hdFJhbmdlKHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBpbnRlcnZhbCwgYXJndW1lbnRGb3JtYXQpIHtcclxuICAgICAgICByZXR1cm4gZm9ybWF0UmFuZ2Uoe1xyXG4gICAgICAgICAgICBzdGFydFZhbHVlOiBzdGFydFZhbHVlLFxyXG4gICAgICAgICAgICBlbmRWYWx1ZTogZW5kVmFsdWUsXHJcbiAgICAgICAgICAgIHRpY2tJbnRlcnZhbDogaW50ZXJ2YWwsXHJcbiAgICAgICAgICAgIGFyZ3VtZW50Rm9ybWF0OiBhcmd1bWVudEZvcm1hdCxcclxuICAgICAgICAgICAgYXhpc09wdGlvbnM6IHRoaXMuZ2V0T3B0aW9ucygpXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBfc2V0VGlja09mZnNldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xyXG4gICAgICAgIHZhciBkaXNjcmV0ZUF4aXNEaXZpc2lvbk1vZGUgPSBvcHRpb25zLmRpc2NyZXRlQXhpc0RpdmlzaW9uTW9kZTtcclxuICAgICAgICB0aGlzLl90aWNrT2Zmc2V0ID0gKyhcImNyb3NzTGFiZWxzXCIgIT09IGRpc2NyZXRlQXhpc0RpdmlzaW9uTW9kZSB8fCAhZGlzY3JldGVBeGlzRGl2aXNpb25Nb2RlKVxyXG4gICAgfSxcclxuICAgIGFnZ3JlZ2F0ZWRQb2ludEJldHdlZW5UaWNrcygpIHtcclxuICAgICAgICByZXR1cm4gXCJjcm9zc1RpY2tzXCIgPT09IHRoaXMuX29wdGlvbnMuYWdncmVnYXRlZFBvaW50c1Bvc2l0aW9uXHJcbiAgICB9LFxyXG4gICAgcmVzZXRBcHBseWluZ0FuaW1hdGlvbjogZnVuY3Rpb24oaXNGaXJzdERyYXdpbmcpIHtcclxuICAgICAgICB0aGlzLl9yZXNldEFwcGx5aW5nQW5pbWF0aW9uID0gdHJ1ZTtcclxuICAgICAgICBpZiAoaXNGaXJzdERyYXdpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlyc3REcmF3aW5nID0gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBpc0ZpcnN0RHJhd2luZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3REcmF3aW5nXHJcbiAgICB9LFxyXG4gICAgZ2V0TWFyZ2luczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcclxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXHJcbiAgICAgICAgICAgIGN1c3RvbVBvc2l0aW9uOiBjdXN0b21Qb3NpdGlvbixcclxuICAgICAgICAgICAgcGxhY2Vob2xkZXJTaXplOiBwbGFjZWhvbGRlclNpemUsXHJcbiAgICAgICAgICAgIGdyaWQ6IGdyaWQsXHJcbiAgICAgICAgICAgIHRpY2s6IHRpY2ssXHJcbiAgICAgICAgICAgIGNyb3NzaGFpck1hcmdpbjogY3Jvc3NoYWlyTWFyZ2luXHJcbiAgICAgICAgfSA9IHRoYXQuX29wdGlvbnM7XHJcbiAgICAgICAgdmFyIGlzRGVmaW5lZEN1c3RvbVBvc2l0aW9uT3B0aW9uID0gaXNEZWZpbmVkKGN1c3RvbVBvc2l0aW9uKTtcclxuICAgICAgICB2YXIgYm91bmRhcnlQb3NpdGlvbiA9IHRoYXQuZ2V0UmVzb2x2ZWRCb3VuZGFyeVBvc2l0aW9uKCk7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoYXQuZ2V0Q2FudmFzKCk7XHJcbiAgICAgICAgdmFyIGNMZWZ0ID0gY2FudmFzLmxlZnQ7XHJcbiAgICAgICAgdmFyIGNUb3AgPSBjYW52YXMudG9wO1xyXG4gICAgICAgIHZhciBjUmlnaHQgPSBjYW52YXMud2lkdGggLSBjYW52YXMucmlnaHQ7XHJcbiAgICAgICAgdmFyIGNCb3R0b20gPSBjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmJvdHRvbTtcclxuICAgICAgICB2YXIgZWRnZU1hcmdpbkNvcnJlY3Rpb24gPSBfbWF4KGdyaWQudmlzaWJsZSAmJiBncmlkLndpZHRoIHx8IDAsIHRpY2sudmlzaWJsZSAmJiB0aWNrLndpZHRoIHx8IDApO1xyXG4gICAgICAgIHZhciBjb25zdGFudExpbmVBYm92ZVNlcmllcyA9IHRoYXQuX2F4aXNDb25zdGFudExpbmVHcm91cHMuYWJvdmU7XHJcbiAgICAgICAgdmFyIGNvbnN0YW50TGluZVVuZGVyU2VyaWVzID0gdGhhdC5fYXhpc0NvbnN0YW50TGluZUdyb3Vwcy51bmRlcjtcclxuICAgICAgICB2YXIgYm94ZXMgPSBbdGhhdC5fYXhpc0VsZW1lbnRzR3JvdXAsIGNvbnN0YW50TGluZUFib3ZlU2VyaWVzLm91dHNpZGUxLCBjb25zdGFudExpbmVBYm92ZVNlcmllcy5vdXRzaWRlMiwgY29uc3RhbnRMaW5lVW5kZXJTZXJpZXMub3V0c2lkZTEsIGNvbnN0YW50TGluZVVuZGVyU2VyaWVzLm91dHNpZGUyLCB0aGF0Ll9heGlzTGluZUdyb3VwXS5tYXAoZ3JvdXAgPT4gZ3JvdXAgJiYgZ3JvdXAuZ2V0QkJveCgpKS5jb25jYXQoZnVuY3Rpb24oZ3JvdXApIHtcclxuICAgICAgICAgICAgdmFyIGJveCA9IGdyb3VwICYmIGdyb3VwLmdldEJCb3goKTtcclxuICAgICAgICAgICAgaWYgKCFib3ggfHwgYm94LmlzRW1wdHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBib3hcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhhdC5faXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICBib3gueCA9IGNMZWZ0O1xyXG4gICAgICAgICAgICAgICAgYm94LndpZHRoID0gY1JpZ2h0IC0gY0xlZnRcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJveC55ID0gY1RvcDtcclxuICAgICAgICAgICAgICAgIGJveC5oZWlnaHQgPSBjQm90dG9tIC0gY1RvcFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBib3hcclxuICAgICAgICB9KHRoYXQuX2F4aXNUaXRsZUdyb3VwKSk7XHJcbiAgICAgICAgdmFyIG1hcmdpbnMgPSBjYWxjdWxhdGVDYW52YXNNYXJnaW5zKGJveGVzLCBjYW52YXMpO1xyXG4gICAgICAgIG1hcmdpbnNbcG9zaXRpb25dICs9IGNyb3NzaGFpck1hcmdpbjtcclxuICAgICAgICBpZiAodGhhdC5oYXNOb25Cb3VuZGFyeVBvc2l0aW9uKCkgJiYgaXNEZWZpbmVkQ3VzdG9tUG9zaXRpb25PcHRpb24pIHtcclxuICAgICAgICAgICAgbWFyZ2luc1tib3VuZGFyeVBvc2l0aW9uXSA9IDBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyU2l6ZSkge1xyXG4gICAgICAgICAgICBtYXJnaW5zW3Bvc2l0aW9uXSA9IHBsYWNlaG9sZGVyU2l6ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWRnZU1hcmdpbkNvcnJlY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoYXQuX2lzSG9yaXpvbnRhbCAmJiBjYW52YXMucmlnaHQgPCBlZGdlTWFyZ2luQ29ycmVjdGlvbiAmJiBtYXJnaW5zLnJpZ2h0IDwgZWRnZU1hcmdpbkNvcnJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIG1hcmdpbnMucmlnaHQgPSBlZGdlTWFyZ2luQ29ycmVjdGlvblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhhdC5faXNIb3Jpem9udGFsICYmIGNhbnZhcy5ib3R0b20gPCBlZGdlTWFyZ2luQ29ycmVjdGlvbiAmJiBtYXJnaW5zLmJvdHRvbSA8IGVkZ2VNYXJnaW5Db3JyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJnaW5zLmJvdHRvbSA9IGVkZ2VNYXJnaW5Db3JyZWN0aW9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0RlZmluZWRDdXN0b21Qb3NpdGlvbk9wdGlvbiAmJiBpc0RlZmluZWQob2Zmc2V0KSkge1xyXG4gICAgICAgICAgICB2YXIgbW92ZUJ5T2Zmc2V0ID0gdGhhdC5jdXN0b21Qb3NpdGlvbklzQm91bmRhcnkoKSAmJiAob2Zmc2V0ID4gMCAmJiAoYm91bmRhcnlQb3NpdGlvbiA9PT0gTEVGVCB8fCBib3VuZGFyeVBvc2l0aW9uID09PSBUT1ApIHx8IG9mZnNldCA8IDAgJiYgKGJvdW5kYXJ5UG9zaXRpb24gPT09IFJJR0hUIHx8IGJvdW5kYXJ5UG9zaXRpb24gPT09IEJPVFRPTSkpO1xyXG4gICAgICAgICAgICBtYXJnaW5zW2JvdW5kYXJ5UG9zaXRpb25dIC09IG1vdmVCeU9mZnNldCA/IG9mZnNldCA6IDBcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hcmdpbnNcclxuICAgIH0sXHJcbiAgICB2YWxpZGF0ZVVuaXQ6IGZ1bmN0aW9uKHVuaXQsIGlkRXJyb3IsIHBhcmFtZXRlcnMpIHtcclxuICAgICAgICB1bml0ID0gdGhpcy5wYXJzZXIodW5pdCk7XHJcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gdW5pdCAmJiBpZEVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luY2lkZW50T2NjdXJyZWQoaWRFcnJvciwgW3BhcmFtZXRlcnNdKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5pdFxyXG4gICAgfSxcclxuICAgIF9zZXRUeXBlOiBmdW5jdGlvbihheGlzVHlwZSwgZHJhd2luZ1R5cGUpIHtcclxuICAgICAgICB2YXIgYXhpc1R5cGVNZXRob2RzO1xyXG4gICAgICAgIHN3aXRjaCAoYXhpc1R5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInh5QXhlc1wiOlxyXG4gICAgICAgICAgICAgICAgYXhpc1R5cGVNZXRob2RzID0geHlNZXRob2RzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwb2xhckF4ZXNcIjpcclxuICAgICAgICAgICAgICAgIGF4aXNUeXBlTWV0aG9kcyA9IHBvbGFyTWV0aG9kc1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHRlbmQodGhpcywgYXhpc1R5cGVNZXRob2RzW2RyYXdpbmdUeXBlXSlcclxuICAgIH0sXHJcbiAgICBfZ2V0U2hhcnBQYXJhbTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgIH0sXHJcbiAgICBfZGlzcG9zZUJyZWFrc0dyb3VwOiBfbm9vcCxcclxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFt0aGlzLl9heGlzRWxlbWVudHNHcm91cCwgdGhpcy5fYXhpc1N0cmlwR3JvdXAsIHRoaXMuX2F4aXNHcm91cF0uZm9yRWFjaCgoZnVuY3Rpb24oZykge1xyXG4gICAgICAgICAgICBnLmRpc3Bvc2UoKVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLl9zdHJpcHMgPSB0aGlzLl90aXRsZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYXhpc1N0cmlwR3JvdXAgPSB0aGlzLl9heGlzQ29uc3RhbnRMaW5lR3JvdXBzID0gdGhpcy5fYXhpc1N0cmlwTGFiZWxHcm91cCA9IHRoaXMuX2F4aXNCcmVha3NHcm91cCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYXhpc0xpbmVHcm91cCA9IHRoaXMuX2F4aXNFbGVtZW50c0dyb3VwID0gdGhpcy5fYXhpc0dyaWRHcm91cCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYXhpc0dyb3VwID0gdGhpcy5fYXhpc1RpdGxlR3JvdXAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2F4ZXNDb250YWluZXJHcm91cCA9IHRoaXMuX3N0cmlwc0dyb3VwID0gdGhpcy5fY29uc3RhbnRMaW5lc0dyb3VwID0gdGhpcy5fbGFiZWxzQXhlc0dyb3VwID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IHRoaXMuX29wdGlvbnMgPSB0aGlzLl90ZXh0T3B0aW9ucyA9IHRoaXMuX3RleHRGb250U3R5bGVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl90cmFuc2xhdG9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9tYWpvclRpY2tzID0gdGhpcy5fbWlub3JUaWNrcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZUJyZWFrc0dyb3VwKCk7XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVzUmVuZGVyZWQgJiYgdGhpcy5fdGVtcGxhdGVzUmVuZGVyZWQucmVqZWN0KClcclxuICAgIH0sXHJcbiAgICBnZXRPcHRpb25zOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1xyXG4gICAgfSxcclxuICAgIHNldFBhbmU6IGZ1bmN0aW9uKHBhbmUpIHtcclxuICAgICAgICB0aGlzLnBhbmUgPSBwYW5lO1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMucGFuZSA9IHBhbmVcclxuICAgIH0sXHJcbiAgICBzZXRUeXBlczogZnVuY3Rpb24odHlwZSwgYXhpc1R5cGUsIHR5cGVTZWxlY3Rvcikge1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMudHlwZSA9IHR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlO1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnNbdHlwZVNlbGVjdG9yXSA9IGF4aXNUeXBlIHx8IHRoaXMuX29wdGlvbnNbdHlwZVNlbGVjdG9yXTtcclxuICAgICAgICB0aGlzLl91cGRhdGVUcmFuc2xhdG9yKClcclxuICAgIH0sXHJcbiAgICByZXNldFR5cGVzOiBmdW5jdGlvbih0eXBlU2VsZWN0b3IpIHtcclxuICAgICAgICB0aGlzLl9vcHRpb25zLnR5cGUgPSB0aGlzLl9pbml0VHlwZXMudHlwZTtcclxuICAgICAgICB0aGlzLl9vcHRpb25zW3R5cGVTZWxlY3Rvcl0gPSB0aGlzLl9pbml0VHlwZXNbdHlwZVNlbGVjdG9yXVxyXG4gICAgfSxcclxuICAgIGdldFRyYW5zbGF0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2xhdG9yXHJcbiAgICB9LFxyXG4gICAgdXBkYXRlT3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgbGFiZWxPcHQgPSBvcHRpb25zLmxhYmVsO1xyXG4gICAgICAgIHZhbGlkYXRlQXhpc09wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgdGhhdC5fb3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgb3B0aW9ucy50aWNrID0gb3B0aW9ucy50aWNrIHx8IHt9O1xyXG4gICAgICAgIG9wdGlvbnMubWlub3JUaWNrID0gb3B0aW9ucy5taW5vclRpY2sgfHwge307XHJcbiAgICAgICAgb3B0aW9ucy5ncmlkID0gb3B0aW9ucy5ncmlkIHx8IHt9O1xyXG4gICAgICAgIG9wdGlvbnMubWlub3JHcmlkID0gb3B0aW9ucy5taW5vckdyaWQgfHwge307XHJcbiAgICAgICAgb3B0aW9ucy50aXRsZSA9IG9wdGlvbnMudGl0bGUgfHwge307XHJcbiAgICAgICAgb3B0aW9ucy5tYXJrZXIgPSBvcHRpb25zLm1hcmtlciB8fCB7fTtcclxuICAgICAgICB0aGF0Ll9pbml0VHlwZXMgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZSxcclxuICAgICAgICAgICAgYXJndW1lbnRUeXBlOiBvcHRpb25zLmFyZ3VtZW50VHlwZSxcclxuICAgICAgICAgICAgdmFsdWVUeXBlOiBvcHRpb25zLnZhbHVlVHlwZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhhdC5fc2V0VGlja09mZnNldCgpO1xyXG4gICAgICAgIHRoYXQuX2lzSG9yaXpvbnRhbCA9IG9wdGlvbnMuaXNIb3Jpem9udGFsO1xyXG4gICAgICAgIHRoYXQucGFuZSA9IG9wdGlvbnMucGFuZTtcclxuICAgICAgICB0aGF0Lm5hbWUgPSBvcHRpb25zLm5hbWU7XHJcbiAgICAgICAgdGhhdC5wcmlvcml0eSA9IG9wdGlvbnMucHJpb3JpdHk7XHJcbiAgICAgICAgdGhhdC5faGFzTGFiZWxGb3JtYXQgPSBcIlwiICE9PSBsYWJlbE9wdC5mb3JtYXQgJiYgaXNEZWZpbmVkKGxhYmVsT3B0LmZvcm1hdCk7XHJcbiAgICAgICAgdGhhdC5fdGV4dE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IGxhYmVsT3B0Lm9wYWNpdHksXHJcbiAgICAgICAgICAgIGFsaWduOiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICBjbGFzczogbGFiZWxPcHQuY3NzQ2xhc3NcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoYXQuX3RleHRGb250U3R5bGVzID0gcGF0Y2hGb250T3B0aW9ucyhsYWJlbE9wdC5mb250KTtcclxuICAgICAgICBpZiAob3B0aW9ucy50eXBlID09PSBjb25zdGFudHMubG9nYXJpdGhtaWMpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9nYXJpdGhtQmFzZUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9pbmNpZGVudE9jY3VycmVkKFwiRTIxMDRcIik7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5sb2dhcml0aG1CYXNlRXJyb3JcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGF0Ll91cGRhdGVUcmFuc2xhdG9yKCk7XHJcbiAgICAgICAgdGhhdC5fY3JlYXRlQ29uc3RhbnRMaW5lcygpO1xyXG4gICAgICAgIHRoYXQuX3N0cmlwcyA9IChvcHRpb25zLnN0cmlwcyB8fCBbXSkubWFwKG8gPT4gY3JlYXRlU3RyaXAodGhhdCwgbykpO1xyXG4gICAgICAgIHRoYXQuX21ham9yVGlja3MgPSB0aGF0Ll9taW5vclRpY2tzID0gbnVsbDtcclxuICAgICAgICB0aGF0Ll9maXJzdERyYXdpbmcgPSB0cnVlXHJcbiAgICB9LFxyXG4gICAgY2FsY3VsYXRlSW50ZXJ2YWw6IGZ1bmN0aW9uKHZhbHVlLCBwcmV2VmFsdWUpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnM7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMudHlwZSAhPT0gY29uc3RhbnRzLmxvZ2FyaXRobWljKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfYWJzKHZhbHVlIC0gcHJldlZhbHVlKVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICBhbGxvd05lZ2F0aXZlczogYWxsb3dOZWdhdGl2ZXMsXHJcbiAgICAgICAgICAgIGxpbmVhclRocmVzaG9sZDogbGluZWFyVGhyZXNob2xkXHJcbiAgICAgICAgfSA9IG5ldyBSYW5nZSh0aGlzLmdldFRyYW5zbGF0b3IoKS5nZXRCdXNpbmVzc1JhbmdlKCkpO1xyXG4gICAgICAgIHJldHVybiBfYWJzKGdldExvZyh2YWx1ZSwgb3B0aW9ucy5sb2dhcml0aG1CYXNlLCBhbGxvd05lZ2F0aXZlcywgbGluZWFyVGhyZXNob2xkKSAtIGdldExvZyhwcmV2VmFsdWUsIG9wdGlvbnMubG9nYXJpdGhtQmFzZSwgYWxsb3dOZWdhdGl2ZXMsIGxpbmVhclRocmVzaG9sZCkpXHJcbiAgICB9LFxyXG4gICAgZ2V0Q2FudmFzUmFuZ2UoKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0b3IgPSB0aGlzLl90cmFuc2xhdG9yO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHRyYW5zbGF0b3IuZnJvbSh0cmFuc2xhdG9yLnRyYW5zbGF0ZShcImNhbnZhc19wb3NpdGlvbl9zdGFydFwiKSksXHJcbiAgICAgICAgICAgIGVuZFZhbHVlOiB0cmFuc2xhdG9yLmZyb20odHJhbnNsYXRvci50cmFuc2xhdGUoXCJjYW52YXNfcG9zaXRpb25fZW5kXCIpKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfcHJvY2Vzc0NhbnZhczogZnVuY3Rpb24oY2FudmFzKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbnZhc1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZUNhbnZhczogZnVuY3Rpb24oY2FudmFzLCBjYW52YXNSZWRlc2lnbikge1xyXG4gICAgICAgIGlmICghY2FudmFzUmVkZXNpZ24pIHtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHRoaXMuX29ydGhvZ29uYWxQb3NpdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogIXRoaXMuX2lzSG9yaXpvbnRhbCA/IGNhbnZhcy5sZWZ0IDogY2FudmFzLnRvcCxcclxuICAgICAgICAgICAgICAgIGVuZDogIXRoaXMuX2lzSG9yaXpvbnRhbCA/IGNhbnZhcy53aWR0aCAtIGNhbnZhcy5yaWdodCA6IGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuYm90dG9tXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHBvc2l0aW9ucy5jZW50ZXIgPSBwb3NpdGlvbnMuc3RhcnQgKyAocG9zaXRpb25zLmVuZCAtIHBvc2l0aW9ucy5zdGFydCkgLyAyXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fb3J0aG9nb25hbFBvc2l0aW9ucyA9IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zbGF0b3IudXBkYXRlQ2FudmFzKHRoaXMuX3Byb2Nlc3NDYW52YXMoY2FudmFzKSk7XHJcbiAgICAgICAgdGhpcy5faW5pdEF4aXNQb3NpdGlvbnMoKVxyXG4gICAgfSxcclxuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc1xyXG4gICAgfSxcclxuICAgIGdldEF4aXNTaGlmdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXhpc1NoaWZ0IHx8IDBcclxuICAgIH0sXHJcbiAgICBoaWRlVGl0bGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnRpdGxlLnRleHQpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5jaWRlbnRPY2N1cnJlZChcIlcyMTA1XCIsIFt0aGlzLl9pc0hvcml6b250YWwgPyBcImhvcml6b250YWxcIiA6IFwidmVydGljYWxcIl0pO1xyXG4gICAgICAgICAgICB0aGlzLl9heGlzVGl0bGVHcm91cC5jbGVhcigpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldFRpdGxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGl0bGVcclxuICAgIH0sXHJcbiAgICBoaWRlT3V0ZXJFbGVtZW50czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xyXG4gICAgICAgIGlmICgob3B0aW9ucy5sYWJlbC52aXNpYmxlIHx8IHRoaXMuX291dHNpZGVDb25zdGFudExpbmVzLmxlbmd0aCkgJiYgIXRoaXMuX3RyYW5zbGF0b3IuZ2V0QnVzaW5lc3NSYW5nZSgpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbmNpZGVudE9jY3VycmVkKFwiVzIxMDZcIiwgW3RoaXMuX2lzSG9yaXpvbnRhbCA/IFwiaG9yaXpvbnRhbFwiIDogXCJ2ZXJ0aWNhbFwiXSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2F4aXNFbGVtZW50c0dyb3VwLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIGNhbGxBY3Rpb24odGhpcy5fb3V0c2lkZUNvbnN0YW50TGluZXMsIFwicmVtb3ZlTGFiZWxcIilcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3Jlc29sdmVMb2dhcml0aG1pY09wdGlvbnNGb3JSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICBpZiAob3B0aW9ucy50eXBlID09PSBjb25zdGFudHMubG9nYXJpdGhtaWMpIHtcclxuICAgICAgICAgICAgcmFuZ2UuYWRkUmFuZ2Uoe1xyXG4gICAgICAgICAgICAgICAgYWxsb3dOZWdhdGl2ZXM6IHZvaWQgMCAhPT0gb3B0aW9ucy5hbGxvd05lZ2F0aXZlcyA/IG9wdGlvbnMuYWxsb3dOZWdhdGl2ZXMgOiByYW5nZS5taW4gPD0gMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFpc05hTihvcHRpb25zLmxpbmVhclRocmVzaG9sZCkpIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlLmxpbmVhclRocmVzaG9sZCA9IG9wdGlvbnMubGluZWFyVGhyZXNob2xkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgYWRqdXN0Vmlld3BvcnQoYnVzaW5lc3NSYW5nZSkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICB2YXIgaXNEaXNjcmV0ZSA9IG9wdGlvbnMudHlwZSA9PT0gY29uc3RhbnRzLmRpc2NyZXRlO1xyXG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gdGhpcy5fc2VyaWVzRGF0YSAmJiB0aGlzLl9zZXJpZXNEYXRhLmNhdGVnb3JpZXMgfHwgW107XHJcbiAgICAgICAgdmFyIHdob2xlUmFuZ2UgPSB0aGlzLmFkanVzdFJhbmdlKGdldFZpelJhbmdlT2JqZWN0KG9wdGlvbnMud2hvbGVSYW5nZSkpO1xyXG4gICAgICAgIHZhciB2aXN1YWxSYW5nZSA9IHRoaXMuZ2V0Vmlld3BvcnQoKSB8fCB7fTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFJhbmdlKGJ1c2luZXNzUmFuZ2UpO1xyXG4gICAgICAgIHRoaXMuX2FkZENvbnN0YW50TGluZXNUb1JhbmdlKHJlc3VsdCwgXCJtaW5WaXNpYmxlXCIsIFwibWF4VmlzaWJsZVwiKTtcclxuICAgICAgICB2YXIgbWluRGVmaW5lZCA9IGlzRGVmaW5lZCh2aXN1YWxSYW5nZS5zdGFydFZhbHVlKTtcclxuICAgICAgICB2YXIgbWF4RGVmaW5lZCA9IGlzRGVmaW5lZCh2aXN1YWxSYW5nZS5lbmRWYWx1ZSk7XHJcbiAgICAgICAgaWYgKCFpc0Rpc2NyZXRlKSB7XHJcbiAgICAgICAgICAgIG1pbkRlZmluZWQgPSBtaW5EZWZpbmVkICYmICghaXNEZWZpbmVkKHdob2xlUmFuZ2UuZW5kVmFsdWUpIHx8IHZpc3VhbFJhbmdlLnN0YXJ0VmFsdWUgPCB3aG9sZVJhbmdlLmVuZFZhbHVlKTtcclxuICAgICAgICAgICAgbWF4RGVmaW5lZCA9IG1heERlZmluZWQgJiYgKCFpc0RlZmluZWQod2hvbGVSYW5nZS5zdGFydFZhbHVlKSB8fCB2aXN1YWxSYW5nZS5lbmRWYWx1ZSA+IHdob2xlUmFuZ2Uuc3RhcnRWYWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1pblZpc2libGUgPSBtaW5EZWZpbmVkID8gdmlzdWFsUmFuZ2Uuc3RhcnRWYWx1ZSA6IHJlc3VsdC5taW5WaXNpYmxlO1xyXG4gICAgICAgIHZhciBtYXhWaXNpYmxlID0gbWF4RGVmaW5lZCA/IHZpc3VhbFJhbmdlLmVuZFZhbHVlIDogcmVzdWx0Lm1heFZpc2libGU7XHJcbiAgICAgICAgaWYgKCFpc0Rpc2NyZXRlKSB7XHJcbiAgICAgICAgICAgIHZhciBfd2hvbGVSYW5nZSRzdGFydFZhbHUsIF93aG9sZVJhbmdlJGVuZFZhbHVlO1xyXG4gICAgICAgICAgICByZXN1bHQubWluID0gbnVsbCAhPT0gKF93aG9sZVJhbmdlJHN0YXJ0VmFsdSA9IHdob2xlUmFuZ2Uuc3RhcnRWYWx1ZSkgJiYgdm9pZCAwICE9PSBfd2hvbGVSYW5nZSRzdGFydFZhbHUgPyBfd2hvbGVSYW5nZSRzdGFydFZhbHUgOiByZXN1bHQubWluO1xyXG4gICAgICAgICAgICByZXN1bHQubWF4ID0gbnVsbCAhPT0gKF93aG9sZVJhbmdlJGVuZFZhbHVlID0gd2hvbGVSYW5nZS5lbmRWYWx1ZSkgJiYgdm9pZCAwICE9PSBfd2hvbGVSYW5nZSRlbmRWYWx1ZSA/IF93aG9sZVJhbmdlJGVuZFZhbHVlIDogcmVzdWx0Lm1heFxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBjYXRlZ29yaWVzSW5mbyA9IGdldENhdGVnb3JpZXNJbmZvKGNhdGVnb3JpZXMsIHdob2xlUmFuZ2Uuc3RhcnRWYWx1ZSwgd2hvbGVSYW5nZS5lbmRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGNhdGVnb3JpZXMgPSBjYXRlZ29yaWVzSW5mby5jYXRlZ29yaWVzO1xyXG4gICAgICAgICAgICByZXN1bHQuY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXNcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFkanVzdGVkVmlzdWFsUmFuZ2UgPSBhZGp1c3RWaXN1YWxSYW5nZSh7XHJcbiAgICAgICAgICAgIGF4aXNUeXBlOiBvcHRpb25zLnR5cGUsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiBvcHRpb25zLmRhdGFUeXBlLFxyXG4gICAgICAgICAgICBiYXNlOiBvcHRpb25zLmxvZ2FyaXRobUJhc2VcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIHN0YXJ0VmFsdWU6IG1pbkRlZmluZWQgPyB2aXN1YWxSYW5nZS5zdGFydFZhbHVlIDogdm9pZCAwLFxyXG4gICAgICAgICAgICBlbmRWYWx1ZTogbWF4RGVmaW5lZCA/IHZpc3VhbFJhbmdlLmVuZFZhbHVlIDogdm9pZCAwLFxyXG4gICAgICAgICAgICBsZW5ndGg6IHZpc3VhbFJhbmdlLmxlbmd0aFxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgICAgY2F0ZWdvcmllczogY2F0ZWdvcmllcyxcclxuICAgICAgICAgICAgbWluOiB3aG9sZVJhbmdlLnN0YXJ0VmFsdWUsXHJcbiAgICAgICAgICAgIG1heDogd2hvbGVSYW5nZS5lbmRWYWx1ZVxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgICAgY2F0ZWdvcmllczogY2F0ZWdvcmllcyxcclxuICAgICAgICAgICAgbWluOiBtaW5WaXNpYmxlLFxyXG4gICAgICAgICAgICBtYXg6IG1heFZpc2libGVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXN1bHQubWluVmlzaWJsZSA9IGFkanVzdGVkVmlzdWFsUmFuZ2Uuc3RhcnRWYWx1ZTtcclxuICAgICAgICByZXN1bHQubWF4VmlzaWJsZSA9IGFkanVzdGVkVmlzdWFsUmFuZ2UuZW5kVmFsdWU7XHJcbiAgICAgICAgIWlzRGVmaW5lZChyZXN1bHQubWluKSAmJiAocmVzdWx0Lm1pbiA9IHJlc3VsdC5taW5WaXNpYmxlKTtcclxuICAgICAgICAhaXNEZWZpbmVkKHJlc3VsdC5tYXgpICYmIChyZXN1bHQubWF4ID0gcmVzdWx0Lm1heFZpc2libGUpO1xyXG4gICAgICAgIHJlc3VsdC5hZGRSYW5nZSh7fSk7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUxvZ2FyaXRobWljT3B0aW9uc0ZvclJhbmdlKHJlc3VsdCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgfSxcclxuICAgIGFkanVzdFJhbmdlKHJhbmdlKSB7XHJcbiAgICAgICAgcmFuZ2UgPSByYW5nZSB8fCB7fTtcclxuICAgICAgICB2YXIgaXNEaXNjcmV0ZSA9IHRoaXMuX29wdGlvbnMudHlwZSA9PT0gY29uc3RhbnRzLmRpc2NyZXRlO1xyXG4gICAgICAgIHZhciBpc0xvZ2FyaXRobWljID0gdGhpcy5fb3B0aW9ucy50eXBlID09PSBjb25zdGFudHMubG9nYXJpdGhtaWM7XHJcbiAgICAgICAgdmFyIGRpc2FibGVkTmVnYXRpdmVzID0gZmFsc2UgPT09IHRoaXMuX29wdGlvbnMuYWxsb3dOZWdhdGl2ZXM7XHJcbiAgICAgICAgaWYgKGlzTG9nYXJpdGhtaWMpIHtcclxuICAgICAgICAgICAgcmFuZ2Uuc3RhcnRWYWx1ZSA9IGRpc2FibGVkTmVnYXRpdmVzICYmIHJhbmdlLnN0YXJ0VmFsdWUgPD0gMCA/IG51bGwgOiByYW5nZS5zdGFydFZhbHVlO1xyXG4gICAgICAgICAgICByYW5nZS5lbmRWYWx1ZSA9IGRpc2FibGVkTmVnYXRpdmVzICYmIHJhbmdlLmVuZFZhbHVlIDw9IDAgPyBudWxsIDogcmFuZ2UuZW5kVmFsdWVcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0Rpc2NyZXRlICYmIGlzRGVmaW5lZChyYW5nZS5zdGFydFZhbHVlKSAmJiBpc0RlZmluZWQocmFuZ2UuZW5kVmFsdWUpICYmIHJhbmdlLnN0YXJ0VmFsdWUgPiByYW5nZS5lbmRWYWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgdG1wID0gcmFuZ2UuZW5kVmFsdWU7XHJcbiAgICAgICAgICAgIHJhbmdlLmVuZFZhbHVlID0gcmFuZ2Uuc3RhcnRWYWx1ZTtcclxuICAgICAgICAgICAgcmFuZ2Uuc3RhcnRWYWx1ZSA9IHRtcFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmFuZ2VcclxuICAgIH0sXHJcbiAgICBfZ2V0VmlzdWFsUmFuZ2VVcGRhdGVNb2RlKHZpZXdwb3J0LCBuZXdSYW5nZSwgb3Bwb3NpdGVWYWx1ZSkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX29wdGlvbnMudmlzdWFsUmFuZ2VVcGRhdGVNb2RlO1xyXG4gICAgICAgIHZhciB0cmFuc2xhdG9yID0gdGhpcy5fdHJhbnNsYXRvcjtcclxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9zZXJpZXNEYXRhO1xyXG4gICAgICAgIHZhciBwcmV2RGF0YUluZm8gPSB0aGlzLl9wcmV2RGF0YUluZm87XHJcbiAgICAgICAgaWYgKHByZXZEYXRhSW5mby5pc0VtcHR5ICYmICFwcmV2RGF0YUluZm8uY29udGFpbnNDb25zdGFudExpbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEtFRVBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQXJndW1lbnRBeGlzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KCk7XHJcbiAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKF92aWV3cG9ydC5zdGFydFZhbHVlKSAmJiAhaXNEZWZpbmVkKF92aWV3cG9ydC5lbmRWYWx1ZSkgJiYgIWlzRGVmaW5lZChfdmlld3BvcnQubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJFU0VUXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBcmd1bWVudEF4aXMpIHtcclxuICAgICAgICAgICAgaWYgKC0xID09PSBbU0hJRlQsIEtFRVAsIFJFU0VUXS5pbmRleE9mKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmF4aXNUeXBlID09PSBjb25zdGFudHMuZGlzY3JldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IHJhbmdlLmNhdGVnb3JpZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0NhdGVnb3JpZXMgPSBuZXdSYW5nZS5jYXRlZ29yaWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2aXN1YWxSYW5nZSA9IHRoaXMudmlzdWFsUmFuZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcmllcyAmJiBuZXdDYXRlZ29yaWVzICYmIGNhdGVnb3JpZXMubGVuZ3RoICYmIC0xICE9PSBuZXdDYXRlZ29yaWVzLm1hcChjID0+IGMudmFsdWVPZigpKS5qb2luKFwiLFwiKS5pbmRleE9mKGNhdGVnb3JpZXMubWFwKGMgPT4gYy52YWx1ZU9mKCkpLmpvaW4oXCIsXCIpKSAmJiAodmlzdWFsUmFuZ2Uuc3RhcnRWYWx1ZS52YWx1ZU9mKCkgIT09IGNhdGVnb3JpZXNbMF0udmFsdWVPZigpIHx8IHZpc3VhbFJhbmdlLmVuZFZhbHVlLnZhbHVlT2YoKSAhPT0gY2F0ZWdvcmllc1tjYXRlZ29yaWVzLmxlbmd0aCAtIDFdLnZhbHVlT2YoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBLRUVQXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBSRVNFVFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pblBvaW50ID0gdHJhbnNsYXRvci50cmFuc2xhdGUocmFuZ2UubWluKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWluVmlzaWJsZVBvaW50ID0gdHJhbnNsYXRvci50cmFuc2xhdGUodmlld3BvcnQuc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heFBvaW50ID0gdHJhbnNsYXRvci50cmFuc2xhdGUocmFuZ2UubWF4KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4VmlzaWJsZVBvaW50ID0gdHJhbnNsYXRvci50cmFuc2xhdGUodmlld3BvcnQuZW5kVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5Qb2ludCA9PT0gbWluVmlzaWJsZVBvaW50ICYmIG1heFBvaW50ID09PSBtYXhWaXNpYmxlUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBSRVNFVFxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWluUG9pbnQgIT09IG1pblZpc2libGVQb2ludCAmJiBtYXhQb2ludCA9PT0gbWF4VmlzaWJsZVBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gU0hJRlRcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEtFRVBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IEtFRVAgJiYgcHJldkRhdGFJbmZvLmlzRW1wdHkgJiYgcHJldkRhdGFJbmZvLmNvbnRhaW5zQ29uc3RhbnRMaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBSRVNFVFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICgtMSA9PT0gW0tFRVAsIFJFU0VUXS5pbmRleE9mKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAob3Bwb3NpdGVWYWx1ZSA9PT0gS0VFUCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBLRUVQXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFJFU0VUXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICB9LFxyXG4gICAgX2hhbmRsZUJ1c2luZXNzUmFuZ2VDaGFuZ2VkKG9wcG9zaXRlVmlzdWFsUmFuZ2VVcGRhdGVNb2RlLCBheGlzUmVpbml0aWFsaXplZCwgbmV3UmFuZ2UpIHtcclxuICAgICAgICB2YXIgdmlzdWFsUmFuZ2UgPSB0aGlzLnZpc3VhbFJhbmdlKCk7XHJcbiAgICAgICAgaWYgKGF4aXNSZWluaXRpYWxpemVkIHx8IHRoaXMuX3RyYW5zbGF0b3IuZ2V0QnVzaW5lc3NSYW5nZSgpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZpc3VhbFJhbmdlVXBkYXRlTW9kZSA9IHRoaXMuX2xhc3RWaXN1YWxSYW5nZVVwZGF0ZU1vZGUgPSB0aGlzLl9nZXRWaXN1YWxSYW5nZVVwZGF0ZU1vZGUodmlzdWFsUmFuZ2UsIG5ld1JhbmdlLCBvcHBvc2l0ZVZpc3VhbFJhbmdlVXBkYXRlTW9kZSk7XHJcbiAgICAgICAgaWYgKHZpc3VhbFJhbmdlVXBkYXRlTW9kZSA9PT0gS0VFUCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRWaXN1YWxSYW5nZShbdmlzdWFsUmFuZ2Uuc3RhcnRWYWx1ZSwgdmlzdWFsUmFuZ2UuZW5kVmFsdWVdKVxyXG4gICAgICAgIH0gZWxzZSBpZiAodmlzdWFsUmFuZ2VVcGRhdGVNb2RlID09PSBSRVNFVCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRWaXN1YWxSYW5nZShbbnVsbCwgbnVsbF0pXHJcbiAgICAgICAgfSBlbHNlIGlmICh2aXN1YWxSYW5nZVVwZGF0ZU1vZGUgPT09IFNISUZUKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFZpc3VhbFJhbmdlKHtcclxuICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy5nZXRWaXN1YWxSYW5nZUxlbmd0aCgpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldFZpc3VhbFJhbmdlTGVuZ3RoKHJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRCdXNpbmVzc1JhbmdlID0gcmFuZ2UgfHwgdGhpcy5fdHJhbnNsYXRvci5nZXRCdXNpbmVzc1JhbmdlKCk7XHJcbiAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgIH0gPSB0aGlzLl9vcHRpb25zO1xyXG4gICAgICAgIHZhciBsZW5ndGg7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IGNvbnN0YW50cy5sb2dhcml0aG1pYykge1xyXG4gICAgICAgICAgICBsZW5ndGggPSBhZGp1c3QodGhpcy5jYWxjdWxhdGVJbnRlcnZhbChjdXJyZW50QnVzaW5lc3NSYW5nZS5tYXhWaXNpYmxlLCBjdXJyZW50QnVzaW5lc3NSYW5nZS5taW5WaXNpYmxlKSlcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGNvbnN0YW50cy5kaXNjcmV0ZSkge1xyXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcmllc0luZm8gPSBnZXRDYXRlZ29yaWVzSW5mbyhjdXJyZW50QnVzaW5lc3NSYW5nZS5jYXRlZ29yaWVzLCBjdXJyZW50QnVzaW5lc3NSYW5nZS5taW5WaXNpYmxlLCBjdXJyZW50QnVzaW5lc3NSYW5nZS5tYXhWaXNpYmxlKTtcclxuICAgICAgICAgICAgbGVuZ3RoID0gY2F0ZWdvcmllc0luZm8uY2F0ZWdvcmllcy5sZW5ndGhcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZW5ndGggPSBjdXJyZW50QnVzaW5lc3NSYW5nZS5tYXhWaXNpYmxlIC0gY3VycmVudEJ1c2luZXNzUmFuZ2UubWluVmlzaWJsZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGVuZ3RoXHJcbiAgICB9LFxyXG4gICAgZ2V0VmlzdWFsUmFuZ2VDZW50ZXIocmFuZ2UsIHVzZU1lcmdlKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0b3IgPSB0aGlzLmdldFRyYW5zbGF0b3IoKTtcclxuICAgICAgICB2YXIgYnVzaW5lc3NSYW5nZSA9IHRyYW5zbGF0b3IuZ2V0QnVzaW5lc3NSYW5nZSgpO1xyXG4gICAgICAgIHZhciBjdXJyZW50QnVzaW5lc3NSYW5nZSA9IHVzZU1lcmdlID8gZXh0ZW5kKHRydWUsIHt9LCBidXNpbmVzc1JhbmdlLCByYW5nZSB8fCB7fSkgOiByYW5nZSB8fCBidXNpbmVzc1JhbmdlO1xyXG4gICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgIGxvZ2FyaXRobUJhc2U6IGxvZ2FyaXRobUJhc2VcclxuICAgICAgICB9ID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICB2YXIgY2VudGVyO1xyXG4gICAgICAgIGlmICghaXNEZWZpbmVkKGN1cnJlbnRCdXNpbmVzc1JhbmdlLm1pblZpc2libGUpIHx8ICFpc0RlZmluZWQoY3VycmVudEJ1c2luZXNzUmFuZ2UubWF4VmlzaWJsZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBjb25zdGFudHMubG9nYXJpdGhtaWMpIHtcclxuICAgICAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgICAgIGFsbG93TmVnYXRpdmVzOiBhbGxvd05lZ2F0aXZlcyxcclxuICAgICAgICAgICAgICAgIGxpbmVhclRocmVzaG9sZDogbGluZWFyVGhyZXNob2xkLFxyXG4gICAgICAgICAgICAgICAgbWluVmlzaWJsZTogbWluVmlzaWJsZSxcclxuICAgICAgICAgICAgICAgIG1heFZpc2libGU6IG1heFZpc2libGVcclxuICAgICAgICAgICAgfSA9IGN1cnJlbnRCdXNpbmVzc1JhbmdlO1xyXG4gICAgICAgICAgICBjZW50ZXIgPSByYWlzZVRvKGFkanVzdChnZXRMb2cobWF4VmlzaWJsZSwgbG9nYXJpdGhtQmFzZSwgYWxsb3dOZWdhdGl2ZXMsIGxpbmVhclRocmVzaG9sZCkgKyBnZXRMb2cobWluVmlzaWJsZSwgbG9nYXJpdGhtQmFzZSwgYWxsb3dOZWdhdGl2ZXMsIGxpbmVhclRocmVzaG9sZCkpIC8gMiwgbG9nYXJpdGhtQmFzZSwgYWxsb3dOZWdhdGl2ZXMsIGxpbmVhclRocmVzaG9sZClcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGNvbnN0YW50cy5kaXNjcmV0ZSkge1xyXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcmllc0luZm8gPSBnZXRDYXRlZ29yaWVzSW5mbyhjdXJyZW50QnVzaW5lc3NSYW5nZS5jYXRlZ29yaWVzLCBjdXJyZW50QnVzaW5lc3NSYW5nZS5taW5WaXNpYmxlLCBjdXJyZW50QnVzaW5lc3NSYW5nZS5tYXhWaXNpYmxlKTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5jZWlsKGNhdGVnb3JpZXNJbmZvLmNhdGVnb3JpZXMubGVuZ3RoIC8gMikgLSAxO1xyXG4gICAgICAgICAgICBjZW50ZXIgPSBidXNpbmVzc1JhbmdlLmNhdGVnb3JpZXMuaW5kZXhPZihjYXRlZ29yaWVzSW5mby5jYXRlZ29yaWVzW2luZGV4XSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjZW50ZXIgPSB0cmFuc2xhdG9yLnRvVmFsdWUoKGN1cnJlbnRCdXNpbmVzc1JhbmdlLm1heFZpc2libGUudmFsdWVPZigpICsgY3VycmVudEJ1c2luZXNzUmFuZ2UubWluVmlzaWJsZS52YWx1ZU9mKCkpIC8gMilcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNlbnRlclxyXG4gICAgfSxcclxuICAgIHNldEJ1c2luZXNzUmFuZ2UocmFuZ2UsIGF4aXNSZWluaXRpYWxpemVkLCBvcHBvc2l0ZVZpc3VhbFJhbmdlVXBkYXRlTW9kZSwgYXJnQ2F0ZWdvcmllcykge1xyXG4gICAgICAgIHZhciBfdGhhdCRfc2VyaWVzRGF0YSRtaW4sIF90aGF0JF9zZXJpZXNEYXRhJG1heDtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnM7XHJcbiAgICAgICAgdmFyIGlzRGlzY3JldGUgPSBvcHRpb25zLnR5cGUgPT09IGNvbnN0YW50cy5kaXNjcmV0ZTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVCdXNpbmVzc1JhbmdlQ2hhbmdlZChvcHBvc2l0ZVZpc3VhbFJhbmdlVXBkYXRlTW9kZSwgYXhpc1JlaW5pdGlhbGl6ZWQsIHJhbmdlKTtcclxuICAgICAgICB0aGlzLl9zZXJpZXNEYXRhID0gbmV3IFJhbmdlKHJhbmdlKTtcclxuICAgICAgICB2YXIgZGF0YUlzRW1wdHkgPSB0aGlzLl9zZXJpZXNEYXRhLmlzRW1wdHkoKTtcclxuICAgICAgICB2YXIgcmFuZ2VXaXRoQ29uc3RhbnRMaW5lcyA9IG5ldyBSYW5nZSh0aGlzLl9zZXJpZXNEYXRhKTtcclxuICAgICAgICB0aGlzLl9hZGRDb25zdGFudExpbmVzVG9SYW5nZShyYW5nZVdpdGhDb25zdGFudExpbmVzLCBcIm1pblZpc2libGVcIiwgXCJtYXhWaXNpYmxlXCIpO1xyXG4gICAgICAgIHRoaXMuX3ByZXZEYXRhSW5mbyA9IHtcclxuICAgICAgICAgICAgaXNFbXB0eTogZGF0YUlzRW1wdHksXHJcbiAgICAgICAgICAgIGNvbnRhaW5zQ29uc3RhbnRMaW5lOiByYW5nZVdpdGhDb25zdGFudExpbmVzLmNvbnRhaW5zQ29uc3RhbnRMaW5lXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9zZXJpZXNEYXRhLmFkZFJhbmdlKHtcclxuICAgICAgICAgICAgY2F0ZWdvcmllczogb3B0aW9ucy5jYXRlZ29yaWVzLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogb3B0aW9ucy5kYXRhVHlwZSxcclxuICAgICAgICAgICAgYXhpc1R5cGU6IG9wdGlvbnMudHlwZSxcclxuICAgICAgICAgICAgYmFzZTogb3B0aW9ucy5sb2dhcml0aG1CYXNlLFxyXG4gICAgICAgICAgICBpbnZlcnQ6IG9wdGlvbnMuaW52ZXJ0ZWRcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9yZXNvbHZlTG9nYXJpdGhtaWNPcHRpb25zRm9yUmFuZ2UodGhpcy5fc2VyaWVzRGF0YSk7XHJcbiAgICAgICAgaWYgKCFpc0Rpc2NyZXRlKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKHRoaXMuX3Nlcmllc0RhdGEubWluKSAmJiAhaXNEZWZpbmVkKHRoaXMuX3Nlcmllc0RhdGEubWF4KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZpc3VhbFJhbmdlID0gdGhpcy5nZXRWaWV3cG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgdmlzdWFsUmFuZ2UgJiYgdGhpcy5fc2VyaWVzRGF0YS5hZGRSYW5nZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluOiB2aXN1YWxSYW5nZS5zdGFydFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heDogdmlzdWFsUmFuZ2UuZW5kVmFsdWVcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHN5bmNocm9uaXplZFZhbHVlID0gb3B0aW9ucy5zeW5jaHJvbml6ZWRWYWx1ZTtcclxuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChzeW5jaHJvbml6ZWRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nlcmllc0RhdGEuYWRkUmFuZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbjogc3luY2hyb25pemVkVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4OiBzeW5jaHJvbml6ZWRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zZXJpZXNEYXRhLm1pblZpc2libGUgPSBudWxsICE9PSAoX3RoYXQkX3Nlcmllc0RhdGEkbWluID0gdGhpcy5fc2VyaWVzRGF0YS5taW5WaXNpYmxlKSAmJiB2b2lkIDAgIT09IF90aGF0JF9zZXJpZXNEYXRhJG1pbiA/IF90aGF0JF9zZXJpZXNEYXRhJG1pbiA6IHRoaXMuX3Nlcmllc0RhdGEubWluO1xyXG4gICAgICAgIHRoaXMuX3Nlcmllc0RhdGEubWF4VmlzaWJsZSA9IG51bGwgIT09IChfdGhhdCRfc2VyaWVzRGF0YSRtYXggPSB0aGlzLl9zZXJpZXNEYXRhLm1heFZpc2libGUpICYmIHZvaWQgMCAhPT0gX3RoYXQkX3Nlcmllc0RhdGEkbWF4ID8gX3RoYXQkX3Nlcmllc0RhdGEkbWF4IDogdGhpcy5fc2VyaWVzRGF0YS5tYXg7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQXJndW1lbnRBeGlzICYmIG9wdGlvbnMuc2hvd1plcm8pIHtcclxuICAgICAgICAgICAgdGhpcy5fc2VyaWVzRGF0YS5jb3JyZWN0VmFsdWVaZXJvTGV2ZWwoKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zZXJpZXNEYXRhLnNvcnRDYXRlZ29yaWVzKHRoaXMuZ2V0Q2F0ZWdvcmllc1NvcnRlcihhcmdDYXRlZ29yaWVzKSk7XHJcbiAgICAgICAgdGhpcy5fc2VyaWVzRGF0YS51c2VyQnJlYWtzID0gdGhpcy5fc2VyaWVzRGF0YS5pc0VtcHR5KCkgPyBbXSA6IHRoaXMuX2dldFNjYWxlQnJlYWtzKG9wdGlvbnMsIHRoaXMuX3Nlcmllc0RhdGEsIHRoaXMuX3NlcmllcywgdGhpcy5pc0FyZ3VtZW50QXhpcyk7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRvci51cGRhdGVCdXNpbmVzc1JhbmdlKHRoaXMuX2dldFZpZXdwb3J0UmFuZ2UoKSlcclxuICAgIH0sXHJcbiAgICBfYWRkQ29uc3RhbnRMaW5lc1RvUmFuZ2UoZGF0YVJhbmdlLCBtaW5WYWx1ZUZpZWxkLCBtYXhWYWx1ZUZpZWxkKSB7XHJcbiAgICAgICAgdGhpcy5fb3V0c2lkZUNvbnN0YW50TGluZXMuY29uY2F0KHRoaXMuX2luc2lkZUNvbnN0YW50TGluZXMgfHwgW10pLmZvckVhY2goY2wgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2wub3B0aW9ucy5leHRlbmRBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjbC5nZXRQYXJzZWRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgZGF0YVJhbmdlLmFkZFJhbmdlKHtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluc0NvbnN0YW50TGluZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBbbWluVmFsdWVGaWVsZF06IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIFttYXhWYWx1ZUZpZWxkXTogdmFsdWVcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuICAgIHNldEdyb3VwU2VyaWVzOiBmdW5jdGlvbihzZXJpZXMpIHtcclxuICAgICAgICB0aGlzLl9zZXJpZXMgPSBzZXJpZXNcclxuICAgIH0sXHJcbiAgICBnZXRMYWJlbHNQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgICAgdmFyIGxhYmVsU2hpZnQgPSBvcHRpb25zLmxhYmVsLmluZGVudEZyb21BeGlzICsgKHRoaXMuX2F4aXNTaGlmdCB8fCAwKSArIHRoaXMuX2NvbnN0YW50TGFiZWxPZmZzZXQ7XHJcbiAgICAgICAgdmFyIGF4aXNQb3NpdGlvbiA9IHRoaXMuX2F4aXNQb3NpdGlvbjtcclxuICAgICAgICByZXR1cm4gcG9zaXRpb24gPT09IFRPUCB8fCBwb3NpdGlvbiA9PT0gTEVGVCA/IGF4aXNQb3NpdGlvbiAtIGxhYmVsU2hpZnQgOiBheGlzUG9zaXRpb24gKyBsYWJlbFNoaWZ0XHJcbiAgICB9LFxyXG4gICAgZ2V0Rm9ybWF0dGVkVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zLCBwb2ludCkge1xyXG4gICAgICAgIHZhciBsYWJlbE9wdGlvbnMgPSB0aGlzLl9vcHRpb25zLmxhYmVsO1xyXG4gICAgICAgIHJldHVybiBpc0RlZmluZWQodmFsdWUpID8gdGhpcy5mb3JtYXRMYWJlbCh2YWx1ZSwgZXh0ZW5kKHRydWUsIHt9LCBsYWJlbE9wdGlvbnMsIG9wdGlvbnMpLCB2b2lkIDAsIHBvaW50KSA6IG51bGxcclxuICAgIH0sXHJcbiAgICBfZ2V0Qm91bmRhcnlUaWNrczogZnVuY3Rpb24obWFqb3JzLCB2aWV3UG9ydCkge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBtYWpvcnMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICB2YXIgY3VzdG9tQm91bmRzID0gb3B0aW9ucy5jdXN0b21Cb3VuZFRpY2tzO1xyXG4gICAgICAgIHZhciBtaW4gPSB2aWV3UG9ydC5taW5WaXNpYmxlO1xyXG4gICAgICAgIHZhciBtYXggPSB2aWV3UG9ydC5tYXhWaXNpYmxlO1xyXG4gICAgICAgIHZhciBhZGRNaW5NYXggPSBvcHRpb25zLnNob3dDdXN0b21Cb3VuZGFyeVRpY2tzID8gdGhpcy5fYm91bmRhcnlUaWNrc1Zpc2liaWxpdHkgOiB7fTtcclxuICAgICAgICB2YXIgYm91bmRhcnlUaWNrcyA9IFtdO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09IGNvbnN0YW50cy5kaXNjcmV0ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdGlja09mZnNldCAmJiAwICE9PSBtYWpvcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZGFyeVRpY2tzID0gW21ham9yc1swXSwgbWFqb3JzW21ham9ycy5sZW5ndGggLSAxXV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tQm91bmRzKSB7XHJcbiAgICAgICAgICAgIGlmIChhZGRNaW5NYXgubWluICYmIGlzRGVmaW5lZChjdXN0b21Cb3VuZHNbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZGFyeVRpY2tzLnB1c2goY3VzdG9tQm91bmRzWzBdKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhZGRNaW5NYXgubWF4ICYmIGlzRGVmaW5lZChjdXN0b21Cb3VuZHNbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZGFyeVRpY2tzLnB1c2goY3VzdG9tQm91bmRzWzFdKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGFkZE1pbk1heC5taW4gJiYgKDAgPT09IGxlbmd0aCB8fCBtYWpvcnNbMF0gPiBtaW4pKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZGFyeVRpY2tzLnB1c2gobWluKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhZGRNaW5NYXgubWF4ICYmICgwID09PSBsZW5ndGggfHwgbWFqb3JzW2xlbmd0aCAtIDFdIDwgbWF4KSkge1xyXG4gICAgICAgICAgICAgICAgYm91bmRhcnlUaWNrcy5wdXNoKG1heClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYm91bmRhcnlUaWNrc1xyXG4gICAgfSxcclxuICAgIHNldFBlcmNlbnRMYWJlbEZvcm1hdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNMYWJlbEZvcm1hdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLmxhYmVsLmZvcm1hdCA9IFwicGVyY2VudFwiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlc2V0QXV0b0xhYmVsRm9ybWF0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2hhc0xhYmVsRm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9vcHRpb25zLmxhYmVsLmZvcm1hdFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBnZXRNdWx0aXBsZUF4ZXNTcGFjaW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5tdWx0aXBsZUF4ZXNTcGFjaW5nIHx8IDBcclxuICAgIH0sXHJcbiAgICBnZXRUaWNrc1ZhbHVlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWFqb3JUaWNrc1ZhbHVlczogY29udmVydFRpY2tzVG9WYWx1ZXModGhpcy5fbWFqb3JUaWNrcyksXHJcbiAgICAgICAgICAgIG1pbm9yVGlja3NWYWx1ZXM6IGNvbnZlcnRUaWNrc1RvVmFsdWVzKHRoaXMuX21pbm9yVGlja3MpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGVzdGltYXRlVGlja0ludGVydmFsOiBmdW5jdGlvbihjYW52YXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNhbnZhcyhjYW52YXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aWNrSW50ZXJ2YWwgIT09IHRoaXMuX2dldFRpY2tzKHRoaXMuX2dldFZpZXdwb3J0UmFuZ2UoKSwgX25vb3AsIHRydWUpLnRpY2tJbnRlcnZhbFxyXG4gICAgfSxcclxuICAgIHNldFRpY2tzOiBmdW5jdGlvbih0aWNrcykge1xyXG4gICAgICAgIHZhciBtYWpvcnMgPSB0aWNrcy5tYWpvclRpY2tzIHx8IFtdO1xyXG4gICAgICAgIHRoaXMuX21ham9yVGlja3MgPSBtYWpvcnMubWFwKGNyZWF0ZU1ham9yVGljayh0aGlzLCB0aGlzLl9yZW5kZXJlciwgdGhpcy5fZ2V0U2tpcHBlZENhdGVnb3J5KG1ham9ycykpKTtcclxuICAgICAgICB0aGlzLl9taW5vclRpY2tzID0gKHRpY2tzLm1pbm9yVGlja3MgfHwgW10pLm1hcChjcmVhdGVNaW5vclRpY2sodGhpcywgdGhpcy5fcmVuZGVyZXIpKTtcclxuICAgICAgICB0aGlzLl9pc1N5bmNocm9uaXplZCA9IHRydWVcclxuICAgIH0sXHJcbiAgICBfYWRqdXN0RGl2aXNpb25GYWN0b3I6IGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICAgIHJldHVybiB2YWxcclxuICAgIH0sXHJcbiAgICBfZ2V0VGlja3M6IGZ1bmN0aW9uKHZpZXdQb3J0LCBpbmNpZGVudE9jY3VycmVkLCBza2lwVGlja0dlbmVyYXRpb24pIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnM7XHJcbiAgICAgICAgdmFyIGN1c3RvbVRpY2tzID0gb3B0aW9ucy5jdXN0b21UaWNrcztcclxuICAgICAgICB2YXIgY3VzdG9tTWlub3JUaWNrcyA9IG9wdGlvbnMuY3VzdG9tTWlub3JUaWNrcztcclxuICAgICAgICByZXR1cm4gZ2V0VGlja0dlbmVyYXRvcihvcHRpb25zLCBpbmNpZGVudE9jY3VycmVkIHx8IHRoaXMuX2luY2lkZW50T2NjdXJyZWQsIHNraXBUaWNrR2VuZXJhdGlvbiwgdGhpcy5fdHJhbnNsYXRvci5nZXRCdXNpbmVzc1JhbmdlKCkuaXNFbXB0eSgpLCB0aGlzLl9hZGp1c3REaXZpc2lvbkZhY3Rvci5iaW5kKHRoaXMpLCB2aWV3UG9ydCkoe1xyXG4gICAgICAgICAgICBtaW46IHZpZXdQb3J0Lm1pblZpc2libGUsXHJcbiAgICAgICAgICAgIG1heDogdmlld1BvcnQubWF4VmlzaWJsZSxcclxuICAgICAgICAgICAgY2F0ZWdvcmllczogdmlld1BvcnQuY2F0ZWdvcmllcyxcclxuICAgICAgICAgICAgaXNTcGFjZWRNYXJnaW46IHZpZXdQb3J0LmlzU3BhY2VkTWFyZ2luXHJcbiAgICAgICAgfSwgdGhpcy5fZ2V0U2NyZWVuRGVsdGEoKSwgb3B0aW9ucy50aWNrSW50ZXJ2YWwsIFwiaWdub3JlXCIgPT09IG9wdGlvbnMubGFiZWwub3ZlcmxhcHBpbmdCZWhhdmlvciB8fCBvcHRpb25zLmZvcmNlVXNlclRpY2tJbnRlcnZhbCwge1xyXG4gICAgICAgICAgICBtYWpvcnM6IGN1c3RvbVRpY2tzLFxyXG4gICAgICAgICAgICBtaW5vcnM6IGN1c3RvbU1pbm9yVGlja3NcclxuICAgICAgICB9LCBvcHRpb25zLm1pbm9yVGlja0ludGVydmFsLCBvcHRpb25zLm1pbm9yVGlja0NvdW50LCB0aGlzLl9pbml0aWFsQnJlYWtzKVxyXG4gICAgfSxcclxuICAgIF9jcmVhdGVUaWNrc0FuZExhYmVsRm9ybWF0OiBmdW5jdGlvbihyYW5nZSwgaW5jaWRlbnRPY2N1cnJlZCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICB2YXIgdGlja3MgPSB0aGlzLl9nZXRUaWNrcyhyYW5nZSwgaW5jaWRlbnRPY2N1cnJlZCwgZmFsc2UpO1xyXG4gICAgICAgIGlmICghcmFuZ2UuaXNFbXB0eSgpICYmIG9wdGlvbnMudHlwZSA9PT0gY29uc3RhbnRzLmRpc2NyZXRlICYmIFwiZGF0ZXRpbWVcIiA9PT0gb3B0aW9ucy5kYXRhVHlwZSAmJiAhdGhpcy5faGFzTGFiZWxGb3JtYXQgJiYgdGlja3MudGlja3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMubGFiZWwuZm9ybWF0ID0gZm9ybWF0SGVscGVyLmdldERhdGVGb3JtYXRCeVRpY2tzKHRpY2tzLnRpY2tzKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGlja3NcclxuICAgIH0sXHJcbiAgICBnZXRBZ2dyZWdhdGlvbkluZm8odXNlQWxsQWdncmVnYXRlZFBvaW50cywgcmFuZ2UpIHtcclxuICAgICAgICB2YXIgX3Zpc3VhbFJhbmdlJHN0YXJ0VmFsLCBfdmlzdWFsUmFuZ2UkZW5kVmFsdWUsIF90aGF0JF9zZXJpZXNEYXRhO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICB2YXIgbWFyZ2luT3B0aW9ucyA9IHRoaXMuX21hcmdpbk9wdGlvbnM7XHJcbiAgICAgICAgdmFyIGJ1c2luZXNzUmFuZ2UgPSBuZXcgUmFuZ2UodGhpcy5nZXRUcmFuc2xhdG9yKCkuZ2V0QnVzaW5lc3NSYW5nZSgpKS5hZGRSYW5nZShyYW5nZSk7XHJcbiAgICAgICAgdmFyIHZpc3VhbFJhbmdlID0gdGhpcy5nZXRWaWV3cG9ydCgpO1xyXG4gICAgICAgIHZhciBtaW5WaXNpYmxlID0gbnVsbCAhPT0gKF92aXN1YWxSYW5nZSRzdGFydFZhbCA9IG51bGwgPT09IHZpc3VhbFJhbmdlIHx8IHZvaWQgMCA9PT0gdmlzdWFsUmFuZ2UgPyB2b2lkIDAgOiB2aXN1YWxSYW5nZS5zdGFydFZhbHVlKSAmJiB2b2lkIDAgIT09IF92aXN1YWxSYW5nZSRzdGFydFZhbCA/IF92aXN1YWxSYW5nZSRzdGFydFZhbCA6IGJ1c2luZXNzUmFuZ2UubWluVmlzaWJsZTtcclxuICAgICAgICB2YXIgbWF4VmlzaWJsZSA9IG51bGwgIT09IChfdmlzdWFsUmFuZ2UkZW5kVmFsdWUgPSBudWxsID09PSB2aXN1YWxSYW5nZSB8fCB2b2lkIDAgPT09IHZpc3VhbFJhbmdlID8gdm9pZCAwIDogdmlzdWFsUmFuZ2UuZW5kVmFsdWUpICYmIHZvaWQgMCAhPT0gX3Zpc3VhbFJhbmdlJGVuZFZhbHVlID8gX3Zpc3VhbFJhbmdlJGVuZFZhbHVlIDogYnVzaW5lc3NSYW5nZS5tYXhWaXNpYmxlO1xyXG4gICAgICAgIHZhciB0aWNrcyA9IFtdO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09IGNvbnN0YW50cy5kaXNjcmV0ZSAmJiBvcHRpb25zLmFnZ3JlZ2F0ZUJ5Q2F0ZWdvcnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZUJ5Q2F0ZWdvcnk6IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWdncmVnYXRpb25JbnRlcnZhbCA9IG9wdGlvbnMuYWdncmVnYXRpb25JbnRlcnZhbDtcclxuICAgICAgICB2YXIgYWdncmVnYXRpb25Hcm91cFdpZHRoID0gb3B0aW9ucy5hZ2dyZWdhdGlvbkdyb3VwV2lkdGg7XHJcbiAgICAgICAgaWYgKCFhZ2dyZWdhdGlvbkdyb3VwV2lkdGggJiYgbWFyZ2luT3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAobWFyZ2luT3B0aW9ucy5jaGVja0ludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGlvbkdyb3VwV2lkdGggPSBvcHRpb25zLmF4aXNEaXZpc2lvbkZhY3RvclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXJnaW5PcHRpb25zLnNpemVQb2ludE5vcm1hbFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGlvbkdyb3VwV2lkdGggPSBNYXRoLm1pbihtYXJnaW5PcHRpb25zLnNpemVQb2ludE5vcm1hbFN0YXRlLCBvcHRpb25zLmF4aXNEaXZpc2lvbkZhY3RvcilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWluSW50ZXJ2YWwgPSAhb3B0aW9ucy5hZ2dyZWdhdGlvbkdyb3VwV2lkdGggJiYgIWFnZ3JlZ2F0aW9uSW50ZXJ2YWwgJiYgcmFuZ2UuaW50ZXJ2YWw7XHJcbiAgICAgICAgdmFyIGdlbmVyYXRlVGlja3MgPSBjb25maWd1cmVHZW5lcmF0b3Iob3B0aW9ucywgYWdncmVnYXRpb25Hcm91cFdpZHRoLCBidXNpbmVzc1JhbmdlLCB0aGlzLl9nZXRTY3JlZW5EZWx0YSgpLCBtaW5JbnRlcnZhbCk7XHJcbiAgICAgICAgdmFyIHRpY2tJbnRlcnZhbCA9IGdlbmVyYXRlVGlja3MoYWdncmVnYXRpb25JbnRlcnZhbCwgdHJ1ZSwgbWluVmlzaWJsZSwgbWF4VmlzaWJsZSwgbnVsbCA9PT0gKF90aGF0JF9zZXJpZXNEYXRhID0gdGhpcy5fc2VyaWVzRGF0YSkgfHwgdm9pZCAwID09PSBfdGhhdCRfc2VyaWVzRGF0YSA/IHZvaWQgMCA6IF90aGF0JF9zZXJpZXNEYXRhLmJyZWFrcykudGlja0ludGVydmFsO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnR5cGUgIT09IGNvbnN0YW50cy5kaXNjcmV0ZSkge1xyXG4gICAgICAgICAgICB2YXIgbWluID0gdXNlQWxsQWdncmVnYXRlZFBvaW50cyA/IGJ1c2luZXNzUmFuZ2UubWluIDogbWluVmlzaWJsZTtcclxuICAgICAgICAgICAgdmFyIG1heCA9IHVzZUFsbEFnZ3JlZ2F0ZWRQb2ludHMgPyBidXNpbmVzc1JhbmdlLm1heCA6IG1heFZpc2libGU7XHJcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQobWluKSAmJiBpc0RlZmluZWQobWF4KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFkZCA9IGdldEFkZEZ1bmN0aW9uKHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlOiBvcHRpb25zLmxvZ2FyaXRobUJhc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc1R5cGU6IG9wdGlvbnMudHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogb3B0aW9ucy5kYXRhVHlwZVxyXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbWluO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IG1heDtcclxuICAgICAgICAgICAgICAgIGlmICghdXNlQWxsQWdncmVnYXRlZFBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhNaW5EaXN0YW5jZSA9IE1hdGgubWF4KHRoaXMuY2FsY3VsYXRlSW50ZXJ2YWwobWF4LCBtaW4pLCBcImRhdGV0aW1lXCIgPT09IG9wdGlvbnMuZGF0YVR5cGUgPyBkYXRlVXRpbHMuZGF0ZVRvTWlsbGlzZWNvbmRzKHRpY2tJbnRlcnZhbCkgOiB0aWNrSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gYWRkKG1pbiwgbWF4TWluRGlzdGFuY2UsIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBhZGQobWF4LCBtYXhNaW5EaXN0YW5jZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgPCBidXNpbmVzc1JhbmdlLm1pbiA/IGJ1c2luZXNzUmFuZ2UubWluIDogc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBlbmQgPiBidXNpbmVzc1JhbmdlLm1heCA/IGJ1c2luZXNzUmFuZ2UubWF4IDogZW5kO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJyZWFrcyA9IHRoaXMuX2dldFNjYWxlQnJlYWtzKG9wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5WaXNpYmxlOiBzdGFydCxcclxuICAgICAgICAgICAgICAgICAgICBtYXhWaXNpYmxlOiBlbmRcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMuX3NlcmllcywgdGhpcy5pc0FyZ3VtZW50QXhpcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRCcmVha3MgPSB0aGlzLl9maWx0ZXJCcmVha3MoYnJlYWtzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluVmlzaWJsZTogc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4VmlzaWJsZTogZW5kXHJcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmJyZWFrU3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKHRpY2tJbnRlcnZhbCwgZmFsc2UsIHN0YXJ0LCBlbmQsIGZpbHRlcmVkQnJlYWtzKS50aWNrc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2FnZ3JlZ2F0aW9uSW50ZXJ2YWwgPSB0aWNrSW50ZXJ2YWw7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaW50ZXJ2YWw6IHRpY2tJbnRlcnZhbCxcclxuICAgICAgICAgICAgdGlja3M6IHRpY2tzXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldFRpY2tJbnRlcnZhbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGlja0ludGVydmFsXHJcbiAgICB9LFxyXG4gICAgZ2V0QWdncmVnYXRpb25JbnRlcnZhbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWdncmVnYXRpb25JbnRlcnZhbFxyXG4gICAgfSxcclxuICAgIGNyZWF0ZVRpY2tzOiBmdW5jdGlvbihjYW52YXMpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhhdC5fcmVuZGVyZXI7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGF0Ll9vcHRpb25zO1xyXG4gICAgICAgIGlmICghY2FudmFzKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGF0Ll9pc1N5bmNocm9uaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoYXQudXBkYXRlQ2FudmFzKGNhbnZhcyk7XHJcbiAgICAgICAgdmFyIHJhbmdlID0gdGhhdC5fZ2V0Vmlld3BvcnRSYW5nZSgpO1xyXG4gICAgICAgIHRoYXQuX2luaXRpYWxCcmVha3MgPSByYW5nZS5icmVha3MgPSB0aGlzLl9zZXJpZXNEYXRhLmJyZWFrcyA9IHRoYXQuX2ZpbHRlckJyZWFrcyh0aGlzLl9zZXJpZXNEYXRhLnVzZXJCcmVha3MsIHJhbmdlLCBvcHRpb25zLmJyZWFrU3R5bGUpO1xyXG4gICAgICAgIHRoYXQuX2VzdGltYXRlZFRpY2tJbnRlcnZhbCA9IHRoYXQuX2dldFRpY2tzKHRoYXQuYWRqdXN0Vmlld3BvcnQodGhpcy5fc2VyaWVzRGF0YSksIF9ub29wLCB0cnVlKS50aWNrSW50ZXJ2YWw7XHJcbiAgICAgICAgdmFyIG1hcmdpbnMgPSB0aGlzLl9jYWxjdWxhdGVWYWx1ZU1hcmdpbnMoKTtcclxuICAgICAgICByYW5nZS5hZGRSYW5nZSh7XHJcbiAgICAgICAgICAgIG1pblZpc2libGU6IG1hcmdpbnMubWluVmFsdWUsXHJcbiAgICAgICAgICAgIG1heFZpc2libGU6IG1hcmdpbnMubWF4VmFsdWUsXHJcbiAgICAgICAgICAgIGlzU3BhY2VkTWFyZ2luOiBtYXJnaW5zLmlzU3BhY2VkTWFyZ2luXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHRpY2tzID0gdGhhdC5fY3JlYXRlVGlja3NBbmRMYWJlbEZvcm1hdChyYW5nZSk7XHJcbiAgICAgICAgdmFyIGJvdW5kYXJ5VGlja3MgPSB0aGF0Ll9nZXRCb3VuZGFyeVRpY2tzKHRpY2tzLnRpY2tzLCB0aGF0Ll9nZXRWaWV3cG9ydFJhbmdlKCkpO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dDdXN0b21Cb3VuZGFyeVRpY2tzICYmIGJvdW5kYXJ5VGlja3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoYXQuX2JvdW5kYXJ5VGlja3MgPSBbYm91bmRhcnlUaWNrc1swXV0ubWFwKGNyZWF0ZUJvdW5kYXJ5VGljayh0aGF0LCByZW5kZXJlciwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICBpZiAoYm91bmRhcnlUaWNrcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9ib3VuZGFyeVRpY2tzID0gdGhhdC5fYm91bmRhcnlUaWNrcy5jb25jYXQoW2JvdW5kYXJ5VGlja3NbMV1dLm1hcChjcmVhdGVCb3VuZGFyeVRpY2sodGhhdCwgcmVuZGVyZXIsIGZhbHNlKSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGF0Ll9ib3VuZGFyeVRpY2tzID0gW11cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1pbm9ycyA9ICh0aWNrcy5taW5vclRpY2tzIHx8IFtdKS5maWx0ZXIoKGZ1bmN0aW9uKG1pbm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhYm91bmRhcnlUaWNrcy5zb21lKChmdW5jdGlvbihib3VuZGFyeSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlT2YoYm91bmRhcnkpID09PSB2YWx1ZU9mKG1pbm9yKVxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhhdC5fdGlja0ludGVydmFsID0gdGlja3MudGlja0ludGVydmFsO1xyXG4gICAgICAgIHRoYXQuX21pbm9yVGlja0ludGVydmFsID0gdGlja3MubWlub3JUaWNrSW50ZXJ2YWw7XHJcbiAgICAgICAgdmFyIG9sZE1ham9yVGlja3MgPSB0aGF0Ll9tYWpvclRpY2tzIHx8IFtdO1xyXG4gICAgICAgIHZhciBtYWpvclRpY2tzQnlWYWx1ZXMgPSBvbGRNYWpvclRpY2tzLnJlZHVjZSgociwgdCkgPT4ge1xyXG4gICAgICAgICAgICByW3QudmFsdWUudmFsdWVPZigpXSA9IHQ7XHJcbiAgICAgICAgICAgIHJldHVybiByXHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgICAgIHZhciBzYW1lVHlwZSA9IHR5cGUodGlja3MudGlja3NbMF0pID09PSB0eXBlKG9sZE1ham9yVGlja3NbMF0gJiYgb2xkTWFqb3JUaWNrc1swXS52YWx1ZSk7XHJcbiAgICAgICAgdmFyIHNraXBwZWRDYXRlZ29yeSA9IHRoYXQuX2dldFNraXBwZWRDYXRlZ29yeSh0aWNrcy50aWNrcyk7XHJcbiAgICAgICAgdmFyIG1ham9yVGlja3MgPSB0aWNrcy50aWNrcy5tYXAodiA9PiB7XHJcbiAgICAgICAgICAgIHZhciB0aWNrID0gbWFqb3JUaWNrc0J5VmFsdWVzW3YudmFsdWVPZigpXTtcclxuICAgICAgICAgICAgaWYgKHRpY2sgJiYgc2FtZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYWpvclRpY2tzQnlWYWx1ZXNbdi52YWx1ZU9mKCldO1xyXG4gICAgICAgICAgICAgICAgdGljay5zZXRTa2lwcGVkQ2F0ZWdvcnkoc2tpcHBlZENhdGVnb3J5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aWNrXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlTWFqb3JUaWNrKHRoYXQsIHJlbmRlcmVyLCBza2lwcGVkQ2F0ZWdvcnkpKHYpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGF0Ll9tYWpvclRpY2tzID0gbWFqb3JUaWNrcztcclxuICAgICAgICB2YXIgb2xkTWlub3JUaWNrcyA9IHRoYXQuX21pbm9yVGlja3MgfHwgW107XHJcbiAgICAgICAgdGhhdC5fbWlub3JUaWNrcyA9IG1pbm9ycy5tYXAoKHYsIGkpID0+IHtcclxuICAgICAgICAgICAgdmFyIG1pbm9yVGljayA9IG9sZE1pbm9yVGlja3NbaV07XHJcbiAgICAgICAgICAgIGlmIChtaW5vclRpY2spIHtcclxuICAgICAgICAgICAgICAgIG1pbm9yVGljay51cGRhdGVWYWx1ZSh2KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaW5vclRpY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTWlub3JUaWNrKHRoYXQsIHJlbmRlcmVyKSh2KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoYXQuX3RpY2tzVG9SZW1vdmUgPSBPYmplY3Qua2V5cyhtYWpvclRpY2tzQnlWYWx1ZXMpLm1hcChrID0+IG1ham9yVGlja3NCeVZhbHVlc1trXSkuY29uY2F0KG9sZE1pbm9yVGlja3Muc2xpY2UodGhhdC5fbWlub3JUaWNrcy5sZW5ndGgsIG9sZE1pbm9yVGlja3MubGVuZ3RoKSk7XHJcbiAgICAgICAgdGhhdC5fdGlja3NUb1JlbW92ZS5mb3JFYWNoKHQgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX3QkbGFiZWw7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsID09PSAoX3QkbGFiZWwgPSB0LmxhYmVsKSB8fCB2b2lkIDAgPT09IF90JGxhYmVsID8gdm9pZCAwIDogX3QkbGFiZWwucmVtb3ZlVGl0bGUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aWNrcy5icmVha3MpIHtcclxuICAgICAgICAgICAgdGhhdC5fc2VyaWVzRGF0YS5icmVha3MgPSB0aWNrcy5icmVha3NcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhhdC5fcmVpbml0VHJhbnNsYXRvcih0aGF0Ll9nZXRWaWV3cG9ydFJhbmdlKCkpXHJcbiAgICB9LFxyXG4gICAgX3JlaW5pdFRyYW5zbGF0b3I6IGZ1bmN0aW9uKHJhbmdlKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0b3IgPSB0aGlzLl90cmFuc2xhdG9yO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc1N5bmNocm9uaXplZCkge1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhbnNsYXRvci51cGRhdGVCdXNpbmVzc1JhbmdlKHJhbmdlKVxyXG4gICAgfSxcclxuICAgIF9nZXRWaWV3cG9ydFJhbmdlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkanVzdFZpZXdwb3J0KHRoaXMuX3Nlcmllc0RhdGEpXHJcbiAgICB9LFxyXG4gICAgc2V0TWFyZ2luT3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX21hcmdpbk9wdGlvbnMgPSBvcHRpb25zXHJcbiAgICB9LFxyXG4gICAgZ2V0TWFyZ2luT3B0aW9ucygpIHtcclxuICAgICAgICB2YXIgX3RoaXMkX21hcmdpbk9wdGlvbnM7XHJcbiAgICAgICAgcmV0dXJuIG51bGwgIT09IChfdGhpcyRfbWFyZ2luT3B0aW9ucyA9IHRoaXMuX21hcmdpbk9wdGlvbnMpICYmIHZvaWQgMCAhPT0gX3RoaXMkX21hcmdpbk9wdGlvbnMgPyBfdGhpcyRfbWFyZ2luT3B0aW9ucyA6IHt9XHJcbiAgICB9LFxyXG4gICAgX2NhbGN1bGF0ZVJhbmdlSW50ZXJ2YWw6IGZ1bmN0aW9uKGludGVydmFsKSB7XHJcbiAgICAgICAgdmFyIGlzRGF0ZVRpbWUgPSBcImRhdGV0aW1lXCIgPT09IHRoaXMuX29wdGlvbnMuZGF0YVR5cGU7XHJcbiAgICAgICAgdmFyIG1pbkFyZ3MgPSBbXTtcclxuICAgICAgICB2YXIgYWRkVG9BcmdzID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgaXNEZWZpbmVkKHZhbHVlKSAmJiBtaW5BcmdzLnB1c2goaXNEYXRlVGltZSA/IGRhdGVVdGlscy5kYXRlVG9NaWxsaXNlY29uZHModmFsdWUpIDogdmFsdWUpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBhZGRUb0FyZ3ModGhpcy5fdGlja0ludGVydmFsKTtcclxuICAgICAgICBhZGRUb0FyZ3ModGhpcy5fZXN0aW1hdGVkVGlja0ludGVydmFsKTtcclxuICAgICAgICBpc0RlZmluZWQoaW50ZXJ2YWwpICYmIG1pbkFyZ3MucHVzaChpbnRlcnZhbCk7XHJcbiAgICAgICAgYWRkVG9BcmdzKHRoaXMuX2FnZ3JlZ2F0aW9uSW50ZXJ2YWwpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVXb3JrV2Vla0ludGVydmFsKF9taW4uYXBwbHkodGhpcywgbWluQXJncykpXHJcbiAgICB9LFxyXG4gICAgX2NhbGN1bGF0ZVdvcmtXZWVrSW50ZXJ2YWwoYnVzaW5lc3NJbnRlcnZhbCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICBpZiAoXCJkYXRldGltZVwiID09PSBvcHRpb25zLmRhdGFUeXBlICYmIG9wdGlvbnMud29ya2RheXNPbmx5ICYmIGJ1c2luZXNzSW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgdmFyIHdvcmtXZWVrID0gb3B0aW9ucy53b3JrV2Vlay5sZW5ndGggKiBkYXRlSW50ZXJ2YWxzLmRheTtcclxuICAgICAgICAgICAgdmFyIHdlZWtlbmQgPSBkYXRlSW50ZXJ2YWxzLndlZWsgLSB3b3JrV2VlaztcclxuICAgICAgICAgICAgaWYgKHdvcmtXZWVrICE9PSBidXNpbmVzc0ludGVydmFsICYmIHdlZWtlbmQgPCBidXNpbmVzc0ludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2Vla2VuZHNDb3VudCA9IE1hdGguY2VpbChidXNpbmVzc0ludGVydmFsIC8gZGF0ZUludGVydmFscy53ZWVrKTtcclxuICAgICAgICAgICAgICAgIGJ1c2luZXNzSW50ZXJ2YWwgLT0gd2Vla2VuZCAqIHdlZWtlbmRzQ291bnRcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh3ZWVrZW5kID49IGJ1c2luZXNzSW50ZXJ2YWwgJiYgYnVzaW5lc3NJbnRlcnZhbCA+IGRhdGVJbnRlcnZhbHMuZGF5KSB7XHJcbiAgICAgICAgICAgICAgICBidXNpbmVzc0ludGVydmFsID0gZGF0ZUludGVydmFscy5kYXlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnVzaW5lc3NJbnRlcnZhbFxyXG4gICAgfSxcclxuICAgIF9nZXRDb252ZXJ0SW50ZXJ2YWxDb2VmZmljaWVudChpbnRlcnZhbEluUHgsIHNjcmVlbkRlbHRhKSB7XHJcbiAgICAgICAgdmFyIHJhdGlvT2ZDYW52YXNSYW5nZSA9IHRoaXMuX3RyYW5zbGF0b3IucmF0aW9PZkNhbnZhc1JhbmdlKCk7XHJcbiAgICAgICAgcmV0dXJuIHJhdGlvT2ZDYW52YXNSYW5nZSAvIChyYXRpb09mQ2FudmFzUmFuZ2UgKiBzY3JlZW5EZWx0YSAvIChpbnRlcnZhbEluUHggKyBzY3JlZW5EZWx0YSkpXHJcbiAgICB9LFxyXG4gICAgX2NhbGN1bGF0ZVZhbHVlTWFyZ2lucyh0aWNrcykge1xyXG4gICAgICAgIHRoaXMuX3Jlc2V0TWFyZ2lucygpO1xyXG4gICAgICAgIHZhciBtYXJnaW5zID0gdGhpcy5nZXRNYXJnaW5PcHRpb25zKCk7XHJcbiAgICAgICAgdmFyIG1hcmdpblNpemUgPSAobWFyZ2lucy5zaXplIHx8IDApIC8gMjtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnM7XHJcbiAgICAgICAgdmFyIGRhdGFSYW5nZSA9IHRoaXMuX2dldFZpZXdwb3J0UmFuZ2UoKTtcclxuICAgICAgICB2YXIgdmlld1BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KCk7XHJcbiAgICAgICAgdmFyIHNjcmVlbkRlbHRhID0gdGhpcy5fZ2V0U2NyZWVuRGVsdGEoKTtcclxuICAgICAgICB2YXIgaXNEaXNjcmV0ZSA9IC0xICE9PSAob3B0aW9ucy50eXBlIHx8IFwiXCIpLmluZGV4T2YoY29uc3RhbnRzLmRpc2NyZXRlKTtcclxuICAgICAgICB2YXIgdmFsdWVNYXJnaW5zRW5hYmxlZCA9IG9wdGlvbnMudmFsdWVNYXJnaW5zRW5hYmxlZCAmJiAhaXNEaXNjcmV0ZSAmJiAhdGhpcy5jdXN0b21Qb3NpdGlvbklzQm91bmRhcnlPcnRob2dvbmFsQXhpcygpO1xyXG4gICAgICAgIHZhciB0cmFuc2xhdG9yID0gdGhpcy5fdHJhbnNsYXRvcjtcclxuICAgICAgICB2YXIgbWluVmFsdWVNYXJnaW4gPSBvcHRpb25zLm1pblZhbHVlTWFyZ2luO1xyXG4gICAgICAgIHZhciBtYXhWYWx1ZU1hcmdpbiA9IG9wdGlvbnMubWF4VmFsdWVNYXJnaW47XHJcbiAgICAgICAgdmFyIG1pblBhZGRpbmcgPSAwO1xyXG4gICAgICAgIHZhciBtYXhQYWRkaW5nID0gMDtcclxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAwO1xyXG4gICAgICAgIHZhciByYW5nZUludGVydmFsO1xyXG4gICAgICAgIGlmIChkYXRhUmFuZ2Uuc3R1YkRhdGEgfHwgIXNjcmVlbkRlbHRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdGFydFBhZGRpbmc6IDAsXHJcbiAgICAgICAgICAgICAgICBlbmRQYWRkaW5nOiAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBcmd1bWVudEF4aXMgJiYgbWFyZ2lucy5jaGVja0ludGVydmFsKSB7XHJcbiAgICAgICAgICAgIHJhbmdlSW50ZXJ2YWwgPSB0aGlzLl9jYWxjdWxhdGVSYW5nZUludGVydmFsKGRhdGFSYW5nZS5pbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIHZhciBweEludGVydmFsID0gdHJhbnNsYXRvci5nZXRJbnRlcnZhbChyYW5nZUludGVydmFsKTtcclxuICAgICAgICAgICAgaWYgKGlzRmluaXRlKHB4SW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IE1hdGguY2VpbChweEludGVydmFsIC8gKDIgKiB0aGlzLl9nZXRDb252ZXJ0SW50ZXJ2YWxDb2VmZmljaWVudChweEludGVydmFsLCBzY3JlZW5EZWx0YSkpKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2VJbnRlcnZhbCA9IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWluUGVyY2VudFBhZGRpbmc7XHJcbiAgICAgICAgdmFyIG1heFBlcmNlbnRQYWRkaW5nO1xyXG4gICAgICAgIHZhciBtYXhQYWRkaW5nVmFsdWUgPSBzY3JlZW5EZWx0YSAqIE1BWF9NQVJHSU5fVkFMVUUgLyAyO1xyXG4gICAgICAgIGlmICh2YWx1ZU1hcmdpbnNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQobWluVmFsdWVNYXJnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5QZXJjZW50UGFkZGluZyA9IGlzRmluaXRlKG1pblZhbHVlTWFyZ2luKSA/IG1pblZhbHVlTWFyZ2luIDogMFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzQXJndW1lbnRBeGlzICYmIG1hcmdpbnMuY2hlY2tJbnRlcnZhbCAmJiB2YWx1ZU9mKGRhdGFSYW5nZS5taW5WaXNpYmxlKSA+IDAgJiYgdmFsdWVPZihkYXRhUmFuZ2UubWluVmlzaWJsZSkgPT09IHZhbHVlT2YoZGF0YVJhbmdlLm1pbikpIHtcclxuICAgICAgICAgICAgICAgIG1pblBhZGRpbmcgPSBNSU5fQkFSX01BUkdJTlxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWluUGFkZGluZyA9IE1hdGgubWF4KG1hcmdpblNpemUsIGludGVydmFsKTtcclxuICAgICAgICAgICAgICAgIG1pblBhZGRpbmcgPSBNYXRoLm1pbihtYXhQYWRkaW5nVmFsdWUsIG1pblBhZGRpbmcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChtYXhWYWx1ZU1hcmdpbikpIHtcclxuICAgICAgICAgICAgICAgIG1heFBlcmNlbnRQYWRkaW5nID0gaXNGaW5pdGUobWF4VmFsdWVNYXJnaW4pID8gbWF4VmFsdWVNYXJnaW4gOiAwXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNBcmd1bWVudEF4aXMgJiYgbWFyZ2lucy5jaGVja0ludGVydmFsICYmIHZhbHVlT2YoZGF0YVJhbmdlLm1heFZpc2libGUpIDwgMCAmJiB2YWx1ZU9mKGRhdGFSYW5nZS5tYXhWaXNpYmxlKSA9PT0gdmFsdWVPZihkYXRhUmFuZ2UubWF4KSkge1xyXG4gICAgICAgICAgICAgICAgbWF4UGFkZGluZyA9IE1JTl9CQVJfTUFSR0lOXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtYXhQYWRkaW5nID0gTWF0aC5tYXgobWFyZ2luU2l6ZSwgaW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgbWF4UGFkZGluZyA9IE1hdGgubWluKG1heFBhZGRpbmdWYWx1ZSwgbWF4UGFkZGluZylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGVyY2VudFN0aWNrID0gbWFyZ2lucy5wZXJjZW50U3RpY2sgJiYgIXRoaXMuaXNBcmd1bWVudEF4aXM7XHJcbiAgICAgICAgaWYgKHBlcmNlbnRTdGljaykge1xyXG4gICAgICAgICAgICBpZiAoMSA9PT0gX2FicyhkYXRhUmFuZ2UubWF4KSkge1xyXG4gICAgICAgICAgICAgICAgbWF4UGFkZGluZyA9IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoMSA9PT0gX2FicyhkYXRhUmFuZ2UubWluKSkge1xyXG4gICAgICAgICAgICAgICAgbWluUGFkZGluZyA9IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FudmFzU3RhcnRFbmQgPSB0aGlzLl9nZXRDYW52YXNTdGFydEVuZCgpO1xyXG4gICAgICAgIHZhciBjb21tb25NYXJnaW4gPSAxICsgKG1pblBlcmNlbnRQYWRkaW5nIHx8IDApICsgKG1heFBlcmNlbnRQYWRkaW5nIHx8IDApO1xyXG4gICAgICAgIHZhciBzY3JlZW5EZWx0YVdpdGhNYXJnaW5zID0gKHNjcmVlbkRlbHRhIC0gbWluUGFkZGluZyAtIG1heFBhZGRpbmcpIC8gY29tbW9uTWFyZ2luIHx8IHNjcmVlbkRlbHRhO1xyXG4gICAgICAgIGlmICh2b2lkIDAgIT09IG1pblBlcmNlbnRQYWRkaW5nIHx8IHZvaWQgMCAhPT0gbWF4UGVyY2VudFBhZGRpbmcpIHtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gbWluUGVyY2VudFBhZGRpbmcpIHtcclxuICAgICAgICAgICAgICAgIG1pblBhZGRpbmcgPSBzY3JlZW5EZWx0YVdpdGhNYXJnaW5zICogbWluUGVyY2VudFBhZGRpbmdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBtYXhQZXJjZW50UGFkZGluZykge1xyXG4gICAgICAgICAgICAgICAgbWF4UGFkZGluZyA9IHNjcmVlbkRlbHRhV2l0aE1hcmdpbnMgKiBtYXhQZXJjZW50UGFkZGluZ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaW5WYWx1ZTtcclxuICAgICAgICB2YXIgbWF4VmFsdWU7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudHlwZSAhPT0gY29uc3RhbnRzLmRpc2NyZXRlICYmIHRpY2tzICYmIHRpY2tzLmxlbmd0aCA+IDEgJiYgIW9wdGlvbnMuc2tpcFZpZXdwb3J0RXh0ZW5kaW5nICYmICF2aWV3UG9ydC5hY3Rpb24gJiYgZmFsc2UgIT09IG9wdGlvbnMuZW5kT25UaWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aWNrcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFRpY2tQb3NpdGlvbiA9IHRyYW5zbGF0b3IudHJhbnNsYXRlKHRpY2tzWzBdLnZhbHVlKTtcclxuICAgICAgICAgICAgdmFyIGxhc3RUaWNrUG9zaXRpb24gPSB0cmFuc2xhdG9yLnRyYW5zbGF0ZSh0aWNrc1tsZW5ndGggLSAxXS52YWx1ZSk7XHJcbiAgICAgICAgICAgIHZhciBpbnZlcnRNdWx0aXBsaWVyID0gZmlyc3RUaWNrUG9zaXRpb24gPiBsYXN0VGlja1Bvc2l0aW9uID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB2YXIgbWluVGlja1BhZGRpbmcgPSBfbWF4KGludmVydE11bHRpcGxpZXIgKiAoY2FudmFzU3RhcnRFbmQuc3RhcnQgLSBmaXJzdFRpY2tQb3NpdGlvbiksIDApO1xyXG4gICAgICAgICAgICB2YXIgbWF4VGlja1BhZGRpbmcgPSBfbWF4KGludmVydE11bHRpcGxpZXIgKiAobGFzdFRpY2tQb3NpdGlvbiAtIGNhbnZhc1N0YXJ0RW5kLmVuZCksIDApO1xyXG4gICAgICAgICAgICBpZiAobWluVGlja1BhZGRpbmcgPiBtaW5QYWRkaW5nIHx8IG1heFRpY2tQYWRkaW5nID4gbWF4UGFkZGluZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbW1vblBhZGRpbmcgPSBtYXhUaWNrUGFkZGluZyArIG1pblRpY2tQYWRkaW5nO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvZWZmID0gdGhpcy5fZ2V0Q29udmVydEludGVydmFsQ29lZmZpY2llbnQoY29tbW9uUGFkZGluZywgc2NyZWVuRGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pblRpY2tQYWRkaW5nID49IG1pblBhZGRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IHRpY2tzWzBdLnZhbHVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4VGlja1BhZGRpbmcgPj0gbWF4UGFkZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFZhbHVlID0gdGlja3NbbGVuZ3RoIC0gMV0udmFsdWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1pblBhZGRpbmcgPSBfbWF4KG1pblRpY2tQYWRkaW5nLCBtaW5QYWRkaW5nKSAvIGNvZWZmO1xyXG4gICAgICAgICAgICAgICAgbWF4UGFkZGluZyA9IF9tYXgobWF4VGlja1BhZGRpbmcsIG1heFBhZGRpbmcpIC8gY29lZmZcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtaW5QZXJjZW50UGFkZGluZyA9IHZvaWQgMCA9PT0gbWluUGVyY2VudFBhZGRpbmcgPyBtaW5QYWRkaW5nIC8gc2NyZWVuRGVsdGFXaXRoTWFyZ2lucyA6IG1pblBlcmNlbnRQYWRkaW5nO1xyXG4gICAgICAgIG1heFBlcmNlbnRQYWRkaW5nID0gdm9pZCAwID09PSBtYXhQZXJjZW50UGFkZGluZyA/IG1heFBhZGRpbmcgLyBzY3JlZW5EZWx0YVdpdGhNYXJnaW5zIDogbWF4UGVyY2VudFBhZGRpbmc7XHJcbiAgICAgICAgaWYgKCFpc0Rpc2NyZXRlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2xhdG9yLmlzSW52ZXJ0ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9taW5WYWx1ZSwgX21heFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgbWluVmFsdWUgPSBudWxsICE9PSAoX21pblZhbHVlID0gbWluVmFsdWUpICYmIHZvaWQgMCAhPT0gX21pblZhbHVlID8gX21pblZhbHVlIDogdHJhbnNsYXRvci5mcm9tKGNhbnZhc1N0YXJ0RW5kLnN0YXJ0ICsgc2NyZWVuRGVsdGEgKiBtaW5QZXJjZW50UGFkZGluZywgLTEpO1xyXG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBudWxsICE9PSAoX21heFZhbHVlID0gbWF4VmFsdWUpICYmIHZvaWQgMCAhPT0gX21heFZhbHVlID8gX21heFZhbHVlIDogdHJhbnNsYXRvci5mcm9tKGNhbnZhc1N0YXJ0RW5kLmVuZCAtIHNjcmVlbkRlbHRhICogbWF4UGVyY2VudFBhZGRpbmcsIDEpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX21pblZhbHVlMiwgX21heFZhbHVlMjtcclxuICAgICAgICAgICAgICAgIG1pblZhbHVlID0gbnVsbCAhPT0gKF9taW5WYWx1ZTIgPSBtaW5WYWx1ZSkgJiYgdm9pZCAwICE9PSBfbWluVmFsdWUyID8gX21pblZhbHVlMiA6IHRyYW5zbGF0b3IuZnJvbShjYW52YXNTdGFydEVuZC5zdGFydCAtIHNjcmVlbkRlbHRhICogbWluUGVyY2VudFBhZGRpbmcsIC0xKTtcclxuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gbnVsbCAhPT0gKF9tYXhWYWx1ZTIgPSBtYXhWYWx1ZSkgJiYgdm9pZCAwICE9PSBfbWF4VmFsdWUyID8gX21heFZhbHVlMiA6IHRyYW5zbGF0b3IuZnJvbShjYW52YXNTdGFydEVuZC5lbmQgKyBzY3JlZW5EZWx0YSAqIG1heFBlcmNlbnRQYWRkaW5nLCAxKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgIGNvcnJlY3RlZE1pbjogY29ycmVjdGVkTWluLFxyXG4gICAgICAgICAgICBjb3JyZWN0ZWRNYXg6IGNvcnJlY3RlZE1heCxcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGVuZFxyXG4gICAgICAgIH0gPSB0aGlzLmdldENvcnJlY3RlZFZhbHVlc1RvWmVybyhtaW5WYWx1ZSwgbWF4VmFsdWUpO1xyXG4gICAgICAgIG1pblBhZGRpbmcgPSBudWxsICE9PSBzdGFydCAmJiB2b2lkIDAgIT09IHN0YXJ0ID8gc3RhcnQgOiBtaW5QYWRkaW5nO1xyXG4gICAgICAgIG1heFBhZGRpbmcgPSBudWxsICE9PSBlbmQgJiYgdm9pZCAwICE9PSBlbmQgPyBlbmQgOiBtYXhQYWRkaW5nO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXJ0UGFkZGluZzogdHJhbnNsYXRvci5pc0ludmVydGVkKCkgPyBtYXhQYWRkaW5nIDogbWluUGFkZGluZyxcclxuICAgICAgICAgICAgZW5kUGFkZGluZzogdHJhbnNsYXRvci5pc0ludmVydGVkKCkgPyBtaW5QYWRkaW5nIDogbWF4UGFkZGluZyxcclxuICAgICAgICAgICAgbWluVmFsdWU6IG51bGwgIT09IGNvcnJlY3RlZE1pbiAmJiB2b2lkIDAgIT09IGNvcnJlY3RlZE1pbiA/IGNvcnJlY3RlZE1pbiA6IG1pblZhbHVlLFxyXG4gICAgICAgICAgICBtYXhWYWx1ZTogbnVsbCAhPT0gY29ycmVjdGVkTWF4ICYmIHZvaWQgMCAhPT0gY29ycmVjdGVkTWF4ID8gY29ycmVjdGVkTWF4IDogbWF4VmFsdWUsXHJcbiAgICAgICAgICAgIGludGVydmFsOiByYW5nZUludGVydmFsLFxyXG4gICAgICAgICAgICBpc1NwYWNlZE1hcmdpbjogbWluUGFkZGluZyA9PT0gbWF4UGFkZGluZyAmJiAwICE9PSBtaW5QYWRkaW5nXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldENvcnJlY3RlZFZhbHVlc1RvWmVybyhtaW5WYWx1ZSwgbWF4VmFsdWUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0b3IgPSB0aGF0Ll90cmFuc2xhdG9yO1xyXG4gICAgICAgIHZhciBjYW52YXNTdGFydEVuZCA9IHRoYXQuX2dldENhbnZhc1N0YXJ0RW5kKCk7XHJcbiAgICAgICAgdmFyIGRhdGFSYW5nZSA9IHRoYXQuX2dldFZpZXdwb3J0UmFuZ2UoKTtcclxuICAgICAgICB2YXIgc2NyZWVuRGVsdGEgPSB0aGF0Ll9nZXRTY3JlZW5EZWx0YSgpO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhhdC5fb3B0aW9ucztcclxuICAgICAgICB2YXIgc3RhcnQ7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICB2YXIgY29ycmVjdGVkTWluO1xyXG4gICAgICAgIHZhciBjb3JyZWN0ZWRNYXg7XHJcbiAgICAgICAgdmFyIGNvcnJlY3RaZXJvTGV2ZWwgPSAobWluUG9pbnQsIG1heFBvaW50KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBtaW5FeHBlY3RlZFBhZGRpbmcgPSBfYWJzKGNhbnZhc1N0YXJ0RW5kLnN0YXJ0IC0gbWluUG9pbnQpO1xyXG4gICAgICAgICAgICB2YXIgbWF4RXhwZWN0ZWRQYWRkaW5nID0gX2FicyhjYW52YXNTdGFydEVuZC5lbmQgLSBtYXhQb2ludCk7XHJcbiAgICAgICAgICAgIHZhciBjb2VmZiA9IHRoYXQuX2dldENvbnZlcnRJbnRlcnZhbENvZWZmaWNpZW50KG1pbkV4cGVjdGVkUGFkZGluZyArIG1heEV4cGVjdGVkUGFkZGluZywgc2NyZWVuRGVsdGEpO1xyXG4gICAgICAgICAgICBzdGFydCA9IG1pbkV4cGVjdGVkUGFkZGluZyAvIGNvZWZmO1xyXG4gICAgICAgICAgICBlbmQgPSBtYXhFeHBlY3RlZFBhZGRpbmcgLyBjb2VmZlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCF0aGF0LmlzQXJndW1lbnRBeGlzICYmIFwiZGF0ZXRpbWVcIiAhPT0gb3B0aW9ucy5kYXRhVHlwZSkge1xyXG4gICAgICAgICAgICBpZiAobWluVmFsdWUgKiBkYXRhUmFuZ2UubWluIDw9IDAgJiYgbWluVmFsdWUgKiBkYXRhUmFuZ2UubWluVmlzaWJsZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb3JyZWN0WmVyb0xldmVsKHRyYW5zbGF0b3IudHJhbnNsYXRlKDApLCB0cmFuc2xhdG9yLnRyYW5zbGF0ZShtYXhWYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgY29ycmVjdGVkTWluID0gMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXhWYWx1ZSAqIGRhdGFSYW5nZS5tYXggPD0gMCAmJiBtYXhWYWx1ZSAqIGRhdGFSYW5nZS5tYXhWaXNpYmxlIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGNvcnJlY3RaZXJvTGV2ZWwodHJhbnNsYXRvci50cmFuc2xhdGUobWluVmFsdWUpLCB0cmFuc2xhdG9yLnRyYW5zbGF0ZSgwKSk7XHJcbiAgICAgICAgICAgICAgICBjb3JyZWN0ZWRNYXggPSAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnQ6IGlzRmluaXRlKHN0YXJ0KSA/IHN0YXJ0IDogbnVsbCxcclxuICAgICAgICAgICAgZW5kOiBpc0Zpbml0ZShlbmQpID8gZW5kIDogbnVsbCxcclxuICAgICAgICAgICAgY29ycmVjdGVkTWluOiBjb3JyZWN0ZWRNaW4sXHJcbiAgICAgICAgICAgIGNvcnJlY3RlZE1heDogY29ycmVjdGVkTWF4XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGFwcGx5TWFyZ2lucygpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNTeW5jaHJvbml6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtYXJnaW5zID0gdGhpcy5fY2FsY3VsYXRlVmFsdWVNYXJnaW5zKHRoaXMuX21ham9yVGlja3MpO1xyXG4gICAgICAgIHZhciBjYW52YXMgPSBleHRlbmQoe30sIHRoaXMuX2NhbnZhcywge1xyXG4gICAgICAgICAgICBzdGFydFBhZGRpbmc6IG1hcmdpbnMuc3RhcnRQYWRkaW5nLFxyXG4gICAgICAgICAgICBlbmRQYWRkaW5nOiBtYXJnaW5zLmVuZFBhZGRpbmdcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl90cmFuc2xhdG9yLnVwZGF0ZUNhbnZhcyh0aGlzLl9wcm9jZXNzQ2FudmFzKGNhbnZhcykpO1xyXG4gICAgICAgIGlmIChpc0Zpbml0ZShtYXJnaW5zLmludGVydmFsKSkge1xyXG4gICAgICAgICAgICB2YXIgYnIgPSB0aGlzLl90cmFuc2xhdG9yLmdldEJ1c2luZXNzUmFuZ2UoKTtcclxuICAgICAgICAgICAgYnIuYWRkUmFuZ2Uoe1xyXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IG1hcmdpbnMuaW50ZXJ2YWxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0b3IudXBkYXRlQnVzaW5lc3NSYW5nZShicilcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3Jlc2V0TWFyZ2luczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fcmVpbml0VHJhbnNsYXRvcih0aGlzLl9nZXRWaWV3cG9ydFJhbmdlKCkpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jYW52YXMpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRvci51cGRhdGVDYW52YXModGhpcy5fcHJvY2Vzc0NhbnZhcyh0aGlzLl9jYW52YXMpKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfY3JlYXRlQ29uc3RhbnRMaW5lcygpIHtcclxuICAgICAgICB2YXIgY29uc3RhbnRMaW5lcyA9ICh0aGlzLl9vcHRpb25zLmNvbnN0YW50TGluZXMgfHwgW10pLm1hcChvID0+IGNyZWF0ZUNvbnN0YW50TGluZSh0aGlzLCBvKSk7XHJcbiAgICAgICAgdGhpcy5fb3V0c2lkZUNvbnN0YW50TGluZXMgPSBjb25zdGFudExpbmVzLmZpbHRlcihsID0+IFwib3V0c2lkZVwiID09PSBsLmxhYmVsUG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuX2luc2lkZUNvbnN0YW50TGluZXMgPSBjb25zdGFudExpbmVzLmZpbHRlcihsID0+IFwiaW5zaWRlXCIgPT09IGwubGFiZWxQb3NpdGlvbilcclxuICAgIH0sXHJcbiAgICBkcmF3OiBmdW5jdGlvbihjYW52YXMsIGJvcmRlck9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xyXG4gICAgICAgIHRoYXQuYm9yZGVyT3B0aW9ucyA9IGJvcmRlck9wdGlvbnMgfHwge1xyXG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhhdC5fcmVzZXRNYXJnaW5zKCk7XHJcbiAgICAgICAgdGhhdC5jcmVhdGVUaWNrcyhjYW52YXMpO1xyXG4gICAgICAgIHRoYXQuYXBwbHlNYXJnaW5zKCk7XHJcbiAgICAgICAgdGhhdC5fY2xlYXJBeGlzR3JvdXBzKCk7XHJcbiAgICAgICAgaW5pdFRpY2tDb29yZHModGhhdC5fbWFqb3JUaWNrcyk7XHJcbiAgICAgICAgaW5pdFRpY2tDb29yZHModGhhdC5fbWlub3JUaWNrcyk7XHJcbiAgICAgICAgaW5pdFRpY2tDb29yZHModGhhdC5fYm91bmRhcnlUaWNrcyk7XHJcbiAgICAgICAgdGhhdC5fYXhpc0dyb3VwLmFwcGVuZCh0aGF0Ll9heGVzQ29udGFpbmVyR3JvdXApO1xyXG4gICAgICAgIHRoYXQuX2RyYXdBeGlzKCk7XHJcbiAgICAgICAgdGhhdC5fZHJhd1RpdGxlKCk7XHJcbiAgICAgICAgZHJhd1RpY2tNYXJrcyh0aGF0Ll9tYWpvclRpY2tzLCBvcHRpb25zLnRpY2spO1xyXG4gICAgICAgIGRyYXdUaWNrTWFya3ModGhhdC5fbWlub3JUaWNrcywgb3B0aW9ucy5taW5vclRpY2spO1xyXG4gICAgICAgIGRyYXdUaWNrTWFya3ModGhhdC5fYm91bmRhcnlUaWNrcywgb3B0aW9ucy50aWNrKTtcclxuICAgICAgICB2YXIgZHJhd0dyaWRMaW5lID0gdGhhdC5fZ2V0R3JpZExpbmVEcmF3ZXIoKTtcclxuICAgICAgICBkcmF3R3JpZHModGhhdC5fbWFqb3JUaWNrcywgZHJhd0dyaWRMaW5lKTtcclxuICAgICAgICBkcmF3R3JpZHModGhhdC5fbWlub3JUaWNrcywgZHJhd0dyaWRMaW5lKTtcclxuICAgICAgICBjYWxsQWN0aW9uKHRoYXQuX21ham9yVGlja3MsIFwiZHJhd0xhYmVsXCIsIHRoYXQuX2dldFZpZXdwb3J0UmFuZ2UoKSwgdGhhdC5fZ2V0VGVtcGxhdGUob3B0aW9ucy5sYWJlbC50ZW1wbGF0ZSkpO1xyXG4gICAgICAgIHRoYXQuX3RlbXBsYXRlc1JlbmRlcmVkICYmIHRoYXQuX3RlbXBsYXRlc1JlbmRlcmVkLnJlamVjdCgpO1xyXG4gICAgICAgIHRoYXQuX3RlbXBsYXRlc1JlbmRlcmVkID0gbmV3IERlZmVycmVkO1xyXG4gICAgICAgIHRoYXQuX21ham9yVGlja3MuZm9yRWFjaCgoZnVuY3Rpb24odGljaykge1xyXG4gICAgICAgICAgICB0aWNrLmxhYmVsUm90YXRpb25BbmdsZSA9IDA7XHJcbiAgICAgICAgICAgIHRpY2subGFiZWxBbGlnbm1lbnQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHRpY2subGFiZWxPZmZzZXQgPSAwXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGNhbGxBY3Rpb24odGhhdC5fb3V0c2lkZUNvbnN0YW50TGluZXMuY29uY2F0KHRoYXQuX2luc2lkZUNvbnN0YW50TGluZXMpLCBcImRyYXdcIik7XHJcbiAgICAgICAgY2FsbEFjdGlvbih0aGF0Ll9zdHJpcHMsIFwiZHJhd1wiKTtcclxuICAgICAgICB0aGF0Ll9kYXRlTWFya2VycyA9IHRoYXQuX2RyYXdEYXRlTWFya2VycygpIHx8IFtdO1xyXG4gICAgICAgIHRoYXQuX3N0cmlwTGFiZWxBeGVzR3JvdXAgJiYgdGhhdC5fYXhpc1N0cmlwTGFiZWxHcm91cC5hcHBlbmQodGhhdC5fc3RyaXBMYWJlbEF4ZXNHcm91cCk7XHJcbiAgICAgICAgdGhhdC5fZ3JpZENvbnRhaW5lckdyb3VwICYmIHRoYXQuX2F4aXNHcmlkR3JvdXAuYXBwZW5kKHRoYXQuX2dyaWRDb250YWluZXJHcm91cCk7XHJcbiAgICAgICAgdGhhdC5fc3RyaXBzR3JvdXAgJiYgdGhhdC5fYXhpc1N0cmlwR3JvdXAuYXBwZW5kKHRoYXQuX3N0cmlwc0dyb3VwKTtcclxuICAgICAgICB0aGF0Ll9sYWJlbHNBeGVzR3JvdXAgJiYgdGhhdC5fYXhpc0VsZW1lbnRzR3JvdXAuYXBwZW5kKHRoYXQuX2xhYmVsc0F4ZXNHcm91cCk7XHJcbiAgICAgICAgaWYgKHRoYXQuX2NvbnN0YW50TGluZXNHcm91cCkge1xyXG4gICAgICAgICAgICB0aGF0Ll9heGlzQ29uc3RhbnRMaW5lR3JvdXBzLmFib3ZlLmluc2lkZS5hcHBlbmQodGhhdC5fY29uc3RhbnRMaW5lc0dyb3VwLmFib3ZlKTtcclxuICAgICAgICAgICAgdGhhdC5fYXhpc0NvbnN0YW50TGluZUdyb3Vwcy5hYm92ZS5vdXRzaWRlMS5hcHBlbmQodGhhdC5fY29uc3RhbnRMaW5lc0dyb3VwLmFib3ZlKTtcclxuICAgICAgICAgICAgdGhhdC5fYXhpc0NvbnN0YW50TGluZUdyb3Vwcy5hYm92ZS5vdXRzaWRlMi5hcHBlbmQodGhhdC5fY29uc3RhbnRMaW5lc0dyb3VwLmFib3ZlKTtcclxuICAgICAgICAgICAgdGhhdC5fYXhpc0NvbnN0YW50TGluZUdyb3Vwcy51bmRlci5pbnNpZGUuYXBwZW5kKHRoYXQuX2NvbnN0YW50TGluZXNHcm91cC51bmRlcik7XHJcbiAgICAgICAgICAgIHRoYXQuX2F4aXNDb25zdGFudExpbmVHcm91cHMudW5kZXIub3V0c2lkZTEuYXBwZW5kKHRoYXQuX2NvbnN0YW50TGluZXNHcm91cC51bmRlcik7XHJcbiAgICAgICAgICAgIHRoYXQuX2F4aXNDb25zdGFudExpbmVHcm91cHMudW5kZXIub3V0c2lkZTIuYXBwZW5kKHRoYXQuX2NvbnN0YW50TGluZXNHcm91cC51bmRlcilcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhhdC5fbWVhc3VyZVRpdGxlKCk7XHJcbiAgICAgICAgbWVhc3VyZUxhYmVscyh0aGF0Ll9tYWpvclRpY2tzKTtcclxuICAgICAgICAhb3B0aW9ucy5sYWJlbC50ZW1wbGF0ZSAmJiB0aGF0Ll9hcHBseVdvcmRXcmFwKCk7XHJcbiAgICAgICAgbWVhc3VyZUxhYmVscyh0aGF0Ll9vdXRzaWRlQ29uc3RhbnRMaW5lcyk7XHJcbiAgICAgICAgbWVhc3VyZUxhYmVscyh0aGF0Ll9pbnNpZGVDb25zdGFudExpbmVzKTtcclxuICAgICAgICBtZWFzdXJlTGFiZWxzKHRoYXQuX3N0cmlwcyk7XHJcbiAgICAgICAgbWVhc3VyZUxhYmVscyh0aGF0Ll9kYXRlTWFya2Vycyk7XHJcbiAgICAgICAgdGhhdC5fYWRqdXN0Q29uc3RhbnRMaW5lTGFiZWxzKHRoYXQuX2luc2lkZUNvbnN0YW50TGluZXMpO1xyXG4gICAgICAgIHRoYXQuX2FkanVzdFN0cmlwTGFiZWxzKCk7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoYXQuX2NvbnN0YW50TGFiZWxPZmZzZXQgPSB0aGF0Ll9hZGp1c3RDb25zdGFudExpbmVMYWJlbHModGhhdC5fb3V0c2lkZUNvbnN0YW50TGluZXMpO1xyXG4gICAgICAgIGlmICghdGhhdC5fdHJhbnNsYXRvci5nZXRCdXNpbmVzc1JhbmdlKCkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHRoYXQuX3NldExhYmVsc1BsYWNlbWVudCgpO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGF0Ll9hZGp1c3RMYWJlbHMob2Zmc2V0KVxyXG4gICAgICAgIH1cclxuICAgICAgICB3aGVuLmFwcGx5KHRoaXMsIHRoYXQuX21ham9yVGlja3MubWFwKHRpY2sgPT4gdGljay5nZXRUZW1wbGF0ZURlZmVycmVkKCkpKS5kb25lKCgpID0+IHtcclxuICAgICAgICAgICAgdGhhdC5fdGVtcGxhdGVzUmVuZGVyZWQucmVzb2x2ZSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb2Zmc2V0ID0gdGhhdC5fYWRqdXN0RGF0ZU1hcmtlcnMob2Zmc2V0KTtcclxuICAgICAgICB0aGF0Ll9hZGp1c3RUaXRsZShvZmZzZXQpXHJcbiAgICB9LFxyXG4gICAgZ2V0VGVtcGxhdGVzRGVmKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZXNSZW5kZXJlZFxyXG4gICAgfSxcclxuICAgIHNldFJlbmRlcmVkU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICB0aGlzLl9kcmF3biA9IHN0YXRlXHJcbiAgICB9LFxyXG4gICAgaXNSZW5kZXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZHJhd25cclxuICAgIH0sXHJcbiAgICBfYXBwbHlXb3JkV3JhcCgpIHtcclxuICAgICAgICB2YXIgY29udmVydGVkVGlja0ludGVydmFsO1xyXG4gICAgICAgIHZhciB0ZXh0V2lkdGg7XHJcbiAgICAgICAgdmFyIHRleHRIZWlnaHQ7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xyXG4gICAgICAgIHZhciB0aWNrSW50ZXJ2YWwgPSB0aGlzLl90aWNrSW50ZXJ2YWw7XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0aWNrSW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgIGNvbnZlcnRlZFRpY2tJbnRlcnZhbCA9IHRoaXMuZ2V0VHJhbnNsYXRvcigpLmdldEludGVydmFsKFwiZGF0ZXRpbWVcIiA9PT0gb3B0aW9ucy5kYXRhVHlwZSA/IGRhdGVVdGlscy5kYXRlVG9NaWxsaXNlY29uZHModGlja0ludGVydmFsKSA6IHRpY2tJbnRlcnZhbClcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRpc3BsYXlNb2RlID0gdGhpcy5fdmFsaWRhdGVEaXNwbGF5TW9kZShvcHRpb25zLmxhYmVsLmRpc3BsYXlNb2RlKTtcclxuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdNb2RlID0gdGhpcy5fdmFsaWRhdGVPdmVybGFwcGluZ01vZGUob3B0aW9ucy5sYWJlbC5vdmVybGFwcGluZ0JlaGF2aW9yLCBkaXNwbGF5TW9kZSk7XHJcbiAgICAgICAgdmFyIHdvcmRXcmFwTW9kZSA9IG9wdGlvbnMubGFiZWwud29yZFdyYXAgfHwgXCJub25lXCI7XHJcbiAgICAgICAgdmFyIG92ZXJmbG93TW9kZSA9IG9wdGlvbnMubGFiZWwudGV4dE92ZXJmbG93IHx8IFwibm9uZVwiO1xyXG4gICAgICAgIGlmICgoXCJub25lXCIgIT09IHdvcmRXcmFwTW9kZSB8fCBcIm5vbmVcIiAhPT0gb3ZlcmZsb3dNb2RlKSAmJiBkaXNwbGF5TW9kZSAhPT0gUk9UQVRFICYmIG92ZXJsYXBwaW5nTW9kZSAhPT0gUk9UQVRFICYmIFwiYXV0b1wiICE9PSBvdmVybGFwcGluZ01vZGUpIHtcclxuICAgICAgICAgICAgdmFyIHVzZWZ1bFNwYWNlID0gaXNEZWZpbmVkKG9wdGlvbnMucGxhY2Vob2xkZXJTaXplKSA/IG9wdGlvbnMucGxhY2Vob2xkZXJTaXplIC0gb3B0aW9ucy5sYWJlbC5pbmRlbnRGcm9tQXhpcyA6IHZvaWQgMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dFdpZHRoID0gY29udmVydGVkVGlja0ludGVydmFsO1xyXG4gICAgICAgICAgICAgICAgdGV4dEhlaWdodCA9IHVzZWZ1bFNwYWNlXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSB1c2VmdWxTcGFjZTtcclxuICAgICAgICAgICAgICAgIHRleHRIZWlnaHQgPSBjb252ZXJ0ZWRUaWNrSW50ZXJ2YWxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29ycmVjdEJ5V2lkdGggPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGNvcnJlY3RCeUhlaWdodCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGV4dFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWFqb3JUaWNrcy5zb21lKHRpY2sgPT4gdGljay5sYWJlbEJCb3gud2lkdGggPiB0ZXh0V2lkdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ycmVjdEJ5V2lkdGggPSB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRleHRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYWpvclRpY2tzLnNvbWUodGljayA9PiB0aWNrLmxhYmVsQkJveC5oZWlnaHQgPiB0ZXh0SGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcnJlY3RCeUhlaWdodCA9IHRydWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29ycmVjdEJ5V2lkdGggfHwgY29ycmVjdEJ5SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWpvclRpY2tzLmZvckVhY2godGljayA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGljay5sYWJlbCAmJiB0aWNrLmxhYmVsLnNldE1heFNpemUodGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCBvcHRpb25zLmxhYmVsKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBtZWFzdXJlTGFiZWxzKHRoaXMuX21ham9yVGlja3MpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX21lYXN1cmVUaXRsZTogX25vb3AsXHJcbiAgICBhbmltYXRlKCkge1xyXG4gICAgICAgIGNhbGxBY3Rpb24odGhpcy5fbWFqb3JUaWNrcywgXCJhbmltYXRlTGFiZWxzXCIpXHJcbiAgICB9LFxyXG4gICAgdXBkYXRlU2l6ZShjYW52YXMsIGFuaW1hdGUpIHtcclxuICAgICAgICB2YXIgdXBkYXRlVGl0bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IHRydWU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDYW52YXMoY2FudmFzKTtcclxuICAgICAgICBpZiAodXBkYXRlVGl0bGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hlY2tUaXRsZU92ZXJmbG93KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX21lYXN1cmVUaXRsZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUaXRsZUNvb3JkcygpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlaW5pdFRyYW5zbGF0b3IodGhpcy5fZ2V0Vmlld3BvcnRSYW5nZSgpKTtcclxuICAgICAgICB0aGlzLmFwcGx5TWFyZ2lucygpO1xyXG4gICAgICAgIHZhciBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuX2ZpcnN0RHJhd2luZyAmJiBhbmltYXRlO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICBpbml0VGlja0Nvb3Jkcyh0aGlzLl9tYWpvclRpY2tzKTtcclxuICAgICAgICBpbml0VGlja0Nvb3Jkcyh0aGlzLl9taW5vclRpY2tzKTtcclxuICAgICAgICBpbml0VGlja0Nvb3Jkcyh0aGlzLl9ib3VuZGFyeVRpY2tzKTtcclxuICAgICAgICBpZiAodGhpcy5fcmVzZXRBcHBseWluZ0FuaW1hdGlvbiAmJiAhdGhpcy5fZmlyc3REcmF3aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0U3RhcnRDb29yZGluYXRlcygpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsZWFuVXBJbnZhbGlkVGlja3ModGhpcy5fbWFqb3JUaWNrcyk7XHJcbiAgICAgICAgY2xlYW5VcEludmFsaWRUaWNrcyh0aGlzLl9taW5vclRpY2tzKTtcclxuICAgICAgICBjbGVhblVwSW52YWxpZFRpY2tzKHRoaXMuX2JvdW5kYXJ5VGlja3MpO1xyXG4gICAgICAgIGlmICh0aGlzLl9heGlzRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVBeGlzRWxlbWVudFBvc2l0aW9uKClcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlVGlja3NQb3NpdGlvbih0aGlzLl9tYWpvclRpY2tzLCBvcHRpb25zLnRpY2ssIGFuaW1hdGlvbkVuYWJsZWQpO1xyXG4gICAgICAgIHVwZGF0ZVRpY2tzUG9zaXRpb24odGhpcy5fbWlub3JUaWNrcywgb3B0aW9ucy5taW5vclRpY2ssIGFuaW1hdGlvbkVuYWJsZWQpO1xyXG4gICAgICAgIHVwZGF0ZVRpY2tzUG9zaXRpb24odGhpcy5fYm91bmRhcnlUaWNrcywgb3B0aW9ucy50aWNrKTtcclxuICAgICAgICBjYWxsQWN0aW9uKHRoaXMuX21ham9yVGlja3MsIFwidXBkYXRlTGFiZWxQb3NpdGlvblwiLCBhbmltYXRpb25FbmFibGVkKTtcclxuICAgICAgICB0aGlzLl9vdXRzaWRlQ29uc3RhbnRMaW5lcy5jb25jYXQodGhpcy5faW5zaWRlQ29uc3RhbnRMaW5lcyB8fCBbXSkuZm9yRWFjaChsID0+IGwudXBkYXRlUG9zaXRpb24oYW5pbWF0aW9uRW5hYmxlZCkpO1xyXG4gICAgICAgIGNhbGxBY3Rpb24odGhpcy5fc3RyaXBzLCBcInVwZGF0ZVBvc2l0aW9uXCIsIGFuaW1hdGlvbkVuYWJsZWQpO1xyXG4gICAgICAgIHVwZGF0ZUdyaWRzUG9zaXRpb24odGhpcy5fbWFqb3JUaWNrcywgYW5pbWF0aW9uRW5hYmxlZCk7XHJcbiAgICAgICAgdXBkYXRlR3JpZHNQb3NpdGlvbih0aGlzLl9taW5vclRpY2tzLCBhbmltYXRpb25FbmFibGVkKTtcclxuICAgICAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xyXG4gICAgICAgICAgICBjYWxsQWN0aW9uKHRoaXMuX3RpY2tzVG9SZW1vdmUgfHwgW10sIFwiZmFkZU91dEVsZW1lbnRzXCIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucHJlcGFyZUFuaW1hdGlvbigpO1xyXG4gICAgICAgIHRoaXMuX3RpY2tzVG9SZW1vdmUgPSBudWxsO1xyXG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNsYXRvci5nZXRCdXNpbmVzc1JhbmdlKCkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0RHJhd2luZyA9IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Jlc2V0QXBwbHlpbmdBbmltYXRpb24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl91cGRhdGVMYWJlbHNQb3NpdGlvbigpXHJcbiAgICB9LFxyXG4gICAgX3VwZGF0ZUxhYmVsc1Bvc2l0aW9uOiBfbm9vcCxcclxuICAgIHByZXBhcmVBbmltYXRpb24oKSB7XHJcbiAgICAgICAgdmFyIGFjdGlvbiA9IFwic2F2ZUNvb3Jkc1wiO1xyXG4gICAgICAgIGNhbGxBY3Rpb24odGhpcy5fbWFqb3JUaWNrcywgYWN0aW9uKTtcclxuICAgICAgICBjYWxsQWN0aW9uKHRoaXMuX21pbm9yVGlja3MsIGFjdGlvbik7XHJcbiAgICAgICAgY2FsbEFjdGlvbih0aGlzLl9pbnNpZGVDb25zdGFudExpbmVzLCBhY3Rpb24pO1xyXG4gICAgICAgIGNhbGxBY3Rpb24odGhpcy5fb3V0c2lkZUNvbnN0YW50TGluZXMsIGFjdGlvbik7XHJcbiAgICAgICAgY2FsbEFjdGlvbih0aGlzLl9zdHJpcHMsIGFjdGlvbilcclxuICAgIH0sXHJcbiAgICBfcmVzZXRTdGFydENvb3JkaW5hdGVzKCkge1xyXG4gICAgICAgIHZhciBhY3Rpb24gPSBcInJlc2V0Q29vcmRpbmF0ZXNcIjtcclxuICAgICAgICBjYWxsQWN0aW9uKHRoaXMuX21ham9yVGlja3MsIGFjdGlvbik7XHJcbiAgICAgICAgY2FsbEFjdGlvbih0aGlzLl9taW5vclRpY2tzLCBhY3Rpb24pO1xyXG4gICAgICAgIGNhbGxBY3Rpb24odGhpcy5faW5zaWRlQ29uc3RhbnRMaW5lcywgYWN0aW9uKTtcclxuICAgICAgICBjYWxsQWN0aW9uKHRoaXMuX291dHNpZGVDb25zdGFudExpbmVzLCBhY3Rpb24pO1xyXG4gICAgICAgIGNhbGxBY3Rpb24odGhpcy5fc3RyaXBzLCBhY3Rpb24pXHJcbiAgICB9LFxyXG4gICAgYXBwbHlDbGlwUmVjdHM6IGZ1bmN0aW9uKGVsZW1lbnRzQ2xpcElELCBjYW52YXNDbGlwSUQpIHtcclxuICAgICAgICB0aGlzLl9heGlzR3JvdXAuYXR0cih7XHJcbiAgICAgICAgICAgIFwiY2xpcC1wYXRoXCI6IGNhbnZhc0NsaXBJRFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2F4aXNTdHJpcEdyb3VwLmF0dHIoe1xyXG4gICAgICAgICAgICBcImNsaXAtcGF0aFwiOiBlbGVtZW50c0NsaXBJRFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2F4aXNFbGVtZW50c0dyb3VwLmF0dHIoe1xyXG4gICAgICAgICAgICBcImNsaXAtcGF0aFwiOiBjYW52YXNDbGlwSURcclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuICAgIF92YWxpZGF0ZVZpc3VhbFJhbmdlKG9wdGlvblZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHJhbmdlID0gZ2V0Vml6UmFuZ2VPYmplY3Qob3B0aW9uVmFsdWUpO1xyXG4gICAgICAgIGlmICh2b2lkIDAgIT09IHJhbmdlLnN0YXJ0VmFsdWUpIHtcclxuICAgICAgICAgICAgcmFuZ2Uuc3RhcnRWYWx1ZSA9IHRoaXMudmFsaWRhdGVVbml0KHJhbmdlLnN0YXJ0VmFsdWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2b2lkIDAgIT09IHJhbmdlLmVuZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJhbmdlLmVuZFZhbHVlID0gdGhpcy52YWxpZGF0ZVVuaXQocmFuZ2UuZW5kVmFsdWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb252ZXJ0VmlzdWFsUmFuZ2VPYmplY3QocmFuZ2UsICFfaXNBcnJheShvcHRpb25WYWx1ZSkpXHJcbiAgICB9LFxyXG4gICAgX3ZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucy53aG9sZVJhbmdlID0gdGhpcy5fdmFsaWRhdGVWaXN1YWxSYW5nZShvcHRpb25zLndob2xlUmFuZ2UpO1xyXG4gICAgICAgIG9wdGlvbnMudmlzdWFsUmFuZ2UgPSBvcHRpb25zLl9jdXN0b21WaXN1YWxSYW5nZSA9IHRoaXMuX3ZhbGlkYXRlVmlzdWFsUmFuZ2Uob3B0aW9ucy5fY3VzdG9tVmlzdWFsUmFuZ2UpO1xyXG4gICAgICAgIHRoaXMuX3NldFZpc3VhbFJhbmdlKG9wdGlvbnMuX2N1c3RvbVZpc3VhbFJhbmdlKVxyXG4gICAgfSxcclxuICAgIHZhbGlkYXRlKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICB2YXIgZGF0YVR5cGUgPSB0aGlzLmlzQXJndW1lbnRBeGlzID8gb3B0aW9ucy5hcmd1bWVudFR5cGUgOiBvcHRpb25zLnZhbHVlVHlwZTtcclxuICAgICAgICB2YXIgcGFyc2VyID0gZGF0YVR5cGUgPyBnZXRQYXJzZXIoZGF0YVR5cGUpIDogZnVuY3Rpb24odW5pdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5pdFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICAgICAgb3B0aW9ucy5kYXRhVHlwZSA9IGRhdGFUeXBlO1xyXG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKVxyXG4gICAgfSxcclxuICAgIHJlc2V0VmlzdWFsUmFuZ2UoaXNTaWxlbnQpIHtcclxuICAgICAgICB0aGlzLl9zZXJpZXNEYXRhLm1pblZpc2libGUgPSB0aGlzLl9zZXJpZXNEYXRhLm1pbjtcclxuICAgICAgICB0aGlzLl9zZXJpZXNEYXRhLm1heFZpc2libGUgPSB0aGlzLl9zZXJpZXNEYXRhLm1heDtcclxuICAgICAgICB0aGlzLmhhbmRsZVpvb21pbmcoW251bGwsIG51bGxdLCB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiAhIWlzU2lsZW50LFxyXG4gICAgICAgICAgICBlbmQ6ICEhaXNTaWxlbnRcclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuICAgIF9zZXRWaXN1YWxSYW5nZSh2aXN1YWxSYW5nZSwgYWxsb3dQYXJ0aWFsVXBkYXRlKSB7XHJcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5hZGp1c3RSYW5nZShnZXRWaXpSYW5nZU9iamVjdCh2aXN1YWxSYW5nZSkpO1xyXG4gICAgICAgIGlmIChhbGxvd1BhcnRpYWxVcGRhdGUpIHtcclxuICAgICAgICAgICAgaXNEZWZpbmVkKHJhbmdlLnN0YXJ0VmFsdWUpICYmICh0aGlzLl92aWV3cG9ydC5zdGFydFZhbHVlID0gcmFuZ2Uuc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlzRGVmaW5lZChyYW5nZS5lbmRWYWx1ZSkgJiYgKHRoaXMuX3ZpZXdwb3J0LmVuZFZhbHVlID0gcmFuZ2UuZW5kVmFsdWUpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdmlld3BvcnQgPSByYW5nZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfYXBwbHlab29taW5nKHZpc3VhbFJhbmdlLCBhbGxvd1BhcnRpYWxVcGRhdGUpIHtcclxuICAgICAgICB0aGlzLl9yZXNldFZpc3VhbFJhbmdlT3B0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5fc2V0VmlzdWFsUmFuZ2UodmlzdWFsUmFuZ2UsIGFsbG93UGFydGlhbFVwZGF0ZSk7XHJcbiAgICAgICAgdmFyIHZpZXdQb3J0ID0gdGhpcy5nZXRWaWV3cG9ydCgpO1xyXG4gICAgICAgIHRoaXMuX3Nlcmllc0RhdGEudXNlckJyZWFrcyA9IHRoaXMuX2dldFNjYWxlQnJlYWtzKHRoaXMuX29wdGlvbnMsIHtcclxuICAgICAgICAgICAgbWluVmlzaWJsZTogdmlld1BvcnQuc3RhcnRWYWx1ZSxcclxuICAgICAgICAgICAgbWF4VmlzaWJsZTogdmlld1BvcnQuZW5kVmFsdWVcclxuICAgICAgICB9LCB0aGlzLl9zZXJpZXMsIHRoaXMuaXNBcmd1bWVudEF4aXMpO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zbGF0b3IudXBkYXRlQnVzaW5lc3NSYW5nZSh0aGlzLl9nZXRWaWV3cG9ydFJhbmdlKCkpXHJcbiAgICB9LFxyXG4gICAgZ2V0Wm9vbVN0YXJ0RXZlbnRBcmcoZXZlbnQsIGFjdGlvblR5cGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBheGlzOiB0aGlzLFxyXG4gICAgICAgICAgICByYW5nZTogdGhpcy52aXN1YWxSYW5nZSgpLFxyXG4gICAgICAgICAgICBjYW5jZWw6IGZhbHNlLFxyXG4gICAgICAgICAgICBldmVudDogZXZlbnQsXHJcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IGFjdGlvblR5cGVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2dldFpvb21FbmRFdmVudEFyZyhwcmV2aW91c1JhbmdlLCBldmVudCwgYWN0aW9uVHlwZSwgem9vbUZhY3Rvciwgc2hpZnQpIHtcclxuICAgICAgICB2YXIgbmV3UmFuZ2UgPSB0aGlzLnZpc3VhbFJhbmdlKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYXhpczogdGhpcyxcclxuICAgICAgICAgICAgcHJldmlvdXNSYW5nZTogcHJldmlvdXNSYW5nZSxcclxuICAgICAgICAgICAgcmFuZ2U6IG5ld1JhbmdlLFxyXG4gICAgICAgICAgICBjYW5jZWw6IGZhbHNlLFxyXG4gICAgICAgICAgICBldmVudDogZXZlbnQsXHJcbiAgICAgICAgICAgIGFjdGlvblR5cGU6IGFjdGlvblR5cGUsXHJcbiAgICAgICAgICAgIHpvb21GYWN0b3I6IHpvb21GYWN0b3IsXHJcbiAgICAgICAgICAgIHNoaWZ0OiBzaGlmdCxcclxuICAgICAgICAgICAgcmFuZ2VTdGFydDogbmV3UmFuZ2Uuc3RhcnRWYWx1ZSxcclxuICAgICAgICAgICAgcmFuZ2VFbmQ6IG5ld1JhbmdlLmVuZFZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldFpvb21Cb3VuZHMoKSB7XHJcbiAgICAgICAgdmFyIHdob2xlUmFuZ2UgPSBnZXRWaXpSYW5nZU9iamVjdCh0aGlzLl9vcHRpb25zLndob2xlUmFuZ2UpO1xyXG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0VHJhbnNsYXRvcigpLmdldEJ1c2luZXNzUmFuZ2UoKTtcclxuICAgICAgICB2YXIgc2Vjb25kUHJpb3JpdHlSYW5nZSA9IHtcclxuICAgICAgICAgICAgc3RhcnRWYWx1ZTogZ2V0Wm9vbUJvdW5kVmFsdWUodGhpcy5faW5pdFJhbmdlLnN0YXJ0VmFsdWUsIHJhbmdlLm1pbiksXHJcbiAgICAgICAgICAgIGVuZFZhbHVlOiBnZXRab29tQm91bmRWYWx1ZSh0aGlzLl9pbml0UmFuZ2UuZW5kVmFsdWUsIHJhbmdlLm1heClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXJ0VmFsdWU6IGdldFpvb21Cb3VuZFZhbHVlKHdob2xlUmFuZ2Uuc3RhcnRWYWx1ZSwgc2Vjb25kUHJpb3JpdHlSYW5nZS5zdGFydFZhbHVlKSxcclxuICAgICAgICAgICAgZW5kVmFsdWU6IGdldFpvb21Cb3VuZFZhbHVlKHdob2xlUmFuZ2UuZW5kVmFsdWUsIHNlY29uZFByaW9yaXR5UmFuZ2UuZW5kVmFsdWUpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNldEluaXRSYW5nZSgpIHtcclxuICAgICAgICB0aGlzLl9pbml0UmFuZ2UgPSB7fTtcclxuICAgICAgICBpZiAoMCA9PT0gT2JqZWN0LmtleXModGhpcy5fb3B0aW9ucy53aG9sZVJhbmdlIHx8IHt9KS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdFJhbmdlID0gdGhpcy5nZXRab29tQm91bmRzKClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3Jlc2V0VmlzdWFsUmFuZ2VPcHRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5fY3VzdG9tVmlzdWFsUmFuZ2UgPSB7fVxyXG4gICAgfSxcclxuICAgIGdldFRlbXBsYXRlc0dyb3VwcygpIHtcclxuICAgICAgICB2YXIgdGlja3MgPSB0aGlzLl9tYWpvclRpY2tzO1xyXG4gICAgICAgIGlmICh0aWNrcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFqb3JUaWNrcy5tYXAodGljayA9PiB0aWNrLnRlbXBsYXRlQ29udGFpbmVyKS5maWx0ZXIoaXRlbSA9PiBpc0RlZmluZWQoaXRlbSkpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNldEN1c3RvbVZpc3VhbFJhbmdlKHJhbmdlKSB7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5fY3VzdG9tVmlzdWFsUmFuZ2UgPSByYW5nZVxyXG4gICAgfSxcclxuICAgIHZpc3VhbFJhbmdlKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgIHZhciB2aXN1YWxSYW5nZTtcclxuICAgICAgICBpZiAoMCA9PT0gYXJncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIGFkanVzdGVkUmFuZ2UgPSB0aGlzLl9nZXRBZGp1c3RlZEJ1c2luZXNzUmFuZ2UoKTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBhZGp1c3RlZFJhbmdlLm1pblZpc2libGU7XHJcbiAgICAgICAgICAgIHZhciBlbmRWYWx1ZSA9IGFkanVzdGVkUmFuZ2UubWF4VmlzaWJsZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudHlwZSA9PT0gY29uc3RhbnRzLmRpc2NyZXRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0YXJ0VmFsdWUsIF9lbmRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWUgPSBudWxsICE9PSAoX3N0YXJ0VmFsdWUgPSBzdGFydFZhbHVlKSAmJiB2b2lkIDAgIT09IF9zdGFydFZhbHVlID8gX3N0YXJ0VmFsdWUgOiBhZGp1c3RlZFJhbmdlLmNhdGVnb3JpZXNbMF07XHJcbiAgICAgICAgICAgICAgICBlbmRWYWx1ZSA9IG51bGwgIT09IChfZW5kVmFsdWUgPSBlbmRWYWx1ZSkgJiYgdm9pZCAwICE9PSBfZW5kVmFsdWUgPyBfZW5kVmFsdWUgOiBhZGp1c3RlZFJhbmdlLmNhdGVnb3JpZXNbYWRqdXN0ZWRSYW5nZS5jYXRlZ29yaWVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiBzdGFydFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZFZhbHVlOiBlbmRWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzOiBnZXRDYXRlZ29yaWVzSW5mbyhhZGp1c3RlZFJhbmdlLmNhdGVnb3JpZXMsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKS5jYXRlZ29yaWVzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHN0YXJ0VmFsdWUsXHJcbiAgICAgICAgICAgICAgICBlbmRWYWx1ZTogZW5kVmFsdWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoX2lzQXJyYXkoYXJnc1swXSkpIHtcclxuICAgICAgICAgICAgdmlzdWFsUmFuZ2UgPSBhcmdzWzBdXHJcbiAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGFyZ3NbMF0pKSB7XHJcbiAgICAgICAgICAgIHZpc3VhbFJhbmdlID0gZXh0ZW5kKHt9LCBhcmdzWzBdKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZpc3VhbFJhbmdlID0gW2FyZ3NbMF0sIGFyZ3NbMV1dXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB6b29tUmVzdWx0cyA9IHRoaXMuaGFuZGxlWm9vbWluZyh2aXN1YWxSYW5nZSwgYXJnc1sxXSk7XHJcbiAgICAgICAgaWYgKCF6b29tUmVzdWx0cy5pc1ByZXZlbnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl92aXN1YWxSYW5nZSh0aGlzLCB6b29tUmVzdWx0cylcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaGFuZGxlWm9vbWluZyh2aXN1YWxSYW5nZSwgcHJldmVudEV2ZW50cywgZG9tRXZlbnQsIGFjdGlvbikge1xyXG4gICAgICAgIHByZXZlbnRFdmVudHMgPSBwcmV2ZW50RXZlbnRzIHx8IHt9O1xyXG4gICAgICAgIGlmIChpc0RlZmluZWQodmlzdWFsUmFuZ2UpKSB7XHJcbiAgICAgICAgICAgIHZpc3VhbFJhbmdlID0gdGhpcy5fdmFsaWRhdGVWaXN1YWxSYW5nZSh2aXN1YWxSYW5nZSk7XHJcbiAgICAgICAgICAgIHZpc3VhbFJhbmdlLmFjdGlvbiA9IGFjdGlvblxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgem9vbVN0YXJ0RXZlbnQgPSB0aGlzLmdldFpvb21TdGFydEV2ZW50QXJnKGRvbUV2ZW50LCBhY3Rpb24pO1xyXG4gICAgICAgIHZhciBwcmV2aW91c1JhbmdlID0gem9vbVN0YXJ0RXZlbnQucmFuZ2U7XHJcbiAgICAgICAgIXByZXZlbnRFdmVudHMuc3RhcnQgJiYgdGhpcy5fZXZlbnRUcmlnZ2VyKFwiem9vbVN0YXJ0XCIsIHpvb21TdGFydEV2ZW50KTtcclxuICAgICAgICB2YXIgem9vbVJlc3VsdHMgPSB7XHJcbiAgICAgICAgICAgIGlzUHJldmVudGVkOiB6b29tU3RhcnRFdmVudC5jYW5jZWwsXHJcbiAgICAgICAgICAgIHNraXBFdmVudFJpc2luZzogcHJldmVudEV2ZW50cy5za2lwRXZlbnRSaXNpbmcsXHJcbiAgICAgICAgICAgIHJhbmdlOiB2aXN1YWxSYW5nZSB8fCB6b29tU3RhcnRFdmVudC5yYW5nZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCF6b29tU3RhcnRFdmVudC5jYW5jZWwpIHtcclxuICAgICAgICAgICAgaXNEZWZpbmVkKHZpc3VhbFJhbmdlKSAmJiB0aGlzLl9hcHBseVpvb21pbmcodmlzdWFsUmFuZ2UsIHByZXZlbnRFdmVudHMuYWxsb3dQYXJ0aWFsVXBkYXRlKTtcclxuICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQodGhpcy5fc3RvcmVkWm9vbUVuZFBhcmFtcykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3JlZFpvb21FbmRQYXJhbXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRSYW5nZTogcHJldmlvdXNSYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmdldE9wdGlvbnMoKS50eXBlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc3RvcmVkWm9vbUVuZFBhcmFtcy5ldmVudCA9IGRvbUV2ZW50O1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9yZWRab29tRW5kUGFyYW1zLmFjdGlvbiA9IGFjdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcmVkWm9vbUVuZFBhcmFtcy5wcmV2ZW50ID0gISFwcmV2ZW50RXZlbnRzLmVuZFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gem9vbVJlc3VsdHNcclxuICAgIH0sXHJcbiAgICBoYW5kbGVab29tRW5kKCkge1xyXG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5fc3RvcmVkWm9vbUVuZFBhcmFtcykgJiYgIXRoaXMuX3N0b3JlZFpvb21FbmRQYXJhbXMucHJldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNSYW5nZSA9IHRoaXMuX3N0b3JlZFpvb21FbmRQYXJhbXMuc3RhcnRSYW5nZTtcclxuICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gdGhpcy5fc3RvcmVkWm9vbUVuZFBhcmFtcy5ldmVudDtcclxuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuX3N0b3JlZFpvb21FbmRQYXJhbXMuYWN0aW9uO1xyXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNCdXNpbmVzc1JhbmdlID0ge1xyXG4gICAgICAgICAgICAgICAgbWluVmlzaWJsZTogcHJldmlvdXNSYW5nZS5zdGFydFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgbWF4VmlzaWJsZTogcHJldmlvdXNSYW5nZS5lbmRWYWx1ZSxcclxuICAgICAgICAgICAgICAgIGNhdGVnb3JpZXM6IHByZXZpb3VzUmFuZ2UuY2F0ZWdvcmllc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgdHlwZUlzTm90Q2hhbmdlZCA9IHRoaXMuZ2V0T3B0aW9ucygpLnR5cGUgPT09IHRoaXMuX3N0b3JlZFpvb21FbmRQYXJhbXMudHlwZTtcclxuICAgICAgICAgICAgdmFyIHNoaWZ0ID0gdHlwZUlzTm90Q2hhbmdlZCA/IGFkanVzdCh0aGlzLmdldFZpc3VhbFJhbmdlQ2VudGVyKCkgLSB0aGlzLmdldFZpc3VhbFJhbmdlQ2VudGVyKHByZXZpb3VzQnVzaW5lc3NSYW5nZSwgZmFsc2UpKSA6IE5hTjtcclxuICAgICAgICAgICAgdmFyIHpvb21GYWN0b3IgPSB0eXBlSXNOb3RDaGFuZ2VkID8gKyhNYXRoLnJvdW5kKHRoaXMuZ2V0VmlzdWFsUmFuZ2VMZW5ndGgocHJldmlvdXNCdXNpbmVzc1JhbmdlKSAvICh0aGlzLmdldFZpc3VhbFJhbmdlTGVuZ3RoKCkgfHwgMSkgKyBcImUrMlwiKSArIFwiZS0yXCIpIDogTmFOO1xyXG4gICAgICAgICAgICB2YXIgem9vbUVuZEV2ZW50ID0gdGhpcy5fZ2V0Wm9vbUVuZEV2ZW50QXJnKHByZXZpb3VzUmFuZ2UsIGRvbUV2ZW50LCBhY3Rpb24sIHpvb21GYWN0b3IsIHNoaWZ0KTtcclxuICAgICAgICAgICAgem9vbUVuZEV2ZW50LmNhbmNlbCA9IHRoaXMuY2hlY2tab29taW5nTG93ZXJMaW1pdE92ZXJjb21lKDEgPT09IHpvb21GYWN0b3IgPyBcInBhblwiIDogXCJ6b29tXCIsIHpvb21GYWN0b3IpLnN0b3BJbnRlcmFjdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRUcmlnZ2VyKFwiem9vbUVuZFwiLCB6b29tRW5kRXZlbnQpO1xyXG4gICAgICAgICAgICBpZiAoem9vbUVuZEV2ZW50LmNhbmNlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzdG9yZVByZXZpb3VzVmlzdWFsUmFuZ2UocHJldmlvdXNSYW5nZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zdG9yZWRab29tRW5kUGFyYW1zID0gbnVsbFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfcmVzdG9yZVByZXZpb3VzVmlzdWFsUmFuZ2UocHJldmlvdXNSYW5nZSkge1xyXG4gICAgICAgIHRoaXMuX3N0b3JlZFpvb21FbmRQYXJhbXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2FwcGx5Wm9vbWluZyhwcmV2aW91c1JhbmdlKTtcclxuICAgICAgICB0aGlzLl92aXN1YWxSYW5nZSh0aGlzLCBwcmV2aW91c1JhbmdlKVxyXG4gICAgfSxcclxuICAgIGNoZWNrWm9vbWluZ0xvd2VyTGltaXRPdmVyY29tZShhY3Rpb25UeXBlLCB6b29tRmFjdG9yLCByYW5nZSkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICB2YXIgdHJhbnNsYXRvciA9IHRoaXMuX3RyYW5zbGF0b3I7XHJcbiAgICAgICAgdmFyIG1pblpvb20gPSBvcHRpb25zLm1pblZpc3VhbFJhbmdlTGVuZ3RoO1xyXG4gICAgICAgIHZhciBjb3JyZWN0ZWRSYW5nZSA9IHJhbmdlO1xyXG4gICAgICAgIHZhciB2aXN1YWxSYW5nZTtcclxuICAgICAgICB2YXIgaXNPdmVyY29taW5nID0gXCJ6b29tXCIgPT09IGFjdGlvblR5cGUgJiYgem9vbUZhY3RvciA+PSAxO1xyXG4gICAgICAgIHZhciBidXNpbmVzc1JhbmdlID0gdHJhbnNsYXRvci5nZXRCdXNpbmVzc1JhbmdlKCk7XHJcbiAgICAgICAgaWYgKHJhbmdlKSB7XHJcbiAgICAgICAgICAgIHZpc3VhbFJhbmdlID0gdGhpcy5hZGp1c3RSYW5nZShnZXRWaXpSYW5nZU9iamVjdChyYW5nZSkpO1xyXG4gICAgICAgICAgICB2aXN1YWxSYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIG1pblZpc2libGU6IHZpc3VhbFJhbmdlLnN0YXJ0VmFsdWUsXHJcbiAgICAgICAgICAgICAgICBtYXhWaXNpYmxlOiB2aXN1YWxSYW5nZS5lbmRWYWx1ZSxcclxuICAgICAgICAgICAgICAgIGNhdGVnb3JpZXM6IGJ1c2luZXNzUmFuZ2UuY2F0ZWdvcmllc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiZWZvcmVWaXN1YWxSYW5nZUxlbmd0aCA9IHRoaXMuZ2V0VmlzdWFsUmFuZ2VMZW5ndGgoYnVzaW5lc3NSYW5nZSk7XHJcbiAgICAgICAgdmFyIGFmdGVyVmlzdWFsUmFuZ2VMZW5ndGggPSB0aGlzLmdldFZpc3VhbFJhbmdlTGVuZ3RoKHZpc3VhbFJhbmdlKTtcclxuICAgICAgICBpZiAoaXNEZWZpbmVkKG1pblpvb20pIHx8IFwiZGlzY3JldGVcIiA9PT0gb3B0aW9ucy50eXBlKSB7XHJcbiAgICAgICAgICAgIG1pblpvb20gPSB0cmFuc2xhdG9yLmNvbnZlcnQobWluWm9vbSk7XHJcbiAgICAgICAgICAgIGlmICh2aXN1YWxSYW5nZSAmJiBtaW5ab29tIDwgYmVmb3JlVmlzdWFsUmFuZ2VMZW5ndGggJiYgbWluWm9vbSA+PSBhZnRlclZpc3VhbFJhbmdlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb3JyZWN0ZWRSYW5nZSA9IGdldFZpelJhbmdlT2JqZWN0KHRyYW5zbGF0b3IuZ2V0UmFuZ2VCeU1pblpvb21WYWx1ZShtaW5ab29tLCB2aXN1YWxSYW5nZSkpO1xyXG4gICAgICAgICAgICAgICAgaXNPdmVyY29taW5nID0gZmFsc2VcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlzT3ZlcmNvbWluZyAmPSBtaW5ab29tID4gYWZ0ZXJWaXN1YWxSYW5nZUxlbmd0aFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGNhbnZhc0xlbmd0aCA9IHRoaXMuX3RyYW5zbGF0b3IuY2FudmFzTGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgZnVsbFJhbmdlID0ge1xyXG4gICAgICAgICAgICAgICAgbWluVmlzaWJsZTogYnVzaW5lc3NSYW5nZS5taW4sXHJcbiAgICAgICAgICAgICAgICBtYXhWaXNpYmxlOiBidXNpbmVzc1JhbmdlLm1heCxcclxuICAgICAgICAgICAgICAgIGNhdGVnb3JpZXM6IGJ1c2luZXNzUmFuZ2UuY2F0ZWdvcmllc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpc092ZXJjb21pbmcgJj0gdGhpcy5nZXRWaXN1YWxSYW5nZUxlbmd0aChmdWxsUmFuZ2UpIC8gY2FudmFzTGVuZ3RoID49IGFmdGVyVmlzdWFsUmFuZ2VMZW5ndGhcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RvcEludGVyYWN0aW9uOiAhIWlzT3ZlcmNvbWluZyxcclxuICAgICAgICAgICAgY29ycmVjdGVkUmFuZ2U6IGNvcnJlY3RlZFJhbmdlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGlzRXh0cmVtZVBvc2l0aW9uKGlzTWF4KSB7XHJcbiAgICAgICAgdmFyIGV4dHJlbWVEYXRhVmFsdWU7XHJcbiAgICAgICAgdmFyIHNlcmllc0RhdGE7XHJcbiAgICAgICAgaWYgKFwiZGlzY3JldGVcIiA9PT0gdGhpcy5fb3B0aW9ucy50eXBlKSB7XHJcbiAgICAgICAgICAgIHNlcmllc0RhdGEgPSB0aGlzLl90cmFuc2xhdG9yLmdldEJ1c2luZXNzUmFuZ2UoKTtcclxuICAgICAgICAgICAgZXh0cmVtZURhdGFWYWx1ZSA9IGlzTWF4ID8gc2VyaWVzRGF0YS5jYXRlZ29yaWVzW3Nlcmllc0RhdGEuY2F0ZWdvcmllcy5sZW5ndGggLSAxXSA6IHNlcmllc0RhdGEuY2F0ZWdvcmllc1swXVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlcmllc0RhdGEgPSB0aGlzLmdldFpvb21Cb3VuZHMoKTtcclxuICAgICAgICAgICAgZXh0cmVtZURhdGFWYWx1ZSA9IGlzTWF4ID8gc2VyaWVzRGF0YS5lbmRWYWx1ZSA6IHNlcmllc0RhdGEuc3RhcnRWYWx1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdHJhbnNsYXRvciA9IHRoaXMuZ2V0VHJhbnNsYXRvcigpO1xyXG4gICAgICAgIHZhciBleHRyZW1lUG9pbnQgPSB0cmFuc2xhdG9yLnRyYW5zbGF0ZShleHRyZW1lRGF0YVZhbHVlKTtcclxuICAgICAgICB2YXIgdmlzdWFsUmFuZ2UgPSB0aGlzLnZpc3VhbFJhbmdlKCk7XHJcbiAgICAgICAgdmFyIHZpc3VhbFJhbmdlUG9pbnQgPSBpc01heCA/IHRyYW5zbGF0b3IudHJhbnNsYXRlKHZpc3VhbFJhbmdlLmVuZFZhbHVlKSA6IHRyYW5zbGF0b3IudHJhbnNsYXRlKHZpc3VhbFJhbmdlLnN0YXJ0VmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBfYWJzKHZpc3VhbFJhbmdlUG9pbnQgLSBleHRyZW1lUG9pbnQpIDwgU0NST0xMX1RIUkVTSE9MRFxyXG4gICAgfSxcclxuICAgIGdldFZpZXdwb3J0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFxyXG4gICAgfSxcclxuICAgIGdldEZ1bGxUaWNrczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG1ham9ycyA9IHRoaXMuX21ham9yVGlja3MgfHwgW107XHJcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudHlwZSA9PT0gY29uc3RhbnRzLmRpc2NyZXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VGlja3NUb1ZhbHVlcyhtYWpvcnMpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUaWNrc1RvVmFsdWVzKG1ham9ycy5jb25jYXQodGhpcy5fbWlub3JUaWNrcywgdGhpcy5fYm91bmRhcnlUaWNrcykpLnNvcnQoKGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZU9mKGEpIC0gdmFsdWVPZihiKVxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVhc3VyZUxhYmVsczogZnVuY3Rpb24oY2FudmFzLCB3aXRoSW5kZW50cykge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoYXQuX29wdGlvbnM7XHJcbiAgICAgICAgdmFyIHdpZHRoQXhpcyA9IG9wdGlvbnMudmlzaWJsZSA/IG9wdGlvbnMud2lkdGggOiAwO1xyXG4gICAgICAgIHZhciB0aWNrcztcclxuICAgICAgICB2YXIgaW5kZW50ID0gd2l0aEluZGVudHMgPyBvcHRpb25zLmxhYmVsLmluZGVudEZyb21BeGlzICsgLjUgKiBvcHRpb25zLnRpY2subGVuZ3RoIDogMDtcclxuICAgICAgICB2YXIgdGlja0ludGVydmFsO1xyXG4gICAgICAgIHZhciB2aWV3cG9ydFJhbmdlID0gdGhhdC5fZ2V0Vmlld3BvcnRSYW5nZSgpO1xyXG4gICAgICAgIGlmICh2aWV3cG9ydFJhbmdlLmlzRW1wdHkoKSB8fCAhb3B0aW9ucy5sYWJlbC52aXNpYmxlIHx8ICF0aGF0Ll9heGlzRWxlbWVudHNHcm91cCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB3aWR0aEF4aXMsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGhBeGlzLFxyXG4gICAgICAgICAgICAgICAgeDogMCxcclxuICAgICAgICAgICAgICAgIHk6IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhhdC5fbWFqb3JUaWNrcykge1xyXG4gICAgICAgICAgICB0aWNrcyA9IGNvbnZlcnRUaWNrc1RvVmFsdWVzKHRoYXQuX21ham9yVGlja3MpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhhdC51cGRhdGVDYW52YXMoY2FudmFzKTtcclxuICAgICAgICAgICAgdGlja3MgPSB0aGF0Ll9jcmVhdGVUaWNrc0FuZExhYmVsRm9ybWF0KHZpZXdwb3J0UmFuZ2UsIF9ub29wKTtcclxuICAgICAgICAgICAgdGlja0ludGVydmFsID0gdGlja3MudGlja0ludGVydmFsO1xyXG4gICAgICAgICAgICB0aWNrcyA9IHRpY2tzLnRpY2tzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtYXhUZXh0ID0gdGlja3MucmVkdWNlKChmdW5jdGlvbihwcmV2TGFiZWwsIHRpY2ssIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IHRoYXQuZm9ybWF0TGFiZWwodGljaywgb3B0aW9ucy5sYWJlbCwgdmlld3BvcnRSYW5nZSwgdm9pZCAwLCB0aWNrSW50ZXJ2YWwsIHRpY2tzKTtcclxuICAgICAgICAgICAgaWYgKHByZXZMYWJlbC5sZW5ndGggPCBsYWJlbC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZMYWJlbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIHRoYXQuZm9ybWF0TGFiZWwodGlja3NbMF0sIG9wdGlvbnMubGFiZWwsIHZpZXdwb3J0UmFuZ2UsIHZvaWQgMCwgdGlja0ludGVydmFsLCB0aWNrcykpO1xyXG4gICAgICAgIHZhciB0ZXh0ID0gdGhhdC5fcmVuZGVyZXIudGV4dChtYXhUZXh0LCAwLCAwKS5jc3ModGhhdC5fdGV4dEZvbnRTdHlsZXMpLmF0dHIodGhhdC5fdGV4dE9wdGlvbnMpLmFwcGVuZCh0aGF0Ll9yZW5kZXJlci5yb290KTtcclxuICAgICAgICB2YXIgYm94ID0gdGV4dC5nZXRCQm94KCk7XHJcbiAgICAgICAgdGV4dC5yZW1vdmUoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBib3gueCxcclxuICAgICAgICAgICAgeTogYm94LnksXHJcbiAgICAgICAgICAgIHdpZHRoOiBib3gud2lkdGggKyBpbmRlbnQsXHJcbiAgICAgICAgICAgIGhlaWdodDogYm94LmhlaWdodCArIGluZGVudFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfc2V0TGFiZWxzUGxhY2VtZW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMubGFiZWwudmlzaWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxhYmVsT3B0ID0gdGhpcy5fb3B0aW9ucy5sYWJlbDtcclxuICAgICAgICB2YXIgZGlzcGxheU1vZGUgPSB0aGlzLl92YWxpZGF0ZURpc3BsYXlNb2RlKGxhYmVsT3B0LmRpc3BsYXlNb2RlKTtcclxuICAgICAgICB2YXIgb3ZlcmxhcHBpbmdNb2RlID0gdGhpcy5fdmFsaWRhdGVPdmVybGFwcGluZ01vZGUobGFiZWxPcHQub3ZlcmxhcHBpbmdCZWhhdmlvciwgZGlzcGxheU1vZGUpO1xyXG4gICAgICAgIHZhciBpZ25vcmVPdmVybGFwcGluZyA9IFwibm9uZVwiID09PSBvdmVybGFwcGluZ01vZGUgfHwgXCJpZ25vcmVcIiA9PT0gb3ZlcmxhcHBpbmdNb2RlO1xyXG4gICAgICAgIHZhciBiZWhhdmlvciA9IHtcclxuICAgICAgICAgICAgcm90YXRpb25BbmdsZTogbGFiZWxPcHQucm90YXRpb25BbmdsZSxcclxuICAgICAgICAgICAgc3RhZ2dlcmluZ1NwYWNpbmc6IGxhYmVsT3B0LnN0YWdnZXJpbmdTcGFjaW5nXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgbm90UmVjYXN0U3RlcDtcclxuICAgICAgICB2YXIgYm94ZXMgPSB0aGlzLl9tYWpvclRpY2tzLm1hcCgoZnVuY3Rpb24odGljaykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGljay5sYWJlbEJCb3hcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLl9nZXRTdGVwKGJveGVzKTtcclxuICAgICAgICBzd2l0Y2ggKGRpc3BsYXlNb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgUk9UQVRFOlxyXG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZU92ZXJsYXBwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm90UmVjYXN0U3RlcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5TGFiZWxNb2RlKGRpc3BsYXlNb2RlLCBzdGVwLCBib3hlcywgbGFiZWxPcHQsIG5vdFJlY2FzdFN0ZXApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzdGFnZ2VyXCI6XHJcbiAgICAgICAgICAgICAgICBpZiAoaWdub3JlT3ZlcmxhcHBpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGVwID0gMlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlMYWJlbE1vZGUoZGlzcGxheU1vZGUsIF9tYXgoc3RlcCwgMiksIGJveGVzLCBsYWJlbE9wdCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5TGFiZWxPdmVybGFwcGluZyhib3hlcywgb3ZlcmxhcHBpbmdNb2RlLCBzdGVwLCBiZWhhdmlvcilcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2FwcGx5TGFiZWxPdmVybGFwcGluZzogZnVuY3Rpb24oYm94ZXMsIG1vZGUsIHN0ZXAsIGJlaGF2aW9yKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsT3B0ID0gdGhpcy5fb3B0aW9ucy5sYWJlbDtcclxuICAgICAgICB2YXIgbWFqb3JUaWNrcyA9IHRoaXMuX21ham9yVGlja3M7XHJcbiAgICAgICAgaWYgKFwibm9uZVwiID09PSBtb2RlIHx8IFwiaWdub3JlXCIgPT09IG1vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGVwID4gMSAmJiBib3hlcy5zb21lKChmdW5jdGlvbihib3gsIGluZGV4LCBhcnJheSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzLmFyZUxhYmVsc092ZXJsYXAoYm94LCBhcnJheVtpbmRleCAtIDFdLCBsYWJlbE9wdC5taW5TcGFjaW5nLCBsYWJlbE9wdC5hbGlnbm1lbnQpXHJcbiAgICAgICAgICAgIH0pKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUxhYmVsTW9kZShtb2RlLCBzdGVwLCBib3hlcywgYmVoYXZpb3IpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NoZWNrQm91bmRlZExhYmVsc092ZXJsYXBwaW5nKG1ham9yVGlja3MsIGJveGVzLCBtb2RlKTtcclxuICAgICAgICB0aGlzLl9jaGVja1NoaWZ0ZWRMYWJlbHMobWFqb3JUaWNrcywgYm94ZXMsIGxhYmVsT3B0Lm1pblNwYWNpbmcsIGxhYmVsT3B0LmFsaWdubWVudClcclxuICAgIH0sXHJcbiAgICBfYXBwbHlMYWJlbE1vZGU6IGZ1bmN0aW9uKG1vZGUsIHN0ZXAsIGJveGVzLCBiZWhhdmlvciwgbm90UmVjYXN0U3RlcCkge1xyXG4gICAgICAgIHZhciBtYWpvclRpY2tzID0gdGhpcy5fbWFqb3JUaWNrcztcclxuICAgICAgICB2YXIgbGFiZWxPcHQgPSB0aGlzLl9vcHRpb25zLmxhYmVsO1xyXG4gICAgICAgIHZhciBhbmdsZSA9IGJlaGF2aW9yLnJvdGF0aW9uQW5nbGU7XHJcbiAgICAgICAgdmFyIGxhYmVsSGVpZ2h0O1xyXG4gICAgICAgIHZhciBhbGlnbm1lbnQ7XHJcbiAgICAgICAgdmFyIGZ1bmM7XHJcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgUk9UQVRFOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFsYWJlbE9wdC51c2VyQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gYW5nbGUgPCAwID8gUklHSFQgOiBMRUZUO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZSAlIDkwID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IENFTlRFUlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0ZXAgPSBub3RSZWNhc3RTdGVwID8gc3RlcCA6IHRoaXMuX2dldFN0ZXAoYm94ZXMsIGFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbih0aWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRDb250YWluZXIgPSB0aWNrLmdldENvbnRlbnRDb250YWluZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRDb250YWluZXIucm90YXRlKGFuZ2xlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aWNrLmxhYmVsUm90YXRpb25BbmdsZSA9IGFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudCAmJiAodGljay5sYWJlbEFsaWdubWVudCA9IGFsaWdubWVudClcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVMYWJlbHMobWFqb3JUaWNrcywgc3RlcCwgZnVuYyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInN0YWdnZXJcIjpcclxuICAgICAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gdGhpcy5fZ2V0TWF4TGFiZWxIZWlnaHQoYm94ZXMsIGJlaGF2aW9yLnN0YWdnZXJpbmdTcGFjaW5nKTtcclxuICAgICAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbih0aWNrLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAvIChzdGVwIC0gMSkgJSAyICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2subGFiZWxPZmZzZXQgPSBsYWJlbEhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVMYWJlbHMobWFqb3JUaWNrcywgc3RlcCAtIDEsIGZ1bmMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhdXRvXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJfYXV0b1wiOlxyXG4gICAgICAgICAgICAgICAgaWYgKDIgPT09IHN0ZXApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUxhYmVsTW9kZShcInN0YWdnZXJcIiwgc3RlcCwgYm94ZXMsIGJlaGF2aW9yKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUxhYmVsTW9kZShST1RBVEUsIHN0ZXAsIGJveGVzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uQW5nbGU6IGdldE9wdGltYWxBbmdsZShib3hlcywgbGFiZWxPcHQpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdXBkYXRlTGFiZWxzKG1ham9yVGlja3MsIHN0ZXApXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldE1hcmtlclRyYWNrZXJzOiBfbm9vcCxcclxuICAgIF9kcmF3RGF0ZU1hcmtlcnM6IF9ub29wLFxyXG4gICAgX2FkanVzdERhdGVNYXJrZXJzOiBfbm9vcCxcclxuICAgIGNvb3Jkc0luOiBfbm9vcCxcclxuICAgIGFyZUNvb3Jkc091dHNpZGVBeGlzOiBfbm9vcCxcclxuICAgIF9nZXRTa2lwcGVkQ2F0ZWdvcnk6IF9ub29wLFxyXG4gICAgX2luaXRBeGlzUG9zaXRpb25zOiBfbm9vcCxcclxuICAgIF9kcmF3VGl0bGU6IF9ub29wLFxyXG4gICAgX3VwZGF0ZVRpdGxlQ29vcmRzOiBfbm9vcCxcclxuICAgIF9hZGp1c3RDb25zdGFudExpbmVMYWJlbHM6IF9ub29wLFxyXG4gICAgX2NyZWF0ZVRyYW5zbGF0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNsYXRvcjJEKHt9LCB7fSwge30pXHJcbiAgICB9LFxyXG4gICAgX3VwZGF0ZVRyYW5zbGF0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0cmFuc2xhdG9yID0gdGhpcy5fdHJhbnNsYXRvcjtcclxuICAgICAgICB0cmFuc2xhdG9yLnVwZGF0ZSh0cmFuc2xhdG9yLmdldEJ1c2luZXNzUmFuZ2UoKSwgdGhpcy5fY2FudmFzIHx8IHt9LCB0aGlzLl9nZXRUcmFuc2xhdG9yT3B0aW9ucygpKVxyXG4gICAgfSxcclxuICAgIF9nZXRUcmFuc2xhdG9yT3B0aW9uczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIF9vcHRpb25zJHdvcmtXZWVrMiwgX29wdGlvbnMkYnJlYWtTdHlsZSR3LCBfb3B0aW9ucyRicmVha1N0eWxlO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc0hvcml6b250YWw6IHRoaXMuX2lzSG9yaXpvbnRhbCxcclxuICAgICAgICAgICAgc2hpZnRaZXJvVmFsdWU6ICF0aGlzLmlzQXJndW1lbnRBeGlzLFxyXG4gICAgICAgICAgICBpbnRlcnZhbDogb3B0aW9ucy5zZW1pRGlzY3JldGVJbnRlcnZhbCxcclxuICAgICAgICAgICAgZmlyc3REYXlPZldlZWs6IG51bGwgPT09IChfb3B0aW9ucyR3b3JrV2VlazIgPSBvcHRpb25zLndvcmtXZWVrKSB8fCB2b2lkIDAgPT09IF9vcHRpb25zJHdvcmtXZWVrMiA/IHZvaWQgMCA6IF9vcHRpb25zJHdvcmtXZWVrMlswXSxcclxuICAgICAgICAgICAgc3RpY2s6IHRoaXMuX2dldFN0aWNrKCksXHJcbiAgICAgICAgICAgIGJyZWFrc1NpemU6IG51bGwgIT09IChfb3B0aW9ucyRicmVha1N0eWxlJHcgPSBudWxsID09PSAoX29wdGlvbnMkYnJlYWtTdHlsZSA9IG9wdGlvbnMuYnJlYWtTdHlsZSkgfHwgdm9pZCAwID09PSBfb3B0aW9ucyRicmVha1N0eWxlID8gdm9pZCAwIDogX29wdGlvbnMkYnJlYWtTdHlsZS53aWR0aCkgJiYgdm9pZCAwICE9PSBfb3B0aW9ucyRicmVha1N0eWxlJHcgPyBfb3B0aW9ucyRicmVha1N0eWxlJHcgOiAwXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdldFZpc2libGVBcmVhKCkge1xyXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9nZXRDYW52YXNTdGFydEVuZCgpO1xyXG4gICAgICAgIHJldHVybiBbY2FudmFzLnN0YXJ0LCBjYW52YXMuZW5kXS5zb3J0KChhLCBiKSA9PiBhIC0gYilcclxuICAgIH0sXHJcbiAgICBfZ2V0Q2FudmFzU3RhcnRFbmQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpc0hvcml6b250YWwgPSB0aGlzLl9pc0hvcml6b250YWw7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcyB8fCB7fTtcclxuICAgICAgICB2YXIgaW52ZXJ0ID0gdGhpcy5fdHJhbnNsYXRvci5nZXRCdXNpbmVzc1JhbmdlKCkuaW52ZXJ0O1xyXG4gICAgICAgIHZhciBjb29yZHMgPSBpc0hvcml6b250YWwgPyBbY2FudmFzLmxlZnQsIGNhbnZhcy53aWR0aCAtIGNhbnZhcy5yaWdodF0gOiBbY2FudmFzLmhlaWdodCAtIGNhbnZhcy5ib3R0b20sIGNhbnZhcy50b3BdO1xyXG4gICAgICAgIGludmVydCAmJiBjb29yZHMucmV2ZXJzZSgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBjb29yZHNbMF0sXHJcbiAgICAgICAgICAgIGVuZDogY29vcmRzWzFdXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9nZXRTY3JlZW5EZWx0YTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX2dldENhbnZhc1N0YXJ0RW5kKCk7XHJcbiAgICAgICAgdmFyIGJyZWFrcyA9IHRoaXMuX3Nlcmllc0RhdGEgPyB0aGlzLl9zZXJpZXNEYXRhLmJyZWFrcyB8fCBbXSA6IFtdO1xyXG4gICAgICAgIHZhciBicmVha3NMZW5ndGggPSBicmVha3MubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzY3JlZW5EZWx0YSA9IF9hYnMoY2FudmFzLnN0YXJ0IC0gY2FudmFzLmVuZCk7XHJcbiAgICAgICAgcmV0dXJuIHNjcmVlbkRlbHRhIC0gKGJyZWFrc0xlbmd0aCA/IGJyZWFrc1ticmVha3NMZW5ndGggLSAxXS5jdW11bGF0aXZlV2lkdGggOiAwKVxyXG4gICAgfSxcclxuICAgIF9nZXRTY2FsZUJyZWFrczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdXHJcbiAgICB9LFxyXG4gICAgX2ZpbHRlckJyZWFrczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdXHJcbiAgICB9LFxyXG4gICAgX2FkanVzdFRpdGxlOiBfbm9vcCxcclxuICAgIF9jaGVja1RpdGxlT3ZlcmZsb3c6IF9ub29wLFxyXG4gICAgZ2V0U3BpZGVyVGlja3M6IF9ub29wLFxyXG4gICAgc2V0U3BpZGVyVGlja3M6IF9ub29wLFxyXG4gICAgX2NoZWNrQm91bmRlZExhYmVsc092ZXJsYXBwaW5nOiBfbm9vcCxcclxuICAgIF9jaGVja1NoaWZ0ZWRMYWJlbHM6IF9ub29wLFxyXG4gICAgZHJhd1NjYWxlQnJlYWtzOiBfbm9vcCxcclxuICAgIF92aXN1YWxSYW5nZTogX25vb3AsXHJcbiAgICBfcm90YXRlQ29uc3RhbnRMaW5lOiBfbm9vcCxcclxuICAgIGFwcGx5VmlzdWFsUmFuZ2VTZXR0ZXIodmlzdWFsUmFuZ2VTZXR0ZXIpIHtcclxuICAgICAgICB0aGlzLl92aXN1YWxSYW5nZSA9IHZpc3VhbFJhbmdlU2V0dGVyXHJcbiAgICB9LFxyXG4gICAgZ2V0Q2F0ZWdvcmllc1NvcnRlcihhcmdDYXRlZ29yaWVzKSB7XHJcbiAgICAgICAgdmFyIHNvcnQ7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBcmd1bWVudEF4aXMpIHtcclxuICAgICAgICAgICAgc29ydCA9IGFyZ0NhdGVnb3JpZXNcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgY2F0ZWdvcmllc1NvcnRpbmdNZXRob2QgPSB0aGlzLl9vcHRpb25zLmNhdGVnb3JpZXNTb3J0aW5nTWV0aG9kO1xyXG4gICAgICAgICAgICBzb3J0ID0gbnVsbCAhPT0gY2F0ZWdvcmllc1NvcnRpbmdNZXRob2QgJiYgdm9pZCAwICE9PSBjYXRlZ29yaWVzU29ydGluZ01ldGhvZCA/IGNhdGVnb3JpZXNTb3J0aW5nTWV0aG9kIDogdGhpcy5fb3B0aW9ucy5jYXRlZ29yaWVzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzb3J0XHJcbiAgICB9LFxyXG4gICAgX2dldEFkanVzdGVkQnVzaW5lc3NSYW5nZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGp1c3RWaWV3cG9ydCh0aGlzLl90cmFuc2xhdG9yLmdldEJ1c2luZXNzUmFuZ2UoKSlcclxuICAgIH1cclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/axes/base_axis.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/axes/constant_line.js":
/*!***************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/axes/constant_line.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return createConstantLine; });\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/**\r\n * DevExtreme (esm/viz/axes/constant_line.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\nfunction createConstantLine(axis, options) {\r\n    var labelOptions = options.label || {};\r\n    var labelPosition = labelOptions.position || \"inside\";\r\n    var parsedValue;\r\n    var valueIsParsed = false;\r\n    var lastStoredCoordinates;\r\n    axis._checkAlignmentConstantLineLabels(labelOptions);\r\n    var storedCoord;\r\n    return {\r\n        options: options,\r\n        labelOptions: labelOptions,\r\n        labelPosition: labelPosition,\r\n        label: null,\r\n        line: null,\r\n        getParsedValue() {\r\n            if (!valueIsParsed) {\r\n                parsedValue = axis.validateUnit(options.value, \"E2105\", \"constantLine\");\r\n                valueIsParsed = true;\r\n                return parsedValue\r\n            }\r\n            return parsedValue\r\n        },\r\n        draw() {\r\n            if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(options.value) || axis._translator.getBusinessRange().isEmpty()) {\r\n                return this\r\n            }\r\n            var canvas = axis._getCanvasStartEnd();\r\n            var parsedValue = this.getParsedValue();\r\n            this.coord = axis._getConstantLinePos(parsedValue, canvas.start, canvas.end);\r\n            var rootGroup = options.displayBehindSeries ? axis._axisConstantLineGroups.under : axis._axisConstantLineGroups.above;\r\n            var group = rootGroup[labelPosition];\r\n            if (!group) {\r\n                var side = axis._isHorizontal ? labelOptions.verticalAlignment : labelOptions.horizontalAlignment;\r\n                group = rootGroup[side]\r\n            }\r\n            if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(this.coord)) {\r\n                return this\r\n            }\r\n            var path = axis._createConstantLine(this.coord, {\r\n                stroke: options.color,\r\n                \"stroke-width\": options.width,\r\n                dashStyle: options.dashStyle\r\n            });\r\n            this.line = path.append(rootGroup.inside);\r\n            this.label = labelOptions.visible ? axis._drawConstantLineLabels(parsedValue, labelOptions, this.coord, group) : null;\r\n            this.updatePosition();\r\n            return this\r\n        },\r\n        getContentContainer() {\r\n            return this.label\r\n        },\r\n        removeLabel() {\r\n            this.label && this.label.remove()\r\n        },\r\n        updatePosition(animate) {\r\n            var canvas = axis._getCanvasStartEnd();\r\n            var coord = axis._getConstantLinePos(this.getParsedValue(), canvas.start, canvas.end);\r\n            if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(coord)) {\r\n                return\r\n            }\r\n            this.coord = coord;\r\n            if (animate && storedCoord) {\r\n                this.label && this.label.attr(axis._getConstantLineLabelsCoords(storedCoord, this.labelOptions));\r\n                this.line && this.line.attr(axis._getConstantLineGraphicAttributes(storedCoord));\r\n                this.label && this.label.animate(axis._getConstantLineLabelsCoords(this.coord, this.labelOptions));\r\n                this.line && this.line.animate(axis._getConstantLineGraphicAttributes(this.coord))\r\n            } else {\r\n                this.label && this.label.attr(axis._getConstantLineLabelsCoords(this.coord, this.labelOptions));\r\n                this.line && this.line.attr(axis._getConstantLineGraphicAttributes(this.coord));\r\n                axis._rotateConstantLine(this.line, this.coord)\r\n            }\r\n        },\r\n        saveCoords() {\r\n            lastStoredCoordinates = storedCoord;\r\n            storedCoord = this.coord\r\n        },\r\n        resetCoordinates() {\r\n            storedCoord = lastStoredCoordinates\r\n        }\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2F4ZXMvY29uc3RhbnRfbGluZS5qcz8xYTA5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHK0I7QUFDaEI7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUJBQWlCLGtFQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0VBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0VBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS92aXovYXhlcy9jb25zdGFudF9saW5lLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS92aXovYXhlcy9jb25zdGFudF9saW5lLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQge1xyXG4gICAgaXNEZWZpbmVkXHJcbn0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvdHlwZVwiO1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVDb25zdGFudExpbmUoYXhpcywgb3B0aW9ucykge1xyXG4gICAgdmFyIGxhYmVsT3B0aW9ucyA9IG9wdGlvbnMubGFiZWwgfHwge307XHJcbiAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsT3B0aW9ucy5wb3NpdGlvbiB8fCBcImluc2lkZVwiO1xyXG4gICAgdmFyIHBhcnNlZFZhbHVlO1xyXG4gICAgdmFyIHZhbHVlSXNQYXJzZWQgPSBmYWxzZTtcclxuICAgIHZhciBsYXN0U3RvcmVkQ29vcmRpbmF0ZXM7XHJcbiAgICBheGlzLl9jaGVja0FsaWdubWVudENvbnN0YW50TGluZUxhYmVscyhsYWJlbE9wdGlvbnMpO1xyXG4gICAgdmFyIHN0b3JlZENvb3JkO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxyXG4gICAgICAgIGxhYmVsT3B0aW9uczogbGFiZWxPcHRpb25zLFxyXG4gICAgICAgIGxhYmVsUG9zaXRpb246IGxhYmVsUG9zaXRpb24sXHJcbiAgICAgICAgbGFiZWw6IG51bGwsXHJcbiAgICAgICAgbGluZTogbnVsbCxcclxuICAgICAgICBnZXRQYXJzZWRWYWx1ZSgpIHtcclxuICAgICAgICAgICAgaWYgKCF2YWx1ZUlzUGFyc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWRWYWx1ZSA9IGF4aXMudmFsaWRhdGVVbml0KG9wdGlvbnMudmFsdWUsIFwiRTIxMDVcIiwgXCJjb25zdGFudExpbmVcIik7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZUlzUGFyc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRWYWx1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRWYWx1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZHJhdygpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQob3B0aW9ucy52YWx1ZSkgfHwgYXhpcy5fdHJhbnNsYXRvci5nZXRCdXNpbmVzc1JhbmdlKCkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBheGlzLl9nZXRDYW52YXNTdGFydEVuZCgpO1xyXG4gICAgICAgICAgICB2YXIgcGFyc2VkVmFsdWUgPSB0aGlzLmdldFBhcnNlZFZhbHVlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29vcmQgPSBheGlzLl9nZXRDb25zdGFudExpbmVQb3MocGFyc2VkVmFsdWUsIGNhbnZhcy5zdGFydCwgY2FudmFzLmVuZCk7XHJcbiAgICAgICAgICAgIHZhciByb290R3JvdXAgPSBvcHRpb25zLmRpc3BsYXlCZWhpbmRTZXJpZXMgPyBheGlzLl9heGlzQ29uc3RhbnRMaW5lR3JvdXBzLnVuZGVyIDogYXhpcy5fYXhpc0NvbnN0YW50TGluZUdyb3Vwcy5hYm92ZTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gcm9vdEdyb3VwW2xhYmVsUG9zaXRpb25dO1xyXG4gICAgICAgICAgICBpZiAoIWdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2lkZSA9IGF4aXMuX2lzSG9yaXpvbnRhbCA/IGxhYmVsT3B0aW9ucy52ZXJ0aWNhbEFsaWdubWVudCA6IGxhYmVsT3B0aW9ucy5ob3Jpem9udGFsQWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgZ3JvdXAgPSByb290R3JvdXBbc2lkZV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLmNvb3JkKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IGF4aXMuX2NyZWF0ZUNvbnN0YW50TGluZSh0aGlzLmNvb3JkLCB7XHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IG9wdGlvbnMuY29sb3IsXHJcbiAgICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBvcHRpb25zLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgZGFzaFN0eWxlOiBvcHRpb25zLmRhc2hTdHlsZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5saW5lID0gcGF0aC5hcHBlbmQocm9vdEdyb3VwLmluc2lkZSk7XHJcbiAgICAgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbE9wdGlvbnMudmlzaWJsZSA/IGF4aXMuX2RyYXdDb25zdGFudExpbmVMYWJlbHMocGFyc2VkVmFsdWUsIGxhYmVsT3B0aW9ucywgdGhpcy5jb29yZCwgZ3JvdXApIDogbnVsbDtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0Q29udGVudENvbnRhaW5lcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUxhYmVsKCkge1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVsICYmIHRoaXMubGFiZWwucmVtb3ZlKClcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVwZGF0ZVBvc2l0aW9uKGFuaW1hdGUpIHtcclxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGF4aXMuX2dldENhbnZhc1N0YXJ0RW5kKCk7XHJcbiAgICAgICAgICAgIHZhciBjb29yZCA9IGF4aXMuX2dldENvbnN0YW50TGluZVBvcyh0aGlzLmdldFBhcnNlZFZhbHVlKCksIGNhbnZhcy5zdGFydCwgY2FudmFzLmVuZCk7XHJcbiAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKGNvb3JkKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb29yZCA9IGNvb3JkO1xyXG4gICAgICAgICAgICBpZiAoYW5pbWF0ZSAmJiBzdG9yZWRDb29yZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbCAmJiB0aGlzLmxhYmVsLmF0dHIoYXhpcy5fZ2V0Q29uc3RhbnRMaW5lTGFiZWxzQ29vcmRzKHN0b3JlZENvb3JkLCB0aGlzLmxhYmVsT3B0aW9ucykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lICYmIHRoaXMubGluZS5hdHRyKGF4aXMuX2dldENvbnN0YW50TGluZUdyYXBoaWNBdHRyaWJ1dGVzKHN0b3JlZENvb3JkKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsICYmIHRoaXMubGFiZWwuYW5pbWF0ZShheGlzLl9nZXRDb25zdGFudExpbmVMYWJlbHNDb29yZHModGhpcy5jb29yZCwgdGhpcy5sYWJlbE9wdGlvbnMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGluZSAmJiB0aGlzLmxpbmUuYW5pbWF0ZShheGlzLl9nZXRDb25zdGFudExpbmVHcmFwaGljQXR0cmlidXRlcyh0aGlzLmNvb3JkKSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWwgJiYgdGhpcy5sYWJlbC5hdHRyKGF4aXMuX2dldENvbnN0YW50TGluZUxhYmVsc0Nvb3Jkcyh0aGlzLmNvb3JkLCB0aGlzLmxhYmVsT3B0aW9ucykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lICYmIHRoaXMubGluZS5hdHRyKGF4aXMuX2dldENvbnN0YW50TGluZUdyYXBoaWNBdHRyaWJ1dGVzKHRoaXMuY29vcmQpKTtcclxuICAgICAgICAgICAgICAgIGF4aXMuX3JvdGF0ZUNvbnN0YW50TGluZSh0aGlzLmxpbmUsIHRoaXMuY29vcmQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhdmVDb29yZHMoKSB7XHJcbiAgICAgICAgICAgIGxhc3RTdG9yZWRDb29yZGluYXRlcyA9IHN0b3JlZENvb3JkO1xyXG4gICAgICAgICAgICBzdG9yZWRDb29yZCA9IHRoaXMuY29vcmRcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc2V0Q29vcmRpbmF0ZXMoKSB7XHJcbiAgICAgICAgICAgIHN0b3JlZENvb3JkID0gbGFzdFN0b3JlZENvb3JkaW5hdGVzXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/axes/constant_line.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/axes/datetime_breaks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/axes/datetime_breaks.js ***!
  \*****************************************************************/
/*! exports provided: generateDateBreaks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateDateBreaks\", function() { return generateDateBreaks; });\n/* harmony import */ var _core_utils_date__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/utils/date */ \"./node_modules/devextreme/esm/core/utils/date.js\");\n/**\r\n * DevExtreme (esm/viz/axes/datetime_breaks.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\nvar days = [0, 1, 2, 3, 4, 5, 6];\r\n\r\nfunction getWeekendDays(workdays) {\r\n    return days.filter((function(day) {\r\n        return !workdays.some((function(workDay) {\r\n            return workDay === day\r\n        }))\r\n    }))\r\n}\r\n\r\nfunction getNextDayIndex(dayIndex) {\r\n    return (dayIndex + 1) % 7\r\n}\r\n\r\nfunction dayBetweenWeekend(weekend, day) {\r\n    var start = weekend.start;\r\n    var end = weekend.end;\r\n    while (start !== end) {\r\n        if (start === day) {\r\n            return true\r\n        }\r\n        start = getNextDayIndex(start)\r\n    }\r\n    return false\r\n}\r\n\r\nfunction getDaysDistance(day, end) {\r\n    var length = 0;\r\n    while (day !== end) {\r\n        day = getNextDayIndex(day);\r\n        length++\r\n    }\r\n    return length\r\n}\r\n\r\nfunction separateBreak(scaleBreak, day) {\r\n    var result = [];\r\n    var dayEnd = new Date(day);\r\n    dayEnd.setDate(day.getDate() + 1);\r\n    if (day > scaleBreak.from) {\r\n        result.push({\r\n            from: scaleBreak.from,\r\n            to: day\r\n        })\r\n    }\r\n    if (dayEnd < scaleBreak.to) {\r\n        result.push({\r\n            from: dayEnd,\r\n            to: scaleBreak.to\r\n        })\r\n    }\r\n    return result\r\n}\r\n\r\nfunction getWeekEndDayIndices(workDays) {\r\n    var indices = getWeekendDays(workDays);\r\n    if (indices.length < 7) {\r\n        while (getNextDayIndex(indices[indices.length - 1]) === indices[0]) {\r\n            indices.unshift(indices.pop())\r\n        }\r\n    }\r\n    return indices\r\n}\r\n\r\nfunction generateDateBreaksForWeekend(min, max, weekendDayIndices) {\r\n    var day = min.getDate();\r\n    var breaks = [];\r\n    var weekends = weekendDayIndices.reduce((function(obj, day) {\r\n        var currentWeekEnd = obj[1];\r\n        if (void 0 === currentWeekEnd.start) {\r\n            currentWeekEnd = {\r\n                start: day,\r\n                end: getNextDayIndex(day)\r\n            };\r\n            obj[0].push(currentWeekEnd);\r\n            return [obj[0], currentWeekEnd]\r\n        } else if (currentWeekEnd.end === day) {\r\n            currentWeekEnd.end = getNextDayIndex(day);\r\n            return obj\r\n        }\r\n        currentWeekEnd = {\r\n            start: day,\r\n            end: getNextDayIndex(day)\r\n        };\r\n        obj[0].push(currentWeekEnd);\r\n        return [obj[0], currentWeekEnd]\r\n    }), [\r\n        [], {}\r\n    ]);\r\n    weekends[0].forEach((function(weekend) {\r\n        var currentDate = new Date(min);\r\n        currentDate = _core_utils_date__WEBPACK_IMPORTED_MODULE_0__[\"default\"].trimTime(currentDate);\r\n        while (currentDate < max) {\r\n            day = currentDate.getDay();\r\n            var date = currentDate.getDate();\r\n            if (dayBetweenWeekend(weekend, day)) {\r\n                var from = new Date(currentDate);\r\n                currentDate.setDate(date + getDaysDistance(day, weekend.end));\r\n                var to = new Date(currentDate);\r\n                breaks.push({\r\n                    from: from,\r\n                    to: to\r\n                })\r\n            }\r\n            currentDate.setDate(currentDate.getDate() + 1)\r\n        }\r\n    }));\r\n    return breaks\r\n}\r\n\r\nfunction excludeWorkDaysFromWeekEndBreaks(breaks, exactWorkDays) {\r\n    var result = breaks.slice();\r\n    var i;\r\n    var processWorkDay = function(workday) {\r\n        workday = _core_utils_date__WEBPACK_IMPORTED_MODULE_0__[\"default\"].trimTime(new Date(workday));\r\n        if (result[i].from <= workday && result[i].to > workday) {\r\n            var separatedBreak = separateBreak(result[i], workday);\r\n            if (2 === separatedBreak.length) {\r\n                result.splice(i, 1, separatedBreak[0], separatedBreak[1])\r\n            } else if (1 === separatedBreak.length) {\r\n                result.splice(i, 1, separatedBreak[0])\r\n            } else {\r\n                result.splice(i, 1)\r\n            }\r\n        }\r\n    };\r\n    for (i = 0; i < result.length; i++) {\r\n        exactWorkDays.forEach(processWorkDay)\r\n    }\r\n    return result\r\n}\r\n\r\nfunction generateBreaksForHolidays(min, max, holidays, weekendDayIndices) {\r\n    var day;\r\n    var dayInWeekend = function(dayIndex) {\r\n        return dayIndex === day\r\n    };\r\n    var adjustedMin = _core_utils_date__WEBPACK_IMPORTED_MODULE_0__[\"default\"].trimTime(min);\r\n    var adjustedMax = _core_utils_date__WEBPACK_IMPORTED_MODULE_0__[\"default\"].trimTime(max);\r\n    adjustedMax.setDate(max.getDate() + 1);\r\n    return holidays.reduce((function(breaks, holiday) {\r\n        var holidayStart;\r\n        var holidayEnd;\r\n        holiday = new Date(holiday);\r\n        day = holiday.getDay();\r\n        if (!weekendDayIndices.some(dayInWeekend) && holiday >= adjustedMin && holiday <= adjustedMax) {\r\n            holidayStart = _core_utils_date__WEBPACK_IMPORTED_MODULE_0__[\"default\"].trimTime(holiday);\r\n            holidayEnd = new Date(holidayStart);\r\n            holidayEnd.setDate(holidayStart.getDate() + 1);\r\n            breaks.push({\r\n                from: holidayStart,\r\n                to: holidayEnd\r\n            })\r\n        }\r\n        return breaks\r\n    }), [])\r\n}\r\n\r\nfunction calculateGaps(breaks) {\r\n    return breaks.map((function(b) {\r\n        return {\r\n            from: b.from,\r\n            to: b.to,\r\n            gapSize: _core_utils_date__WEBPACK_IMPORTED_MODULE_0__[\"default\"].convertMillisecondsToDateUnits(b.to - b.from)\r\n        }\r\n    }))\r\n}\r\nfunction generateDateBreaks(min, max, workWeek, singleWorkdays, holidays) {\r\n    var weekendDayIndices = getWeekEndDayIndices(workWeek);\r\n    var breaks = generateDateBreaksForWeekend(min, max, weekendDayIndices);\r\n    breaks.push.apply(breaks, generateBreaksForHolidays(min, max, holidays || [], weekendDayIndices));\r\n    return calculateGaps(excludeWorkDaysFromWeekEndBreaks(breaks, singleWorkdays || []))\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2F4ZXMvZGF0ZXRpbWVfYnJlYWtzLmpzPzQ5ODAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdEQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3REFBUztBQUMvQixzQkFBc0Isd0RBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQVM7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2F4ZXMvZGF0ZXRpbWVfYnJlYWtzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS92aXovYXhlcy9kYXRldGltZV9icmVha3MuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCBkYXRlVXRpbHMgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvZGF0ZVwiO1xyXG52YXIgZGF5cyA9IFswLCAxLCAyLCAzLCA0LCA1LCA2XTtcclxuXHJcbmZ1bmN0aW9uIGdldFdlZWtlbmREYXlzKHdvcmtkYXlzKSB7XHJcbiAgICByZXR1cm4gZGF5cy5maWx0ZXIoKGZ1bmN0aW9uKGRheSkge1xyXG4gICAgICAgIHJldHVybiAhd29ya2RheXMuc29tZSgoZnVuY3Rpb24od29ya0RheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gd29ya0RheSA9PT0gZGF5XHJcbiAgICAgICAgfSkpXHJcbiAgICB9KSlcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TmV4dERheUluZGV4KGRheUluZGV4KSB7XHJcbiAgICByZXR1cm4gKGRheUluZGV4ICsgMSkgJSA3XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRheUJldHdlZW5XZWVrZW5kKHdlZWtlbmQsIGRheSkge1xyXG4gICAgdmFyIHN0YXJ0ID0gd2Vla2VuZC5zdGFydDtcclxuICAgIHZhciBlbmQgPSB3ZWVrZW5kLmVuZDtcclxuICAgIHdoaWxlIChzdGFydCAhPT0gZW5kKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBkYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhcnQgPSBnZXROZXh0RGF5SW5kZXgoc3RhcnQpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGF5c0Rpc3RhbmNlKGRheSwgZW5kKSB7XHJcbiAgICB2YXIgbGVuZ3RoID0gMDtcclxuICAgIHdoaWxlIChkYXkgIT09IGVuZCkge1xyXG4gICAgICAgIGRheSA9IGdldE5leHREYXlJbmRleChkYXkpO1xyXG4gICAgICAgIGxlbmd0aCsrXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuZ3RoXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlcGFyYXRlQnJlYWsoc2NhbGVCcmVhaywgZGF5KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICB2YXIgZGF5RW5kID0gbmV3IERhdGUoZGF5KTtcclxuICAgIGRheUVuZC5zZXREYXRlKGRheS5nZXREYXRlKCkgKyAxKTtcclxuICAgIGlmIChkYXkgPiBzY2FsZUJyZWFrLmZyb20pIHtcclxuICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICAgIGZyb206IHNjYWxlQnJlYWsuZnJvbSxcclxuICAgICAgICAgICAgdG86IGRheVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBpZiAoZGF5RW5kIDwgc2NhbGVCcmVhay50bykge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgZnJvbTogZGF5RW5kLFxyXG4gICAgICAgICAgICB0bzogc2NhbGVCcmVhay50b1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFdlZWtFbmREYXlJbmRpY2VzKHdvcmtEYXlzKSB7XHJcbiAgICB2YXIgaW5kaWNlcyA9IGdldFdlZWtlbmREYXlzKHdvcmtEYXlzKTtcclxuICAgIGlmIChpbmRpY2VzLmxlbmd0aCA8IDcpIHtcclxuICAgICAgICB3aGlsZSAoZ2V0TmV4dERheUluZGV4KGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSkgPT09IGluZGljZXNbMF0pIHtcclxuICAgICAgICAgICAgaW5kaWNlcy51bnNoaWZ0KGluZGljZXMucG9wKCkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluZGljZXNcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVEYXRlQnJlYWtzRm9yV2Vla2VuZChtaW4sIG1heCwgd2Vla2VuZERheUluZGljZXMpIHtcclxuICAgIHZhciBkYXkgPSBtaW4uZ2V0RGF0ZSgpO1xyXG4gICAgdmFyIGJyZWFrcyA9IFtdO1xyXG4gICAgdmFyIHdlZWtlbmRzID0gd2Vla2VuZERheUluZGljZXMucmVkdWNlKChmdW5jdGlvbihvYmosIGRheSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50V2Vla0VuZCA9IG9ialsxXTtcclxuICAgICAgICBpZiAodm9pZCAwID09PSBjdXJyZW50V2Vla0VuZC5zdGFydCkge1xyXG4gICAgICAgICAgICBjdXJyZW50V2Vla0VuZCA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXksXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGdldE5leHREYXlJbmRleChkYXkpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG9ialswXS5wdXNoKGN1cnJlbnRXZWVrRW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtvYmpbMF0sIGN1cnJlbnRXZWVrRW5kXVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFdlZWtFbmQuZW5kID09PSBkYXkpIHtcclxuICAgICAgICAgICAgY3VycmVudFdlZWtFbmQuZW5kID0gZ2V0TmV4dERheUluZGV4KGRheSk7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmpcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFdlZWtFbmQgPSB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBkYXksXHJcbiAgICAgICAgICAgIGVuZDogZ2V0TmV4dERheUluZGV4KGRheSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIG9ialswXS5wdXNoKGN1cnJlbnRXZWVrRW5kKTtcclxuICAgICAgICByZXR1cm4gW29ialswXSwgY3VycmVudFdlZWtFbmRdXHJcbiAgICB9KSwgW1xyXG4gICAgICAgIFtdLCB7fVxyXG4gICAgXSk7XHJcbiAgICB3ZWVrZW5kc1swXS5mb3JFYWNoKChmdW5jdGlvbih3ZWVrZW5kKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnREYXRlID0gbmV3IERhdGUobWluKTtcclxuICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVVdGlscy50cmltVGltZShjdXJyZW50RGF0ZSk7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnREYXRlIDwgbWF4KSB7XHJcbiAgICAgICAgICAgIGRheSA9IGN1cnJlbnREYXRlLmdldERheSgpO1xyXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IGN1cnJlbnREYXRlLmdldERhdGUoKTtcclxuICAgICAgICAgICAgaWYgKGRheUJldHdlZW5XZWVrZW5kKHdlZWtlbmQsIGRheSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gbmV3IERhdGUoY3VycmVudERhdGUpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUuc2V0RGF0ZShkYXRlICsgZ2V0RGF5c0Rpc3RhbmNlKGRheSwgd2Vla2VuZC5lbmQpKTtcclxuICAgICAgICAgICAgICAgIHZhciB0byA9IG5ldyBEYXRlKGN1cnJlbnREYXRlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvOiB0b1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50RGF0ZS5zZXREYXRlKGN1cnJlbnREYXRlLmdldERhdGUoKSArIDEpXHJcbiAgICAgICAgfVxyXG4gICAgfSkpO1xyXG4gICAgcmV0dXJuIGJyZWFrc1xyXG59XHJcblxyXG5mdW5jdGlvbiBleGNsdWRlV29ya0RheXNGcm9tV2Vla0VuZEJyZWFrcyhicmVha3MsIGV4YWN0V29ya0RheXMpIHtcclxuICAgIHZhciByZXN1bHQgPSBicmVha3Muc2xpY2UoKTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIHByb2Nlc3NXb3JrRGF5ID0gZnVuY3Rpb24od29ya2RheSkge1xyXG4gICAgICAgIHdvcmtkYXkgPSBkYXRlVXRpbHMudHJpbVRpbWUobmV3IERhdGUod29ya2RheSkpO1xyXG4gICAgICAgIGlmIChyZXN1bHRbaV0uZnJvbSA8PSB3b3JrZGF5ICYmIHJlc3VsdFtpXS50byA+IHdvcmtkYXkpIHtcclxuICAgICAgICAgICAgdmFyIHNlcGFyYXRlZEJyZWFrID0gc2VwYXJhdGVCcmVhayhyZXN1bHRbaV0sIHdvcmtkYXkpO1xyXG4gICAgICAgICAgICBpZiAoMiA9PT0gc2VwYXJhdGVkQnJlYWsubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc3BsaWNlKGksIDEsIHNlcGFyYXRlZEJyZWFrWzBdLCBzZXBhcmF0ZWRCcmVha1sxXSlcclxuICAgICAgICAgICAgfSBlbHNlIGlmICgxID09PSBzZXBhcmF0ZWRCcmVhay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMSwgc2VwYXJhdGVkQnJlYWtbMF0pXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc3BsaWNlKGksIDEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGV4YWN0V29ya0RheXMuZm9yRWFjaChwcm9jZXNzV29ya0RheSlcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3NGb3JIb2xpZGF5cyhtaW4sIG1heCwgaG9saWRheXMsIHdlZWtlbmREYXlJbmRpY2VzKSB7XHJcbiAgICB2YXIgZGF5O1xyXG4gICAgdmFyIGRheUluV2Vla2VuZCA9IGZ1bmN0aW9uKGRheUluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGRheUluZGV4ID09PSBkYXlcclxuICAgIH07XHJcbiAgICB2YXIgYWRqdXN0ZWRNaW4gPSBkYXRlVXRpbHMudHJpbVRpbWUobWluKTtcclxuICAgIHZhciBhZGp1c3RlZE1heCA9IGRhdGVVdGlscy50cmltVGltZShtYXgpO1xyXG4gICAgYWRqdXN0ZWRNYXguc2V0RGF0ZShtYXguZ2V0RGF0ZSgpICsgMSk7XHJcbiAgICByZXR1cm4gaG9saWRheXMucmVkdWNlKChmdW5jdGlvbihicmVha3MsIGhvbGlkYXkpIHtcclxuICAgICAgICB2YXIgaG9saWRheVN0YXJ0O1xyXG4gICAgICAgIHZhciBob2xpZGF5RW5kO1xyXG4gICAgICAgIGhvbGlkYXkgPSBuZXcgRGF0ZShob2xpZGF5KTtcclxuICAgICAgICBkYXkgPSBob2xpZGF5LmdldERheSgpO1xyXG4gICAgICAgIGlmICghd2Vla2VuZERheUluZGljZXMuc29tZShkYXlJbldlZWtlbmQpICYmIGhvbGlkYXkgPj0gYWRqdXN0ZWRNaW4gJiYgaG9saWRheSA8PSBhZGp1c3RlZE1heCkge1xyXG4gICAgICAgICAgICBob2xpZGF5U3RhcnQgPSBkYXRlVXRpbHMudHJpbVRpbWUoaG9saWRheSk7XHJcbiAgICAgICAgICAgIGhvbGlkYXlFbmQgPSBuZXcgRGF0ZShob2xpZGF5U3RhcnQpO1xyXG4gICAgICAgICAgICBob2xpZGF5RW5kLnNldERhdGUoaG9saWRheVN0YXJ0LmdldERhdGUoKSArIDEpO1xyXG4gICAgICAgICAgICBicmVha3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBmcm9tOiBob2xpZGF5U3RhcnQsXHJcbiAgICAgICAgICAgICAgICB0bzogaG9saWRheUVuZFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnJlYWtzXHJcbiAgICB9KSwgW10pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZUdhcHMoYnJlYWtzKSB7XHJcbiAgICByZXR1cm4gYnJlYWtzLm1hcCgoZnVuY3Rpb24oYikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZyb206IGIuZnJvbSxcclxuICAgICAgICAgICAgdG86IGIudG8sXHJcbiAgICAgICAgICAgIGdhcFNpemU6IGRhdGVVdGlscy5jb252ZXJ0TWlsbGlzZWNvbmRzVG9EYXRlVW5pdHMoYi50byAtIGIuZnJvbSlcclxuICAgICAgICB9XHJcbiAgICB9KSlcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVEYXRlQnJlYWtzKG1pbiwgbWF4LCB3b3JrV2Vlaywgc2luZ2xlV29ya2RheXMsIGhvbGlkYXlzKSB7XHJcbiAgICB2YXIgd2Vla2VuZERheUluZGljZXMgPSBnZXRXZWVrRW5kRGF5SW5kaWNlcyh3b3JrV2Vlayk7XHJcbiAgICB2YXIgYnJlYWtzID0gZ2VuZXJhdGVEYXRlQnJlYWtzRm9yV2Vla2VuZChtaW4sIG1heCwgd2Vla2VuZERheUluZGljZXMpO1xyXG4gICAgYnJlYWtzLnB1c2guYXBwbHkoYnJlYWtzLCBnZW5lcmF0ZUJyZWFrc0ZvckhvbGlkYXlzKG1pbiwgbWF4LCBob2xpZGF5cyB8fCBbXSwgd2Vla2VuZERheUluZGljZXMpKTtcclxuICAgIHJldHVybiBjYWxjdWxhdGVHYXBzKGV4Y2x1ZGVXb3JrRGF5c0Zyb21XZWVrRW5kQnJlYWtzKGJyZWFrcywgc2luZ2xlV29ya2RheXMgfHwgW10pKVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/axes/datetime_breaks.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/axes/polar_axes.js":
/*!************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/axes/polar_axes.js ***!
  \************************************************************/
/*! exports provided: circular, circularSpider, linear, linearSpider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"circular\", function() { return circular; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"circularSpider\", function() { return circularSpider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linear\", function() { return linear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linearSpider\", function() { return linearSpider; });\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _axes_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./axes_constants */ \"./node_modules/devextreme/esm/viz/axes/axes_constants.js\");\n/* harmony import */ var _xy_axes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./xy_axes */ \"./node_modules/devextreme/esm/viz/axes/xy_axes.js\");\n/* harmony import */ var _tick__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tick */ \"./node_modules/devextreme/esm/viz/axes/tick.js\");\n/* harmony import */ var _axes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./axes_utils */ \"./node_modules/devextreme/esm/viz/axes/axes_utils.js\");\n/* harmony import */ var _core_utils_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/utils/common */ \"./node_modules/devextreme/esm/core/utils/common.js\");\n/**\r\n * DevExtreme (esm/viz/axes/polar_axes.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar {\r\n    PI: PI,\r\n    abs: abs,\r\n    atan: atan,\r\n    round: round\r\n} = Math;\r\nvar _min = Math.min;\r\nvar _max = Math.max;\r\nvar xyAxesLinear = _xy_axes__WEBPACK_IMPORTED_MODULE_4__[\"default\"].linear;\r\nvar HALF_PI_ANGLE = 90;\r\n\r\nfunction getPolarQuarter(angle) {\r\n    var quarter;\r\n    angle = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"normalizeAngle\"])(angle);\r\n    if (angle >= 315 && angle <= 360 || angle < 45 && angle >= 0) {\r\n        quarter = 1\r\n    } else if (angle >= 45 && angle < 135) {\r\n        quarter = 2\r\n    } else if (angle >= 135 && angle < 225) {\r\n        quarter = 3\r\n    } else if (angle >= 225 && angle < 315) {\r\n        quarter = 4\r\n    }\r\n    return quarter\r\n}\r\nvar circularAxes = {\r\n    _calculateValueMargins(ticks) {\r\n        var {\r\n            minVisible: minVisible,\r\n            maxVisible: maxVisible\r\n        } = this._getViewportRange();\r\n        if (ticks && ticks.length > 1) {\r\n            minVisible = minVisible < ticks[0].value ? minVisible : ticks[0].value;\r\n            maxVisible = minVisible > ticks[ticks.length - 1].value ? maxVisible : ticks[ticks.length - 1].value\r\n        }\r\n        return {\r\n            minValue: minVisible,\r\n            maxValue: maxVisible\r\n        }\r\n    },\r\n    applyMargins() {\r\n        var margins = this._calculateValueMargins(this._majorTicks);\r\n        var br = this._translator.getBusinessRange();\r\n        br.addRange({\r\n            minVisible: margins.minValue,\r\n            maxVisible: margins.maxValue,\r\n            interval: this._calculateRangeInterval(br.interval)\r\n        });\r\n        this._translator.updateBusinessRange(br)\r\n    },\r\n    _getTranslatorOptions: function() {\r\n        return {\r\n            isHorizontal: true,\r\n            conversionValue: true,\r\n            addSpiderCategory: this._getSpiderCategoryOption(),\r\n            stick: this._getStick()\r\n        }\r\n    },\r\n    getCenter: function() {\r\n        return this._center\r\n    },\r\n    getRadius: function() {\r\n        return this._radius\r\n    },\r\n    getAngles: function() {\r\n        var options = this._options;\r\n        return [options.startAngle, options.endAngle]\r\n    },\r\n    _updateRadius(canvas) {\r\n        var rad = _min(canvas.width - canvas.left - canvas.right, canvas.height - canvas.top - canvas.bottom) / 2;\r\n        this._radius = rad < 0 ? 0 : rad\r\n    },\r\n    _updateCenter: function(canvas) {\r\n        this._center = {\r\n            x: canvas.left + (canvas.width - canvas.right - canvas.left) / 2,\r\n            y: canvas.top + (canvas.height - canvas.top - canvas.bottom) / 2\r\n        }\r\n    },\r\n    _processCanvas: function(canvas) {\r\n        this._updateRadius(canvas);\r\n        this._updateCenter(canvas);\r\n        return {\r\n            left: 0,\r\n            right: 0,\r\n            width: this._getScreenDelta()\r\n        }\r\n    },\r\n    _createAxisElement: function() {\r\n        return this._renderer.circle()\r\n    },\r\n    _updateAxisElementPosition: function() {\r\n        var center = this.getCenter();\r\n        this._axisElement.attr({\r\n            cx: center.x,\r\n            cy: center.y,\r\n            r: this.getRadius()\r\n        })\r\n    },\r\n    _boundaryTicksVisibility: {\r\n        min: true\r\n    },\r\n    _getSpiderCategoryOption: function() {\r\n        return this._options.firstPointOnStartAngle\r\n    },\r\n    _validateOptions(options) {\r\n        var originValue = options.originValue;\r\n        var wholeRange = options.wholeRange = {};\r\n        var period = options.period;\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(originValue)) {\r\n            originValue = this.validateUnit(originValue)\r\n        }\r\n        if (period > 0 && options.argumentType === _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].numeric) {\r\n            originValue = originValue || 0;\r\n            wholeRange.endValue = originValue + period;\r\n            this._viewport = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getVizRangeObject\"])([originValue, wholeRange.endValue])\r\n        }\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(originValue)) {\r\n            wholeRange.startValue = originValue\r\n        }\r\n    },\r\n    getMargins() {\r\n        var tickOptions = this._options.tick;\r\n        var tickOuterLength = _max(tickOptions.visible ? tickOptions.length / 2 + tickOptions.shift : 0, 0);\r\n        var radius = this.getRadius();\r\n        var {\r\n            x: x,\r\n            y: y\r\n        } = this._center;\r\n        var labelBoxes = this._majorTicks.map(t => t.label && t.label.getBBox()).filter(b => b);\r\n        var canvas = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])({}, this._canvas, {\r\n            left: x - radius,\r\n            top: y - radius,\r\n            right: this._canvas.width - (x + radius),\r\n            bottom: this._canvas.height - (y + radius)\r\n        });\r\n        var margins = Object(_axes_utils__WEBPACK_IMPORTED_MODULE_6__[\"calculateCanvasMargins\"])(labelBoxes, canvas);\r\n        Object.keys(margins).forEach(k => margins[k] = margins[k] < tickOuterLength ? tickOuterLength : margins[k]);\r\n        return margins\r\n    },\r\n    _updateLabelsPosition() {\r\n        Object(_axes_utils__WEBPACK_IMPORTED_MODULE_6__[\"measureLabels\"])(this._majorTicks);\r\n        this._adjustLabelsCoord(0, 0, true);\r\n        this._checkBoundedLabelsOverlapping(this._majorTicks, this._majorTicks.map(t => t.labelBBox))\r\n    },\r\n    _setVisualRange: _core_utils_common__WEBPACK_IMPORTED_MODULE_7__[\"noop\"],\r\n    applyVisualRangeSetter: _core_utils_common__WEBPACK_IMPORTED_MODULE_7__[\"noop\"],\r\n    _getStick: function() {\r\n        return this._options.firstPointOnStartAngle || this._options.type !== _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].discrete\r\n    },\r\n    _getTranslatedCoord: function(value, offset) {\r\n        return this._translator.translate(value, offset) - HALF_PI_ANGLE\r\n    },\r\n    _getCanvasStartEnd: function() {\r\n        return {\r\n            start: 0 - HALF_PI_ANGLE,\r\n            end: 360 - HALF_PI_ANGLE\r\n        }\r\n    },\r\n    _getStripGraphicAttributes: function(fromAngle, toAngle) {\r\n        var center = this.getCenter();\r\n        var angle = this.getAngles()[0];\r\n        var r = this.getRadius();\r\n        return {\r\n            x: center.x,\r\n            y: center.y,\r\n            innerRadius: 0,\r\n            outerRadius: r,\r\n            startAngle: -toAngle - angle,\r\n            endAngle: -fromAngle - angle\r\n        }\r\n    },\r\n    _createStrip: function(coords) {\r\n        return this._renderer.arc(coords.x, coords.y, coords.innerRadius, coords.outerRadius, coords.startAngle, coords.endAngle)\r\n    },\r\n    _getStripLabelCoords: function(from, to) {\r\n        var coords = this._getStripGraphicAttributes(from, to);\r\n        var angle = coords.startAngle + (coords.endAngle - coords.startAngle) / 2;\r\n        var cosSin = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getCosAndSin\"])(angle);\r\n        var halfRad = this.getRadius() / 2;\r\n        var center = this.getCenter();\r\n        var x = round(center.x + halfRad * cosSin.cos);\r\n        var y = round(center.y - halfRad * cosSin.sin);\r\n        return {\r\n            x: x,\r\n            y: y,\r\n            align: _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].center\r\n        }\r\n    },\r\n    _getConstantLineGraphicAttributes: function(value) {\r\n        var center = this.getCenter();\r\n        var r = this.getRadius();\r\n        return {\r\n            points: [center.x, center.y, center.x + r, center.y]\r\n        }\r\n    },\r\n    _createConstantLine: function(value, attr) {\r\n        return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr)\r\n    },\r\n    _rotateConstantLine(line, value) {\r\n        var {\r\n            x: x,\r\n            y: y\r\n        } = this.getCenter();\r\n        line.rotate(value + this.getAngles()[0], x, y)\r\n    },\r\n    _getConstantLineLabelsCoords: function(value) {\r\n        var cosSin = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getCosAndSin\"])(-value - this.getAngles()[0]);\r\n        var halfRad = this.getRadius() / 2;\r\n        var center = this.getCenter();\r\n        var x = round(center.x + halfRad * cosSin.cos);\r\n        var y = round(center.y - halfRad * cosSin.sin);\r\n        return {\r\n            x: x,\r\n            y: y\r\n        }\r\n    },\r\n    _checkAlignmentConstantLineLabels: _core_utils_common__WEBPACK_IMPORTED_MODULE_7__[\"noop\"],\r\n    _adjustDivisionFactor: function(val) {\r\n        return 180 * val / (this.getRadius() * PI)\r\n    },\r\n    _getScreenDelta: function() {\r\n        var angles = this.getAngles();\r\n        return abs(angles[0] - angles[1])\r\n    },\r\n    _getTickMarkPoints: function(coords, length, _ref) {\r\n        var {\r\n            shift: shift = 0\r\n        } = _ref;\r\n        var center = this.getCenter();\r\n        var radiusWithTicks = this.getRadius() + length * {\r\n            inside: -1,\r\n            center: -.5,\r\n            outside: 0\r\n        } [this._options.tickOrientation || \"center\"];\r\n        return [center.x + radiusWithTicks + shift, center.y, center.x + radiusWithTicks + length + shift, center.y]\r\n    },\r\n    _getLabelAdjustedCoord: function(tick, _offset, _maxWidth, checkCanvas) {\r\n        var labelCoords = tick.labelCoords;\r\n        var labelY = labelCoords.y;\r\n        var labelAngle = labelCoords.angle;\r\n        var cosSin = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getCosAndSin\"])(labelAngle);\r\n        var cos = cosSin.cos;\r\n        var sin = cosSin.sin;\r\n        var box = tick.labelBBox;\r\n        var halfWidth = box.width / 2;\r\n        var halfHeight = box.height / 2;\r\n        var indentFromAxis = this._options.label.indentFromAxis || 0;\r\n        var x = labelCoords.x + indentFromAxis * cos;\r\n        var y = labelY + (labelY - box.y - halfHeight) + indentFromAxis * sin;\r\n        var shiftX = 0;\r\n        var shiftY = 0;\r\n        switch (getPolarQuarter(labelAngle)) {\r\n            case 1:\r\n                shiftX = halfWidth;\r\n                shiftY = halfHeight * sin;\r\n                break;\r\n            case 2:\r\n                shiftX = halfWidth * cos;\r\n                shiftY = halfHeight;\r\n                break;\r\n            case 3:\r\n                shiftX = -halfWidth;\r\n                shiftY = halfHeight * sin;\r\n                break;\r\n            case 4:\r\n                shiftX = halfWidth * cos;\r\n                shiftY = -halfHeight\r\n        }\r\n        if (checkCanvas) {\r\n            var canvas = this._canvas;\r\n            var boxShiftX = x - labelCoords.x + shiftX;\r\n            var boxShiftY = y - labelCoords.y + shiftY;\r\n            if (box.x + boxShiftX < canvas.originalLeft) {\r\n                shiftX -= box.x + boxShiftX - canvas.originalLeft\r\n            }\r\n            if (box.x + box.width + boxShiftX > canvas.width - canvas.originalRight) {\r\n                shiftX -= box.x + box.width + boxShiftX - (canvas.width - canvas.originalRight)\r\n            }\r\n            if (box.y + boxShiftY < canvas.originalTop) {\r\n                shiftY -= box.y + boxShiftY - canvas.originalTop\r\n            }\r\n            if (box.y + box.height + boxShiftY > canvas.height - canvas.originalBottom) {\r\n                shiftY -= box.y + box.height + boxShiftY - (canvas.height - canvas.originalBottom)\r\n            }\r\n        }\r\n        return {\r\n            x: x + shiftX,\r\n            y: y + shiftY\r\n        }\r\n    },\r\n    _getGridLineDrawer: function() {\r\n        var that = this;\r\n        return function(tick, gridStyle) {\r\n            var center = that.getCenter();\r\n            return that._createPathElement(that._getGridPoints().points, gridStyle).rotate(tick.coords.angle, center.x, center.y)\r\n        }\r\n    },\r\n    _getGridPoints: function() {\r\n        var r = this.getRadius();\r\n        var center = this.getCenter();\r\n        return {\r\n            points: [center.x, center.y, center.x + r, center.y]\r\n        }\r\n    },\r\n    _getTranslatedValue: function(value, offset) {\r\n        var startAngle = this.getAngles()[0];\r\n        var angle = this._translator.translate(value, -offset);\r\n        var coords = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"convertPolarToXY\"])(this.getCenter(), startAngle, angle, this.getRadius());\r\n        return {\r\n            x: coords.x,\r\n            y: coords.y,\r\n            angle: this.getTranslatedAngle(angle)\r\n        }\r\n    },\r\n    _getAdjustedStripLabelCoords: function(strip) {\r\n        var box = strip.labelBBox;\r\n        return {\r\n            translateY: strip.label.attr(\"y\") - box.y - box.height / 2\r\n        }\r\n    },\r\n    coordsIn: function(x, y) {\r\n        return Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"convertXYToPolar\"])(this.getCenter(), x, y).r > this.getRadius()\r\n    },\r\n    _rotateTick: function(element, coords) {\r\n        var center = this.getCenter();\r\n        element.rotate(coords.angle, center.x, center.y)\r\n    },\r\n    _validateOverlappingMode: function(mode) {\r\n        return _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].validateOverlappingMode(mode)\r\n    },\r\n    _validateDisplayMode: function() {\r\n        return \"standard\"\r\n    },\r\n    _getStep: function(boxes) {\r\n        var radius = this.getRadius() + (this._options.label.indentFromAxis || 0);\r\n        var maxLabelBox = boxes.reduce((function(prevValue, box) {\r\n            var curValue = prevValue;\r\n            if (prevValue.width < box.width) {\r\n                curValue.width = box.width\r\n            }\r\n            if (prevValue.height < box.height) {\r\n                curValue.height = box.height\r\n            }\r\n            return curValue\r\n        }), {\r\n            width: 0,\r\n            height: 0\r\n        });\r\n        var angle1 = abs(2 * atan(maxLabelBox.height / (2 * radius - maxLabelBox.width)) * 180 / PI);\r\n        var angle2 = abs(2 * atan(maxLabelBox.width / (2 * radius - maxLabelBox.height)) * 180 / PI);\r\n        return _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getTicksCountInRange(this._majorTicks, \"angle\", _max(angle1, angle2))\r\n    },\r\n    _checkBoundedLabelsOverlapping: function(majorTicks, boxes, mode) {\r\n        var labelOpt = this._options.label;\r\n        mode = mode || this._validateOverlappingMode(labelOpt.overlappingBehavior);\r\n        if (\"hide\" !== mode) {\r\n            return\r\n        }\r\n        var lastVisibleLabelIndex = majorTicks.reduce((lastVisibleLabelIndex, tick, index) => tick.label ? index : lastVisibleLabelIndex, null);\r\n        if (!lastVisibleLabelIndex) {\r\n            return\r\n        }\r\n        if (_axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].areLabelsOverlap(boxes[0], boxes[lastVisibleLabelIndex], labelOpt.minSpacing, _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].center)) {\r\n            \"first\" === labelOpt.hideFirstOrLast ? majorTicks[0].removeLabel() : majorTicks[lastVisibleLabelIndex].removeLabel()\r\n        }\r\n    },\r\n    shift: function(margins) {\r\n        this._axisGroup.attr({\r\n            translateX: margins.right,\r\n            translateY: margins.bottom\r\n        });\r\n        this._axisElementsGroup.attr({\r\n            translateX: margins.right,\r\n            translateY: margins.bottom\r\n        })\r\n    },\r\n    getTranslatedAngle(angle) {\r\n        var startAngle = this.getAngles()[0];\r\n        return angle + startAngle - HALF_PI_ANGLE\r\n    }\r\n};\r\nvar circular = circularAxes;\r\nvar circularSpider = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])({}, circularAxes, {\r\n    _createAxisElement: function() {\r\n        return this._renderer.path([], \"area\")\r\n    },\r\n    _updateAxisElementPosition: function() {\r\n        this._axisElement.attr({\r\n            points: Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(this.getSpiderTicks(), (function(tick) {\r\n                return {\r\n                    x: tick.coords.x,\r\n                    y: tick.coords.y\r\n                }\r\n            }))\r\n        })\r\n    },\r\n    _getStick: function() {\r\n        return true\r\n    },\r\n    _getSpiderCategoryOption: function() {\r\n        return true\r\n    },\r\n    getSpiderTicks: function() {\r\n        var ticks = this.getFullTicks();\r\n        this._spiderTicks = ticks.map(Object(_tick__WEBPACK_IMPORTED_MODULE_5__[\"tick\"])(this, this.renderer, {}, {}, this._getSkippedCategory(ticks), true));\r\n        this._spiderTicks.forEach((function(tick) {\r\n            tick.initCoords()\r\n        }));\r\n        return this._spiderTicks\r\n    },\r\n    _getStripGraphicAttributes: function(fromAngle, toAngle) {\r\n        var center = this.getCenter();\r\n        var spiderTicks = this.getSpiderTicks();\r\n        var firstTick;\r\n        var lastTick;\r\n        var nextTick;\r\n        var tick;\r\n        var points = [];\r\n        var i = 0;\r\n        var len = spiderTicks.length;\r\n        while (i < len) {\r\n            tick = spiderTicks[i].coords;\r\n            if (tick.angle >= fromAngle && tick.angle <= toAngle) {\r\n                if (!firstTick) {\r\n                    firstTick = (spiderTicks[i - 1] || spiderTicks[spiderTicks.length - 1]).coords;\r\n                    points.push((tick.x + firstTick.x) / 2, (tick.y + firstTick.y) / 2)\r\n                }\r\n                points.push(tick.x, tick.y);\r\n                nextTick = (spiderTicks[i + 1] || spiderTicks[0]).coords;\r\n                lastTick = {\r\n                    x: (tick.x + nextTick.x) / 2,\r\n                    y: (tick.y + nextTick.y) / 2\r\n                }\r\n            }\r\n            i++\r\n        }\r\n        points.push(lastTick.x, lastTick.y);\r\n        points.push(center.x, center.y);\r\n        return {\r\n            points: points\r\n        }\r\n    },\r\n    _createStrip: function(_ref2) {\r\n        var {\r\n            points: points\r\n        } = _ref2;\r\n        return this._renderer.path(points, \"area\")\r\n    },\r\n    _getTranslatedCoord: function(value, offset) {\r\n        return this._translator.translate(value, offset) - HALF_PI_ANGLE\r\n    },\r\n    _setTickOffset: function() {\r\n        this._tickOffset = false\r\n    }\r\n});\r\nvar linear = {\r\n    _resetMargins() {\r\n        this._reinitTranslator(this._getViewportRange())\r\n    },\r\n    _getStick: xyAxesLinear._getStick,\r\n    _getSpiderCategoryOption: _core_utils_common__WEBPACK_IMPORTED_MODULE_7__[\"noop\"],\r\n    _getTranslatorOptions: function() {\r\n        return {\r\n            isHorizontal: true,\r\n            stick: this._getStick()\r\n        }\r\n    },\r\n    getRadius: circularAxes.getRadius,\r\n    getCenter: circularAxes.getCenter,\r\n    getAngles: circularAxes.getAngles,\r\n    _updateRadius: circularAxes._updateRadius,\r\n    _updateCenter: circularAxes._updateCenter,\r\n    _processCanvas(canvas) {\r\n        this._updateRadius(canvas);\r\n        this._updateCenter(canvas);\r\n        return {\r\n            left: 0,\r\n            right: 0,\r\n            startPadding: canvas.startPadding,\r\n            endPadding: canvas.endPadding,\r\n            width: this.getRadius()\r\n        }\r\n    },\r\n    _createAxisElement: xyAxesLinear._createAxisElement,\r\n    _updateAxisElementPosition: function() {\r\n        var centerCoord = this.getCenter();\r\n        this._axisElement.attr({\r\n            points: [centerCoord.x, centerCoord.y, centerCoord.x + this.getRadius(), centerCoord.y]\r\n        }).rotate(this.getAngles()[0] - HALF_PI_ANGLE, centerCoord.x, centerCoord.y)\r\n    },\r\n    _getScreenDelta: function() {\r\n        return this.getRadius()\r\n    },\r\n    _getTickMarkPoints: function(coords, length) {\r\n        return [coords.x - length / 2, coords.y, coords.x + length / 2, coords.y]\r\n    },\r\n    _getLabelAdjustedCoord: function(tick) {\r\n        var labelCoords = tick.labelCoords;\r\n        var labelY = labelCoords.y;\r\n        var cosSin = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getCosAndSin\"])(labelCoords.angle);\r\n        var indentFromAxis = this._options.label.indentFromAxis || 0;\r\n        var box = tick.labelBBox;\r\n        var x = labelCoords.x - abs(indentFromAxis * cosSin.sin) + abs(box.width / 2 * cosSin.cos) - box.width / 2;\r\n        var y = labelY + (labelY - box.y) - abs(box.height / 2 * cosSin.sin) + abs(indentFromAxis * cosSin.cos);\r\n        return {\r\n            x: x,\r\n            y: y\r\n        }\r\n    },\r\n    _getGridLineDrawer: function() {\r\n        var that = this;\r\n        return function(tick, gridStyle) {\r\n            var grid = that._getGridPoints(tick.coords);\r\n            return that._renderer.circle(grid.cx, grid.cy, grid.r).attr(gridStyle).sharp()\r\n        }\r\n    },\r\n    _getGridPoints: function(coords) {\r\n        var pos = this.getCenter();\r\n        var radius = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getDistance\"])(pos.x, pos.y, coords.x, coords.y);\r\n        if (radius > this.getRadius()) {\r\n            return {\r\n                cx: null,\r\n                cy: null,\r\n                r: null\r\n            }\r\n        }\r\n        return {\r\n            cx: pos.x,\r\n            cy: pos.y,\r\n            r: radius\r\n        }\r\n    },\r\n    _getTranslatedValue: function(value, offset) {\r\n        var startAngle = this.getAngles()[0];\r\n        var xy = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"convertPolarToXY\"])(this.getCenter(), startAngle, 0, this._translator.translate(value, offset));\r\n        return {\r\n            x: xy.x,\r\n            y: xy.y,\r\n            angle: startAngle - HALF_PI_ANGLE\r\n        }\r\n    },\r\n    _getTranslatedCoord: function(value, offset) {\r\n        return this._translator.translate(value, offset)\r\n    },\r\n    _getCanvasStartEnd() {\r\n        var invert = this.getTranslator().getBusinessRange().invert;\r\n        var coords = [0, this.getRadius()];\r\n        invert && coords.reverse();\r\n        return {\r\n            start: coords[0],\r\n            end: coords[1]\r\n        }\r\n    },\r\n    _getStripGraphicAttributes: function(fromPoint, toPoint) {\r\n        var center = this.getCenter();\r\n        return {\r\n            x: center.x,\r\n            y: center.y,\r\n            innerRadius: fromPoint,\r\n            outerRadius: toPoint\r\n        }\r\n    },\r\n    _createStrip: function(attrs) {\r\n        return this._renderer.arc(attrs.x, attrs.y, attrs.innerRadius, attrs.outerRadius, 0, 360)\r\n    },\r\n    _getAdjustedStripLabelCoords: circularAxes._getAdjustedStripLabelCoords,\r\n    _getStripLabelCoords: function(from, to) {\r\n        var labelPos = from + (to - from) / 2;\r\n        var center = this.getCenter();\r\n        var y = round(center.y - labelPos);\r\n        return {\r\n            x: center.x,\r\n            y: y,\r\n            align: _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].center\r\n        }\r\n    },\r\n    _getConstantLineGraphicAttributes: function(value) {\r\n        var center = this.getCenter();\r\n        return {\r\n            cx: center.x,\r\n            cy: center.y,\r\n            r: value\r\n        }\r\n    },\r\n    _createConstantLine: function(value, attr) {\r\n        var attrs = this._getConstantLineGraphicAttributes(value);\r\n        return this._renderer.circle(attrs.cx, attrs.cy, attrs.r).attr(attr).sharp()\r\n    },\r\n    _getConstantLineLabelsCoords: function(value) {\r\n        var center = this.getCenter();\r\n        var y = round(center.y - value);\r\n        return {\r\n            x: center.x,\r\n            y: y\r\n        }\r\n    },\r\n    _checkAlignmentConstantLineLabels: _core_utils_common__WEBPACK_IMPORTED_MODULE_7__[\"noop\"],\r\n    _rotateTick: function(element, coords, isGridLine) {\r\n        !isGridLine && element.rotate(coords.angle + HALF_PI_ANGLE, coords.x, coords.y)\r\n    },\r\n    _validateOverlappingMode: circularAxes._validateOverlappingMode,\r\n    _validateDisplayMode: circularAxes._validateDisplayMode,\r\n    _getStep: function(boxes) {\r\n        var quarter = getPolarQuarter(this.getAngles()[0]);\r\n        var spacing = this._options.label.minSpacing;\r\n        var func = 2 === quarter || 4 === quarter ? function(box) {\r\n            return box.width + spacing\r\n        } : function(box) {\r\n            return box.height\r\n        };\r\n        var maxLabelLength = boxes.reduce((prevValue, box) => _max(prevValue, func(box)), 0);\r\n        return _axes_constants__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getTicksCountInRange(this._majorTicks, 2 === quarter || 4 === quarter ? \"x\" : \"y\", maxLabelLength)\r\n    }\r\n};\r\nvar linearSpider = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])({}, linear, {\r\n    _createPathElement: function(points, attr) {\r\n        return this._renderer.path(points, \"area\").attr(attr).sharp()\r\n    },\r\n    setSpiderTicks: function(ticks) {\r\n        this._spiderTicks = ticks\r\n    },\r\n    _getGridLineDrawer: function() {\r\n        var that = this;\r\n        return function(tick, gridStyle) {\r\n            return that._createPathElement(that._getGridPoints(tick.coords).points, gridStyle)\r\n        }\r\n    },\r\n    _getGridPoints: function(coords) {\r\n        var pos = this.getCenter();\r\n        var radius = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getDistance\"])(pos.x, pos.y, coords.x, coords.y);\r\n        return this._getGridPointsByRadius(radius)\r\n    },\r\n    _getGridPointsByRadius: function(radius) {\r\n        var pos = this.getCenter();\r\n        if (radius > this.getRadius()) {\r\n            return {\r\n                points: null\r\n            }\r\n        }\r\n        return {\r\n            points: Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(this._spiderTicks, (function(tick) {\r\n                var cosSin = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getCosAndSin\"])(tick.coords.angle);\r\n                return {\r\n                    x: round(pos.x + radius * cosSin.cos),\r\n                    y: round(pos.y + radius * cosSin.sin)\r\n                }\r\n            }))\r\n        }\r\n    },\r\n    _getStripGraphicAttributes: function(fromPoint, toPoint) {\r\n        var innerPoints = this._getGridPointsByRadius(toPoint).points;\r\n        var outerPoints = this._getGridPointsByRadius(fromPoint).points;\r\n        return {\r\n            points: [outerPoints, innerPoints.reverse()]\r\n        }\r\n    },\r\n    _createStrip: circularSpider._createStrip,\r\n    _getConstantLineGraphicAttributes: function(value) {\r\n        return this._getGridPointsByRadius(value)\r\n    },\r\n    _createConstantLine: function(value, attr) {\r\n        return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr)\r\n    }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2F4ZXMvcG9sYXJfYXhlcy5qcz81NTI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVN1QjtBQUdRO0FBR0U7QUFDUTtBQUNWO0FBR2Y7QUFJTTtBQUdXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1CQUFtQixnREFBTTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxrRUFBYztBQUMxQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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Q0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS92aXovYXhlcy9wb2xhcl9heGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS92aXovYXhlcy9wb2xhcl9heGVzLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQge1xyXG4gICAgbWFwIGFzIF9tYXAsXHJcbiAgICBjb252ZXJ0UG9sYXJUb1hZLFxyXG4gICAgY29udmVydFhZVG9Qb2xhcixcclxuICAgIG5vcm1hbGl6ZUFuZ2xlLFxyXG4gICAgZ2V0Vml6UmFuZ2VPYmplY3QsXHJcbiAgICBnZXRDb3NBbmRTaW4sXHJcbiAgICBnZXREaXN0YW5jZVxyXG59IGZyb20gXCIuLi9jb3JlL3V0aWxzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBpc0RlZmluZWRcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy90eXBlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBleHRlbmRcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9leHRlbmRcIjtcclxuaW1wb3J0IGNvbnN0YW50cyBmcm9tIFwiLi9heGVzX2NvbnN0YW50c1wiO1xyXG5pbXBvcnQgeHlBeGVzIGZyb20gXCIuL3h5X2F4ZXNcIjtcclxuaW1wb3J0IHtcclxuICAgIHRpY2tcclxufSBmcm9tIFwiLi90aWNrXCI7XHJcbmltcG9ydCB7XHJcbiAgICBjYWxjdWxhdGVDYW52YXNNYXJnaW5zLFxyXG4gICAgbWVhc3VyZUxhYmVsc1xyXG59IGZyb20gXCIuL2F4ZXNfdXRpbHNcIjtcclxuaW1wb3J0IHtcclxuICAgIG5vb3AgYXMgX25vb3BcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9jb21tb25cIjtcclxudmFyIHtcclxuICAgIFBJOiBQSSxcclxuICAgIGFiczogYWJzLFxyXG4gICAgYXRhbjogYXRhbixcclxuICAgIHJvdW5kOiByb3VuZFxyXG59ID0gTWF0aDtcclxudmFyIF9taW4gPSBNYXRoLm1pbjtcclxudmFyIF9tYXggPSBNYXRoLm1heDtcclxudmFyIHh5QXhlc0xpbmVhciA9IHh5QXhlcy5saW5lYXI7XHJcbnZhciBIQUxGX1BJX0FOR0xFID0gOTA7XHJcblxyXG5mdW5jdGlvbiBnZXRQb2xhclF1YXJ0ZXIoYW5nbGUpIHtcclxuICAgIHZhciBxdWFydGVyO1xyXG4gICAgYW5nbGUgPSBub3JtYWxpemVBbmdsZShhbmdsZSk7XHJcbiAgICBpZiAoYW5nbGUgPj0gMzE1ICYmIGFuZ2xlIDw9IDM2MCB8fCBhbmdsZSA8IDQ1ICYmIGFuZ2xlID49IDApIHtcclxuICAgICAgICBxdWFydGVyID0gMVxyXG4gICAgfSBlbHNlIGlmIChhbmdsZSA+PSA0NSAmJiBhbmdsZSA8IDEzNSkge1xyXG4gICAgICAgIHF1YXJ0ZXIgPSAyXHJcbiAgICB9IGVsc2UgaWYgKGFuZ2xlID49IDEzNSAmJiBhbmdsZSA8IDIyNSkge1xyXG4gICAgICAgIHF1YXJ0ZXIgPSAzXHJcbiAgICB9IGVsc2UgaWYgKGFuZ2xlID49IDIyNSAmJiBhbmdsZSA8IDMxNSkge1xyXG4gICAgICAgIHF1YXJ0ZXIgPSA0XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVhcnRlclxyXG59XHJcbnZhciBjaXJjdWxhckF4ZXMgPSB7XHJcbiAgICBfY2FsY3VsYXRlVmFsdWVNYXJnaW5zKHRpY2tzKSB7XHJcbiAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgbWluVmlzaWJsZTogbWluVmlzaWJsZSxcclxuICAgICAgICAgICAgbWF4VmlzaWJsZTogbWF4VmlzaWJsZVxyXG4gICAgICAgIH0gPSB0aGlzLl9nZXRWaWV3cG9ydFJhbmdlKCk7XHJcbiAgICAgICAgaWYgKHRpY2tzICYmIHRpY2tzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgbWluVmlzaWJsZSA9IG1pblZpc2libGUgPCB0aWNrc1swXS52YWx1ZSA/IG1pblZpc2libGUgOiB0aWNrc1swXS52YWx1ZTtcclxuICAgICAgICAgICAgbWF4VmlzaWJsZSA9IG1pblZpc2libGUgPiB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSA/IG1heFZpc2libGUgOiB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtaW5WYWx1ZTogbWluVmlzaWJsZSxcclxuICAgICAgICAgICAgbWF4VmFsdWU6IG1heFZpc2libGVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgYXBwbHlNYXJnaW5zKCkge1xyXG4gICAgICAgIHZhciBtYXJnaW5zID0gdGhpcy5fY2FsY3VsYXRlVmFsdWVNYXJnaW5zKHRoaXMuX21ham9yVGlja3MpO1xyXG4gICAgICAgIHZhciBiciA9IHRoaXMuX3RyYW5zbGF0b3IuZ2V0QnVzaW5lc3NSYW5nZSgpO1xyXG4gICAgICAgIGJyLmFkZFJhbmdlKHtcclxuICAgICAgICAgICAgbWluVmlzaWJsZTogbWFyZ2lucy5taW5WYWx1ZSxcclxuICAgICAgICAgICAgbWF4VmlzaWJsZTogbWFyZ2lucy5tYXhWYWx1ZSxcclxuICAgICAgICAgICAgaW50ZXJ2YWw6IHRoaXMuX2NhbGN1bGF0ZVJhbmdlSW50ZXJ2YWwoYnIuaW50ZXJ2YWwpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRvci51cGRhdGVCdXNpbmVzc1JhbmdlKGJyKVxyXG4gICAgfSxcclxuICAgIF9nZXRUcmFuc2xhdG9yT3B0aW9uczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaXNIb3Jpem9udGFsOiB0cnVlLFxyXG4gICAgICAgICAgICBjb252ZXJzaW9uVmFsdWU6IHRydWUsXHJcbiAgICAgICAgICAgIGFkZFNwaWRlckNhdGVnb3J5OiB0aGlzLl9nZXRTcGlkZXJDYXRlZ29yeU9wdGlvbigpLFxyXG4gICAgICAgICAgICBzdGljazogdGhpcy5fZ2V0U3RpY2soKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJcclxuICAgIH0sXHJcbiAgICBnZXRSYWRpdXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXNcclxuICAgIH0sXHJcbiAgICBnZXRBbmdsZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICByZXR1cm4gW29wdGlvbnMuc3RhcnRBbmdsZSwgb3B0aW9ucy5lbmRBbmdsZV1cclxuICAgIH0sXHJcbiAgICBfdXBkYXRlUmFkaXVzKGNhbnZhcykge1xyXG4gICAgICAgIHZhciByYWQgPSBfbWluKGNhbnZhcy53aWR0aCAtIGNhbnZhcy5sZWZ0IC0gY2FudmFzLnJpZ2h0LCBjYW52YXMuaGVpZ2h0IC0gY2FudmFzLnRvcCAtIGNhbnZhcy5ib3R0b20pIC8gMjtcclxuICAgICAgICB0aGlzLl9yYWRpdXMgPSByYWQgPCAwID8gMCA6IHJhZFxyXG4gICAgfSxcclxuICAgIF91cGRhdGVDZW50ZXI6IGZ1bmN0aW9uKGNhbnZhcykge1xyXG4gICAgICAgIHRoaXMuX2NlbnRlciA9IHtcclxuICAgICAgICAgICAgeDogY2FudmFzLmxlZnQgKyAoY2FudmFzLndpZHRoIC0gY2FudmFzLnJpZ2h0IC0gY2FudmFzLmxlZnQpIC8gMixcclxuICAgICAgICAgICAgeTogY2FudmFzLnRvcCArIChjYW52YXMuaGVpZ2h0IC0gY2FudmFzLnRvcCAtIGNhbnZhcy5ib3R0b20pIC8gMlxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfcHJvY2Vzc0NhbnZhczogZnVuY3Rpb24oY2FudmFzKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlUmFkaXVzKGNhbnZhcyk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2VudGVyKGNhbnZhcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLl9nZXRTY3JlZW5EZWx0YSgpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9jcmVhdGVBeGlzRWxlbWVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmNpcmNsZSgpXHJcbiAgICB9LFxyXG4gICAgX3VwZGF0ZUF4aXNFbGVtZW50UG9zaXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgIHRoaXMuX2F4aXNFbGVtZW50LmF0dHIoe1xyXG4gICAgICAgICAgICBjeDogY2VudGVyLngsXHJcbiAgICAgICAgICAgIGN5OiBjZW50ZXIueSxcclxuICAgICAgICAgICAgcjogdGhpcy5nZXRSYWRpdXMoKVxyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgX2JvdW5kYXJ5VGlja3NWaXNpYmlsaXR5OiB7XHJcbiAgICAgICAgbWluOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgX2dldFNwaWRlckNhdGVnb3J5T3B0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5maXJzdFBvaW50T25TdGFydEFuZ2xlXHJcbiAgICB9LFxyXG4gICAgX3ZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9yaWdpblZhbHVlID0gb3B0aW9ucy5vcmlnaW5WYWx1ZTtcclxuICAgICAgICB2YXIgd2hvbGVSYW5nZSA9IG9wdGlvbnMud2hvbGVSYW5nZSA9IHt9O1xyXG4gICAgICAgIHZhciBwZXJpb2QgPSBvcHRpb25zLnBlcmlvZDtcclxuICAgICAgICBpZiAoaXNEZWZpbmVkKG9yaWdpblZhbHVlKSkge1xyXG4gICAgICAgICAgICBvcmlnaW5WYWx1ZSA9IHRoaXMudmFsaWRhdGVVbml0KG9yaWdpblZhbHVlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGVyaW9kID4gMCAmJiBvcHRpb25zLmFyZ3VtZW50VHlwZSA9PT0gY29uc3RhbnRzLm51bWVyaWMpIHtcclxuICAgICAgICAgICAgb3JpZ2luVmFsdWUgPSBvcmlnaW5WYWx1ZSB8fCAwO1xyXG4gICAgICAgICAgICB3aG9sZVJhbmdlLmVuZFZhbHVlID0gb3JpZ2luVmFsdWUgKyBwZXJpb2Q7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gZ2V0Vml6UmFuZ2VPYmplY3QoW29yaWdpblZhbHVlLCB3aG9sZVJhbmdlLmVuZFZhbHVlXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZChvcmlnaW5WYWx1ZSkpIHtcclxuICAgICAgICAgICAgd2hvbGVSYW5nZS5zdGFydFZhbHVlID0gb3JpZ2luVmFsdWVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZ2V0TWFyZ2lucygpIHtcclxuICAgICAgICB2YXIgdGlja09wdGlvbnMgPSB0aGlzLl9vcHRpb25zLnRpY2s7XHJcbiAgICAgICAgdmFyIHRpY2tPdXRlckxlbmd0aCA9IF9tYXgodGlja09wdGlvbnMudmlzaWJsZSA/IHRpY2tPcHRpb25zLmxlbmd0aCAvIDIgKyB0aWNrT3B0aW9ucy5zaGlmdCA6IDAsIDApO1xyXG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLmdldFJhZGl1cygpO1xyXG4gICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgIHk6IHlcclxuICAgICAgICB9ID0gdGhpcy5fY2VudGVyO1xyXG4gICAgICAgIHZhciBsYWJlbEJveGVzID0gdGhpcy5fbWFqb3JUaWNrcy5tYXAodCA9PiB0LmxhYmVsICYmIHQubGFiZWwuZ2V0QkJveCgpKS5maWx0ZXIoYiA9PiBiKTtcclxuICAgICAgICB2YXIgY2FudmFzID0gZXh0ZW5kKHt9LCB0aGlzLl9jYW52YXMsIHtcclxuICAgICAgICAgICAgbGVmdDogeCAtIHJhZGl1cyxcclxuICAgICAgICAgICAgdG9wOiB5IC0gcmFkaXVzLFxyXG4gICAgICAgICAgICByaWdodDogdGhpcy5fY2FudmFzLndpZHRoIC0gKHggKyByYWRpdXMpLFxyXG4gICAgICAgICAgICBib3R0b206IHRoaXMuX2NhbnZhcy5oZWlnaHQgLSAoeSArIHJhZGl1cylcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgbWFyZ2lucyA9IGNhbGN1bGF0ZUNhbnZhc01hcmdpbnMobGFiZWxCb3hlcywgY2FudmFzKTtcclxuICAgICAgICBPYmplY3Qua2V5cyhtYXJnaW5zKS5mb3JFYWNoKGsgPT4gbWFyZ2luc1trXSA9IG1hcmdpbnNba10gPCB0aWNrT3V0ZXJMZW5ndGggPyB0aWNrT3V0ZXJMZW5ndGggOiBtYXJnaW5zW2tdKTtcclxuICAgICAgICByZXR1cm4gbWFyZ2luc1xyXG4gICAgfSxcclxuICAgIF91cGRhdGVMYWJlbHNQb3NpdGlvbigpIHtcclxuICAgICAgICBtZWFzdXJlTGFiZWxzKHRoaXMuX21ham9yVGlja3MpO1xyXG4gICAgICAgIHRoaXMuX2FkanVzdExhYmVsc0Nvb3JkKDAsIDAsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuX2NoZWNrQm91bmRlZExhYmVsc092ZXJsYXBwaW5nKHRoaXMuX21ham9yVGlja3MsIHRoaXMuX21ham9yVGlja3MubWFwKHQgPT4gdC5sYWJlbEJCb3gpKVxyXG4gICAgfSxcclxuICAgIF9zZXRWaXN1YWxSYW5nZTogX25vb3AsXHJcbiAgICBhcHBseVZpc3VhbFJhbmdlU2V0dGVyOiBfbm9vcCxcclxuICAgIF9nZXRTdGljazogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZmlyc3RQb2ludE9uU3RhcnRBbmdsZSB8fCB0aGlzLl9vcHRpb25zLnR5cGUgIT09IGNvbnN0YW50cy5kaXNjcmV0ZVxyXG4gICAgfSxcclxuICAgIF9nZXRUcmFuc2xhdGVkQ29vcmQ6IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNsYXRvci50cmFuc2xhdGUodmFsdWUsIG9mZnNldCkgLSBIQUxGX1BJX0FOR0xFXHJcbiAgICB9LFxyXG4gICAgX2dldENhbnZhc1N0YXJ0RW5kOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydDogMCAtIEhBTEZfUElfQU5HTEUsXHJcbiAgICAgICAgICAgIGVuZDogMzYwIC0gSEFMRl9QSV9BTkdMRVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0U3RyaXBHcmFwaGljQXR0cmlidXRlczogZnVuY3Rpb24oZnJvbUFuZ2xlLCB0b0FuZ2xlKSB7XHJcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5nZXRBbmdsZXMoKVswXTtcclxuICAgICAgICB2YXIgciA9IHRoaXMuZ2V0UmFkaXVzKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogY2VudGVyLngsXHJcbiAgICAgICAgICAgIHk6IGNlbnRlci55LFxyXG4gICAgICAgICAgICBpbm5lclJhZGl1czogMCxcclxuICAgICAgICAgICAgb3V0ZXJSYWRpdXM6IHIsXHJcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IC10b0FuZ2xlIC0gYW5nbGUsXHJcbiAgICAgICAgICAgIGVuZEFuZ2xlOiAtZnJvbUFuZ2xlIC0gYW5nbGVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2NyZWF0ZVN0cmlwOiBmdW5jdGlvbihjb29yZHMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuYXJjKGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLmlubmVyUmFkaXVzLCBjb29yZHMub3V0ZXJSYWRpdXMsIGNvb3Jkcy5zdGFydEFuZ2xlLCBjb29yZHMuZW5kQW5nbGUpXHJcbiAgICB9LFxyXG4gICAgX2dldFN0cmlwTGFiZWxDb29yZHM6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XHJcbiAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuX2dldFN0cmlwR3JhcGhpY0F0dHJpYnV0ZXMoZnJvbSwgdG8pO1xyXG4gICAgICAgIHZhciBhbmdsZSA9IGNvb3Jkcy5zdGFydEFuZ2xlICsgKGNvb3Jkcy5lbmRBbmdsZSAtIGNvb3Jkcy5zdGFydEFuZ2xlKSAvIDI7XHJcbiAgICAgICAgdmFyIGNvc1NpbiA9IGdldENvc0FuZFNpbihhbmdsZSk7XHJcbiAgICAgICAgdmFyIGhhbGZSYWQgPSB0aGlzLmdldFJhZGl1cygpIC8gMjtcclxuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcclxuICAgICAgICB2YXIgeCA9IHJvdW5kKGNlbnRlci54ICsgaGFsZlJhZCAqIGNvc1Npbi5jb3MpO1xyXG4gICAgICAgIHZhciB5ID0gcm91bmQoY2VudGVyLnkgLSBoYWxmUmFkICogY29zU2luLnNpbik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeSxcclxuICAgICAgICAgICAgYWxpZ246IGNvbnN0YW50cy5jZW50ZXJcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2dldENvbnN0YW50TGluZUdyYXBoaWNBdHRyaWJ1dGVzOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgIHZhciByID0gdGhpcy5nZXRSYWRpdXMoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwb2ludHM6IFtjZW50ZXIueCwgY2VudGVyLnksIGNlbnRlci54ICsgciwgY2VudGVyLnldXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9jcmVhdGVDb25zdGFudExpbmU6IGZ1bmN0aW9uKHZhbHVlLCBhdHRyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVBhdGhFbGVtZW50KHRoaXMuX2dldENvbnN0YW50TGluZUdyYXBoaWNBdHRyaWJ1dGVzKHZhbHVlKS5wb2ludHMsIGF0dHIpXHJcbiAgICB9LFxyXG4gICAgX3JvdGF0ZUNvbnN0YW50TGluZShsaW5lLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgIHk6IHlcclxuICAgICAgICB9ID0gdGhpcy5nZXRDZW50ZXIoKTtcclxuICAgICAgICBsaW5lLnJvdGF0ZSh2YWx1ZSArIHRoaXMuZ2V0QW5nbGVzKClbMF0sIHgsIHkpXHJcbiAgICB9LFxyXG4gICAgX2dldENvbnN0YW50TGluZUxhYmVsc0Nvb3JkczogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB2YXIgY29zU2luID0gZ2V0Q29zQW5kU2luKC12YWx1ZSAtIHRoaXMuZ2V0QW5nbGVzKClbMF0pO1xyXG4gICAgICAgIHZhciBoYWxmUmFkID0gdGhpcy5nZXRSYWRpdXMoKSAvIDI7XHJcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgdmFyIHggPSByb3VuZChjZW50ZXIueCArIGhhbGZSYWQgKiBjb3NTaW4uY29zKTtcclxuICAgICAgICB2YXIgeSA9IHJvdW5kKGNlbnRlci55IC0gaGFsZlJhZCAqIGNvc1Npbi5zaW4pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgIHk6IHlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2NoZWNrQWxpZ25tZW50Q29uc3RhbnRMaW5lTGFiZWxzOiBfbm9vcCxcclxuICAgIF9hZGp1c3REaXZpc2lvbkZhY3RvcjogZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIDE4MCAqIHZhbCAvICh0aGlzLmdldFJhZGl1cygpICogUEkpXHJcbiAgICB9LFxyXG4gICAgX2dldFNjcmVlbkRlbHRhOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYW5nbGVzID0gdGhpcy5nZXRBbmdsZXMoKTtcclxuICAgICAgICByZXR1cm4gYWJzKGFuZ2xlc1swXSAtIGFuZ2xlc1sxXSlcclxuICAgIH0sXHJcbiAgICBfZ2V0VGlja01hcmtQb2ludHM6IGZ1bmN0aW9uKGNvb3JkcywgbGVuZ3RoLCBfcmVmKSB7XHJcbiAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgc2hpZnQ6IHNoaWZ0ID0gMFxyXG4gICAgICAgIH0gPSBfcmVmO1xyXG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgIHZhciByYWRpdXNXaXRoVGlja3MgPSB0aGlzLmdldFJhZGl1cygpICsgbGVuZ3RoICoge1xyXG4gICAgICAgICAgICBpbnNpZGU6IC0xLFxyXG4gICAgICAgICAgICBjZW50ZXI6IC0uNSxcclxuICAgICAgICAgICAgb3V0c2lkZTogMFxyXG4gICAgICAgIH0gW3RoaXMuX29wdGlvbnMudGlja09yaWVudGF0aW9uIHx8IFwiY2VudGVyXCJdO1xyXG4gICAgICAgIHJldHVybiBbY2VudGVyLnggKyByYWRpdXNXaXRoVGlja3MgKyBzaGlmdCwgY2VudGVyLnksIGNlbnRlci54ICsgcmFkaXVzV2l0aFRpY2tzICsgbGVuZ3RoICsgc2hpZnQsIGNlbnRlci55XVxyXG4gICAgfSxcclxuICAgIF9nZXRMYWJlbEFkanVzdGVkQ29vcmQ6IGZ1bmN0aW9uKHRpY2ssIF9vZmZzZXQsIF9tYXhXaWR0aCwgY2hlY2tDYW52YXMpIHtcclxuICAgICAgICB2YXIgbGFiZWxDb29yZHMgPSB0aWNrLmxhYmVsQ29vcmRzO1xyXG4gICAgICAgIHZhciBsYWJlbFkgPSBsYWJlbENvb3Jkcy55O1xyXG4gICAgICAgIHZhciBsYWJlbEFuZ2xlID0gbGFiZWxDb29yZHMuYW5nbGU7XHJcbiAgICAgICAgdmFyIGNvc1NpbiA9IGdldENvc0FuZFNpbihsYWJlbEFuZ2xlKTtcclxuICAgICAgICB2YXIgY29zID0gY29zU2luLmNvcztcclxuICAgICAgICB2YXIgc2luID0gY29zU2luLnNpbjtcclxuICAgICAgICB2YXIgYm94ID0gdGljay5sYWJlbEJCb3g7XHJcbiAgICAgICAgdmFyIGhhbGZXaWR0aCA9IGJveC53aWR0aCAvIDI7XHJcbiAgICAgICAgdmFyIGhhbGZIZWlnaHQgPSBib3guaGVpZ2h0IC8gMjtcclxuICAgICAgICB2YXIgaW5kZW50RnJvbUF4aXMgPSB0aGlzLl9vcHRpb25zLmxhYmVsLmluZGVudEZyb21BeGlzIHx8IDA7XHJcbiAgICAgICAgdmFyIHggPSBsYWJlbENvb3Jkcy54ICsgaW5kZW50RnJvbUF4aXMgKiBjb3M7XHJcbiAgICAgICAgdmFyIHkgPSBsYWJlbFkgKyAobGFiZWxZIC0gYm94LnkgLSBoYWxmSGVpZ2h0KSArIGluZGVudEZyb21BeGlzICogc2luO1xyXG4gICAgICAgIHZhciBzaGlmdFggPSAwO1xyXG4gICAgICAgIHZhciBzaGlmdFkgPSAwO1xyXG4gICAgICAgIHN3aXRjaCAoZ2V0UG9sYXJRdWFydGVyKGxhYmVsQW5nbGUpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIHNoaWZ0WCA9IGhhbGZXaWR0aDtcclxuICAgICAgICAgICAgICAgIHNoaWZ0WSA9IGhhbGZIZWlnaHQgKiBzaW47XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgc2hpZnRYID0gaGFsZldpZHRoICogY29zO1xyXG4gICAgICAgICAgICAgICAgc2hpZnRZID0gaGFsZkhlaWdodDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBzaGlmdFggPSAtaGFsZldpZHRoO1xyXG4gICAgICAgICAgICAgICAgc2hpZnRZID0gaGFsZkhlaWdodCAqIHNpbjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBzaGlmdFggPSBoYWxmV2lkdGggKiBjb3M7XHJcbiAgICAgICAgICAgICAgICBzaGlmdFkgPSAtaGFsZkhlaWdodFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hlY2tDYW52YXMpIHtcclxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcclxuICAgICAgICAgICAgdmFyIGJveFNoaWZ0WCA9IHggLSBsYWJlbENvb3Jkcy54ICsgc2hpZnRYO1xyXG4gICAgICAgICAgICB2YXIgYm94U2hpZnRZID0geSAtIGxhYmVsQ29vcmRzLnkgKyBzaGlmdFk7XHJcbiAgICAgICAgICAgIGlmIChib3gueCArIGJveFNoaWZ0WCA8IGNhbnZhcy5vcmlnaW5hbExlZnQpIHtcclxuICAgICAgICAgICAgICAgIHNoaWZ0WCAtPSBib3gueCArIGJveFNoaWZ0WCAtIGNhbnZhcy5vcmlnaW5hbExlZnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm94LnggKyBib3gud2lkdGggKyBib3hTaGlmdFggPiBjYW52YXMud2lkdGggLSBjYW52YXMub3JpZ2luYWxSaWdodCkge1xyXG4gICAgICAgICAgICAgICAgc2hpZnRYIC09IGJveC54ICsgYm94LndpZHRoICsgYm94U2hpZnRYIC0gKGNhbnZhcy53aWR0aCAtIGNhbnZhcy5vcmlnaW5hbFJpZ2h0KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3gueSArIGJveFNoaWZ0WSA8IGNhbnZhcy5vcmlnaW5hbFRvcCkge1xyXG4gICAgICAgICAgICAgICAgc2hpZnRZIC09IGJveC55ICsgYm94U2hpZnRZIC0gY2FudmFzLm9yaWdpbmFsVG9wXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJveC55ICsgYm94LmhlaWdodCArIGJveFNoaWZ0WSA+IGNhbnZhcy5oZWlnaHQgLSBjYW52YXMub3JpZ2luYWxCb3R0b20pIHtcclxuICAgICAgICAgICAgICAgIHNoaWZ0WSAtPSBib3gueSArIGJveC5oZWlnaHQgKyBib3hTaGlmdFkgLSAoY2FudmFzLmhlaWdodCAtIGNhbnZhcy5vcmlnaW5hbEJvdHRvbSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB4ICsgc2hpZnRYLFxyXG4gICAgICAgICAgICB5OiB5ICsgc2hpZnRZXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9nZXRHcmlkTGluZURyYXdlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0aWNrLCBncmlkU3R5bGUpIHtcclxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoYXQuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGF0Ll9jcmVhdGVQYXRoRWxlbWVudCh0aGF0Ll9nZXRHcmlkUG9pbnRzKCkucG9pbnRzLCBncmlkU3R5bGUpLnJvdGF0ZSh0aWNrLmNvb3Jkcy5hbmdsZSwgY2VudGVyLngsIGNlbnRlci55KVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0R3JpZFBvaW50czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHIgPSB0aGlzLmdldFJhZGl1cygpO1xyXG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBvaW50czogW2NlbnRlci54LCBjZW50ZXIueSwgY2VudGVyLnggKyByLCBjZW50ZXIueV1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2dldFRyYW5zbGF0ZWRWYWx1ZTogZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciBzdGFydEFuZ2xlID0gdGhpcy5nZXRBbmdsZXMoKVswXTtcclxuICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLl90cmFuc2xhdG9yLnRyYW5zbGF0ZSh2YWx1ZSwgLW9mZnNldCk7XHJcbiAgICAgICAgdmFyIGNvb3JkcyA9IGNvbnZlcnRQb2xhclRvWFkodGhpcy5nZXRDZW50ZXIoKSwgc3RhcnRBbmdsZSwgYW5nbGUsIHRoaXMuZ2V0UmFkaXVzKCkpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IGNvb3Jkcy54LFxyXG4gICAgICAgICAgICB5OiBjb29yZHMueSxcclxuICAgICAgICAgICAgYW5nbGU6IHRoaXMuZ2V0VHJhbnNsYXRlZEFuZ2xlKGFuZ2xlKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0QWRqdXN0ZWRTdHJpcExhYmVsQ29vcmRzOiBmdW5jdGlvbihzdHJpcCkge1xyXG4gICAgICAgIHZhciBib3ggPSBzdHJpcC5sYWJlbEJCb3g7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHJhbnNsYXRlWTogc3RyaXAubGFiZWwuYXR0cihcInlcIikgLSBib3gueSAtIGJveC5oZWlnaHQgLyAyXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvb3Jkc0luOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRYWVRvUG9sYXIodGhpcy5nZXRDZW50ZXIoKSwgeCwgeSkuciA+IHRoaXMuZ2V0UmFkaXVzKClcclxuICAgIH0sXHJcbiAgICBfcm90YXRlVGljazogZnVuY3Rpb24oZWxlbWVudCwgY29vcmRzKSB7XHJcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgZWxlbWVudC5yb3RhdGUoY29vcmRzLmFuZ2xlLCBjZW50ZXIueCwgY2VudGVyLnkpXHJcbiAgICB9LFxyXG4gICAgX3ZhbGlkYXRlT3ZlcmxhcHBpbmdNb2RlOiBmdW5jdGlvbihtb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50cy52YWxpZGF0ZU92ZXJsYXBwaW5nTW9kZShtb2RlKVxyXG4gICAgfSxcclxuICAgIF92YWxpZGF0ZURpc3BsYXlNb2RlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gXCJzdGFuZGFyZFwiXHJcbiAgICB9LFxyXG4gICAgX2dldFN0ZXA6IGZ1bmN0aW9uKGJveGVzKSB7XHJcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuZ2V0UmFkaXVzKCkgKyAodGhpcy5fb3B0aW9ucy5sYWJlbC5pbmRlbnRGcm9tQXhpcyB8fCAwKTtcclxuICAgICAgICB2YXIgbWF4TGFiZWxCb3ggPSBib3hlcy5yZWR1Y2UoKGZ1bmN0aW9uKHByZXZWYWx1ZSwgYm94KSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJWYWx1ZSA9IHByZXZWYWx1ZTtcclxuICAgICAgICAgICAgaWYgKHByZXZWYWx1ZS53aWR0aCA8IGJveC53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgY3VyVmFsdWUud2lkdGggPSBib3gud2lkdGhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldlZhbHVlLmhlaWdodCA8IGJveC5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGN1clZhbHVlLmhlaWdodCA9IGJveC5oZWlnaHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3VyVmFsdWVcclxuICAgICAgICB9KSwge1xyXG4gICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGFuZ2xlMSA9IGFicygyICogYXRhbihtYXhMYWJlbEJveC5oZWlnaHQgLyAoMiAqIHJhZGl1cyAtIG1heExhYmVsQm94LndpZHRoKSkgKiAxODAgLyBQSSk7XHJcbiAgICAgICAgdmFyIGFuZ2xlMiA9IGFicygyICogYXRhbihtYXhMYWJlbEJveC53aWR0aCAvICgyICogcmFkaXVzIC0gbWF4TGFiZWxCb3guaGVpZ2h0KSkgKiAxODAgLyBQSSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50cy5nZXRUaWNrc0NvdW50SW5SYW5nZSh0aGlzLl9tYWpvclRpY2tzLCBcImFuZ2xlXCIsIF9tYXgoYW5nbGUxLCBhbmdsZTIpKVxyXG4gICAgfSxcclxuICAgIF9jaGVja0JvdW5kZWRMYWJlbHNPdmVybGFwcGluZzogZnVuY3Rpb24obWFqb3JUaWNrcywgYm94ZXMsIG1vZGUpIHtcclxuICAgICAgICB2YXIgbGFiZWxPcHQgPSB0aGlzLl9vcHRpb25zLmxhYmVsO1xyXG4gICAgICAgIG1vZGUgPSBtb2RlIHx8IHRoaXMuX3ZhbGlkYXRlT3ZlcmxhcHBpbmdNb2RlKGxhYmVsT3B0Lm92ZXJsYXBwaW5nQmVoYXZpb3IpO1xyXG4gICAgICAgIGlmIChcImhpZGVcIiAhPT0gbW9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxhc3RWaXNpYmxlTGFiZWxJbmRleCA9IG1ham9yVGlja3MucmVkdWNlKChsYXN0VmlzaWJsZUxhYmVsSW5kZXgsIHRpY2ssIGluZGV4KSA9PiB0aWNrLmxhYmVsID8gaW5kZXggOiBsYXN0VmlzaWJsZUxhYmVsSW5kZXgsIG51bGwpO1xyXG4gICAgICAgIGlmICghbGFzdFZpc2libGVMYWJlbEluZGV4KSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uc3RhbnRzLmFyZUxhYmVsc092ZXJsYXAoYm94ZXNbMF0sIGJveGVzW2xhc3RWaXNpYmxlTGFiZWxJbmRleF0sIGxhYmVsT3B0Lm1pblNwYWNpbmcsIGNvbnN0YW50cy5jZW50ZXIpKSB7XHJcbiAgICAgICAgICAgIFwiZmlyc3RcIiA9PT0gbGFiZWxPcHQuaGlkZUZpcnN0T3JMYXN0ID8gbWFqb3JUaWNrc1swXS5yZW1vdmVMYWJlbCgpIDogbWFqb3JUaWNrc1tsYXN0VmlzaWJsZUxhYmVsSW5kZXhdLnJlbW92ZUxhYmVsKClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2hpZnQ6IGZ1bmN0aW9uKG1hcmdpbnMpIHtcclxuICAgICAgICB0aGlzLl9heGlzR3JvdXAuYXR0cih7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6IG1hcmdpbnMucmlnaHQsXHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IG1hcmdpbnMuYm90dG9tXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fYXhpc0VsZW1lbnRzR3JvdXAuYXR0cih7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6IG1hcmdpbnMucmlnaHQsXHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IG1hcmdpbnMuYm90dG9tXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBnZXRUcmFuc2xhdGVkQW5nbGUoYW5nbGUpIHtcclxuICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHRoaXMuZ2V0QW5nbGVzKClbMF07XHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlICsgc3RhcnRBbmdsZSAtIEhBTEZfUElfQU5HTEVcclxuICAgIH1cclxufTtcclxuZXhwb3J0IHZhciBjaXJjdWxhciA9IGNpcmN1bGFyQXhlcztcclxuZXhwb3J0IHZhciBjaXJjdWxhclNwaWRlciA9IGV4dGVuZCh7fSwgY2lyY3VsYXJBeGVzLCB7XHJcbiAgICBfY3JlYXRlQXhpc0VsZW1lbnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5wYXRoKFtdLCBcImFyZWFcIilcclxuICAgIH0sXHJcbiAgICBfdXBkYXRlQXhpc0VsZW1lbnRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fYXhpc0VsZW1lbnQuYXR0cih7XHJcbiAgICAgICAgICAgIHBvaW50czogX21hcCh0aGlzLmdldFNwaWRlclRpY2tzKCksIChmdW5jdGlvbih0aWNrKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHRpY2suY29vcmRzLngsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogdGljay5jb29yZHMueVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuICAgIF9nZXRTdGljazogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWVcclxuICAgIH0sXHJcbiAgICBfZ2V0U3BpZGVyQ2F0ZWdvcnlPcHRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9LFxyXG4gICAgZ2V0U3BpZGVyVGlja3M6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aWNrcyA9IHRoaXMuZ2V0RnVsbFRpY2tzKCk7XHJcbiAgICAgICAgdGhpcy5fc3BpZGVyVGlja3MgPSB0aWNrcy5tYXAodGljayh0aGlzLCB0aGlzLnJlbmRlcmVyLCB7fSwge30sIHRoaXMuX2dldFNraXBwZWRDYXRlZ29yeSh0aWNrcyksIHRydWUpKTtcclxuICAgICAgICB0aGlzLl9zcGlkZXJUaWNrcy5mb3JFYWNoKChmdW5jdGlvbih0aWNrKSB7XHJcbiAgICAgICAgICAgIHRpY2suaW5pdENvb3JkcygpXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zcGlkZXJUaWNrc1xyXG4gICAgfSxcclxuICAgIF9nZXRTdHJpcEdyYXBoaWNBdHRyaWJ1dGVzOiBmdW5jdGlvbihmcm9tQW5nbGUsIHRvQW5nbGUpIHtcclxuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcclxuICAgICAgICB2YXIgc3BpZGVyVGlja3MgPSB0aGlzLmdldFNwaWRlclRpY2tzKCk7XHJcbiAgICAgICAgdmFyIGZpcnN0VGljaztcclxuICAgICAgICB2YXIgbGFzdFRpY2s7XHJcbiAgICAgICAgdmFyIG5leHRUaWNrO1xyXG4gICAgICAgIHZhciB0aWNrO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIGxlbiA9IHNwaWRlclRpY2tzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgICAgICB0aWNrID0gc3BpZGVyVGlja3NbaV0uY29vcmRzO1xyXG4gICAgICAgICAgICBpZiAodGljay5hbmdsZSA+PSBmcm9tQW5nbGUgJiYgdGljay5hbmdsZSA8PSB0b0FuZ2xlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0VGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0VGljayA9IChzcGlkZXJUaWNrc1tpIC0gMV0gfHwgc3BpZGVyVGlja3Nbc3BpZGVyVGlja3MubGVuZ3RoIC0gMV0pLmNvb3JkcztcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCgodGljay54ICsgZmlyc3RUaWNrLngpIC8gMiwgKHRpY2sueSArIGZpcnN0VGljay55KSAvIDIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh0aWNrLngsIHRpY2sueSk7XHJcbiAgICAgICAgICAgICAgICBuZXh0VGljayA9IChzcGlkZXJUaWNrc1tpICsgMV0gfHwgc3BpZGVyVGlja3NbMF0pLmNvb3JkcztcclxuICAgICAgICAgICAgICAgIGxhc3RUaWNrID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6ICh0aWNrLnggKyBuZXh0VGljay54KSAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogKHRpY2sueSArIG5leHRUaWNrLnkpIC8gMlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrK1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb2ludHMucHVzaChsYXN0VGljay54LCBsYXN0VGljay55KTtcclxuICAgICAgICBwb2ludHMucHVzaChjZW50ZXIueCwgY2VudGVyLnkpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9jcmVhdGVTdHJpcDogZnVuY3Rpb24oX3JlZjIpIHtcclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50c1xyXG4gICAgICAgIH0gPSBfcmVmMjtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIucGF0aChwb2ludHMsIFwiYXJlYVwiKVxyXG4gICAgfSxcclxuICAgIF9nZXRUcmFuc2xhdGVkQ29vcmQ6IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNsYXRvci50cmFuc2xhdGUodmFsdWUsIG9mZnNldCkgLSBIQUxGX1BJX0FOR0xFXHJcbiAgICB9LFxyXG4gICAgX3NldFRpY2tPZmZzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3RpY2tPZmZzZXQgPSBmYWxzZVxyXG4gICAgfVxyXG59KTtcclxuZXhwb3J0IHZhciBsaW5lYXIgPSB7XHJcbiAgICBfcmVzZXRNYXJnaW5zKCkge1xyXG4gICAgICAgIHRoaXMuX3JlaW5pdFRyYW5zbGF0b3IodGhpcy5fZ2V0Vmlld3BvcnRSYW5nZSgpKVxyXG4gICAgfSxcclxuICAgIF9nZXRTdGljazogeHlBeGVzTGluZWFyLl9nZXRTdGljayxcclxuICAgIF9nZXRTcGlkZXJDYXRlZ29yeU9wdGlvbjogX25vb3AsXHJcbiAgICBfZ2V0VHJhbnNsYXRvck9wdGlvbnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbDogdHJ1ZSxcclxuICAgICAgICAgICAgc3RpY2s6IHRoaXMuX2dldFN0aWNrKClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZ2V0UmFkaXVzOiBjaXJjdWxhckF4ZXMuZ2V0UmFkaXVzLFxyXG4gICAgZ2V0Q2VudGVyOiBjaXJjdWxhckF4ZXMuZ2V0Q2VudGVyLFxyXG4gICAgZ2V0QW5nbGVzOiBjaXJjdWxhckF4ZXMuZ2V0QW5nbGVzLFxyXG4gICAgX3VwZGF0ZVJhZGl1czogY2lyY3VsYXJBeGVzLl91cGRhdGVSYWRpdXMsXHJcbiAgICBfdXBkYXRlQ2VudGVyOiBjaXJjdWxhckF4ZXMuX3VwZGF0ZUNlbnRlcixcclxuICAgIF9wcm9jZXNzQ2FudmFzKGNhbnZhcykge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVJhZGl1cyhjYW52YXMpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNlbnRlcihjYW52YXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgICAgICBzdGFydFBhZGRpbmc6IGNhbnZhcy5zdGFydFBhZGRpbmcsXHJcbiAgICAgICAgICAgIGVuZFBhZGRpbmc6IGNhbnZhcy5lbmRQYWRkaW5nLFxyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5nZXRSYWRpdXMoKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfY3JlYXRlQXhpc0VsZW1lbnQ6IHh5QXhlc0xpbmVhci5fY3JlYXRlQXhpc0VsZW1lbnQsXHJcbiAgICBfdXBkYXRlQXhpc0VsZW1lbnRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGNlbnRlckNvb3JkID0gdGhpcy5nZXRDZW50ZXIoKTtcclxuICAgICAgICB0aGlzLl9heGlzRWxlbWVudC5hdHRyKHtcclxuICAgICAgICAgICAgcG9pbnRzOiBbY2VudGVyQ29vcmQueCwgY2VudGVyQ29vcmQueSwgY2VudGVyQ29vcmQueCArIHRoaXMuZ2V0UmFkaXVzKCksIGNlbnRlckNvb3JkLnldXHJcbiAgICAgICAgfSkucm90YXRlKHRoaXMuZ2V0QW5nbGVzKClbMF0gLSBIQUxGX1BJX0FOR0xFLCBjZW50ZXJDb29yZC54LCBjZW50ZXJDb29yZC55KVxyXG4gICAgfSxcclxuICAgIF9nZXRTY3JlZW5EZWx0YTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKClcclxuICAgIH0sXHJcbiAgICBfZ2V0VGlja01hcmtQb2ludHM6IGZ1bmN0aW9uKGNvb3JkcywgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtjb29yZHMueCAtIGxlbmd0aCAvIDIsIGNvb3Jkcy55LCBjb29yZHMueCArIGxlbmd0aCAvIDIsIGNvb3Jkcy55XVxyXG4gICAgfSxcclxuICAgIF9nZXRMYWJlbEFkanVzdGVkQ29vcmQ6IGZ1bmN0aW9uKHRpY2spIHtcclxuICAgICAgICB2YXIgbGFiZWxDb29yZHMgPSB0aWNrLmxhYmVsQ29vcmRzO1xyXG4gICAgICAgIHZhciBsYWJlbFkgPSBsYWJlbENvb3Jkcy55O1xyXG4gICAgICAgIHZhciBjb3NTaW4gPSBnZXRDb3NBbmRTaW4obGFiZWxDb29yZHMuYW5nbGUpO1xyXG4gICAgICAgIHZhciBpbmRlbnRGcm9tQXhpcyA9IHRoaXMuX29wdGlvbnMubGFiZWwuaW5kZW50RnJvbUF4aXMgfHwgMDtcclxuICAgICAgICB2YXIgYm94ID0gdGljay5sYWJlbEJCb3g7XHJcbiAgICAgICAgdmFyIHggPSBsYWJlbENvb3Jkcy54IC0gYWJzKGluZGVudEZyb21BeGlzICogY29zU2luLnNpbikgKyBhYnMoYm94LndpZHRoIC8gMiAqIGNvc1Npbi5jb3MpIC0gYm94LndpZHRoIC8gMjtcclxuICAgICAgICB2YXIgeSA9IGxhYmVsWSArIChsYWJlbFkgLSBib3gueSkgLSBhYnMoYm94LmhlaWdodCAvIDIgKiBjb3NTaW4uc2luKSArIGFicyhpbmRlbnRGcm9tQXhpcyAqIGNvc1Npbi5jb3MpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgIHk6IHlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2dldEdyaWRMaW5lRHJhd2VyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRpY2ssIGdyaWRTdHlsZSkge1xyXG4gICAgICAgICAgICB2YXIgZ3JpZCA9IHRoYXQuX2dldEdyaWRQb2ludHModGljay5jb29yZHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhhdC5fcmVuZGVyZXIuY2lyY2xlKGdyaWQuY3gsIGdyaWQuY3ksIGdyaWQucikuYXR0cihncmlkU3R5bGUpLnNoYXJwKClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2dldEdyaWRQb2ludHM6IGZ1bmN0aW9uKGNvb3Jkcykge1xyXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgIHZhciByYWRpdXMgPSBnZXREaXN0YW5jZShwb3MueCwgcG9zLnksIGNvb3Jkcy54LCBjb29yZHMueSk7XHJcbiAgICAgICAgaWYgKHJhZGl1cyA+IHRoaXMuZ2V0UmFkaXVzKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGN4OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgY3k6IG51bGwsXHJcbiAgICAgICAgICAgICAgICByOiBudWxsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY3g6IHBvcy54LFxyXG4gICAgICAgICAgICBjeTogcG9zLnksXHJcbiAgICAgICAgICAgIHI6IHJhZGl1c1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0VHJhbnNsYXRlZFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSB0aGlzLmdldEFuZ2xlcygpWzBdO1xyXG4gICAgICAgIHZhciB4eSA9IGNvbnZlcnRQb2xhclRvWFkodGhpcy5nZXRDZW50ZXIoKSwgc3RhcnRBbmdsZSwgMCwgdGhpcy5fdHJhbnNsYXRvci50cmFuc2xhdGUodmFsdWUsIG9mZnNldCkpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHh5LngsXHJcbiAgICAgICAgICAgIHk6IHh5LnksXHJcbiAgICAgICAgICAgIGFuZ2xlOiBzdGFydEFuZ2xlIC0gSEFMRl9QSV9BTkdMRVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0VHJhbnNsYXRlZENvb3JkOiBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zbGF0b3IudHJhbnNsYXRlKHZhbHVlLCBvZmZzZXQpXHJcbiAgICB9LFxyXG4gICAgX2dldENhbnZhc1N0YXJ0RW5kKCkge1xyXG4gICAgICAgIHZhciBpbnZlcnQgPSB0aGlzLmdldFRyYW5zbGF0b3IoKS5nZXRCdXNpbmVzc1JhbmdlKCkuaW52ZXJ0O1xyXG4gICAgICAgIHZhciBjb29yZHMgPSBbMCwgdGhpcy5nZXRSYWRpdXMoKV07XHJcbiAgICAgICAgaW52ZXJ0ICYmIGNvb3Jkcy5yZXZlcnNlKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnQ6IGNvb3Jkc1swXSxcclxuICAgICAgICAgICAgZW5kOiBjb29yZHNbMV1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2dldFN0cmlwR3JhcGhpY0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKGZyb21Qb2ludCwgdG9Qb2ludCkge1xyXG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IGNlbnRlci54LFxyXG4gICAgICAgICAgICB5OiBjZW50ZXIueSxcclxuICAgICAgICAgICAgaW5uZXJSYWRpdXM6IGZyb21Qb2ludCxcclxuICAgICAgICAgICAgb3V0ZXJSYWRpdXM6IHRvUG9pbnRcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2NyZWF0ZVN0cmlwOiBmdW5jdGlvbihhdHRycykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5hcmMoYXR0cnMueCwgYXR0cnMueSwgYXR0cnMuaW5uZXJSYWRpdXMsIGF0dHJzLm91dGVyUmFkaXVzLCAwLCAzNjApXHJcbiAgICB9LFxyXG4gICAgX2dldEFkanVzdGVkU3RyaXBMYWJlbENvb3JkczogY2lyY3VsYXJBeGVzLl9nZXRBZGp1c3RlZFN0cmlwTGFiZWxDb29yZHMsXHJcbiAgICBfZ2V0U3RyaXBMYWJlbENvb3JkczogZnVuY3Rpb24oZnJvbSwgdG8pIHtcclxuICAgICAgICB2YXIgbGFiZWxQb3MgPSBmcm9tICsgKHRvIC0gZnJvbSkgLyAyO1xyXG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgIHZhciB5ID0gcm91bmQoY2VudGVyLnkgLSBsYWJlbFBvcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogY2VudGVyLngsXHJcbiAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgIGFsaWduOiBjb25zdGFudHMuY2VudGVyXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9nZXRDb25zdGFudExpbmVHcmFwaGljQXR0cmlidXRlczogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjeDogY2VudGVyLngsXHJcbiAgICAgICAgICAgIGN5OiBjZW50ZXIueSxcclxuICAgICAgICAgICAgcjogdmFsdWVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2NyZWF0ZUNvbnN0YW50TGluZTogZnVuY3Rpb24odmFsdWUsIGF0dHIpIHtcclxuICAgICAgICB2YXIgYXR0cnMgPSB0aGlzLl9nZXRDb25zdGFudExpbmVHcmFwaGljQXR0cmlidXRlcyh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmNpcmNsZShhdHRycy5jeCwgYXR0cnMuY3ksIGF0dHJzLnIpLmF0dHIoYXR0cikuc2hhcnAoKVxyXG4gICAgfSxcclxuICAgIF9nZXRDb25zdGFudExpbmVMYWJlbHNDb29yZHM6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgdmFyIHkgPSByb3VuZChjZW50ZXIueSAtIHZhbHVlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBjZW50ZXIueCxcclxuICAgICAgICAgICAgeTogeVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfY2hlY2tBbGlnbm1lbnRDb25zdGFudExpbmVMYWJlbHM6IF9ub29wLFxyXG4gICAgX3JvdGF0ZVRpY2s6IGZ1bmN0aW9uKGVsZW1lbnQsIGNvb3JkcywgaXNHcmlkTGluZSkge1xyXG4gICAgICAgICFpc0dyaWRMaW5lICYmIGVsZW1lbnQucm90YXRlKGNvb3Jkcy5hbmdsZSArIEhBTEZfUElfQU5HTEUsIGNvb3Jkcy54LCBjb29yZHMueSlcclxuICAgIH0sXHJcbiAgICBfdmFsaWRhdGVPdmVybGFwcGluZ01vZGU6IGNpcmN1bGFyQXhlcy5fdmFsaWRhdGVPdmVybGFwcGluZ01vZGUsXHJcbiAgICBfdmFsaWRhdGVEaXNwbGF5TW9kZTogY2lyY3VsYXJBeGVzLl92YWxpZGF0ZURpc3BsYXlNb2RlLFxyXG4gICAgX2dldFN0ZXA6IGZ1bmN0aW9uKGJveGVzKSB7XHJcbiAgICAgICAgdmFyIHF1YXJ0ZXIgPSBnZXRQb2xhclF1YXJ0ZXIodGhpcy5nZXRBbmdsZXMoKVswXSk7XHJcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLl9vcHRpb25zLmxhYmVsLm1pblNwYWNpbmc7XHJcbiAgICAgICAgdmFyIGZ1bmMgPSAyID09PSBxdWFydGVyIHx8IDQgPT09IHF1YXJ0ZXIgPyBmdW5jdGlvbihib3gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJveC53aWR0aCArIHNwYWNpbmdcclxuICAgICAgICB9IDogZnVuY3Rpb24oYm94KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBib3guaGVpZ2h0XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgbWF4TGFiZWxMZW5ndGggPSBib3hlcy5yZWR1Y2UoKHByZXZWYWx1ZSwgYm94KSA9PiBfbWF4KHByZXZWYWx1ZSwgZnVuYyhib3gpKSwgMCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50cy5nZXRUaWNrc0NvdW50SW5SYW5nZSh0aGlzLl9tYWpvclRpY2tzLCAyID09PSBxdWFydGVyIHx8IDQgPT09IHF1YXJ0ZXIgPyBcInhcIiA6IFwieVwiLCBtYXhMYWJlbExlbmd0aClcclxuICAgIH1cclxufTtcclxuZXhwb3J0IHZhciBsaW5lYXJTcGlkZXIgPSBleHRlbmQoe30sIGxpbmVhciwge1xyXG4gICAgX2NyZWF0ZVBhdGhFbGVtZW50OiBmdW5jdGlvbihwb2ludHMsIGF0dHIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIucGF0aChwb2ludHMsIFwiYXJlYVwiKS5hdHRyKGF0dHIpLnNoYXJwKClcclxuICAgIH0sXHJcbiAgICBzZXRTcGlkZXJUaWNrczogZnVuY3Rpb24odGlja3MpIHtcclxuICAgICAgICB0aGlzLl9zcGlkZXJUaWNrcyA9IHRpY2tzXHJcbiAgICB9LFxyXG4gICAgX2dldEdyaWRMaW5lRHJhd2VyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRpY2ssIGdyaWRTdHlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhhdC5fY3JlYXRlUGF0aEVsZW1lbnQodGhhdC5fZ2V0R3JpZFBvaW50cyh0aWNrLmNvb3JkcykucG9pbnRzLCBncmlkU3R5bGUpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9nZXRHcmlkUG9pbnRzOiBmdW5jdGlvbihjb29yZHMpIHtcclxuICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRDZW50ZXIoKTtcclxuICAgICAgICB2YXIgcmFkaXVzID0gZ2V0RGlzdGFuY2UocG9zLngsIHBvcy55LCBjb29yZHMueCwgY29vcmRzLnkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRHcmlkUG9pbnRzQnlSYWRpdXMocmFkaXVzKVxyXG4gICAgfSxcclxuICAgIF9nZXRHcmlkUG9pbnRzQnlSYWRpdXM6IGZ1bmN0aW9uKHJhZGl1cykge1xyXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmdldENlbnRlcigpO1xyXG4gICAgICAgIGlmIChyYWRpdXMgPiB0aGlzLmdldFJhZGl1cygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IG51bGxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwb2ludHM6IF9tYXAodGhpcy5fc3BpZGVyVGlja3MsIChmdW5jdGlvbih0aWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29zU2luID0gZ2V0Q29zQW5kU2luKHRpY2suY29vcmRzLmFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogcm91bmQocG9zLnggKyByYWRpdXMgKiBjb3NTaW4uY29zKSxcclxuICAgICAgICAgICAgICAgICAgICB5OiByb3VuZChwb3MueSArIHJhZGl1cyAqIGNvc1Npbi5zaW4pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0U3RyaXBHcmFwaGljQXR0cmlidXRlczogZnVuY3Rpb24oZnJvbVBvaW50LCB0b1BvaW50KSB7XHJcbiAgICAgICAgdmFyIGlubmVyUG9pbnRzID0gdGhpcy5fZ2V0R3JpZFBvaW50c0J5UmFkaXVzKHRvUG9pbnQpLnBvaW50cztcclxuICAgICAgICB2YXIgb3V0ZXJQb2ludHMgPSB0aGlzLl9nZXRHcmlkUG9pbnRzQnlSYWRpdXMoZnJvbVBvaW50KS5wb2ludHM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcG9pbnRzOiBbb3V0ZXJQb2ludHMsIGlubmVyUG9pbnRzLnJldmVyc2UoKV1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2NyZWF0ZVN0cmlwOiBjaXJjdWxhclNwaWRlci5fY3JlYXRlU3RyaXAsXHJcbiAgICBfZ2V0Q29uc3RhbnRMaW5lR3JhcGhpY0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEdyaWRQb2ludHNCeVJhZGl1cyh2YWx1ZSlcclxuICAgIH0sXHJcbiAgICBfY3JlYXRlQ29uc3RhbnRMaW5lOiBmdW5jdGlvbih2YWx1ZSwgYXR0cikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVQYXRoRWxlbWVudCh0aGlzLl9nZXRDb25zdGFudExpbmVHcmFwaGljQXR0cmlidXRlcyh2YWx1ZSkucG9pbnRzLCBhdHRyKVxyXG4gICAgfVxyXG59KTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/axes/polar_axes.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/axes/smart_formatter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/axes/smart_formatter.js ***!
  \*****************************************************************/
/*! exports provided: smartFormatter, formatRange */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"smartFormatter\", function() { return smartFormatter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatRange\", function() { return formatRange; });\n/* harmony import */ var _format_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../format_helper */ \"./node_modules/devextreme/esm/format_helper.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_date__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/utils/date */ \"./node_modules/devextreme/esm/core/utils/date.js\");\n/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/utils/math */ \"./node_modules/devextreme/esm/core/utils/math.js\");\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/**\r\n * DevExtreme (esm/viz/axes/smart_formatter.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\nvar _format = _format_helper__WEBPACK_IMPORTED_MODULE_0__[\"default\"].format;\r\nvar {\r\n    abs: abs,\r\n    floor: floor\r\n} = Math;\r\nvar EXPONENTIAL = \"exponential\";\r\nvar formats = [\"fixedPoint\", \"thousands\", \"millions\", \"billions\", \"trillions\", EXPONENTIAL];\r\nvar dateUnitIntervals = [\"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"month\", \"year\"];\r\n\r\nfunction getDatesDifferences(prevDate, curDate, nextDate, tickFormat) {\r\n    var prevDifferences;\r\n    var nextDifferences;\r\n    var dateUnitInterval;\r\n    var dateUnitsLength = dateUnitIntervals.length;\r\n    var i;\r\n    var j;\r\n    if (\"week\" === tickFormat) {\r\n        tickFormat = \"day\"\r\n    } else if (\"quarter\" === tickFormat) {\r\n        tickFormat = \"month\"\r\n    } else if (\"shorttime\" === tickFormat) {\r\n        tickFormat = \"hour\"\r\n    } else if (\"longtime\" === tickFormat) {\r\n        tickFormat = \"second\"\r\n    }\r\n    var tickFormatIndex = dateUnitIntervals.indexOf(tickFormat);\r\n    if (nextDate) {\r\n        nextDifferences = _core_utils_date__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getDatesDifferences(curDate, nextDate);\r\n        prevDifferences = _core_utils_date__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getDatesDifferences(curDate, prevDate);\r\n        if (nextDifferences[tickFormat]) {\r\n            for (i = dateUnitsLength - 1; i >= tickFormatIndex; i--) {\r\n                dateUnitInterval = dateUnitIntervals[i];\r\n                if (i === tickFormatIndex) {\r\n                    setDateUnitInterval(nextDifferences, tickFormatIndex + (nextDifferences.millisecond ? 2 : 1))\r\n                } else if (nextDifferences[dateUnitInterval]) {\r\n                    resetDateUnitInterval(nextDifferences, i);\r\n                    break\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        prevDifferences = _core_utils_date__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getDatesDifferences(prevDate, curDate);\r\n        for (i = dateUnitsLength - 1; i >= tickFormatIndex; i--) {\r\n            dateUnitInterval = dateUnitIntervals[i];\r\n            if (prevDifferences[dateUnitInterval]) {\r\n                if (i - tickFormatIndex > 1) {\r\n                    for (j = tickFormatIndex + 1; j >= 0; j--) {\r\n                        resetDateUnitInterval(prevDifferences, j)\r\n                    }\r\n                    break\r\n                } else if (isDateTimeStart(curDate, dateUnitInterval)) {\r\n                    for (j = i - 1; j > 0; j--) {\r\n                        resetDateUnitInterval(prevDifferences, j)\r\n                    }\r\n                    break\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return nextDate ? nextDifferences : prevDifferences\r\n}\r\n\r\nfunction isDateTimeStart(date, dateUnitInterval) {\r\n    var unitNumbers = [date.getMilliseconds(), date.getSeconds(), date.getMinutes(), date.getHours(), date.getDate(), date.getMonth()];\r\n    var unitIndex = dateUnitIntervals.indexOf(dateUnitInterval);\r\n    var i;\r\n    for (i = 0; i < unitIndex; i++) {\r\n        if (4 === i && 1 !== unitNumbers[i] || 4 !== i && 0 !== unitNumbers[i]) {\r\n            return false\r\n        }\r\n    }\r\n    return true\r\n}\r\n\r\nfunction resetDateUnitInterval(differences, intervalIndex) {\r\n    var dateUnitInterval = dateUnitIntervals[intervalIndex];\r\n    if (differences[dateUnitInterval]) {\r\n        differences[dateUnitInterval] = false;\r\n        differences.count--\r\n    }\r\n}\r\n\r\nfunction setDateUnitInterval(differences, intervalIndex) {\r\n    var dateUnitInterval = dateUnitIntervals[intervalIndex];\r\n    if (false === differences[dateUnitInterval]) {\r\n        differences[dateUnitInterval] = true;\r\n        differences.count++\r\n    }\r\n}\r\n\r\nfunction getNoZeroIndex(str) {\r\n    return str.length - parseInt(str).toString().length\r\n}\r\n\r\nfunction getTransitionTickIndex(ticks, value) {\r\n    var i;\r\n    var curDiff;\r\n    var minDiff;\r\n    var nearestTickIndex = 0;\r\n    minDiff = abs(value - ticks[0]);\r\n    for (i = 1; i < ticks.length; i++) {\r\n        curDiff = abs(value - ticks[i]);\r\n        if (curDiff < minDiff) {\r\n            minDiff = curDiff;\r\n            nearestTickIndex = i\r\n        }\r\n    }\r\n    return nearestTickIndex\r\n}\r\n\r\nfunction splitDecimalNumber(value) {\r\n    return value.toString().split(\".\")\r\n}\r\n\r\nfunction createFormat(type) {\r\n    var formatter;\r\n    if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isFunction\"])(type)) {\r\n        formatter = type;\r\n        type = null\r\n    }\r\n    return {\r\n        type: type,\r\n        formatter: formatter\r\n    }\r\n}\r\nfunction smartFormatter(tick, options) {\r\n    var tickInterval = options.tickInterval;\r\n    var tickIntervalIndex;\r\n    var tickIndex;\r\n    var actualIndex;\r\n    var stringTick = abs(tick).toString();\r\n    var precision = 0;\r\n    var typeFormat;\r\n    var offset = 0;\r\n    var separatedTickInterval;\r\n    var indexOfFormat = 0;\r\n    var indexOfTick = -1;\r\n    var datesDifferences;\r\n    var format = options.labelOptions.format;\r\n    var ticks = options.ticks;\r\n    var log10Tick;\r\n    var prevDateIndex;\r\n    var nextDateIndex;\r\n    var isLogarithmic = \"logarithmic\" === options.type;\r\n    if (1 === ticks.length && 0 === ticks.indexOf(tick) && !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(tickInterval)) {\r\n        tickInterval = abs(tick) >= 1 ? 1 : Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"adjust\"])(1 - abs(tick), tick)\r\n    }\r\n    if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(format) && \"discrete\" !== options.type && tick && (10 === options.logarithmBase || !isLogarithmic)) {\r\n        if (\"datetime\" !== options.dataType && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(tickInterval)) {\r\n            if (ticks.length && -1 === ticks.indexOf(tick)) {\r\n                indexOfTick = getTransitionTickIndex(ticks, tick);\r\n                tickInterval = Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"adjust\"])(abs(tick - ticks[indexOfTick]), tick)\r\n            }\r\n            separatedTickInterval = splitDecimalNumber(tickInterval);\r\n            if (separatedTickInterval < 2) {\r\n                separatedTickInterval = splitDecimalNumber(tick)\r\n            }\r\n            if (isLogarithmic) {\r\n                log10Tick = Object(_core_utils__WEBPACK_IMPORTED_MODULE_4__[\"getAdjustedLog10\"])(abs(tick));\r\n                if (log10Tick > 0) {\r\n                    typeFormat = formats[floor(log10Tick / 3)] || EXPONENTIAL\r\n                } else if (log10Tick < -4) {\r\n                    typeFormat = EXPONENTIAL\r\n                } else {\r\n                    return _format(Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"adjust\"])(tick))\r\n                }\r\n            } else if (separatedTickInterval.length > 1 && !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isExponential\"])(tickInterval)) {\r\n                precision = separatedTickInterval[1].length;\r\n                typeFormat = formats[indexOfFormat]\r\n            } else if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isExponential\"])(tickInterval) && (-1 !== stringTick.indexOf(\".\") || Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isExponential\"])(tick))) {\r\n                typeFormat = EXPONENTIAL;\r\n                if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isExponential\"])(tick)) {\r\n                    precision = abs(getNoZeroIndex(stringTick.split(\".\")[1]) - Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"getExponent\"])(tickInterval) + 1)\r\n                } else {\r\n                    precision = Math.max(abs(Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"getExponent\"])(tick) - Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"getExponent\"])(tickInterval)), abs(Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"getPrecision\"])(tick) - Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"getPrecision\"])(tickInterval)))\r\n                }\r\n            } else {\r\n                tickIntervalIndex = floor(Object(_core_utils__WEBPACK_IMPORTED_MODULE_4__[\"getAdjustedLog10\"])(tickInterval));\r\n                actualIndex = tickIndex = floor(Object(_core_utils__WEBPACK_IMPORTED_MODULE_4__[\"getAdjustedLog10\"])(abs(tick)));\r\n                if (tickIndex - tickIntervalIndex >= 2) {\r\n                    actualIndex = tickIntervalIndex\r\n                }\r\n                indexOfFormat = floor(actualIndex / 3);\r\n                offset = 3 * indexOfFormat;\r\n                if (indexOfFormat < 5) {\r\n                    if (tickIntervalIndex - offset === 2 && tickIndex >= 3) {\r\n                        indexOfFormat++;\r\n                        offset = 3 * indexOfFormat\r\n                    }\r\n                    typeFormat = formats[indexOfFormat]\r\n                } else {\r\n                    typeFormat = formats[formats.length - 1]\r\n                }\r\n                if (offset > 0) {\r\n                    separatedTickInterval = splitDecimalNumber(tickInterval / Math.pow(10, offset));\r\n                    if (separatedTickInterval[1]) {\r\n                        precision = separatedTickInterval[1].length\r\n                    }\r\n                }\r\n            }\r\n            if (void 0 !== typeFormat || void 0 !== precision) {\r\n                format = {\r\n                    type: typeFormat,\r\n                    precision: precision\r\n                }\r\n            }\r\n        } else if (\"datetime\" === options.dataType) {\r\n            typeFormat = _core_utils_date__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getDateFormatByTickInterval(tickInterval);\r\n            if (options.showTransition && ticks.length) {\r\n                indexOfTick = ticks.map(Number).indexOf(+tick);\r\n                if (1 === ticks.length && 0 === indexOfTick) {\r\n                    typeFormat = _format_helper__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getDateFormatByTicks(ticks)\r\n                } else {\r\n                    if (-1 === indexOfTick) {\r\n                        prevDateIndex = getTransitionTickIndex(ticks, tick)\r\n                    } else {\r\n                        prevDateIndex = 0 === indexOfTick ? ticks.length - 1 : indexOfTick - 1;\r\n                        nextDateIndex = 0 === indexOfTick ? 1 : -1\r\n                    }\r\n                    datesDifferences = getDatesDifferences(ticks[prevDateIndex], tick, ticks[nextDateIndex], typeFormat);\r\n                    typeFormat = _format_helper__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getDateFormatByDifferences(datesDifferences, typeFormat)\r\n                }\r\n            }\r\n            format = createFormat(typeFormat)\r\n        }\r\n    }\r\n    return _format(tick, format)\r\n}\r\n\r\nfunction getHighDiffFormat(diff) {\r\n    var stop = false;\r\n    for (var i in diff) {\r\n        if (true === diff[i] || \"hour\" === i || stop) {\r\n            diff[i] = false;\r\n            stop = true\r\n        } else if (false === diff[i]) {\r\n            diff[i] = true\r\n        }\r\n    }\r\n    return createFormat(_format_helper__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getDateFormatByDifferences(diff))\r\n}\r\n\r\nfunction getHighAndSelfDiffFormat(diff, interval) {\r\n    var stop = false;\r\n    for (var i in diff) {\r\n        if (stop) {\r\n            diff[i] = false\r\n        } else if (i === interval) {\r\n            stop = true\r\n        } else {\r\n            diff[i] = true\r\n        }\r\n    }\r\n    return createFormat(_format_helper__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getDateFormatByDifferences(diff))\r\n}\r\n\r\nfunction formatDateRange(startValue, endValue, tickInterval) {\r\n    var diff = getDatesDifferences(startValue, endValue);\r\n    var typeFormat = _core_utils_date__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getDateFormatByTickInterval(tickInterval);\r\n    var diffFormatType = _format_helper__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getDateFormatByDifferences(diff, typeFormat);\r\n    var diffFormat = createFormat(diffFormatType);\r\n    var values = [];\r\n    if (tickInterval in diff) {\r\n        var rangeFormat = getHighAndSelfDiffFormat(getDatesDifferences(startValue, endValue), tickInterval);\r\n        var value = _format(startValue, rangeFormat);\r\n        if (value) {\r\n            values.push(value)\r\n        }\r\n    } else {\r\n        var _rangeFormat = getHighDiffFormat(getDatesDifferences(startValue, endValue));\r\n        var highValue = _format(startValue, _rangeFormat);\r\n        if (highValue) {\r\n            values.push(highValue)\r\n        }\r\n        values.push(\"\".concat(_format(startValue, diffFormat), \" - \").concat(_format(endValue, diffFormat)))\r\n    }\r\n    return values.join(\", \")\r\n}\r\n\r\nfunction processDateInterval(interval) {\r\n    if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isObject\"])(interval)) {\r\n        var dateUnits = Object.keys(interval);\r\n        var sum = dateUnits.reduce((sum, k) => interval[k] + sum, 0);\r\n        if (1 === sum) {\r\n            var dateUnit = dateUnits.filter(k => 1 === interval[k])[0];\r\n            return dateUnit.slice(0, dateUnit.length - 1)\r\n        }\r\n    }\r\n    return interval\r\n}\r\nfunction formatRange(_ref) {\r\n    var {\r\n        startValue: startValue,\r\n        endValue: endValue,\r\n        tickInterval: tickInterval,\r\n        argumentFormat: argumentFormat,\r\n        axisOptions: {\r\n            dataType: dataType,\r\n            type: type,\r\n            logarithmBase: logarithmBase\r\n        }\r\n    } = _ref;\r\n    if (\"discrete\" === type) {\r\n        return \"\"\r\n    }\r\n    if (\"datetime\" === dataType) {\r\n        return formatDateRange(startValue, endValue, processDateInterval(tickInterval))\r\n    }\r\n    var formatOptions = {\r\n        ticks: [],\r\n        type: type,\r\n        dataType: dataType,\r\n        tickInterval: tickInterval,\r\n        logarithmBase: logarithmBase,\r\n        labelOptions: {\r\n            format: argumentFormat\r\n        }\r\n    };\r\n    return \"\".concat(smartFormatter(startValue, formatOptions), \" - \").concat(smartFormatter(endValue, formatOptions))\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2F4ZXMvc21hcnRfZm9ybWF0dGVyLmpzP2I0MTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0M7QUFNaEI7QUFDZTtBQUtmO0FBR1I7QUFDdkIsY0FBYyxzREFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBUztBQUNuQywwQkFBMEIsd0RBQVM7QUFDbkM7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQix3REFBUztBQUNuQyxxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxtRUFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsa0VBQVM7QUFDckUsNENBQTRDLCtEQUFNO0FBQ2xEO0FBQ0EsU0FBUyxrRUFBUztBQUNsQiwrQ0FBK0Msa0VBQVM7QUFDeEQ7QUFDQTtBQUNBLCtCQUErQiwrREFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0VBQUs7QUFDakM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQixtQ0FBbUMsK0RBQU07QUFDekM7QUFDQSxhQUFhLCtDQUErQyxzRUFBYTtBQUN6RTtBQUNBO0FBQ0EsYUFBYSxVQUFVLHNFQUFhLHFEQUFxRCxzRUFBYTtBQUN0RztBQUNBLHFCQUFxQixzRUFBYTtBQUNsQywrRUFBK0Usb0VBQVc7QUFDMUYsaUJBQWlCO0FBQ2pCLDZDQUE2QyxvRUFBVyxTQUFTLG9FQUFXLHFCQUFxQixxRUFBWSxTQUFTLHFFQUFZO0FBQ2xJO0FBQ0EsYUFBYTtBQUNiLDBDQUEwQyxvRUFBSztBQUMvQyxnREFBZ0Qsb0VBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseUJBQXlCLHdEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzREFBWTtBQUM3QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzREFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFZO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFZO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQVM7QUFDOUIseUJBQXlCLHNEQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxpRUFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS92aXovYXhlcy9zbWFydF9mb3JtYXR0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3Zpei9heGVzL3NtYXJ0X2Zvcm1hdHRlci5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IGZvcm1hdEhlbHBlciBmcm9tIFwiLi4vLi4vZm9ybWF0X2hlbHBlclwiO1xyXG5pbXBvcnQge1xyXG4gICAgaXNEZWZpbmVkLFxyXG4gICAgaXNGdW5jdGlvbixcclxuICAgIGlzRXhwb25lbnRpYWwsXHJcbiAgICBpc09iamVjdFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL3R5cGVcIjtcclxuaW1wb3J0IGRhdGVVdGlscyBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9kYXRlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBhZGp1c3QsXHJcbiAgICBnZXRQcmVjaXNpb24sXHJcbiAgICBnZXRFeHBvbmVudFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL21hdGhcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldEFkanVzdGVkTG9nMTAgYXMgbG9nMTBcclxufSBmcm9tIFwiLi4vY29yZS91dGlsc1wiO1xyXG52YXIgX2Zvcm1hdCA9IGZvcm1hdEhlbHBlci5mb3JtYXQ7XHJcbnZhciB7XHJcbiAgICBhYnM6IGFicyxcclxuICAgIGZsb29yOiBmbG9vclxyXG59ID0gTWF0aDtcclxudmFyIEVYUE9ORU5USUFMID0gXCJleHBvbmVudGlhbFwiO1xyXG52YXIgZm9ybWF0cyA9IFtcImZpeGVkUG9pbnRcIiwgXCJ0aG91c2FuZHNcIiwgXCJtaWxsaW9uc1wiLCBcImJpbGxpb25zXCIsIFwidHJpbGxpb25zXCIsIEVYUE9ORU5USUFMXTtcclxudmFyIGRhdGVVbml0SW50ZXJ2YWxzID0gW1wibWlsbGlzZWNvbmRcIiwgXCJzZWNvbmRcIiwgXCJtaW51dGVcIiwgXCJob3VyXCIsIFwiZGF5XCIsIFwibW9udGhcIiwgXCJ5ZWFyXCJdO1xyXG5cclxuZnVuY3Rpb24gZ2V0RGF0ZXNEaWZmZXJlbmNlcyhwcmV2RGF0ZSwgY3VyRGF0ZSwgbmV4dERhdGUsIHRpY2tGb3JtYXQpIHtcclxuICAgIHZhciBwcmV2RGlmZmVyZW5jZXM7XHJcbiAgICB2YXIgbmV4dERpZmZlcmVuY2VzO1xyXG4gICAgdmFyIGRhdGVVbml0SW50ZXJ2YWw7XHJcbiAgICB2YXIgZGF0ZVVuaXRzTGVuZ3RoID0gZGF0ZVVuaXRJbnRlcnZhbHMubGVuZ3RoO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgajtcclxuICAgIGlmIChcIndlZWtcIiA9PT0gdGlja0Zvcm1hdCkge1xyXG4gICAgICAgIHRpY2tGb3JtYXQgPSBcImRheVwiXHJcbiAgICB9IGVsc2UgaWYgKFwicXVhcnRlclwiID09PSB0aWNrRm9ybWF0KSB7XHJcbiAgICAgICAgdGlja0Zvcm1hdCA9IFwibW9udGhcIlxyXG4gICAgfSBlbHNlIGlmIChcInNob3J0dGltZVwiID09PSB0aWNrRm9ybWF0KSB7XHJcbiAgICAgICAgdGlja0Zvcm1hdCA9IFwiaG91clwiXHJcbiAgICB9IGVsc2UgaWYgKFwibG9uZ3RpbWVcIiA9PT0gdGlja0Zvcm1hdCkge1xyXG4gICAgICAgIHRpY2tGb3JtYXQgPSBcInNlY29uZFwiXHJcbiAgICB9XHJcbiAgICB2YXIgdGlja0Zvcm1hdEluZGV4ID0gZGF0ZVVuaXRJbnRlcnZhbHMuaW5kZXhPZih0aWNrRm9ybWF0KTtcclxuICAgIGlmIChuZXh0RGF0ZSkge1xyXG4gICAgICAgIG5leHREaWZmZXJlbmNlcyA9IGRhdGVVdGlscy5nZXREYXRlc0RpZmZlcmVuY2VzKGN1ckRhdGUsIG5leHREYXRlKTtcclxuICAgICAgICBwcmV2RGlmZmVyZW5jZXMgPSBkYXRlVXRpbHMuZ2V0RGF0ZXNEaWZmZXJlbmNlcyhjdXJEYXRlLCBwcmV2RGF0ZSk7XHJcbiAgICAgICAgaWYgKG5leHREaWZmZXJlbmNlc1t0aWNrRm9ybWF0XSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBkYXRlVW5pdHNMZW5ndGggLSAxOyBpID49IHRpY2tGb3JtYXRJbmRleDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlVW5pdEludGVydmFsID0gZGF0ZVVuaXRJbnRlcnZhbHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGlja0Zvcm1hdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RGF0ZVVuaXRJbnRlcnZhbChuZXh0RGlmZmVyZW5jZXMsIHRpY2tGb3JtYXRJbmRleCArIChuZXh0RGlmZmVyZW5jZXMubWlsbGlzZWNvbmQgPyAyIDogMSkpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHREaWZmZXJlbmNlc1tkYXRlVW5pdEludGVydmFsXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0RGF0ZVVuaXRJbnRlcnZhbChuZXh0RGlmZmVyZW5jZXMsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHByZXZEaWZmZXJlbmNlcyA9IGRhdGVVdGlscy5nZXREYXRlc0RpZmZlcmVuY2VzKHByZXZEYXRlLCBjdXJEYXRlKTtcclxuICAgICAgICBmb3IgKGkgPSBkYXRlVW5pdHNMZW5ndGggLSAxOyBpID49IHRpY2tGb3JtYXRJbmRleDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGRhdGVVbml0SW50ZXJ2YWwgPSBkYXRlVW5pdEludGVydmFsc1tpXTtcclxuICAgICAgICAgICAgaWYgKHByZXZEaWZmZXJlbmNlc1tkYXRlVW5pdEludGVydmFsXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgLSB0aWNrRm9ybWF0SW5kZXggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gdGlja0Zvcm1hdEluZGV4ICsgMTsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXREYXRlVW5pdEludGVydmFsKHByZXZEaWZmZXJlbmNlcywgailcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlVGltZVN0YXJ0KGN1ckRhdGUsIGRhdGVVbml0SW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPiAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXREYXRlVW5pdEludGVydmFsKHByZXZEaWZmZXJlbmNlcywgailcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXh0RGF0ZSA/IG5leHREaWZmZXJlbmNlcyA6IHByZXZEaWZmZXJlbmNlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0RhdGVUaW1lU3RhcnQoZGF0ZSwgZGF0ZVVuaXRJbnRlcnZhbCkge1xyXG4gICAgdmFyIHVuaXROdW1iZXJzID0gW2RhdGUuZ2V0TWlsbGlzZWNvbmRzKCksIGRhdGUuZ2V0U2Vjb25kcygpLCBkYXRlLmdldE1pbnV0ZXMoKSwgZGF0ZS5nZXRIb3VycygpLCBkYXRlLmdldERhdGUoKSwgZGF0ZS5nZXRNb250aCgpXTtcclxuICAgIHZhciB1bml0SW5kZXggPSBkYXRlVW5pdEludGVydmFscy5pbmRleE9mKGRhdGVVbml0SW50ZXJ2YWwpO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdW5pdEluZGV4OyBpKyspIHtcclxuICAgICAgICBpZiAoNCA9PT0gaSAmJiAxICE9PSB1bml0TnVtYmVyc1tpXSB8fCA0ICE9PSBpICYmIDAgIT09IHVuaXROdW1iZXJzW2ldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc2V0RGF0ZVVuaXRJbnRlcnZhbChkaWZmZXJlbmNlcywgaW50ZXJ2YWxJbmRleCkge1xyXG4gICAgdmFyIGRhdGVVbml0SW50ZXJ2YWwgPSBkYXRlVW5pdEludGVydmFsc1tpbnRlcnZhbEluZGV4XTtcclxuICAgIGlmIChkaWZmZXJlbmNlc1tkYXRlVW5pdEludGVydmFsXSkge1xyXG4gICAgICAgIGRpZmZlcmVuY2VzW2RhdGVVbml0SW50ZXJ2YWxdID0gZmFsc2U7XHJcbiAgICAgICAgZGlmZmVyZW5jZXMuY291bnQtLVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXREYXRlVW5pdEludGVydmFsKGRpZmZlcmVuY2VzLCBpbnRlcnZhbEluZGV4KSB7XHJcbiAgICB2YXIgZGF0ZVVuaXRJbnRlcnZhbCA9IGRhdGVVbml0SW50ZXJ2YWxzW2ludGVydmFsSW5kZXhdO1xyXG4gICAgaWYgKGZhbHNlID09PSBkaWZmZXJlbmNlc1tkYXRlVW5pdEludGVydmFsXSkge1xyXG4gICAgICAgIGRpZmZlcmVuY2VzW2RhdGVVbml0SW50ZXJ2YWxdID0gdHJ1ZTtcclxuICAgICAgICBkaWZmZXJlbmNlcy5jb3VudCsrXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE5vWmVyb0luZGV4KHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci5sZW5ndGggLSBwYXJzZUludChzdHIpLnRvU3RyaW5nKCkubGVuZ3RoXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25UaWNrSW5kZXgodGlja3MsIHZhbHVlKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBjdXJEaWZmO1xyXG4gICAgdmFyIG1pbkRpZmY7XHJcbiAgICB2YXIgbmVhcmVzdFRpY2tJbmRleCA9IDA7XHJcbiAgICBtaW5EaWZmID0gYWJzKHZhbHVlIC0gdGlja3NbMF0pO1xyXG4gICAgZm9yIChpID0gMTsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY3VyRGlmZiA9IGFicyh2YWx1ZSAtIHRpY2tzW2ldKTtcclxuICAgICAgICBpZiAoY3VyRGlmZiA8IG1pbkRpZmYpIHtcclxuICAgICAgICAgICAgbWluRGlmZiA9IGN1ckRpZmY7XHJcbiAgICAgICAgICAgIG5lYXJlc3RUaWNrSW5kZXggPSBpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5lYXJlc3RUaWNrSW5kZXhcclxufVxyXG5cclxuZnVuY3Rpb24gc3BsaXREZWNpbWFsTnVtYmVyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKS5zcGxpdChcIi5cIilcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0KHR5cGUpIHtcclxuICAgIHZhciBmb3JtYXR0ZXI7XHJcbiAgICBpZiAoaXNGdW5jdGlvbih0eXBlKSkge1xyXG4gICAgICAgIGZvcm1hdHRlciA9IHR5cGU7XHJcbiAgICAgICAgdHlwZSA9IG51bGxcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICBmb3JtYXR0ZXI6IGZvcm1hdHRlclxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBzbWFydEZvcm1hdHRlcih0aWNrLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgdGlja0ludGVydmFsID0gb3B0aW9ucy50aWNrSW50ZXJ2YWw7XHJcbiAgICB2YXIgdGlja0ludGVydmFsSW5kZXg7XHJcbiAgICB2YXIgdGlja0luZGV4O1xyXG4gICAgdmFyIGFjdHVhbEluZGV4O1xyXG4gICAgdmFyIHN0cmluZ1RpY2sgPSBhYnModGljaykudG9TdHJpbmcoKTtcclxuICAgIHZhciBwcmVjaXNpb24gPSAwO1xyXG4gICAgdmFyIHR5cGVGb3JtYXQ7XHJcbiAgICB2YXIgb2Zmc2V0ID0gMDtcclxuICAgIHZhciBzZXBhcmF0ZWRUaWNrSW50ZXJ2YWw7XHJcbiAgICB2YXIgaW5kZXhPZkZvcm1hdCA9IDA7XHJcbiAgICB2YXIgaW5kZXhPZlRpY2sgPSAtMTtcclxuICAgIHZhciBkYXRlc0RpZmZlcmVuY2VzO1xyXG4gICAgdmFyIGZvcm1hdCA9IG9wdGlvbnMubGFiZWxPcHRpb25zLmZvcm1hdDtcclxuICAgIHZhciB0aWNrcyA9IG9wdGlvbnMudGlja3M7XHJcbiAgICB2YXIgbG9nMTBUaWNrO1xyXG4gICAgdmFyIHByZXZEYXRlSW5kZXg7XHJcbiAgICB2YXIgbmV4dERhdGVJbmRleDtcclxuICAgIHZhciBpc0xvZ2FyaXRobWljID0gXCJsb2dhcml0aG1pY1wiID09PSBvcHRpb25zLnR5cGU7XHJcbiAgICBpZiAoMSA9PT0gdGlja3MubGVuZ3RoICYmIDAgPT09IHRpY2tzLmluZGV4T2YodGljaykgJiYgIWlzRGVmaW5lZCh0aWNrSW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgdGlja0ludGVydmFsID0gYWJzKHRpY2spID49IDEgPyAxIDogYWRqdXN0KDEgLSBhYnModGljayksIHRpY2spXHJcbiAgICB9XHJcbiAgICBpZiAoIWlzRGVmaW5lZChmb3JtYXQpICYmIFwiZGlzY3JldGVcIiAhPT0gb3B0aW9ucy50eXBlICYmIHRpY2sgJiYgKDEwID09PSBvcHRpb25zLmxvZ2FyaXRobUJhc2UgfHwgIWlzTG9nYXJpdGhtaWMpKSB7XHJcbiAgICAgICAgaWYgKFwiZGF0ZXRpbWVcIiAhPT0gb3B0aW9ucy5kYXRhVHlwZSAmJiBpc0RlZmluZWQodGlja0ludGVydmFsKSkge1xyXG4gICAgICAgICAgICBpZiAodGlja3MubGVuZ3RoICYmIC0xID09PSB0aWNrcy5pbmRleE9mKHRpY2spKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleE9mVGljayA9IGdldFRyYW5zaXRpb25UaWNrSW5kZXgodGlja3MsIHRpY2spO1xyXG4gICAgICAgICAgICAgICAgdGlja0ludGVydmFsID0gYWRqdXN0KGFicyh0aWNrIC0gdGlja3NbaW5kZXhPZlRpY2tdKSwgdGljaylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXBhcmF0ZWRUaWNrSW50ZXJ2YWwgPSBzcGxpdERlY2ltYWxOdW1iZXIodGlja0ludGVydmFsKTtcclxuICAgICAgICAgICAgaWYgKHNlcGFyYXRlZFRpY2tJbnRlcnZhbCA8IDIpIHtcclxuICAgICAgICAgICAgICAgIHNlcGFyYXRlZFRpY2tJbnRlcnZhbCA9IHNwbGl0RGVjaW1hbE51bWJlcih0aWNrKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0xvZ2FyaXRobWljKSB7XHJcbiAgICAgICAgICAgICAgICBsb2cxMFRpY2sgPSBsb2cxMChhYnModGljaykpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvZzEwVGljayA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlRm9ybWF0ID0gZm9ybWF0c1tmbG9vcihsb2cxMFRpY2sgLyAzKV0gfHwgRVhQT05FTlRJQUxcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9nMTBUaWNrIDwgLTQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlRm9ybWF0ID0gRVhQT05FTlRJQUxcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mb3JtYXQoYWRqdXN0KHRpY2spKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlcGFyYXRlZFRpY2tJbnRlcnZhbC5sZW5ndGggPiAxICYmICFpc0V4cG9uZW50aWFsKHRpY2tJbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IHNlcGFyYXRlZFRpY2tJbnRlcnZhbFsxXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB0eXBlRm9ybWF0ID0gZm9ybWF0c1tpbmRleE9mRm9ybWF0XVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRXhwb25lbnRpYWwodGlja0ludGVydmFsKSAmJiAoLTEgIT09IHN0cmluZ1RpY2suaW5kZXhPZihcIi5cIikgfHwgaXNFeHBvbmVudGlhbCh0aWNrKSkpIHtcclxuICAgICAgICAgICAgICAgIHR5cGVGb3JtYXQgPSBFWFBPTkVOVElBTDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNFeHBvbmVudGlhbCh0aWNrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IGFicyhnZXROb1plcm9JbmRleChzdHJpbmdUaWNrLnNwbGl0KFwiLlwiKVsxXSkgLSBnZXRFeHBvbmVudCh0aWNrSW50ZXJ2YWwpICsgMSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gTWF0aC5tYXgoYWJzKGdldEV4cG9uZW50KHRpY2spIC0gZ2V0RXhwb25lbnQodGlja0ludGVydmFsKSksIGFicyhnZXRQcmVjaXNpb24odGljaykgLSBnZXRQcmVjaXNpb24odGlja0ludGVydmFsKSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aWNrSW50ZXJ2YWxJbmRleCA9IGZsb29yKGxvZzEwKHRpY2tJbnRlcnZhbCkpO1xyXG4gICAgICAgICAgICAgICAgYWN0dWFsSW5kZXggPSB0aWNrSW5kZXggPSBmbG9vcihsb2cxMChhYnModGljaykpKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aWNrSW5kZXggLSB0aWNrSW50ZXJ2YWxJbmRleCA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsSW5kZXggPSB0aWNrSW50ZXJ2YWxJbmRleFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5kZXhPZkZvcm1hdCA9IGZsb29yKGFjdHVhbEluZGV4IC8gMyk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAzICogaW5kZXhPZkZvcm1hdDtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleE9mRm9ybWF0IDwgNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aWNrSW50ZXJ2YWxJbmRleCAtIG9mZnNldCA9PT0gMiAmJiB0aWNrSW5kZXggPj0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleE9mRm9ybWF0Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDMgKiBpbmRleE9mRm9ybWF0XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVGb3JtYXQgPSBmb3JtYXRzW2luZGV4T2ZGb3JtYXRdXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVGb3JtYXQgPSBmb3JtYXRzW2Zvcm1hdHMubGVuZ3RoIC0gMV1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGVkVGlja0ludGVydmFsID0gc3BsaXREZWNpbWFsTnVtYmVyKHRpY2tJbnRlcnZhbCAvIE1hdGgucG93KDEwLCBvZmZzZXQpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdGVkVGlja0ludGVydmFsWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IHNlcGFyYXRlZFRpY2tJbnRlcnZhbFsxXS5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gdHlwZUZvcm1hdCB8fCB2b2lkIDAgIT09IHByZWNpc2lvbikge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVGb3JtYXQsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBwcmVjaXNpb25cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoXCJkYXRldGltZVwiID09PSBvcHRpb25zLmRhdGFUeXBlKSB7XHJcbiAgICAgICAgICAgIHR5cGVGb3JtYXQgPSBkYXRlVXRpbHMuZ2V0RGF0ZUZvcm1hdEJ5VGlja0ludGVydmFsKHRpY2tJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dUcmFuc2l0aW9uICYmIHRpY2tzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaW5kZXhPZlRpY2sgPSB0aWNrcy5tYXAoTnVtYmVyKS5pbmRleE9mKCt0aWNrKTtcclxuICAgICAgICAgICAgICAgIGlmICgxID09PSB0aWNrcy5sZW5ndGggJiYgMCA9PT0gaW5kZXhPZlRpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlRm9ybWF0ID0gZm9ybWF0SGVscGVyLmdldERhdGVGb3JtYXRCeVRpY2tzKHRpY2tzKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoLTEgPT09IGluZGV4T2ZUaWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEYXRlSW5kZXggPSBnZXRUcmFuc2l0aW9uVGlja0luZGV4KHRpY2tzLCB0aWNrKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEYXRlSW5kZXggPSAwID09PSBpbmRleE9mVGljayA/IHRpY2tzLmxlbmd0aCAtIDEgOiBpbmRleE9mVGljayAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHREYXRlSW5kZXggPSAwID09PSBpbmRleE9mVGljayA/IDEgOiAtMVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkYXRlc0RpZmZlcmVuY2VzID0gZ2V0RGF0ZXNEaWZmZXJlbmNlcyh0aWNrc1twcmV2RGF0ZUluZGV4XSwgdGljaywgdGlja3NbbmV4dERhdGVJbmRleF0sIHR5cGVGb3JtYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVGb3JtYXQgPSBmb3JtYXRIZWxwZXIuZ2V0RGF0ZUZvcm1hdEJ5RGlmZmVyZW5jZXMoZGF0ZXNEaWZmZXJlbmNlcywgdHlwZUZvcm1hdClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3JtYXQgPSBjcmVhdGVGb3JtYXQodHlwZUZvcm1hdClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2Zvcm1hdCh0aWNrLCBmb3JtYXQpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhpZ2hEaWZmRm9ybWF0KGRpZmYpIHtcclxuICAgIHZhciBzdG9wID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpIGluIGRpZmYpIHtcclxuICAgICAgICBpZiAodHJ1ZSA9PT0gZGlmZltpXSB8fCBcImhvdXJcIiA9PT0gaSB8fCBzdG9wKSB7XHJcbiAgICAgICAgICAgIGRpZmZbaV0gPSBmYWxzZTtcclxuICAgICAgICAgICAgc3RvcCA9IHRydWVcclxuICAgICAgICB9IGVsc2UgaWYgKGZhbHNlID09PSBkaWZmW2ldKSB7XHJcbiAgICAgICAgICAgIGRpZmZbaV0gPSB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdChmb3JtYXRIZWxwZXIuZ2V0RGF0ZUZvcm1hdEJ5RGlmZmVyZW5jZXMoZGlmZikpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhpZ2hBbmRTZWxmRGlmZkZvcm1hdChkaWZmLCBpbnRlcnZhbCkge1xyXG4gICAgdmFyIHN0b3AgPSBmYWxzZTtcclxuICAgIGZvciAodmFyIGkgaW4gZGlmZikge1xyXG4gICAgICAgIGlmIChzdG9wKSB7XHJcbiAgICAgICAgICAgIGRpZmZbaV0gPSBmYWxzZVxyXG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gaW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgc3RvcCA9IHRydWVcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkaWZmW2ldID0gdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVGb3JtYXQoZm9ybWF0SGVscGVyLmdldERhdGVGb3JtYXRCeURpZmZlcmVuY2VzKGRpZmYpKVxyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXREYXRlUmFuZ2Uoc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIHRpY2tJbnRlcnZhbCkge1xyXG4gICAgdmFyIGRpZmYgPSBnZXREYXRlc0RpZmZlcmVuY2VzKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcclxuICAgIHZhciB0eXBlRm9ybWF0ID0gZGF0ZVV0aWxzLmdldERhdGVGb3JtYXRCeVRpY2tJbnRlcnZhbCh0aWNrSW50ZXJ2YWwpO1xyXG4gICAgdmFyIGRpZmZGb3JtYXRUeXBlID0gZm9ybWF0SGVscGVyLmdldERhdGVGb3JtYXRCeURpZmZlcmVuY2VzKGRpZmYsIHR5cGVGb3JtYXQpO1xyXG4gICAgdmFyIGRpZmZGb3JtYXQgPSBjcmVhdGVGb3JtYXQoZGlmZkZvcm1hdFR5cGUpO1xyXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgaWYgKHRpY2tJbnRlcnZhbCBpbiBkaWZmKSB7XHJcbiAgICAgICAgdmFyIHJhbmdlRm9ybWF0ID0gZ2V0SGlnaEFuZFNlbGZEaWZmRm9ybWF0KGdldERhdGVzRGlmZmVyZW5jZXMoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpLCB0aWNrSW50ZXJ2YWwpO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IF9mb3JtYXQoc3RhcnRWYWx1ZSwgcmFuZ2VGb3JtYXQpO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSlcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBfcmFuZ2VGb3JtYXQgPSBnZXRIaWdoRGlmZkZvcm1hdChnZXREYXRlc0RpZmZlcmVuY2VzKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKSk7XHJcbiAgICAgICAgdmFyIGhpZ2hWYWx1ZSA9IF9mb3JtYXQoc3RhcnRWYWx1ZSwgX3JhbmdlRm9ybWF0KTtcclxuICAgICAgICBpZiAoaGlnaFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGhpZ2hWYWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWVzLnB1c2goXCJcIi5jb25jYXQoX2Zvcm1hdChzdGFydFZhbHVlLCBkaWZmRm9ybWF0KSwgXCIgLSBcIikuY29uY2F0KF9mb3JtYXQoZW5kVmFsdWUsIGRpZmZGb3JtYXQpKSlcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZXMuam9pbihcIiwgXCIpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NEYXRlSW50ZXJ2YWwoaW50ZXJ2YWwpIHtcclxuICAgIGlmIChpc09iamVjdChpbnRlcnZhbCkpIHtcclxuICAgICAgICB2YXIgZGF0ZVVuaXRzID0gT2JqZWN0LmtleXMoaW50ZXJ2YWwpO1xyXG4gICAgICAgIHZhciBzdW0gPSBkYXRlVW5pdHMucmVkdWNlKChzdW0sIGspID0+IGludGVydmFsW2tdICsgc3VtLCAwKTtcclxuICAgICAgICBpZiAoMSA9PT0gc3VtKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRlVW5pdCA9IGRhdGVVbml0cy5maWx0ZXIoayA9PiAxID09PSBpbnRlcnZhbFtrXSlbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlVW5pdC5zbGljZSgwLCBkYXRlVW5pdC5sZW5ndGggLSAxKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpbnRlcnZhbFxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRSYW5nZShfcmVmKSB7XHJcbiAgICB2YXIge1xyXG4gICAgICAgIHN0YXJ0VmFsdWU6IHN0YXJ0VmFsdWUsXHJcbiAgICAgICAgZW5kVmFsdWU6IGVuZFZhbHVlLFxyXG4gICAgICAgIHRpY2tJbnRlcnZhbDogdGlja0ludGVydmFsLFxyXG4gICAgICAgIGFyZ3VtZW50Rm9ybWF0OiBhcmd1bWVudEZvcm1hdCxcclxuICAgICAgICBheGlzT3B0aW9uczoge1xyXG4gICAgICAgICAgICBkYXRhVHlwZTogZGF0YVR5cGUsXHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgIGxvZ2FyaXRobUJhc2U6IGxvZ2FyaXRobUJhc2VcclxuICAgICAgICB9XHJcbiAgICB9ID0gX3JlZjtcclxuICAgIGlmIChcImRpc2NyZXRlXCIgPT09IHR5cGUpIHtcclxuICAgICAgICByZXR1cm4gXCJcIlxyXG4gICAgfVxyXG4gICAgaWYgKFwiZGF0ZXRpbWVcIiA9PT0gZGF0YVR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZm9ybWF0RGF0ZVJhbmdlKHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBwcm9jZXNzRGF0ZUludGVydmFsKHRpY2tJbnRlcnZhbCkpXHJcbiAgICB9XHJcbiAgICB2YXIgZm9ybWF0T3B0aW9ucyA9IHtcclxuICAgICAgICB0aWNrczogW10sXHJcbiAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICBkYXRhVHlwZTogZGF0YVR5cGUsXHJcbiAgICAgICAgdGlja0ludGVydmFsOiB0aWNrSW50ZXJ2YWwsXHJcbiAgICAgICAgbG9nYXJpdGhtQmFzZTogbG9nYXJpdGhtQmFzZSxcclxuICAgICAgICBsYWJlbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgZm9ybWF0OiBhcmd1bWVudEZvcm1hdFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoc21hcnRGb3JtYXR0ZXIoc3RhcnRWYWx1ZSwgZm9ybWF0T3B0aW9ucyksIFwiIC0gXCIpLmNvbmNhdChzbWFydEZvcm1hdHRlcihlbmRWYWx1ZSwgZm9ybWF0T3B0aW9ucykpXHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/axes/smart_formatter.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/axes/strip.js":
/*!*******************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/axes/strip.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return createStrip; });\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/**\r\n * DevExtreme (esm/viz/axes/strip.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\nfunction createStrip(axis, options) {\r\n    var storedCoord;\r\n    var lastStoredCoordinates;\r\n    var labelOptions = options.label || {};\r\n    return {\r\n        options: options,\r\n        label: null,\r\n        rect: null,\r\n        _getCoord() {\r\n            var canvas = axis._getCanvasStartEnd();\r\n            var range = axis._translator.getBusinessRange();\r\n            return axis._getStripPos(options.startValue, options.endValue, canvas.start, canvas.end, range)\r\n        },\r\n        _drawLabel: coords => axis._renderer.text(labelOptions.text, coords.x, coords.y).css(Object(_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"patchFontOptions\"])(Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])({}, axis.getOptions().label.font, labelOptions.font))).attr({\r\n            align: \"center\",\r\n            class: labelOptions.cssClass\r\n        }).append(axis._axisStripLabelGroup),\r\n        draw() {\r\n            if (axis._translator.getBusinessRange().isEmpty()) {\r\n                return\r\n            }\r\n            if ((Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(options.startValue) || Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(options.endValue)) && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(options.color)) {\r\n                var stripPos = this._getCoord();\r\n                this.labelCoords = labelOptions.text ? axis._getStripLabelCoords(stripPos.from, stripPos.to, labelOptions) : null;\r\n                if (stripPos.outOfCanvas || !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(stripPos.to) || !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(stripPos.from)) {\r\n                    return\r\n                }\r\n                this.rect = axis._createStrip(axis._getStripGraphicAttributes(stripPos.from, stripPos.to)).attr({\r\n                    fill: options.color\r\n                }).append(axis._axisStripGroup);\r\n                this.label = labelOptions.text ? this._drawLabel(this.labelCoords) : null\r\n            }\r\n        },\r\n        getContentContainer() {\r\n            return this.label\r\n        },\r\n        removeLabel() {},\r\n        updatePosition(animate) {\r\n            var stripPos = this._getCoord();\r\n            if (animate && storedCoord) {\r\n                this.label && this.label.attr(axis._getStripLabelCoords(storedCoord.from, storedCoord.to, options.label));\r\n                this.rect && this.rect.attr(axis._getStripGraphicAttributes(storedCoord.from, storedCoord.to));\r\n                this.label && this.label.animate(axis._getStripLabelCoords(stripPos.from, stripPos.to, options.label));\r\n                this.rect && this.rect.animate(axis._getStripGraphicAttributes(stripPos.from, stripPos.to))\r\n            } else {\r\n                this.label && this.label.attr(axis._getStripLabelCoords(stripPos.from, stripPos.to, options.label));\r\n                this.rect && this.rect.attr(axis._getStripGraphicAttributes(stripPos.from, stripPos.to))\r\n            }\r\n        },\r\n        saveCoords() {\r\n            lastStoredCoordinates = storedCoord;\r\n            storedCoord = this._getCoord()\r\n        },\r\n        resetCoordinates() {\r\n            storedCoord = lastStoredCoordinates\r\n        }\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2F4ZXMvc3RyaXAuanM/ZGM2NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUcrQjtBQUdSO0FBR1U7QUFDbEI7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZGQUE2RixvRUFBZ0IsQ0FBQyxpRUFBTSxHQUFHO0FBQ3ZIO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0VBQVMsd0JBQXdCLGtFQUFTLHVCQUF1QixrRUFBUztBQUMzRjtBQUNBO0FBQ0EsNkNBQTZDLGtFQUFTLGtCQUFrQixrRUFBUztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS92aXovYXhlcy9zdHJpcC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdml6L2F4ZXMvc3RyaXAuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCB7XHJcbiAgICBpc0RlZmluZWRcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy90eXBlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBwYXRjaEZvbnRPcHRpb25zXHJcbn0gZnJvbSBcIi4uL2NvcmUvdXRpbHNcIjtcclxuaW1wb3J0IHtcclxuICAgIGV4dGVuZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2V4dGVuZFwiO1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVTdHJpcChheGlzLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgc3RvcmVkQ29vcmQ7XHJcbiAgICB2YXIgbGFzdFN0b3JlZENvb3JkaW5hdGVzO1xyXG4gICAgdmFyIGxhYmVsT3B0aW9ucyA9IG9wdGlvbnMubGFiZWwgfHwge307XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXHJcbiAgICAgICAgbGFiZWw6IG51bGwsXHJcbiAgICAgICAgcmVjdDogbnVsbCxcclxuICAgICAgICBfZ2V0Q29vcmQoKSB7XHJcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBheGlzLl9nZXRDYW52YXNTdGFydEVuZCgpO1xyXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBheGlzLl90cmFuc2xhdG9yLmdldEJ1c2luZXNzUmFuZ2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGF4aXMuX2dldFN0cmlwUG9zKG9wdGlvbnMuc3RhcnRWYWx1ZSwgb3B0aW9ucy5lbmRWYWx1ZSwgY2FudmFzLnN0YXJ0LCBjYW52YXMuZW5kLCByYW5nZSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9kcmF3TGFiZWw6IGNvb3JkcyA9PiBheGlzLl9yZW5kZXJlci50ZXh0KGxhYmVsT3B0aW9ucy50ZXh0LCBjb29yZHMueCwgY29vcmRzLnkpLmNzcyhwYXRjaEZvbnRPcHRpb25zKGV4dGVuZCh7fSwgYXhpcy5nZXRPcHRpb25zKCkubGFiZWwuZm9udCwgbGFiZWxPcHRpb25zLmZvbnQpKSkuYXR0cih7XHJcbiAgICAgICAgICAgIGFsaWduOiBcImNlbnRlclwiLFxyXG4gICAgICAgICAgICBjbGFzczogbGFiZWxPcHRpb25zLmNzc0NsYXNzXHJcbiAgICAgICAgfSkuYXBwZW5kKGF4aXMuX2F4aXNTdHJpcExhYmVsR3JvdXApLFxyXG4gICAgICAgIGRyYXcoKSB7XHJcbiAgICAgICAgICAgIGlmIChheGlzLl90cmFuc2xhdG9yLmdldEJ1c2luZXNzUmFuZ2UoKS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoaXNEZWZpbmVkKG9wdGlvbnMuc3RhcnRWYWx1ZSkgfHwgaXNEZWZpbmVkKG9wdGlvbnMuZW5kVmFsdWUpKSAmJiBpc0RlZmluZWQob3B0aW9ucy5jb2xvcikpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHJpcFBvcyA9IHRoaXMuX2dldENvb3JkKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsQ29vcmRzID0gbGFiZWxPcHRpb25zLnRleHQgPyBheGlzLl9nZXRTdHJpcExhYmVsQ29vcmRzKHN0cmlwUG9zLmZyb20sIHN0cmlwUG9zLnRvLCBsYWJlbE9wdGlvbnMpIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChzdHJpcFBvcy5vdXRPZkNhbnZhcyB8fCAhaXNEZWZpbmVkKHN0cmlwUG9zLnRvKSB8fCAhaXNEZWZpbmVkKHN0cmlwUG9zLmZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY3QgPSBheGlzLl9jcmVhdGVTdHJpcChheGlzLl9nZXRTdHJpcEdyYXBoaWNBdHRyaWJ1dGVzKHN0cmlwUG9zLmZyb20sIHN0cmlwUG9zLnRvKSkuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogb3B0aW9ucy5jb2xvclxyXG4gICAgICAgICAgICAgICAgfSkuYXBwZW5kKGF4aXMuX2F4aXNTdHJpcEdyb3VwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbE9wdGlvbnMudGV4dCA/IHRoaXMuX2RyYXdMYWJlbCh0aGlzLmxhYmVsQ29vcmRzKSA6IG51bGxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0Q29udGVudENvbnRhaW5lcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUxhYmVsKCkge30sXHJcbiAgICAgICAgdXBkYXRlUG9zaXRpb24oYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgc3RyaXBQb3MgPSB0aGlzLl9nZXRDb29yZCgpO1xyXG4gICAgICAgICAgICBpZiAoYW5pbWF0ZSAmJiBzdG9yZWRDb29yZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbCAmJiB0aGlzLmxhYmVsLmF0dHIoYXhpcy5fZ2V0U3RyaXBMYWJlbENvb3JkcyhzdG9yZWRDb29yZC5mcm9tLCBzdG9yZWRDb29yZC50bywgb3B0aW9ucy5sYWJlbCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWN0ICYmIHRoaXMucmVjdC5hdHRyKGF4aXMuX2dldFN0cmlwR3JhcGhpY0F0dHJpYnV0ZXMoc3RvcmVkQ29vcmQuZnJvbSwgc3RvcmVkQ29vcmQudG8pKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWwgJiYgdGhpcy5sYWJlbC5hbmltYXRlKGF4aXMuX2dldFN0cmlwTGFiZWxDb29yZHMoc3RyaXBQb3MuZnJvbSwgc3RyaXBQb3MudG8sIG9wdGlvbnMubGFiZWwpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjdCAmJiB0aGlzLnJlY3QuYW5pbWF0ZShheGlzLl9nZXRTdHJpcEdyYXBoaWNBdHRyaWJ1dGVzKHN0cmlwUG9zLmZyb20sIHN0cmlwUG9zLnRvKSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWwgJiYgdGhpcy5sYWJlbC5hdHRyKGF4aXMuX2dldFN0cmlwTGFiZWxDb29yZHMoc3RyaXBQb3MuZnJvbSwgc3RyaXBQb3MudG8sIG9wdGlvbnMubGFiZWwpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjdCAmJiB0aGlzLnJlY3QuYXR0cihheGlzLl9nZXRTdHJpcEdyYXBoaWNBdHRyaWJ1dGVzKHN0cmlwUG9zLmZyb20sIHN0cmlwUG9zLnRvKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2F2ZUNvb3JkcygpIHtcclxuICAgICAgICAgICAgbGFzdFN0b3JlZENvb3JkaW5hdGVzID0gc3RvcmVkQ29vcmQ7XHJcbiAgICAgICAgICAgIHN0b3JlZENvb3JkID0gdGhpcy5fZ2V0Q29vcmQoKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzZXRDb29yZGluYXRlcygpIHtcclxuICAgICAgICAgICAgc3RvcmVkQ29vcmQgPSBsYXN0U3RvcmVkQ29vcmRpbmF0ZXNcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/axes/strip.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/axes/tick.js":
/*!******************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/axes/tick.js ***!
  \******************************************************/
/*! exports provided: tick */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tick\", function() { return createTick; });\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _core_utils_deferred__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/utils/deferred */ \"./node_modules/devextreme/esm/core/utils/deferred.js\");\n/**\r\n * DevExtreme (esm/viz/axes/tick.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\nfunction getPathStyle(options) {\r\n    return {\r\n        stroke: options.color,\r\n        \"stroke-width\": options.width,\r\n        \"stroke-opacity\": options.opacity,\r\n        opacity: 1\r\n    }\r\n}\r\n\r\nfunction createTick(axis, renderer, tickOptions, gridOptions, skippedCategory, skipLabels, offset) {\r\n    var tickOffset = offset || axis._tickOffset;\r\n    var lineGroup = axis._axisLineGroup;\r\n    var elementsGroup = axis._axisElementsGroup;\r\n    var tickStyle = getPathStyle(tickOptions);\r\n    var gridStyle = getPathStyle(gridOptions);\r\n    var emptyStrRegExp = /^\\s+$/;\r\n    var axisOptions = axis.getOptions();\r\n    var labelOptions = axisOptions.label;\r\n    var labelStyle = axis._textOptions;\r\n\r\n    function getLabelFontStyle(tick) {\r\n        var fontStyle = axis._textFontStyles;\r\n        var customizeColor = labelOptions.customizeColor;\r\n        if (customizeColor && customizeColor.call) {\r\n            fontStyle = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])({}, axis._textFontStyles, {\r\n                fill: customizeColor.call(tick, tick)\r\n            })\r\n        }\r\n        return fontStyle\r\n    }\r\n\r\n    function createLabelHint(tick, range) {\r\n        var labelHint = axis.formatHint(tick.value, labelOptions, range);\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(labelHint) && \"\" !== labelHint) {\r\n            tick.getContentContainer().setTitle(labelHint)\r\n        }\r\n    }\r\n    return function(value) {\r\n        var tick = {\r\n            value: value,\r\n            updateValue(newValue) {\r\n                this.value = value = newValue\r\n            },\r\n            initCoords: function() {\r\n                this.coords = axis._getTranslatedValue(value, tickOffset);\r\n                this.labelCoords = axis._getTranslatedValue(value)\r\n            },\r\n            saveCoords() {\r\n                this._lastStoredCoordinates = {\r\n                    coords: this._storedCoords,\r\n                    labelCoords: this._storedLabelsCoords\r\n                };\r\n                this._storedCoords = this.coords;\r\n                this._storedLabelsCoords = this.templateContainer ? this._getTemplateCoords() : this.labelCoords\r\n            },\r\n            resetCoordinates() {\r\n                if (this._lastStoredCoordinates) {\r\n                    this._storedCoords = this._lastStoredCoordinates.coords;\r\n                    this._storedLabelsCoords = this._lastStoredCoordinates.labelCoords\r\n                }\r\n            },\r\n            drawMark(options) {\r\n                if (!tickOptions.visible || skippedCategory === value) {\r\n                    return\r\n                }\r\n                if (axis.areCoordsOutsideAxis(this.coords)) {\r\n                    return\r\n                }\r\n                if (this.mark) {\r\n                    this.mark.append(lineGroup);\r\n                    axis.sharp(this.mark, axis.getSharpDirectionByCoords(this.coords));\r\n                    this.updateTickPosition(options)\r\n                } else {\r\n                    this.mark = axis._createPathElement([], tickStyle, axis.getSharpDirectionByCoords(this.coords)).append(lineGroup);\r\n                    this.updateTickPosition(options)\r\n                }\r\n            },\r\n            setSkippedCategory(category) {\r\n                skippedCategory = category\r\n            },\r\n            _updateLine(lineElement, settings, storedSettings, animate, isGridLine) {\r\n                if (!lineElement) {\r\n                    return\r\n                }\r\n                if (null === settings.points || null === settings.r) {\r\n                    lineElement.remove();\r\n                    return\r\n                }\r\n                if (animate && storedSettings && null !== storedSettings.points) {\r\n                    settings.opacity = 1;\r\n                    lineElement.attr(storedSettings);\r\n                    lineElement.animate(settings)\r\n                } else {\r\n                    settings.opacity = animate ? 0 : 1;\r\n                    lineElement.attr(settings);\r\n                    animate && lineElement.animate({\r\n                        opacity: 1\r\n                    }, {\r\n                        delay: .5,\r\n                        partitionDuration: .5\r\n                    })\r\n                }\r\n                this.coords.angle && axis._rotateTick(lineElement, this.coords, isGridLine)\r\n            },\r\n            updateTickPosition: function(options, animate) {\r\n                this._updateLine(this.mark, {\r\n                    points: axis._getTickMarkPoints(tick.coords, tickOptions.length, options)\r\n                }, this._storedCoords && {\r\n                    points: axis._getTickMarkPoints(tick._storedCoords, tickOptions.length, options)\r\n                }, animate, false)\r\n            },\r\n            drawLabel: function(range, template) {\r\n                if (this.templateContainer && axis.isRendered()) {\r\n                    this.updateLabelPosition();\r\n                    return\r\n                }\r\n                var labelIsVisible = labelOptions.visible && !skipLabels && !axis.getTranslator().getBusinessRange().isEmpty() && !axis.areCoordsOutsideAxis(this.labelCoords);\r\n                if (!labelIsVisible) {\r\n                    if (this.label) {\r\n                        this.removeLabel()\r\n                    }\r\n                    return\r\n                }\r\n                var templateOption = labelOptions.template;\r\n                var text = axis.formatLabel(value, labelOptions, range);\r\n                if (this.label) {\r\n                    this.label.attr({\r\n                        text: text,\r\n                        rotate: 0\r\n                    }).append(elementsGroup);\r\n                    createLabelHint(this, range);\r\n                    this.updateLabelPosition();\r\n                    return\r\n                }\r\n                if (templateOption) {\r\n                    this.templateContainer = renderer.g().append(elementsGroup);\r\n                    this._templateDef && this._templateDef.reject();\r\n                    this._templateDef = new _core_utils_deferred__WEBPACK_IMPORTED_MODULE_2__[\"Deferred\"];\r\n                    template.render({\r\n                        model: {\r\n                            valueText: text,\r\n                            value: this.value,\r\n                            labelFontStyle: getLabelFontStyle(this),\r\n                            labelStyle: labelStyle\r\n                        },\r\n                        container: this.templateContainer.element,\r\n                        onRendered: () => {\r\n                            this.updateLabelPosition();\r\n                            this._templateDef && this._templateDef.resolve()\r\n                        }\r\n                    })\r\n                } else if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(text) && \"\" !== text && !emptyStrRegExp.test(text)) {\r\n                    this.label = renderer.text(text).css(getLabelFontStyle(this)).attr(labelStyle).append(elementsGroup);\r\n                    this.updateLabelPosition();\r\n                    createLabelHint(this, range)\r\n                }\r\n                var containerForData = this.getContentContainer();\r\n                containerForData && containerForData.data(\"chart-data-argument\", this.value);\r\n                this.templateContainer && createLabelHint(this, range)\r\n            },\r\n            getTemplateDeferred() {\r\n                return this._templateDef\r\n            },\r\n            getContentContainer() {\r\n                return this.templateContainer || this.label\r\n            },\r\n            fadeOutElements() {\r\n                var startSettings = {\r\n                    opacity: 1\r\n                };\r\n                var endSettings = {\r\n                    opacity: 0\r\n                };\r\n                var animationSettings = {\r\n                    partitionDuration: .5\r\n                };\r\n                if (this.getContentContainer()) {\r\n                    this._fadeOutLabel()\r\n                }\r\n                if (this.grid) {\r\n                    this.grid.append(axis._axisGridGroup).attr(startSettings).animate(endSettings, animationSettings)\r\n                }\r\n                if (this.mark) {\r\n                    this.mark.append(axis._axisLineGroup).attr(startSettings).animate(endSettings, animationSettings)\r\n                }\r\n            },\r\n            _fadeInLabel() {\r\n                var group = axis._renderer.g().attr({\r\n                    opacity: 0\r\n                }).append(axis._axisElementsGroup).animate({\r\n                    opacity: 1\r\n                }, {\r\n                    delay: .5,\r\n                    partitionDuration: .5\r\n                });\r\n                this.getContentContainer().append(group)\r\n            },\r\n            _fadeOutLabel() {\r\n                var group = axis._renderer.g().attr({\r\n                    opacity: 1\r\n                }).animate({\r\n                    opacity: 0\r\n                }, {\r\n                    partitionDuration: .5\r\n                }).append(axis._axisElementsGroup).toBackground();\r\n                this.getContentContainer().append(group)\r\n            },\r\n            _getTemplateCoords() {\r\n                return axis._getLabelAdjustedCoord(this, (axis._constantLabelOffset || 0) + (tick.labelOffset || 0))\r\n            },\r\n            updateLabelPosition: function(animate) {\r\n                var templateContainer = this.templateContainer;\r\n                if (!this.getContentContainer()) {\r\n                    return\r\n                }\r\n                if (animate && this._storedLabelsCoords) {\r\n                    if (templateContainer) {\r\n                        templateContainer.attr(this._storedLabelsCoords);\r\n                        var lCoords = this._getTemplateCoords();\r\n                        templateContainer.animate(lCoords)\r\n                    } else {\r\n                        this.label.attr({\r\n                            x: this._storedLabelsCoords.x,\r\n                            y: this._storedLabelsCoords.y\r\n                        });\r\n                        this.label.animate({\r\n                            x: this.labelCoords.x,\r\n                            y: this.labelCoords.y\r\n                        })\r\n                    }\r\n                } else {\r\n                    if (templateContainer) {\r\n                        var _lCoords = this._getTemplateCoords();\r\n                        templateContainer.attr(_lCoords)\r\n                    } else {\r\n                        this.label.attr({\r\n                            x: this.labelCoords.x,\r\n                            y: this.labelCoords.y\r\n                        })\r\n                    }\r\n                    if (animate) {\r\n                        this._fadeInLabel()\r\n                    }\r\n                }\r\n            },\r\n            updateMultilineTextAlignment() {\r\n                if (labelOptions.template || !this.label) {\r\n                    return\r\n                }\r\n                this.label.attr({\r\n                    textsAlignment: this.labelAlignment || axis.getOptions().label.alignment\r\n                })\r\n            },\r\n            drawGrid: function(drawLine) {\r\n                if (gridOptions.visible && skippedCategory !== this.value) {\r\n                    if (this.grid) {\r\n                        this.grid.append(axis._axisGridGroup);\r\n                        axis.sharp(this.grid, axis.getSharpDirectionByCoords(this.coords));\r\n                        this.updateGridPosition()\r\n                    } else {\r\n                        this.grid = drawLine(this, gridStyle);\r\n                        this.grid && this.grid.append(axis._axisGridGroup)\r\n                    }\r\n                }\r\n            },\r\n            updateGridPosition: function(animate) {\r\n                this._updateLine(this.grid, axis._getGridPoints(tick.coords), this._storedCoords && axis._getGridPoints(this._storedCoords), animate, true)\r\n            },\r\n            removeLabel() {\r\n                var contentContainer = this.getContentContainer();\r\n                contentContainer && contentContainer.remove();\r\n                this._templateDef && this._templateDef.reject();\r\n                this._templateDef = this.templateContainer = this.label = null\r\n            }\r\n        };\r\n        return tick\r\n    }\r\n}\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2F4ZXMvdGljay5qcz9iNTkyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRytCO0FBR0U7QUFHRTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpRUFBTSxHQUFHO0FBQ2pDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxrRUFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw2REFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUIsVUFBVSxrRUFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3Zpei9heGVzL3RpY2suanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3Zpei9heGVzL3RpY2suanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCB7XHJcbiAgICBpc0RlZmluZWRcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy90eXBlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBleHRlbmRcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9leHRlbmRcIjtcclxuaW1wb3J0IHtcclxuICAgIERlZmVycmVkXHJcbn0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvZGVmZXJyZWRcIjtcclxuXHJcbmZ1bmN0aW9uIGdldFBhdGhTdHlsZShvcHRpb25zKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0cm9rZTogb3B0aW9ucy5jb2xvcixcclxuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBvcHRpb25zLndpZHRoLFxyXG4gICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogb3B0aW9ucy5vcGFjaXR5LFxyXG4gICAgICAgIG9wYWNpdHk6IDFcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlVGljayhheGlzLCByZW5kZXJlciwgdGlja09wdGlvbnMsIGdyaWRPcHRpb25zLCBza2lwcGVkQ2F0ZWdvcnksIHNraXBMYWJlbHMsIG9mZnNldCkge1xyXG4gICAgdmFyIHRpY2tPZmZzZXQgPSBvZmZzZXQgfHwgYXhpcy5fdGlja09mZnNldDtcclxuICAgIHZhciBsaW5lR3JvdXAgPSBheGlzLl9heGlzTGluZUdyb3VwO1xyXG4gICAgdmFyIGVsZW1lbnRzR3JvdXAgPSBheGlzLl9heGlzRWxlbWVudHNHcm91cDtcclxuICAgIHZhciB0aWNrU3R5bGUgPSBnZXRQYXRoU3R5bGUodGlja09wdGlvbnMpO1xyXG4gICAgdmFyIGdyaWRTdHlsZSA9IGdldFBhdGhTdHlsZShncmlkT3B0aW9ucyk7XHJcbiAgICB2YXIgZW1wdHlTdHJSZWdFeHAgPSAvXlxccyskLztcclxuICAgIHZhciBheGlzT3B0aW9ucyA9IGF4aXMuZ2V0T3B0aW9ucygpO1xyXG4gICAgdmFyIGxhYmVsT3B0aW9ucyA9IGF4aXNPcHRpb25zLmxhYmVsO1xyXG4gICAgdmFyIGxhYmVsU3R5bGUgPSBheGlzLl90ZXh0T3B0aW9ucztcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRMYWJlbEZvbnRTdHlsZSh0aWNrKSB7XHJcbiAgICAgICAgdmFyIGZvbnRTdHlsZSA9IGF4aXMuX3RleHRGb250U3R5bGVzO1xyXG4gICAgICAgIHZhciBjdXN0b21pemVDb2xvciA9IGxhYmVsT3B0aW9ucy5jdXN0b21pemVDb2xvcjtcclxuICAgICAgICBpZiAoY3VzdG9taXplQ29sb3IgJiYgY3VzdG9taXplQ29sb3IuY2FsbCkge1xyXG4gICAgICAgICAgICBmb250U3R5bGUgPSBleHRlbmQoe30sIGF4aXMuX3RleHRGb250U3R5bGVzLCB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBjdXN0b21pemVDb2xvci5jYWxsKHRpY2ssIHRpY2spXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb250U3R5bGVcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVMYWJlbEhpbnQodGljaywgcmFuZ2UpIHtcclxuICAgICAgICB2YXIgbGFiZWxIaW50ID0gYXhpcy5mb3JtYXRIaW50KHRpY2sudmFsdWUsIGxhYmVsT3B0aW9ucywgcmFuZ2UpO1xyXG4gICAgICAgIGlmIChpc0RlZmluZWQobGFiZWxIaW50KSAmJiBcIlwiICE9PSBsYWJlbEhpbnQpIHtcclxuICAgICAgICAgICAgdGljay5nZXRDb250ZW50Q29udGFpbmVyKCkuc2V0VGl0bGUobGFiZWxIaW50KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHZhciB0aWNrID0ge1xyXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUgPSBuZXdWYWx1ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbml0Q29vcmRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzID0gYXhpcy5fZ2V0VHJhbnNsYXRlZFZhbHVlKHZhbHVlLCB0aWNrT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxDb29yZHMgPSBheGlzLl9nZXRUcmFuc2xhdGVkVmFsdWUodmFsdWUpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNhdmVDb29yZHMoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0U3RvcmVkQ29vcmRpbmF0ZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzOiB0aGlzLl9zdG9yZWRDb29yZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxDb29yZHM6IHRoaXMuX3N0b3JlZExhYmVsc0Nvb3Jkc1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3JlZENvb3JkcyA9IHRoaXMuY29vcmRzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcmVkTGFiZWxzQ29vcmRzID0gdGhpcy50ZW1wbGF0ZUNvbnRhaW5lciA/IHRoaXMuX2dldFRlbXBsYXRlQ29vcmRzKCkgOiB0aGlzLmxhYmVsQ29vcmRzXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc2V0Q29vcmRpbmF0ZXMoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGFzdFN0b3JlZENvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcmVkQ29vcmRzID0gdGhpcy5fbGFzdFN0b3JlZENvb3JkaW5hdGVzLmNvb3JkcztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9yZWRMYWJlbHNDb29yZHMgPSB0aGlzLl9sYXN0U3RvcmVkQ29vcmRpbmF0ZXMubGFiZWxDb29yZHNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhd01hcmsob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aWNrT3B0aW9ucy52aXNpYmxlIHx8IHNraXBwZWRDYXRlZ29yeSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChheGlzLmFyZUNvb3Jkc091dHNpZGVBeGlzKHRoaXMuY29vcmRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWFyaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFyay5hcHBlbmQobGluZUdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICBheGlzLnNoYXJwKHRoaXMubWFyaywgYXhpcy5nZXRTaGFycERpcmVjdGlvbkJ5Q29vcmRzKHRoaXMuY29vcmRzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUaWNrUG9zaXRpb24ob3B0aW9ucylcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrID0gYXhpcy5fY3JlYXRlUGF0aEVsZW1lbnQoW10sIHRpY2tTdHlsZSwgYXhpcy5nZXRTaGFycERpcmVjdGlvbkJ5Q29vcmRzKHRoaXMuY29vcmRzKSkuYXBwZW5kKGxpbmVHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUaWNrUG9zaXRpb24ob3B0aW9ucylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0U2tpcHBlZENhdGVnb3J5KGNhdGVnb3J5KSB7XHJcbiAgICAgICAgICAgICAgICBza2lwcGVkQ2F0ZWdvcnkgPSBjYXRlZ29yeVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfdXBkYXRlTGluZShsaW5lRWxlbWVudCwgc2V0dGluZ3MsIHN0b3JlZFNldHRpbmdzLCBhbmltYXRlLCBpc0dyaWRMaW5lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gc2V0dGluZ3MucG9pbnRzIHx8IG51bGwgPT09IHNldHRpbmdzLnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lRWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhbmltYXRlICYmIHN0b3JlZFNldHRpbmdzICYmIG51bGwgIT09IHN0b3JlZFNldHRpbmdzLnBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVFbGVtZW50LmF0dHIoc3RvcmVkU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVFbGVtZW50LmFuaW1hdGUoc2V0dGluZ3MpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9wYWNpdHkgPSBhbmltYXRlID8gMCA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZUVsZW1lbnQuYXR0cihzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSAmJiBsaW5lRWxlbWVudC5hbmltYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IC41LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aXRpb25EdXJhdGlvbjogLjVcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb29yZHMuYW5nbGUgJiYgYXhpcy5fcm90YXRlVGljayhsaW5lRWxlbWVudCwgdGhpcy5jb29yZHMsIGlzR3JpZExpbmUpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVwZGF0ZVRpY2tQb3NpdGlvbjogZnVuY3Rpb24ob3B0aW9ucywgYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGluZSh0aGlzLm1hcmssIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IGF4aXMuX2dldFRpY2tNYXJrUG9pbnRzKHRpY2suY29vcmRzLCB0aWNrT3B0aW9ucy5sZW5ndGgsIG9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzLl9zdG9yZWRDb29yZHMgJiYge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogYXhpcy5fZ2V0VGlja01hcmtQb2ludHModGljay5fc3RvcmVkQ29vcmRzLCB0aWNrT3B0aW9ucy5sZW5ndGgsIG9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICB9LCBhbmltYXRlLCBmYWxzZSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhd0xhYmVsOiBmdW5jdGlvbihyYW5nZSwgdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlbXBsYXRlQ29udGFpbmVyICYmIGF4aXMuaXNSZW5kZXJlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYWJlbFBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxJc1Zpc2libGUgPSBsYWJlbE9wdGlvbnMudmlzaWJsZSAmJiAhc2tpcExhYmVscyAmJiAhYXhpcy5nZXRUcmFuc2xhdG9yKCkuZ2V0QnVzaW5lc3NSYW5nZSgpLmlzRW1wdHkoKSAmJiAhYXhpcy5hcmVDb29yZHNPdXRzaWRlQXhpcyh0aGlzLmxhYmVsQ29vcmRzKTtcclxuICAgICAgICAgICAgICAgIGlmICghbGFiZWxJc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxhYmVsKClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVPcHRpb24gPSBsYWJlbE9wdGlvbnMudGVtcGxhdGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGF4aXMuZm9ybWF0TGFiZWwodmFsdWUsIGxhYmVsT3B0aW9ucywgcmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhYmVsLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGU6IDBcclxuICAgICAgICAgICAgICAgICAgICB9KS5hcHBlbmQoZWxlbWVudHNHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlTGFiZWxIaW50KHRoaXMsIHJhbmdlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZU9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVtcGxhdGVDb250YWluZXIgPSByZW5kZXJlci5nKCkuYXBwZW5kKGVsZW1lbnRzR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlRGVmICYmIHRoaXMuX3RlbXBsYXRlRGVmLnJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlRGVmID0gbmV3IERlZmVycmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLnJlbmRlcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVRleHQ6IHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRm9udFN0eWxlOiBnZXRMYWJlbEZvbnRTdHlsZSh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB0aGlzLnRlbXBsYXRlQ29udGFpbmVyLmVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVuZGVyZWQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWxQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGVEZWYgJiYgdGhpcy5fdGVtcGxhdGVEZWYucmVzb2x2ZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0RlZmluZWQodGV4dCkgJiYgXCJcIiAhPT0gdGV4dCAmJiAhZW1wdHlTdHJSZWdFeHAudGVzdCh0ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFiZWwgPSByZW5kZXJlci50ZXh0KHRleHQpLmNzcyhnZXRMYWJlbEZvbnRTdHlsZSh0aGlzKSkuYXR0cihsYWJlbFN0eWxlKS5hcHBlbmQoZWxlbWVudHNHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYWJlbFBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlTGFiZWxIaW50KHRoaXMsIHJhbmdlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lckZvckRhdGEgPSB0aGlzLmdldENvbnRlbnRDb250YWluZXIoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckZvckRhdGEgJiYgY29udGFpbmVyRm9yRGF0YS5kYXRhKFwiY2hhcnQtZGF0YS1hcmd1bWVudFwiLCB0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGVtcGxhdGVDb250YWluZXIgJiYgY3JlYXRlTGFiZWxIaW50KHRoaXMsIHJhbmdlKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXRUZW1wbGF0ZURlZmVycmVkKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlRGVmXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldENvbnRlbnRDb250YWluZXIoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZUNvbnRhaW5lciB8fCB0aGlzLmxhYmVsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZhZGVPdXRFbGVtZW50cygpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydFNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kU2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25TZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0aXRpb25EdXJhdGlvbjogLjVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRDb250ZW50Q29udGFpbmVyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYWRlT3V0TGFiZWwoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5hcHBlbmQoYXhpcy5fYXhpc0dyaWRHcm91cCkuYXR0cihzdGFydFNldHRpbmdzKS5hbmltYXRlKGVuZFNldHRpbmdzLCBhbmltYXRpb25TZXR0aW5ncylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcmspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmsuYXBwZW5kKGF4aXMuX2F4aXNMaW5lR3JvdXApLmF0dHIoc3RhcnRTZXR0aW5ncykuYW5pbWF0ZShlbmRTZXR0aW5ncywgYW5pbWF0aW9uU2V0dGluZ3MpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF9mYWRlSW5MYWJlbCgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGF4aXMuX3JlbmRlcmVyLmcoKS5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgICAgICAgICB9KS5hcHBlbmQoYXhpcy5fYXhpc0VsZW1lbnRzR3JvdXApLmFuaW1hdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheTogLjUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFydGl0aW9uRHVyYXRpb246IC41XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29udGVudENvbnRhaW5lcigpLmFwcGVuZChncm91cClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX2ZhZGVPdXRMYWJlbCgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IGF4aXMuX3JlbmRlcmVyLmcoKS5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXHJcbiAgICAgICAgICAgICAgICB9KS5hbmltYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFydGl0aW9uRHVyYXRpb246IC41XHJcbiAgICAgICAgICAgICAgICB9KS5hcHBlbmQoYXhpcy5fYXhpc0VsZW1lbnRzR3JvdXApLnRvQmFja2dyb3VuZCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDb250ZW50Q29udGFpbmVyKCkuYXBwZW5kKGdyb3VwKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfZ2V0VGVtcGxhdGVDb29yZHMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXhpcy5fZ2V0TGFiZWxBZGp1c3RlZENvb3JkKHRoaXMsIChheGlzLl9jb25zdGFudExhYmVsT2Zmc2V0IHx8IDApICsgKHRpY2subGFiZWxPZmZzZXQgfHwgMCkpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVwZGF0ZUxhYmVsUG9zaXRpb246IGZ1bmN0aW9uKGFuaW1hdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUNvbnRhaW5lciA9IHRoaXMudGVtcGxhdGVDb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Q29udGVudENvbnRhaW5lcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0ZSAmJiB0aGlzLl9zdG9yZWRMYWJlbHNDb29yZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVDb250YWluZXIuYXR0cih0aGlzLl9zdG9yZWRMYWJlbHNDb29yZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbENvb3JkcyA9IHRoaXMuX2dldFRlbXBsYXRlQ29vcmRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlQ29udGFpbmVyLmFuaW1hdGUobENvb3JkcylcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhYmVsLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogdGhpcy5fc3RvcmVkTGFiZWxzQ29vcmRzLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLl9zdG9yZWRMYWJlbHNDb29yZHMueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYWJlbC5hbmltYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRoaXMubGFiZWxDb29yZHMueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMubGFiZWxDb29yZHMueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbENvb3JkcyA9IHRoaXMuX2dldFRlbXBsYXRlQ29vcmRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlQ29udGFpbmVyLmF0dHIoX2xDb29yZHMpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYWJlbC5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRoaXMubGFiZWxDb29yZHMueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMubGFiZWxDb29yZHMueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYWRlSW5MYWJlbCgpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1cGRhdGVNdWx0aWxpbmVUZXh0QWxpZ25tZW50KCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsT3B0aW9ucy50ZW1wbGF0ZSB8fCAhdGhpcy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbC5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0c0FsaWdubWVudDogdGhpcy5sYWJlbEFsaWdubWVudCB8fCBheGlzLmdldE9wdGlvbnMoKS5sYWJlbC5hbGlnbm1lbnRcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYXdHcmlkOiBmdW5jdGlvbihkcmF3TGluZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyaWRPcHRpb25zLnZpc2libGUgJiYgc2tpcHBlZENhdGVnb3J5ICE9PSB0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQuYXBwZW5kKGF4aXMuX2F4aXNHcmlkR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLnNoYXJwKHRoaXMuZ3JpZCwgYXhpcy5nZXRTaGFycERpcmVjdGlvbkJ5Q29vcmRzKHRoaXMuY29vcmRzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlR3JpZFBvc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQgPSBkcmF3TGluZSh0aGlzLCBncmlkU3R5bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQgJiYgdGhpcy5ncmlkLmFwcGVuZChheGlzLl9heGlzR3JpZEdyb3VwKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXBkYXRlR3JpZFBvc2l0aW9uOiBmdW5jdGlvbihhbmltYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMaW5lKHRoaXMuZ3JpZCwgYXhpcy5fZ2V0R3JpZFBvaW50cyh0aWNrLmNvb3JkcyksIHRoaXMuX3N0b3JlZENvb3JkcyAmJiBheGlzLl9nZXRHcmlkUG9pbnRzKHRoaXMuX3N0b3JlZENvb3JkcyksIGFuaW1hdGUsIHRydWUpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlbW92ZUxhYmVsKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRDb250YWluZXIgPSB0aGlzLmdldENvbnRlbnRDb250YWluZXIoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRDb250YWluZXIgJiYgY29udGVudENvbnRhaW5lci5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlRGVmICYmIHRoaXMuX3RlbXBsYXRlRGVmLnJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGVEZWYgPSB0aGlzLnRlbXBsYXRlQ29udGFpbmVyID0gdGhpcy5sYWJlbCA9IG51bGxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRpY2tcclxuICAgIH1cclxufVxyXG5leHBvcnQge1xyXG4gICAgY3JlYXRlVGljayBhcyB0aWNrXHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/axes/tick.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/axes/tick_generator.js":
/*!****************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/axes/tick_generator.js ***!
  \****************************************************************/
/*! exports provided: tickGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tickGenerator\", function() { return tickGenerator; });\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/* harmony import */ var _core_utils_date__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/date */ \"./node_modules/devextreme/esm/core/utils/date.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/utils/math */ \"./node_modules/devextreme/esm/core/utils/math.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/**\r\n * DevExtreme (esm/viz/axes/tick_generator.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\nvar convertDateUnitToMilliseconds = _core_utils_date__WEBPACK_IMPORTED_MODULE_1__[\"default\"].convertDateUnitToMilliseconds;\r\nvar dateToMilliseconds = _core_utils_date__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dateToMilliseconds;\r\nvar math = Math;\r\nvar mathAbs = math.abs;\r\nvar mathFloor = math.floor;\r\nvar mathCeil = math.ceil;\r\nvar mathPow = math.pow;\r\nvar NUMBER_MULTIPLIERS = [1, 2, 2.5, 5];\r\nvar LOGARITHMIC_MULTIPLIERS = [1, 2, 3, 5];\r\nvar DATETIME_MULTIPLIERS = {\r\n    millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],\r\n    second: [1, 2, 3, 5, 10, 15, 20, 30],\r\n    minute: [1, 2, 3, 5, 10, 15, 20, 30],\r\n    hour: [1, 2, 3, 4, 6, 8, 12],\r\n    day: [1, 2],\r\n    week: [1, 2],\r\n    month: [1, 2, 3, 6]\r\n};\r\nvar DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_4__[\"extend\"])({}, DATETIME_MULTIPLIERS, {\r\n    day: [1]\r\n});\r\nvar DATETIME_MINOR_MULTIPLIERS = {\r\n    millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],\r\n    second: [1, 2, 3, 5, 10, 15, 20, 30],\r\n    minute: [1, 2, 3, 5, 10, 15, 20, 30],\r\n    hour: [1, 2, 3, 4, 6, 8, 12],\r\n    day: [1, 2, 3, 7, 14],\r\n    month: [1, 2, 3, 6]\r\n};\r\nvar MINOR_DELIMITERS = [2, 4, 5, 8, 10];\r\nvar VISIBILITY_DELIMITER = 3;\r\nvar MINUTE = 6e4;\r\n\r\nfunction dummyGenerator(options) {\r\n    return function(data, screenDelta, tickInterval, forceTickInterval) {\r\n        var count = mathFloor(screenDelta / options.axisDivisionFactor);\r\n        count = count < 1 ? 1 : count;\r\n        var interval = screenDelta / count;\r\n        return {\r\n            ticks: interval > 0 ? Array.apply(null, new Array(count + 1)).map((_, i) => interval * i) : [],\r\n            tickInterval: interval\r\n        }\r\n    }\r\n}\r\n\r\nfunction discreteGenerator(options) {\r\n    return function(data, screenDelta, tickInterval, forceTickInterval) {\r\n        var categories = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getCategoriesInfo\"])(data.categories, data.min, data.max).categories;\r\n        return {\r\n            ticks: categories,\r\n            tickInterval: mathCeil(categories.length * options.axisDivisionFactor / screenDelta)\r\n        }\r\n    }\r\n}\r\nvar getValue = value => value;\r\nvar getLogValue = (base, allowNegatives, linearThreshold) => value => Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getLogExt\"])(value, base, allowNegatives, linearThreshold);\r\nvar raiseTo = (base, allowNegatives, linearThreshold) => value => Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"raiseToExt\"])(value, base, allowNegatives, linearThreshold);\r\nvar mathRaiseTo = base => value => Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"raiseTo\"])(value, base);\r\nvar logAbsValue = base => value => 0 === value ? 0 : Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getLog\"])(mathAbs(value), base);\r\nvar correctValueByInterval = (post, round, getValue) => (value, interval) => Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"adjust\"])(post(round(Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"adjust\"])(getValue(value) / interval)) * interval));\r\n\r\nfunction correctMinValueByEndOnTick(floorFunc, ceilFunc, resolveEndOnTick, endOnTick) {\r\n    if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(endOnTick)) {\r\n        return endOnTick ? floorFunc : ceilFunc\r\n    }\r\n    return function(value, interval, businessViewInfo, forceEndOnTick) {\r\n        var floorTickValue = floorFunc(value, interval);\r\n        if (value - floorTickValue === 0 || !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(businessViewInfo) || resolveEndOnTick(value, floorTickValue, interval, businessViewInfo) || forceEndOnTick) {\r\n            return floorTickValue\r\n        }\r\n        return ceilFunc(value, interval)\r\n    }\r\n}\r\n\r\nfunction resolveEndOnTick(curValue, tickValue, interval, businessViewInfo) {\r\n    var prevTickDataDiff = interval - mathAbs(tickValue - curValue);\r\n    var intervalCount = math.max(mathCeil(businessViewInfo.businessDelta / interval), 2);\r\n    var businessRatio = businessViewInfo.screenDelta / (intervalCount * interval);\r\n    var potentialTickScreenDiff = math.round(businessRatio * prevTickDataDiff);\r\n    var delimiterFactor = Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getLogExt\"])(businessRatio * interval / businessViewInfo.axisDivisionFactor, 2) + 1;\r\n    var delimiterMultiplier = (businessViewInfo.isSpacedMargin ? 2 : 1) * delimiterFactor;\r\n    var screenDelimiter = math.round(VISIBILITY_DELIMITER * delimiterMultiplier);\r\n    return businessViewInfo.businessDelta > businessViewInfo.interval && potentialTickScreenDiff >= screenDelimiter\r\n}\r\n\r\nfunction resolveEndOnTickLog(base) {\r\n    return function(curValue, tickValue, interval, businessViewInfo) {\r\n        return resolveEndOnTick(Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getLogExt\"])(curValue, base), Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getLogExt\"])(tickValue, base), interval, businessViewInfo)\r\n    }\r\n}\r\n\r\nfunction resolveEndOnTickDate(curValue, tickValue, interval, businessViewInfo) {\r\n    return resolveEndOnTick(curValue.valueOf(), tickValue.valueOf(), dateToMilliseconds(interval), businessViewInfo)\r\n}\r\n\r\nfunction getBusinessDelta(data, breaks) {\r\n    var spacing = 0;\r\n    if (breaks) {\r\n        spacing = breaks.reduce((prev, item) => prev + (item.to - item.from), 0)\r\n    }\r\n    return mathAbs(data.max - data.min - spacing)\r\n}\r\n\r\nfunction getBusinessDeltaLog(base, allowNegatives, linearThreshold) {\r\n    var getLog = getLogValue(base, allowNegatives, linearThreshold);\r\n    return function(data, breaks) {\r\n        var spacing = 0;\r\n        if (breaks) {\r\n            spacing = breaks.reduce((prev, item) => prev + mathAbs(getLog(item.to / item.from)), 0)\r\n        }\r\n        return mathCeil(mathAbs(getLog(data.max) - getLog(data.min)) - spacing)\r\n    }\r\n}\r\n\r\nfunction getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount) {\r\n    var count = screenDelta / axisDivisionFactor - (addTickCount || 0);\r\n    count = count < 1 ? 1 : count;\r\n    return businessDelta / count\r\n}\r\n\r\nfunction getMultiplierFactor(interval, factorDelta) {\r\n    return mathPow(10, mathFloor(Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getLogExt\"])(interval, 10)) + (factorDelta || 0))\r\n}\r\n\r\nfunction calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, _, minTickInterval) {\r\n    var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount);\r\n    var result = 1;\r\n    var onlyIntegers = false === allowDecimals;\r\n    if (!forceTickInterval || !tickInterval) {\r\n        if (interval >= 1 || !onlyIntegers && interval > 0) {\r\n            result = adjustInterval(interval, multipliers, onlyIntegers)\r\n        }\r\n        if (!tickInterval || !forceTickInterval && tickInterval < result) {\r\n            tickInterval = result\r\n        }\r\n    }\r\n    if (!forceTickInterval && minTickInterval) {\r\n        minTickInterval = adjustInterval(minTickInterval, multipliers, onlyIntegers);\r\n        if (minTickInterval > tickInterval) {\r\n            tickInterval = minTickInterval\r\n        }\r\n    }\r\n    return tickInterval\r\n}\r\n\r\nfunction adjustInterval(interval, multipliers, onlyIntegers) {\r\n    var factor = getMultiplierFactor(interval, -1);\r\n    var result = 1;\r\n    multipliers = multipliers || NUMBER_MULTIPLIERS;\r\n    if (interval > 0) {\r\n        interval /= factor;\r\n        result = multipliers.concat(10 * multipliers[0]).map(m => 10 * m).reduce((r, m) => {\r\n            if (.1 === factor && onlyIntegers && 25 === m) {\r\n                return r\r\n            }\r\n            return r < interval ? m : r\r\n        }, 0);\r\n        result = Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"adjust\"])(result * factor, factor)\r\n    }\r\n    return result\r\n}\r\n\r\nfunction calculateMinorTickInterval(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {\r\n    var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);\r\n    return tickInterval || MINOR_DELIMITERS.reduce((r, d) => {\r\n        var cur = businessDelta / d;\r\n        return cur >= interval ? cur : r\r\n    }, 0)\r\n}\r\n\r\nfunction getCalculateTickIntervalLog(skipCalculationLimits) {\r\n    return function(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, _, __, minTickInterval) {\r\n        var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);\r\n        var result = 0;\r\n        var adjustInterval = getAdjustIntervalLog(skipCalculationLimits);\r\n        if (!forceTickInterval || !tickInterval) {\r\n            if (interval > 0) {\r\n                result = adjustInterval(interval, multipliers)\r\n            }\r\n            if (!tickInterval || !forceTickInterval && tickInterval < result) {\r\n                tickInterval = result\r\n            }\r\n        }\r\n        if (!forceTickInterval && minTickInterval) {\r\n            minTickInterval = adjustInterval(minTickInterval, multipliers);\r\n            if (minTickInterval > tickInterval) {\r\n                tickInterval = minTickInterval\r\n            }\r\n        }\r\n        return tickInterval\r\n    }\r\n}\r\n\r\nfunction getAdjustIntervalLog(skipCalculationLimits) {\r\n    return function(interval, multipliers) {\r\n        var factor = getMultiplierFactor(interval);\r\n        multipliers = multipliers || LOGARITHMIC_MULTIPLIERS;\r\n        if (!skipCalculationLimits && factor < 1) {\r\n            factor = 1\r\n        }\r\n        return multipliers.concat(10 * multipliers[0]).reduce((r, m) => r < interval ? m * factor : r, 0)\r\n    }\r\n}\r\n\r\nfunction getDataTimeMultipliers(gapSize) {\r\n    if (gapSize && gapSize > 2) {\r\n        return DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND\r\n    } else {\r\n        return DATETIME_MULTIPLIERS\r\n    }\r\n}\r\n\r\nfunction numbersReducer(interval, key) {\r\n    return function(r, m) {\r\n        if (!r && interval <= convertDateUnitToMilliseconds(key, m)) {\r\n            r = {};\r\n            r[key + \"s\"] = m\r\n        }\r\n        return r\r\n    }\r\n}\r\n\r\nfunction yearsReducer(interval, factor) {\r\n    return function(r, m) {\r\n        var years = factor * m;\r\n        if (!r && interval <= convertDateUnitToMilliseconds(\"year\", years) && 2.5 !== years) {\r\n            r = {\r\n                years: years\r\n            }\r\n        }\r\n        return r\r\n    }\r\n}\r\n\r\nfunction calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, gapSize, minTickInterval) {\r\n    if (!forceTickInterval || !tickInterval) {\r\n        var result = adjustIntervalDateTime(getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor), multipliers, null, gapSize);\r\n        if (!tickInterval || !forceTickInterval && dateToMilliseconds(tickInterval) <= dateToMilliseconds(result)) {\r\n            tickInterval = result\r\n        }\r\n    }\r\n    if (!forceTickInterval && minTickInterval) {\r\n        minTickInterval = adjustIntervalDateTime(minTickInterval, multipliers, null, gapSize);\r\n        if (dateToMilliseconds(minTickInterval) > dateToMilliseconds(tickInterval)) {\r\n            tickInterval = minTickInterval\r\n        }\r\n    }\r\n    return tickInterval\r\n}\r\n\r\nfunction adjustIntervalDateTime(interval, multipliers, _, gapSize) {\r\n    var result;\r\n    multipliers = multipliers || getDataTimeMultipliers(gapSize);\r\n    for (var key in multipliers) {\r\n        result = multipliers[key].reduce(numbersReducer(interval, key), result);\r\n        if (result) {\r\n            break\r\n        }\r\n    }\r\n    if (!result) {\r\n        for (var factor = 1;; factor *= 10) {\r\n            result = NUMBER_MULTIPLIERS.reduce(yearsReducer(interval, factor), result);\r\n            if (result) {\r\n                break\r\n            }\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nfunction calculateMinorTickIntervalDateTime(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {\r\n    return calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, true, axisDivisionFactor, DATETIME_MINOR_MULTIPLIERS)\r\n}\r\n\r\nfunction getTickIntervalByCustomTicks(getValue, postProcess) {\r\n    return ticks => ticks ? postProcess(mathAbs(Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"adjust\"])(getValue(ticks[1]) - getValue(ticks[0])))) || void 0 : void 0\r\n}\r\n\r\nfunction addInterval(value, interval, isNegative) {\r\n    return _core_utils_date__WEBPACK_IMPORTED_MODULE_1__[\"default\"].addInterval(value, interval, isNegative)\r\n}\r\n\r\nfunction addIntervalLog(log, raise) {\r\n    return (value, interval, isNegative) => raise(addInterval(log(value), interval, isNegative))\r\n}\r\n\r\nfunction addIntervalDate(value, interval, isNegative) {\r\n    return addInterval(value, interval, isNegative)\r\n}\r\n\r\nfunction addIntervalWithBreaks(addInterval, breaks, correctValue) {\r\n    breaks = breaks.filter(b => !b.gapSize);\r\n    return function(value, interval, isNegative) {\r\n        var breakSize;\r\n        value = addInterval(value, interval, isNegative);\r\n        if (!breaks.every(item => {\r\n                if (value >= addInterval(item.from, interval) && addInterval(value, interval) < item.to) {\r\n                    breakSize = item.to - item.from - 2 * (addInterval(item.from, interval) - item.from)\r\n                }\r\n                return !breakSize\r\n            })) {\r\n            value = correctValue(addInterval(value, breakSize), interval)\r\n        }\r\n        return value\r\n    }\r\n}\r\n\r\nfunction calculateTicks(addInterval, correctMinValue, adjustInterval, resolveEndOnTick) {\r\n    return function(data, tickInterval, endOnTick, gaps, breaks, businessDelta, screenDelta, axisDivisionFactor, generateExtraTick) {\r\n        var correctTickValue = correctTickValueOnGapSize(addInterval, gaps);\r\n        var min = data.min;\r\n        var max = data.max;\r\n        var businessViewInfo = {\r\n            screenDelta: screenDelta,\r\n            businessDelta: businessDelta,\r\n            axisDivisionFactor: axisDivisionFactor,\r\n            isSpacedMargin: data.isSpacedMargin,\r\n            interval: tickInterval\r\n        };\r\n        var cur = correctMinValue(min, tickInterval, businessViewInfo);\r\n        var ticks = [];\r\n        if (null !== breaks && void 0 !== breaks && breaks.length) {\r\n            addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue)\r\n        }\r\n        if (cur > max) {\r\n            cur = correctMinValue(min, adjustInterval(businessDelta / 2), businessViewInfo);\r\n            if (cur > max) {\r\n                endOnTick = true;\r\n                cur = correctMinValue(min, tickInterval, businessViewInfo, endOnTick)\r\n            }\r\n        }\r\n        cur = correctTickValue(cur);\r\n        var prev;\r\n        while (cur < max && cur !== prev || generateExtraTick && cur <= max) {\r\n            ticks.push(cur);\r\n            prev = cur;\r\n            cur = correctTickValue(addInterval(cur, tickInterval))\r\n        }\r\n        if (endOnTick || cur - max === 0 || !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(endOnTick) && resolveEndOnTick(max, cur, tickInterval, businessViewInfo)) {\r\n            ticks.push(cur)\r\n        }\r\n        return ticks\r\n    }\r\n}\r\n\r\nfunction calculateMinorTicks(updateTickInterval, addInterval, correctMinValue, correctTickValue, ceil) {\r\n    return function(min, max, majorTicks, minorTickInterval, tickInterval, breaks, maxCount) {\r\n        var factor = tickInterval / minorTickInterval;\r\n        var lastMajor = majorTicks[majorTicks.length - 1];\r\n        var firstMajor = majorTicks[0];\r\n        var tickBalance = maxCount - 1;\r\n        if (null !== breaks && void 0 !== breaks && breaks.length) {\r\n            addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue)\r\n        }\r\n        minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, firstMajor, factor);\r\n        if (0 === minorTickInterval) {\r\n            return []\r\n        }\r\n        var cur = correctTickValue(correctMinValue(min, tickInterval, min), minorTickInterval);\r\n        minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, cur, factor);\r\n        var ticks = [];\r\n        while (cur < firstMajor && (!tickBalance || tickBalance > 0)) {\r\n            cur >= min && ticks.push(cur);\r\n            tickBalance--;\r\n            cur = addInterval(cur, minorTickInterval)\r\n        }\r\n        var middleTicks = majorTicks.reduce((r, tick) => {\r\n            tickBalance = maxCount - 1;\r\n            if (null === r.prevTick) {\r\n                r.prevTick = tick;\r\n                return r\r\n            }\r\n            minorTickInterval = updateTickInterval(minorTickInterval, tick, r.prevTick, factor);\r\n            var cur = correctTickValue(r.prevTick, minorTickInterval);\r\n            while (cur < tick && (!tickBalance || tickBalance > 0)) {\r\n                cur !== r.prevTick && r.minors.push(cur);\r\n                tickBalance--;\r\n                cur = addInterval(cur, minorTickInterval)\r\n            }\r\n            r.prevTick = tick;\r\n            return r\r\n        }, {\r\n            prevTick: null,\r\n            minors: []\r\n        });\r\n        ticks = ticks.concat(middleTicks.minors);\r\n        var maxValue = ceil(max, tickInterval, min);\r\n        minorTickInterval = updateTickInterval(minorTickInterval, maxValue, maxValue, factor);\r\n        cur = correctTickValue(lastMajor, minorTickInterval);\r\n        var prev;\r\n        while (cur < max && cur !== prev) {\r\n            ticks.push(cur);\r\n            prev = cur;\r\n            cur = addInterval(cur, minorTickInterval)\r\n        }\r\n        if (lastMajor - max !== 0 && cur - max === 0) {\r\n            ticks.push(cur)\r\n        }\r\n        return ticks\r\n    }\r\n}\r\n\r\nfunction filterTicks(ticks, breaks) {\r\n    if (breaks.length) {\r\n        var result = breaks.reduce((result, b) => {\r\n            var tmpTicks = [];\r\n            var i;\r\n            for (i = result[1]; i < ticks.length; i++) {\r\n                var tickValue = ticks[i];\r\n                if (tickValue < b.from) {\r\n                    tmpTicks.push(tickValue)\r\n                }\r\n                if (tickValue >= b.to) {\r\n                    break\r\n                }\r\n            }\r\n            return [result[0].concat(tmpTicks), i]\r\n        }, [\r\n            [], 0\r\n        ]);\r\n        return result[0].concat(ticks.slice(result[1]))\r\n    }\r\n    return ticks\r\n}\r\n\r\nfunction correctTickValueOnGapSize(addInterval, breaks) {\r\n    return function(value) {\r\n        var gapSize;\r\n        if (!breaks.every(item => {\r\n                if (value >= item.from && value < item.to) {\r\n                    gapSize = item.gapSize\r\n                }\r\n                return !gapSize\r\n            })) {\r\n            value = addInterval(value, gapSize)\r\n        }\r\n        return value\r\n    }\r\n}\r\n\r\nfunction generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, getMajorTickIntervalByCustomTicks, getMinorTickIntervalByCustomTicks, convertTickInterval, calculateTicks, calculateMinorTicks, processScaleBreaks) {\r\n    function correctUserTickInterval(tickInterval, businessDelta, limit) {\r\n        if (tickInterval && businessDelta / convertTickInterval(tickInterval) >= limit + 1) {\r\n            options.incidentOccurred(\"W2003\");\r\n            tickInterval = void 0\r\n        }\r\n        return tickInterval\r\n    }\r\n    return function(data, screenDelta, tickInterval, forceTickInterval, customTicks, minorTickInterval, minorTickCount, breaks) {\r\n        customTicks = customTicks || {};\r\n        var businessDelta = getBusinessDelta(data, breaks);\r\n        var result = function(customTicks) {\r\n            return {\r\n                tickInterval: getMajorTickIntervalByCustomTicks(customTicks.majors),\r\n                ticks: customTicks.majors || [],\r\n                minorTickInterval: getMinorTickIntervalByCustomTicks(customTicks.minors),\r\n                minorTicks: customTicks.minors || []\r\n            }\r\n        }(customTicks);\r\n        if (!isNaN(businessDelta)) {\r\n            if (0 === businessDelta && !customTicks.majors) {\r\n                result.ticks = [data.min]\r\n            } else {\r\n                result = function(ticks, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks) {\r\n                    if (customTicks.majors) {\r\n                        ticks.breaks = breaks;\r\n                        return ticks\r\n                    }\r\n                    var gaps = breaks.filter(b => b.gapSize);\r\n                    var majorTicks;\r\n                    tickInterval = options.skipCalculationLimits ? tickInterval : correctUserTickInterval(tickInterval, businessDelta, screenDelta);\r\n                    tickInterval = calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, options.axisDivisionFactor, options.numberMultipliers, options.allowDecimals, breaks.length, gaps[0] && gaps[0].gapSize.days, options.minTickInterval);\r\n                    if (!options.skipTickGeneration) {\r\n                        majorTicks = calculateTicks(data, tickInterval, options.endOnTick, gaps, breaks, businessDelta, screenDelta, options.axisDivisionFactor, options.generateExtraTick);\r\n                        breaks = processScaleBreaks(breaks, majorTicks, tickInterval);\r\n                        majorTicks = filterTicks(majorTicks, breaks);\r\n                        ticks.breaks = breaks;\r\n                        ticks.ticks = ticks.ticks.concat(majorTicks)\r\n                    }\r\n                    ticks.tickInterval = tickInterval;\r\n                    return ticks\r\n                }(result, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks || []);\r\n                if (!options.skipTickGeneration && businessDelta > 0) {\r\n                    result = function(ticks, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks) {\r\n                        if (!options.calculateMinors) {\r\n                            return ticks\r\n                        }\r\n                        if (customTicks.minors) {\r\n                            return ticks\r\n                        }\r\n                        var minorBusinessDelta = convertTickInterval(ticks.tickInterval);\r\n                        var minorScreenDelta = screenDelta * minorBusinessDelta / businessDelta;\r\n                        var breaks = ticks.breaks;\r\n                        if (!minorTickInterval && minorTickCount) {\r\n                            minorTickInterval = getMinorTickIntervalByCustomTicks([minorBusinessDelta / (minorTickCount + 1), minorBusinessDelta / (minorTickCount + 1) * 2])\r\n                        } else {\r\n                            minorTickCount = void 0\r\n                        }\r\n                        minorTickInterval = correctUserTickInterval(minorTickInterval, minorBusinessDelta, minorScreenDelta);\r\n                        minorTickInterval = calculateMinorTickInterval(minorBusinessDelta, minorScreenDelta, minorTickInterval, options.minorAxisDivisionFactor);\r\n                        ticks.minorTicks = filterTicks(ticks.minorTicks.concat(calculateMinorTicks(data.min, data.max, ticks.ticks, minorTickInterval, ticks.tickInterval, breaks, minorTickCount)), breaks);\r\n                        ticks.minorTickInterval = minorTickInterval;\r\n                        return ticks\r\n                    }(result, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks)\r\n                }\r\n            }\r\n        }\r\n        return result\r\n    }\r\n}\r\n\r\nfunction getBaseTick(breakValue, _ref, interval, getValue) {\r\n    var [tick, insideTick] = _ref;\r\n    if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(tick) || mathAbs(getValue(breakValue) - getValue(tick)) / interval > .25) {\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(insideTick) && mathAbs(getValue(insideTick) - getValue(tick)) / interval < 2) {\r\n            tick = insideTick\r\n        } else if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isDefined\"])(tick)) {\r\n            tick = breakValue\r\n        }\r\n    }\r\n    return tick\r\n}\r\n\r\nfunction getScaleBreaksProcessor(convertTickInterval, getValue, addCorrection) {\r\n    return function(breaks, ticks, tickInterval) {\r\n        var interval = convertTickInterval(tickInterval);\r\n        var correction = .5 * interval;\r\n        return breaks.reduce((result, b) => {\r\n            var breakTicks = ticks.filter(tick => tick <= b.from);\r\n            var from = addCorrection(getBaseTick(b.from, [].concat(breakTicks[breakTicks.length - 1], ticks[breakTicks.length]), interval, getValue), correction);\r\n            breakTicks = ticks.filter(tick => tick >= b.to);\r\n            var to = addCorrection(getBaseTick(b.to, [].concat(breakTicks[0], ticks[ticks.length - breakTicks.length - 1]), interval, getValue), -correction);\r\n            if (getValue(to) - getValue(from) < interval && !b.gapSize) {\r\n                return result\r\n            }\r\n            if (b.gapSize) {\r\n                return result.concat([b])\r\n            }\r\n            return result.concat([{\r\n                from: from,\r\n                to: to,\r\n                cumulativeWidth: b.cumulativeWidth\r\n            }])\r\n        }, [])\r\n    }\r\n}\r\n\r\nfunction numericGenerator(options) {\r\n    var floor = correctValueByInterval(getValue, mathFloor, getValue);\r\n    var ceil = correctValueByInterval(getValue, mathCeil, getValue);\r\n    var calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, getValue);\r\n    return generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, getValue, calculateTicks(addInterval, correctMinValueByEndOnTick(floor, ceil, resolveEndOnTick, options.endOnTick), adjustInterval, resolveEndOnTick), calculateMinorTicks(getValue, addInterval, floor, addInterval, getValue), getScaleBreaksProcessor(getValue, getValue, (value, correction) => value + correction))\r\n}\r\nvar correctValueByIntervalLog = (post, getRound, getValue) => (value, interval) => Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"sign\"])(value) * Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"adjust\"])(post(getRound(value)(Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"adjust\"])(getValue(value) / interval)) * interval));\r\n\r\nfunction logarithmicGenerator(options) {\r\n    var base = options.logBase;\r\n    var raise = raiseTo(base, options.allowNegatives, options.linearThreshold);\r\n    var log = getLogValue(base, options.allowNegatives, options.linearThreshold);\r\n    var absLog = logAbsValue(base);\r\n    var absRaise = mathRaiseTo(base);\r\n    var floor = correctValueByIntervalLog(absRaise, value => value < 0 ? mathCeil : mathFloor, absLog);\r\n    var ceil = correctValueByIntervalLog(absRaise, value => value < 0 ? mathFloor : mathCeil, absLog);\r\n    var ceilNumber = correctValueByInterval(getValue, mathCeil, getValue);\r\n    return generator(options, getBusinessDeltaLog(base, options.allowNegatives, options.linearThreshold), getCalculateTickIntervalLog(options.skipCalculationLimits), calculateMinorTickInterval, getTickIntervalByCustomTicks(log, getValue), getTickIntervalByCustomTicks(getValue, getValue), getValue, calculateTicks(addIntervalLog(log, raise), correctMinValueByEndOnTick(floor, ceil, resolveEndOnTickLog(base), options.endOnTick), getAdjustIntervalLog(options.skipCalculationLimits), resolveEndOnTickLog(base)), calculateMinorTicks((_, tick, prevTick, factor) => Math.max(Math.abs(tick), Math.abs(prevTick)) / factor, addInterval, floor, ceilNumber, ceil), getScaleBreaksProcessor(getValue, log, (value, correction) => raise(log(value) + correction)))\r\n}\r\n\r\nfunction dateGenerator(options) {\r\n    function floor(value, interval) {\r\n        var floorNumber = correctValueByInterval(getValue, mathFloor, getValue);\r\n        var intervalObject = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(interval) ? _core_utils_date__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getDateIntervalByString(interval.toLowerCase()) : interval;\r\n        var divider = dateToMilliseconds(interval);\r\n        if (intervalObject.days % 7 === 0 || interval.quarters) {\r\n            intervalObject = adjustIntervalDateTime(divider)\r\n        }\r\n        var correctDateWithUnitBeginning = v => _core_utils_date__WEBPACK_IMPORTED_MODULE_1__[\"default\"].correctDateWithUnitBeginning(v, intervalObject, null, options.firstDayOfWeek);\r\n        var floorAtStartDate = v => new Date(mathFloor((v.getTime() - v.getTimezoneOffset() * MINUTE) / divider) * divider + v.getTimezoneOffset() * MINUTE);\r\n        value = correctDateWithUnitBeginning(value);\r\n        if (\"years\" in intervalObject) {\r\n            value.setFullYear(floorNumber(value.getFullYear(), intervalObject.years))\r\n        } else if (\"quarters\" in intervalObject) {\r\n            value = correctDateWithUnitBeginning(floorAtStartDate(value))\r\n        } else if (\"months\" in intervalObject) {\r\n            value.setMonth(floorNumber(value.getMonth(), intervalObject.months))\r\n        } else if (\"weeks\" in intervalObject || \"days\" in intervalObject) {\r\n            value = correctDateWithUnitBeginning(floorAtStartDate(value))\r\n        } else if (\"hours\" in intervalObject) {\r\n            value.setHours(floorNumber(value.getHours(), intervalObject.hours))\r\n        } else if (\"minutes\" in intervalObject) {\r\n            value.setMinutes(floorNumber(value.getMinutes(), intervalObject.minutes))\r\n        } else if (\"seconds\" in intervalObject) {\r\n            value.setSeconds(floorNumber(value.getSeconds(), intervalObject.seconds))\r\n        } else if (\"milliseconds\" in intervalObject) {\r\n            value = floorAtStartDate(value)\r\n        }\r\n        return value\r\n    }\r\n    var calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, _core_utils_date__WEBPACK_IMPORTED_MODULE_1__[\"default\"].convertMillisecondsToDateUnits);\r\n    return generator(options, getBusinessDelta, calculateTickIntervalDateTime, calculateMinorTickIntervalDateTime, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, dateToMilliseconds, calculateTicks(addIntervalDate, correctMinValueByEndOnTick(floor, (function(value, interval) {\r\n        var newValue = floor(value, interval);\r\n        while (value - newValue > 0) {\r\n            newValue = addIntervalDate(newValue, interval)\r\n        }\r\n        return newValue\r\n    }), resolveEndOnTickDate, options.endOnTick), adjustIntervalDateTime, resolveEndOnTickDate), calculateMinorTicks(getValue, addIntervalDate, floor, addIntervalDate, getValue), getScaleBreaksProcessor(dateToMilliseconds, getValue, (value, correction) => new Date(value.getTime() + correction)))\r\n}\r\nvar tickGenerator = function(options) {\r\n    var result;\r\n    if (options.rangeIsEmpty) {\r\n        result = dummyGenerator(options)\r\n    } else if (\"discrete\" === options.axisType) {\r\n        result = discreteGenerator(options)\r\n    } else if (\"logarithmic\" === options.axisType) {\r\n        result = logarithmicGenerator(options)\r\n    } else if (\"datetime\" === options.dataType) {\r\n        result = dateGenerator(options)\r\n    } else {\r\n        result = numericGenerator(options)\r\n    }\r\n    return result\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2F4ZXMvdGlja19nZW5lcmF0b3IuanM/OGE0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPdUI7QUFDdUI7QUFJZjtBQUlBO0FBR0U7QUFDakMsb0NBQW9DLHdEQUFTO0FBQzdDLHlCQUF5Qix3REFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpRUFBTSxHQUFHO0FBQ3JEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHFFQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSw2REFBTTtBQUM1RSxrRUFBa0UsOERBQVU7QUFDNUUsbUNBQW1DLDJEQUFTO0FBQzVDLHFEQUFxRCwwREFBTztBQUM1RCw2RUFBNkUsK0RBQU0sWUFBWSwrREFBTTs7QUFFckc7QUFDQSxRQUFRLGtFQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtFQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2REFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLDZEQUFNLGtCQUFrQiw2REFBTTtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLDZEQUFNO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUIsK0RBQU07QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsK0RBQU07QUFD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QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLHdEQUFTO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3Zpei9heGVzL3RpY2tfZ2VuZXJhdG9yLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS92aXovYXhlcy90aWNrX2dlbmVyYXRvci5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IHtcclxuICAgIGdldExvZ0V4dCBhcyBnZXRMb2csXHJcbiAgICBnZXRDYXRlZ29yaWVzSW5mbyxcclxuICAgIHJhaXNlVG9FeHQsXHJcbiAgICBnZXRMb2cgYXMgbWF0aExvZyxcclxuICAgIHJhaXNlVG8gYXMgbWF0aFJhaXNlXHJcbn0gZnJvbSBcIi4uL2NvcmUvdXRpbHNcIjtcclxuaW1wb3J0IGRhdGVVdGlscyBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9kYXRlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBpc0RlZmluZWQsXHJcbiAgICBpc1N0cmluZ1xyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL3R5cGVcIjtcclxuaW1wb3J0IHtcclxuICAgIGFkanVzdCxcclxuICAgIHNpZ25cclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9tYXRoXCI7XHJcbmltcG9ydCB7XHJcbiAgICBleHRlbmRcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9leHRlbmRcIjtcclxudmFyIGNvbnZlcnREYXRlVW5pdFRvTWlsbGlzZWNvbmRzID0gZGF0ZVV0aWxzLmNvbnZlcnREYXRlVW5pdFRvTWlsbGlzZWNvbmRzO1xyXG52YXIgZGF0ZVRvTWlsbGlzZWNvbmRzID0gZGF0ZVV0aWxzLmRhdGVUb01pbGxpc2Vjb25kcztcclxudmFyIG1hdGggPSBNYXRoO1xyXG52YXIgbWF0aEFicyA9IG1hdGguYWJzO1xyXG52YXIgbWF0aEZsb29yID0gbWF0aC5mbG9vcjtcclxudmFyIG1hdGhDZWlsID0gbWF0aC5jZWlsO1xyXG52YXIgbWF0aFBvdyA9IG1hdGgucG93O1xyXG52YXIgTlVNQkVSX01VTFRJUExJRVJTID0gWzEsIDIsIDIuNSwgNV07XHJcbnZhciBMT0dBUklUSE1JQ19NVUxUSVBMSUVSUyA9IFsxLCAyLCAzLCA1XTtcclxudmFyIERBVEVUSU1FX01VTFRJUExJRVJTID0ge1xyXG4gICAgbWlsbGlzZWNvbmQ6IFsxLCAyLCA1LCAxMCwgMjUsIDUwLCAxMDAsIDI1MCwgNTAwXSxcclxuICAgIHNlY29uZDogWzEsIDIsIDMsIDUsIDEwLCAxNSwgMjAsIDMwXSxcclxuICAgIG1pbnV0ZTogWzEsIDIsIDMsIDUsIDEwLCAxNSwgMjAsIDMwXSxcclxuICAgIGhvdXI6IFsxLCAyLCAzLCA0LCA2LCA4LCAxMl0sXHJcbiAgICBkYXk6IFsxLCAyXSxcclxuICAgIHdlZWs6IFsxLCAyXSxcclxuICAgIG1vbnRoOiBbMSwgMiwgMywgNl1cclxufTtcclxudmFyIERBVEVUSU1FX01VTFRJUExJRVJTX1dJVEhfQklHX1dFRUtFTkQgPSBleHRlbmQoe30sIERBVEVUSU1FX01VTFRJUExJRVJTLCB7XHJcbiAgICBkYXk6IFsxXVxyXG59KTtcclxudmFyIERBVEVUSU1FX01JTk9SX01VTFRJUExJRVJTID0ge1xyXG4gICAgbWlsbGlzZWNvbmQ6IFsxLCAyLCA1LCAxMCwgMjUsIDUwLCAxMDAsIDI1MCwgNTAwXSxcclxuICAgIHNlY29uZDogWzEsIDIsIDMsIDUsIDEwLCAxNSwgMjAsIDMwXSxcclxuICAgIG1pbnV0ZTogWzEsIDIsIDMsIDUsIDEwLCAxNSwgMjAsIDMwXSxcclxuICAgIGhvdXI6IFsxLCAyLCAzLCA0LCA2LCA4LCAxMl0sXHJcbiAgICBkYXk6IFsxLCAyLCAzLCA3LCAxNF0sXHJcbiAgICBtb250aDogWzEsIDIsIDMsIDZdXHJcbn07XHJcbnZhciBNSU5PUl9ERUxJTUlURVJTID0gWzIsIDQsIDUsIDgsIDEwXTtcclxudmFyIFZJU0lCSUxJVFlfREVMSU1JVEVSID0gMztcclxudmFyIE1JTlVURSA9IDZlNDtcclxuXHJcbmZ1bmN0aW9uIGR1bW15R2VuZXJhdG9yKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihkYXRhLCBzY3JlZW5EZWx0YSwgdGlja0ludGVydmFsLCBmb3JjZVRpY2tJbnRlcnZhbCkge1xyXG4gICAgICAgIHZhciBjb3VudCA9IG1hdGhGbG9vcihzY3JlZW5EZWx0YSAvIG9wdGlvbnMuYXhpc0RpdmlzaW9uRmFjdG9yKTtcclxuICAgICAgICBjb3VudCA9IGNvdW50IDwgMSA/IDEgOiBjb3VudDtcclxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzY3JlZW5EZWx0YSAvIGNvdW50O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRpY2tzOiBpbnRlcnZhbCA+IDAgPyBBcnJheS5hcHBseShudWxsLCBuZXcgQXJyYXkoY291bnQgKyAxKSkubWFwKChfLCBpKSA9PiBpbnRlcnZhbCAqIGkpIDogW10sXHJcbiAgICAgICAgICAgIHRpY2tJbnRlcnZhbDogaW50ZXJ2YWxcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc2NyZXRlR2VuZXJhdG9yKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihkYXRhLCBzY3JlZW5EZWx0YSwgdGlja0ludGVydmFsLCBmb3JjZVRpY2tJbnRlcnZhbCkge1xyXG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gZ2V0Q2F0ZWdvcmllc0luZm8oZGF0YS5jYXRlZ29yaWVzLCBkYXRhLm1pbiwgZGF0YS5tYXgpLmNhdGVnb3JpZXM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGlja3M6IGNhdGVnb3JpZXMsXHJcbiAgICAgICAgICAgIHRpY2tJbnRlcnZhbDogbWF0aENlaWwoY2F0ZWdvcmllcy5sZW5ndGggKiBvcHRpb25zLmF4aXNEaXZpc2lvbkZhY3RvciAvIHNjcmVlbkRlbHRhKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG52YXIgZ2V0VmFsdWUgPSB2YWx1ZSA9PiB2YWx1ZTtcclxudmFyIGdldExvZ1ZhbHVlID0gKGJhc2UsIGFsbG93TmVnYXRpdmVzLCBsaW5lYXJUaHJlc2hvbGQpID0+IHZhbHVlID0+IGdldExvZyh2YWx1ZSwgYmFzZSwgYWxsb3dOZWdhdGl2ZXMsIGxpbmVhclRocmVzaG9sZCk7XHJcbnZhciByYWlzZVRvID0gKGJhc2UsIGFsbG93TmVnYXRpdmVzLCBsaW5lYXJUaHJlc2hvbGQpID0+IHZhbHVlID0+IHJhaXNlVG9FeHQodmFsdWUsIGJhc2UsIGFsbG93TmVnYXRpdmVzLCBsaW5lYXJUaHJlc2hvbGQpO1xyXG52YXIgbWF0aFJhaXNlVG8gPSBiYXNlID0+IHZhbHVlID0+IG1hdGhSYWlzZSh2YWx1ZSwgYmFzZSk7XHJcbnZhciBsb2dBYnNWYWx1ZSA9IGJhc2UgPT4gdmFsdWUgPT4gMCA9PT0gdmFsdWUgPyAwIDogbWF0aExvZyhtYXRoQWJzKHZhbHVlKSwgYmFzZSk7XHJcbnZhciBjb3JyZWN0VmFsdWVCeUludGVydmFsID0gKHBvc3QsIHJvdW5kLCBnZXRWYWx1ZSkgPT4gKHZhbHVlLCBpbnRlcnZhbCkgPT4gYWRqdXN0KHBvc3Qocm91bmQoYWRqdXN0KGdldFZhbHVlKHZhbHVlKSAvIGludGVydmFsKSkgKiBpbnRlcnZhbCkpO1xyXG5cclxuZnVuY3Rpb24gY29ycmVjdE1pblZhbHVlQnlFbmRPblRpY2soZmxvb3JGdW5jLCBjZWlsRnVuYywgcmVzb2x2ZUVuZE9uVGljaywgZW5kT25UaWNrKSB7XHJcbiAgICBpZiAoaXNEZWZpbmVkKGVuZE9uVGljaykpIHtcclxuICAgICAgICByZXR1cm4gZW5kT25UaWNrID8gZmxvb3JGdW5jIDogY2VpbEZ1bmNcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW50ZXJ2YWwsIGJ1c2luZXNzVmlld0luZm8sIGZvcmNlRW5kT25UaWNrKSB7XHJcbiAgICAgICAgdmFyIGZsb29yVGlja1ZhbHVlID0gZmxvb3JGdW5jKHZhbHVlLCBpbnRlcnZhbCk7XHJcbiAgICAgICAgaWYgKHZhbHVlIC0gZmxvb3JUaWNrVmFsdWUgPT09IDAgfHwgIWlzRGVmaW5lZChidXNpbmVzc1ZpZXdJbmZvKSB8fCByZXNvbHZlRW5kT25UaWNrKHZhbHVlLCBmbG9vclRpY2tWYWx1ZSwgaW50ZXJ2YWwsIGJ1c2luZXNzVmlld0luZm8pIHx8IGZvcmNlRW5kT25UaWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbG9vclRpY2tWYWx1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2VpbEZ1bmModmFsdWUsIGludGVydmFsKVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlRW5kT25UaWNrKGN1clZhbHVlLCB0aWNrVmFsdWUsIGludGVydmFsLCBidXNpbmVzc1ZpZXdJbmZvKSB7XHJcbiAgICB2YXIgcHJldlRpY2tEYXRhRGlmZiA9IGludGVydmFsIC0gbWF0aEFicyh0aWNrVmFsdWUgLSBjdXJWYWx1ZSk7XHJcbiAgICB2YXIgaW50ZXJ2YWxDb3VudCA9IG1hdGgubWF4KG1hdGhDZWlsKGJ1c2luZXNzVmlld0luZm8uYnVzaW5lc3NEZWx0YSAvIGludGVydmFsKSwgMik7XHJcbiAgICB2YXIgYnVzaW5lc3NSYXRpbyA9IGJ1c2luZXNzVmlld0luZm8uc2NyZWVuRGVsdGEgLyAoaW50ZXJ2YWxDb3VudCAqIGludGVydmFsKTtcclxuICAgIHZhciBwb3RlbnRpYWxUaWNrU2NyZWVuRGlmZiA9IG1hdGgucm91bmQoYnVzaW5lc3NSYXRpbyAqIHByZXZUaWNrRGF0YURpZmYpO1xyXG4gICAgdmFyIGRlbGltaXRlckZhY3RvciA9IGdldExvZyhidXNpbmVzc1JhdGlvICogaW50ZXJ2YWwgLyBidXNpbmVzc1ZpZXdJbmZvLmF4aXNEaXZpc2lvbkZhY3RvciwgMikgKyAxO1xyXG4gICAgdmFyIGRlbGltaXRlck11bHRpcGxpZXIgPSAoYnVzaW5lc3NWaWV3SW5mby5pc1NwYWNlZE1hcmdpbiA/IDIgOiAxKSAqIGRlbGltaXRlckZhY3RvcjtcclxuICAgIHZhciBzY3JlZW5EZWxpbWl0ZXIgPSBtYXRoLnJvdW5kKFZJU0lCSUxJVFlfREVMSU1JVEVSICogZGVsaW1pdGVyTXVsdGlwbGllcik7XHJcbiAgICByZXR1cm4gYnVzaW5lc3NWaWV3SW5mby5idXNpbmVzc0RlbHRhID4gYnVzaW5lc3NWaWV3SW5mby5pbnRlcnZhbCAmJiBwb3RlbnRpYWxUaWNrU2NyZWVuRGlmZiA+PSBzY3JlZW5EZWxpbWl0ZXJcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZUVuZE9uVGlja0xvZyhiYXNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oY3VyVmFsdWUsIHRpY2tWYWx1ZSwgaW50ZXJ2YWwsIGJ1c2luZXNzVmlld0luZm8pIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZUVuZE9uVGljayhnZXRMb2coY3VyVmFsdWUsIGJhc2UpLCBnZXRMb2codGlja1ZhbHVlLCBiYXNlKSwgaW50ZXJ2YWwsIGJ1c2luZXNzVmlld0luZm8pXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVFbmRPblRpY2tEYXRlKGN1clZhbHVlLCB0aWNrVmFsdWUsIGludGVydmFsLCBidXNpbmVzc1ZpZXdJbmZvKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUVuZE9uVGljayhjdXJWYWx1ZS52YWx1ZU9mKCksIHRpY2tWYWx1ZS52YWx1ZU9mKCksIGRhdGVUb01pbGxpc2Vjb25kcyhpbnRlcnZhbCksIGJ1c2luZXNzVmlld0luZm8pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEJ1c2luZXNzRGVsdGEoZGF0YSwgYnJlYWtzKSB7XHJcbiAgICB2YXIgc3BhY2luZyA9IDA7XHJcbiAgICBpZiAoYnJlYWtzKSB7XHJcbiAgICAgICAgc3BhY2luZyA9IGJyZWFrcy5yZWR1Y2UoKHByZXYsIGl0ZW0pID0+IHByZXYgKyAoaXRlbS50byAtIGl0ZW0uZnJvbSksIDApXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0aEFicyhkYXRhLm1heCAtIGRhdGEubWluIC0gc3BhY2luZylcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0QnVzaW5lc3NEZWx0YUxvZyhiYXNlLCBhbGxvd05lZ2F0aXZlcywgbGluZWFyVGhyZXNob2xkKSB7XHJcbiAgICB2YXIgZ2V0TG9nID0gZ2V0TG9nVmFsdWUoYmFzZSwgYWxsb3dOZWdhdGl2ZXMsIGxpbmVhclRocmVzaG9sZCk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgYnJlYWtzKSB7XHJcbiAgICAgICAgdmFyIHNwYWNpbmcgPSAwO1xyXG4gICAgICAgIGlmIChicmVha3MpIHtcclxuICAgICAgICAgICAgc3BhY2luZyA9IGJyZWFrcy5yZWR1Y2UoKHByZXYsIGl0ZW0pID0+IHByZXYgKyBtYXRoQWJzKGdldExvZyhpdGVtLnRvIC8gaXRlbS5mcm9tKSksIDApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRoQ2VpbChtYXRoQWJzKGdldExvZyhkYXRhLm1heCkgLSBnZXRMb2coZGF0YS5taW4pKSAtIHNwYWNpbmcpXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEludGVydmFsQnlGYWN0b3IoYnVzaW5lc3NEZWx0YSwgc2NyZWVuRGVsdGEsIGF4aXNEaXZpc2lvbkZhY3RvciwgYWRkVGlja0NvdW50KSB7XHJcbiAgICB2YXIgY291bnQgPSBzY3JlZW5EZWx0YSAvIGF4aXNEaXZpc2lvbkZhY3RvciAtIChhZGRUaWNrQ291bnQgfHwgMCk7XHJcbiAgICBjb3VudCA9IGNvdW50IDwgMSA/IDEgOiBjb3VudDtcclxuICAgIHJldHVybiBidXNpbmVzc0RlbHRhIC8gY291bnRcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TXVsdGlwbGllckZhY3RvcihpbnRlcnZhbCwgZmFjdG9yRGVsdGEpIHtcclxuICAgIHJldHVybiBtYXRoUG93KDEwLCBtYXRoRmxvb3IoZ2V0TG9nKGludGVydmFsLCAxMCkpICsgKGZhY3RvckRlbHRhIHx8IDApKVxyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxjdWxhdGVUaWNrSW50ZXJ2YWwoYnVzaW5lc3NEZWx0YSwgc2NyZWVuRGVsdGEsIHRpY2tJbnRlcnZhbCwgZm9yY2VUaWNrSW50ZXJ2YWwsIGF4aXNEaXZpc2lvbkZhY3RvciwgbXVsdGlwbGllcnMsIGFsbG93RGVjaW1hbHMsIGFkZFRpY2tDb3VudCwgXywgbWluVGlja0ludGVydmFsKSB7XHJcbiAgICB2YXIgaW50ZXJ2YWwgPSBnZXRJbnRlcnZhbEJ5RmFjdG9yKGJ1c2luZXNzRGVsdGEsIHNjcmVlbkRlbHRhLCBheGlzRGl2aXNpb25GYWN0b3IsIGFkZFRpY2tDb3VudCk7XHJcbiAgICB2YXIgcmVzdWx0ID0gMTtcclxuICAgIHZhciBvbmx5SW50ZWdlcnMgPSBmYWxzZSA9PT0gYWxsb3dEZWNpbWFscztcclxuICAgIGlmICghZm9yY2VUaWNrSW50ZXJ2YWwgfHwgIXRpY2tJbnRlcnZhbCkge1xyXG4gICAgICAgIGlmIChpbnRlcnZhbCA+PSAxIHx8ICFvbmx5SW50ZWdlcnMgJiYgaW50ZXJ2YWwgPiAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGFkanVzdEludGVydmFsKGludGVydmFsLCBtdWx0aXBsaWVycywgb25seUludGVnZXJzKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRpY2tJbnRlcnZhbCB8fCAhZm9yY2VUaWNrSW50ZXJ2YWwgJiYgdGlja0ludGVydmFsIDwgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHRpY2tJbnRlcnZhbCA9IHJlc3VsdFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghZm9yY2VUaWNrSW50ZXJ2YWwgJiYgbWluVGlja0ludGVydmFsKSB7XHJcbiAgICAgICAgbWluVGlja0ludGVydmFsID0gYWRqdXN0SW50ZXJ2YWwobWluVGlja0ludGVydmFsLCBtdWx0aXBsaWVycywgb25seUludGVnZXJzKTtcclxuICAgICAgICBpZiAobWluVGlja0ludGVydmFsID4gdGlja0ludGVydmFsKSB7XHJcbiAgICAgICAgICAgIHRpY2tJbnRlcnZhbCA9IG1pblRpY2tJbnRlcnZhbFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aWNrSW50ZXJ2YWxcclxufVxyXG5cclxuZnVuY3Rpb24gYWRqdXN0SW50ZXJ2YWwoaW50ZXJ2YWwsIG11bHRpcGxpZXJzLCBvbmx5SW50ZWdlcnMpIHtcclxuICAgIHZhciBmYWN0b3IgPSBnZXRNdWx0aXBsaWVyRmFjdG9yKGludGVydmFsLCAtMSk7XHJcbiAgICB2YXIgcmVzdWx0ID0gMTtcclxuICAgIG11bHRpcGxpZXJzID0gbXVsdGlwbGllcnMgfHwgTlVNQkVSX01VTFRJUExJRVJTO1xyXG4gICAgaWYgKGludGVydmFsID4gMCkge1xyXG4gICAgICAgIGludGVydmFsIC89IGZhY3RvcjtcclxuICAgICAgICByZXN1bHQgPSBtdWx0aXBsaWVycy5jb25jYXQoMTAgKiBtdWx0aXBsaWVyc1swXSkubWFwKG0gPT4gMTAgKiBtKS5yZWR1Y2UoKHIsIG0pID0+IHtcclxuICAgICAgICAgICAgaWYgKC4xID09PSBmYWN0b3IgJiYgb25seUludGVnZXJzICYmIDI1ID09PSBtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByIDwgaW50ZXJ2YWwgPyBtIDogclxyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICAgIHJlc3VsdCA9IGFkanVzdChyZXN1bHQgKiBmYWN0b3IsIGZhY3RvcilcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsY3VsYXRlTWlub3JUaWNrSW50ZXJ2YWwoYnVzaW5lc3NEZWx0YSwgc2NyZWVuRGVsdGEsIHRpY2tJbnRlcnZhbCwgYXhpc0RpdmlzaW9uRmFjdG9yKSB7XHJcbiAgICB2YXIgaW50ZXJ2YWwgPSBnZXRJbnRlcnZhbEJ5RmFjdG9yKGJ1c2luZXNzRGVsdGEsIHNjcmVlbkRlbHRhLCBheGlzRGl2aXNpb25GYWN0b3IpO1xyXG4gICAgcmV0dXJuIHRpY2tJbnRlcnZhbCB8fCBNSU5PUl9ERUxJTUlURVJTLnJlZHVjZSgociwgZCkgPT4ge1xyXG4gICAgICAgIHZhciBjdXIgPSBidXNpbmVzc0RlbHRhIC8gZDtcclxuICAgICAgICByZXR1cm4gY3VyID49IGludGVydmFsID8gY3VyIDogclxyXG4gICAgfSwgMClcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q2FsY3VsYXRlVGlja0ludGVydmFsTG9nKHNraXBDYWxjdWxhdGlvbkxpbWl0cykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJ1c2luZXNzRGVsdGEsIHNjcmVlbkRlbHRhLCB0aWNrSW50ZXJ2YWwsIGZvcmNlVGlja0ludGVydmFsLCBheGlzRGl2aXNpb25GYWN0b3IsIG11bHRpcGxpZXJzLCBhbGxvd0RlY2ltYWxzLCBfLCBfXywgbWluVGlja0ludGVydmFsKSB7XHJcbiAgICAgICAgdmFyIGludGVydmFsID0gZ2V0SW50ZXJ2YWxCeUZhY3RvcihidXNpbmVzc0RlbHRhLCBzY3JlZW5EZWx0YSwgYXhpc0RpdmlzaW9uRmFjdG9yKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gMDtcclxuICAgICAgICB2YXIgYWRqdXN0SW50ZXJ2YWwgPSBnZXRBZGp1c3RJbnRlcnZhbExvZyhza2lwQ2FsY3VsYXRpb25MaW1pdHMpO1xyXG4gICAgICAgIGlmICghZm9yY2VUaWNrSW50ZXJ2YWwgfHwgIXRpY2tJbnRlcnZhbCkge1xyXG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhZGp1c3RJbnRlcnZhbChpbnRlcnZhbCwgbXVsdGlwbGllcnMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aWNrSW50ZXJ2YWwgfHwgIWZvcmNlVGlja0ludGVydmFsICYmIHRpY2tJbnRlcnZhbCA8IHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgdGlja0ludGVydmFsID0gcmVzdWx0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmb3JjZVRpY2tJbnRlcnZhbCAmJiBtaW5UaWNrSW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgbWluVGlja0ludGVydmFsID0gYWRqdXN0SW50ZXJ2YWwobWluVGlja0ludGVydmFsLCBtdWx0aXBsaWVycyk7XHJcbiAgICAgICAgICAgIGlmIChtaW5UaWNrSW50ZXJ2YWwgPiB0aWNrSW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgIHRpY2tJbnRlcnZhbCA9IG1pblRpY2tJbnRlcnZhbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aWNrSW50ZXJ2YWxcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0QWRqdXN0SW50ZXJ2YWxMb2coc2tpcENhbGN1bGF0aW9uTGltaXRzKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oaW50ZXJ2YWwsIG11bHRpcGxpZXJzKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvciA9IGdldE11bHRpcGxpZXJGYWN0b3IoaW50ZXJ2YWwpO1xyXG4gICAgICAgIG11bHRpcGxpZXJzID0gbXVsdGlwbGllcnMgfHwgTE9HQVJJVEhNSUNfTVVMVElQTElFUlM7XHJcbiAgICAgICAgaWYgKCFza2lwQ2FsY3VsYXRpb25MaW1pdHMgJiYgZmFjdG9yIDwgMSkge1xyXG4gICAgICAgICAgICBmYWN0b3IgPSAxXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtdWx0aXBsaWVycy5jb25jYXQoMTAgKiBtdWx0aXBsaWVyc1swXSkucmVkdWNlKChyLCBtKSA9PiByIDwgaW50ZXJ2YWwgPyBtICogZmFjdG9yIDogciwgMClcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGF0YVRpbWVNdWx0aXBsaWVycyhnYXBTaXplKSB7XHJcbiAgICBpZiAoZ2FwU2l6ZSAmJiBnYXBTaXplID4gMikge1xyXG4gICAgICAgIHJldHVybiBEQVRFVElNRV9NVUxUSVBMSUVSU19XSVRIX0JJR19XRUVLRU5EXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBEQVRFVElNRV9NVUxUSVBMSUVSU1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBudW1iZXJzUmVkdWNlcihpbnRlcnZhbCwga2V5KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24ociwgbSkge1xyXG4gICAgICAgIGlmICghciAmJiBpbnRlcnZhbCA8PSBjb252ZXJ0RGF0ZVVuaXRUb01pbGxpc2Vjb25kcyhrZXksIG0pKSB7XHJcbiAgICAgICAgICAgIHIgPSB7fTtcclxuICAgICAgICAgICAgcltrZXkgKyBcInNcIl0gPSBtXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHllYXJzUmVkdWNlcihpbnRlcnZhbCwgZmFjdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24ociwgbSkge1xyXG4gICAgICAgIHZhciB5ZWFycyA9IGZhY3RvciAqIG07XHJcbiAgICAgICAgaWYgKCFyICYmIGludGVydmFsIDw9IGNvbnZlcnREYXRlVW5pdFRvTWlsbGlzZWNvbmRzKFwieWVhclwiLCB5ZWFycykgJiYgMi41ICE9PSB5ZWFycykge1xyXG4gICAgICAgICAgICByID0ge1xyXG4gICAgICAgICAgICAgICAgeWVhcnM6IHllYXJzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2FsY3VsYXRlVGlja0ludGVydmFsRGF0ZVRpbWUoYnVzaW5lc3NEZWx0YSwgc2NyZWVuRGVsdGEsIHRpY2tJbnRlcnZhbCwgZm9yY2VUaWNrSW50ZXJ2YWwsIGF4aXNEaXZpc2lvbkZhY3RvciwgbXVsdGlwbGllcnMsIGFsbG93RGVjaW1hbHMsIGFkZFRpY2tDb3VudCwgZ2FwU2l6ZSwgbWluVGlja0ludGVydmFsKSB7XHJcbiAgICBpZiAoIWZvcmNlVGlja0ludGVydmFsIHx8ICF0aWNrSW50ZXJ2YWwpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gYWRqdXN0SW50ZXJ2YWxEYXRlVGltZShnZXRJbnRlcnZhbEJ5RmFjdG9yKGJ1c2luZXNzRGVsdGEsIHNjcmVlbkRlbHRhLCBheGlzRGl2aXNpb25GYWN0b3IpLCBtdWx0aXBsaWVycywgbnVsbCwgZ2FwU2l6ZSk7XHJcbiAgICAgICAgaWYgKCF0aWNrSW50ZXJ2YWwgfHwgIWZvcmNlVGlja0ludGVydmFsICYmIGRhdGVUb01pbGxpc2Vjb25kcyh0aWNrSW50ZXJ2YWwpIDw9IGRhdGVUb01pbGxpc2Vjb25kcyhyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHRpY2tJbnRlcnZhbCA9IHJlc3VsdFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghZm9yY2VUaWNrSW50ZXJ2YWwgJiYgbWluVGlja0ludGVydmFsKSB7XHJcbiAgICAgICAgbWluVGlja0ludGVydmFsID0gYWRqdXN0SW50ZXJ2YWxEYXRlVGltZShtaW5UaWNrSW50ZXJ2YWwsIG11bHRpcGxpZXJzLCBudWxsLCBnYXBTaXplKTtcclxuICAgICAgICBpZiAoZGF0ZVRvTWlsbGlzZWNvbmRzKG1pblRpY2tJbnRlcnZhbCkgPiBkYXRlVG9NaWxsaXNlY29uZHModGlja0ludGVydmFsKSkge1xyXG4gICAgICAgICAgICB0aWNrSW50ZXJ2YWwgPSBtaW5UaWNrSW50ZXJ2YWxcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGlja0ludGVydmFsXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkanVzdEludGVydmFsRGF0ZVRpbWUoaW50ZXJ2YWwsIG11bHRpcGxpZXJzLCBfLCBnYXBTaXplKSB7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG4gICAgbXVsdGlwbGllcnMgPSBtdWx0aXBsaWVycyB8fCBnZXREYXRhVGltZU11bHRpcGxpZXJzKGdhcFNpemUpO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG11bHRpcGxpZXJzKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gbXVsdGlwbGllcnNba2V5XS5yZWR1Y2UobnVtYmVyc1JlZHVjZXIoaW50ZXJ2YWwsIGtleSksIHJlc3VsdCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgZmFjdG9yID0gMTs7IGZhY3RvciAqPSAxMCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBOVU1CRVJfTVVMVElQTElFUlMucmVkdWNlKHllYXJzUmVkdWNlcihpbnRlcnZhbCwgZmFjdG9yKSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsY3VsYXRlTWlub3JUaWNrSW50ZXJ2YWxEYXRlVGltZShidXNpbmVzc0RlbHRhLCBzY3JlZW5EZWx0YSwgdGlja0ludGVydmFsLCBheGlzRGl2aXNpb25GYWN0b3IpIHtcclxuICAgIHJldHVybiBjYWxjdWxhdGVUaWNrSW50ZXJ2YWxEYXRlVGltZShidXNpbmVzc0RlbHRhLCBzY3JlZW5EZWx0YSwgdGlja0ludGVydmFsLCB0cnVlLCBheGlzRGl2aXNpb25GYWN0b3IsIERBVEVUSU1FX01JTk9SX01VTFRJUExJRVJTKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUaWNrSW50ZXJ2YWxCeUN1c3RvbVRpY2tzKGdldFZhbHVlLCBwb3N0UHJvY2Vzcykge1xyXG4gICAgcmV0dXJuIHRpY2tzID0+IHRpY2tzID8gcG9zdFByb2Nlc3MobWF0aEFicyhhZGp1c3QoZ2V0VmFsdWUodGlja3NbMV0pIC0gZ2V0VmFsdWUodGlja3NbMF0pKSkpIHx8IHZvaWQgMCA6IHZvaWQgMFxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRJbnRlcnZhbCh2YWx1ZSwgaW50ZXJ2YWwsIGlzTmVnYXRpdmUpIHtcclxuICAgIHJldHVybiBkYXRlVXRpbHMuYWRkSW50ZXJ2YWwodmFsdWUsIGludGVydmFsLCBpc05lZ2F0aXZlKVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRJbnRlcnZhbExvZyhsb2csIHJhaXNlKSB7XHJcbiAgICByZXR1cm4gKHZhbHVlLCBpbnRlcnZhbCwgaXNOZWdhdGl2ZSkgPT4gcmFpc2UoYWRkSW50ZXJ2YWwobG9nKHZhbHVlKSwgaW50ZXJ2YWwsIGlzTmVnYXRpdmUpKVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRJbnRlcnZhbERhdGUodmFsdWUsIGludGVydmFsLCBpc05lZ2F0aXZlKSB7XHJcbiAgICByZXR1cm4gYWRkSW50ZXJ2YWwodmFsdWUsIGludGVydmFsLCBpc05lZ2F0aXZlKVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRJbnRlcnZhbFdpdGhCcmVha3MoYWRkSW50ZXJ2YWwsIGJyZWFrcywgY29ycmVjdFZhbHVlKSB7XHJcbiAgICBicmVha3MgPSBicmVha3MuZmlsdGVyKGIgPT4gIWIuZ2FwU2l6ZSk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGludGVydmFsLCBpc05lZ2F0aXZlKSB7XHJcbiAgICAgICAgdmFyIGJyZWFrU2l6ZTtcclxuICAgICAgICB2YWx1ZSA9IGFkZEludGVydmFsKHZhbHVlLCBpbnRlcnZhbCwgaXNOZWdhdGl2ZSk7XHJcbiAgICAgICAgaWYgKCFicmVha3MuZXZlcnkoaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gYWRkSW50ZXJ2YWwoaXRlbS5mcm9tLCBpbnRlcnZhbCkgJiYgYWRkSW50ZXJ2YWwodmFsdWUsIGludGVydmFsKSA8IGl0ZW0udG8pIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVha1NpemUgPSBpdGVtLnRvIC0gaXRlbS5mcm9tIC0gMiAqIChhZGRJbnRlcnZhbChpdGVtLmZyb20sIGludGVydmFsKSAtIGl0ZW0uZnJvbSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAhYnJlYWtTaXplXHJcbiAgICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gY29ycmVjdFZhbHVlKGFkZEludGVydmFsKHZhbHVlLCBicmVha1NpemUpLCBpbnRlcnZhbClcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVRpY2tzKGFkZEludGVydmFsLCBjb3JyZWN0TWluVmFsdWUsIGFkanVzdEludGVydmFsLCByZXNvbHZlRW5kT25UaWNrKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgdGlja0ludGVydmFsLCBlbmRPblRpY2ssIGdhcHMsIGJyZWFrcywgYnVzaW5lc3NEZWx0YSwgc2NyZWVuRGVsdGEsIGF4aXNEaXZpc2lvbkZhY3RvciwgZ2VuZXJhdGVFeHRyYVRpY2spIHtcclxuICAgICAgICB2YXIgY29ycmVjdFRpY2tWYWx1ZSA9IGNvcnJlY3RUaWNrVmFsdWVPbkdhcFNpemUoYWRkSW50ZXJ2YWwsIGdhcHMpO1xyXG4gICAgICAgIHZhciBtaW4gPSBkYXRhLm1pbjtcclxuICAgICAgICB2YXIgbWF4ID0gZGF0YS5tYXg7XHJcbiAgICAgICAgdmFyIGJ1c2luZXNzVmlld0luZm8gPSB7XHJcbiAgICAgICAgICAgIHNjcmVlbkRlbHRhOiBzY3JlZW5EZWx0YSxcclxuICAgICAgICAgICAgYnVzaW5lc3NEZWx0YTogYnVzaW5lc3NEZWx0YSxcclxuICAgICAgICAgICAgYXhpc0RpdmlzaW9uRmFjdG9yOiBheGlzRGl2aXNpb25GYWN0b3IsXHJcbiAgICAgICAgICAgIGlzU3BhY2VkTWFyZ2luOiBkYXRhLmlzU3BhY2VkTWFyZ2luLFxyXG4gICAgICAgICAgICBpbnRlcnZhbDogdGlja0ludGVydmFsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgY3VyID0gY29ycmVjdE1pblZhbHVlKG1pbiwgdGlja0ludGVydmFsLCBidXNpbmVzc1ZpZXdJbmZvKTtcclxuICAgICAgICB2YXIgdGlja3MgPSBbXTtcclxuICAgICAgICBpZiAobnVsbCAhPT0gYnJlYWtzICYmIHZvaWQgMCAhPT0gYnJlYWtzICYmIGJyZWFrcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYWRkSW50ZXJ2YWwgPSBhZGRJbnRlcnZhbFdpdGhCcmVha3MoYWRkSW50ZXJ2YWwsIGJyZWFrcywgY29ycmVjdE1pblZhbHVlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3VyID4gbWF4KSB7XHJcbiAgICAgICAgICAgIGN1ciA9IGNvcnJlY3RNaW5WYWx1ZShtaW4sIGFkanVzdEludGVydmFsKGJ1c2luZXNzRGVsdGEgLyAyKSwgYnVzaW5lc3NWaWV3SW5mbyk7XHJcbiAgICAgICAgICAgIGlmIChjdXIgPiBtYXgpIHtcclxuICAgICAgICAgICAgICAgIGVuZE9uVGljayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjdXIgPSBjb3JyZWN0TWluVmFsdWUobWluLCB0aWNrSW50ZXJ2YWwsIGJ1c2luZXNzVmlld0luZm8sIGVuZE9uVGljaylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjdXIgPSBjb3JyZWN0VGlja1ZhbHVlKGN1cik7XHJcbiAgICAgICAgdmFyIHByZXY7XHJcbiAgICAgICAgd2hpbGUgKGN1ciA8IG1heCAmJiBjdXIgIT09IHByZXYgfHwgZ2VuZXJhdGVFeHRyYVRpY2sgJiYgY3VyIDw9IG1heCkge1xyXG4gICAgICAgICAgICB0aWNrcy5wdXNoKGN1cik7XHJcbiAgICAgICAgICAgIHByZXYgPSBjdXI7XHJcbiAgICAgICAgICAgIGN1ciA9IGNvcnJlY3RUaWNrVmFsdWUoYWRkSW50ZXJ2YWwoY3VyLCB0aWNrSW50ZXJ2YWwpKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kT25UaWNrIHx8IGN1ciAtIG1heCA9PT0gMCB8fCAhaXNEZWZpbmVkKGVuZE9uVGljaykgJiYgcmVzb2x2ZUVuZE9uVGljayhtYXgsIGN1ciwgdGlja0ludGVydmFsLCBidXNpbmVzc1ZpZXdJbmZvKSkge1xyXG4gICAgICAgICAgICB0aWNrcy5wdXNoKGN1cilcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRpY2tzXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZU1pbm9yVGlja3ModXBkYXRlVGlja0ludGVydmFsLCBhZGRJbnRlcnZhbCwgY29ycmVjdE1pblZhbHVlLCBjb3JyZWN0VGlja1ZhbHVlLCBjZWlsKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24obWluLCBtYXgsIG1ham9yVGlja3MsIG1pbm9yVGlja0ludGVydmFsLCB0aWNrSW50ZXJ2YWwsIGJyZWFrcywgbWF4Q291bnQpIHtcclxuICAgICAgICB2YXIgZmFjdG9yID0gdGlja0ludGVydmFsIC8gbWlub3JUaWNrSW50ZXJ2YWw7XHJcbiAgICAgICAgdmFyIGxhc3RNYWpvciA9IG1ham9yVGlja3NbbWFqb3JUaWNrcy5sZW5ndGggLSAxXTtcclxuICAgICAgICB2YXIgZmlyc3RNYWpvciA9IG1ham9yVGlja3NbMF07XHJcbiAgICAgICAgdmFyIHRpY2tCYWxhbmNlID0gbWF4Q291bnQgLSAxO1xyXG4gICAgICAgIGlmIChudWxsICE9PSBicmVha3MgJiYgdm9pZCAwICE9PSBicmVha3MgJiYgYnJlYWtzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBhZGRJbnRlcnZhbCA9IGFkZEludGVydmFsV2l0aEJyZWFrcyhhZGRJbnRlcnZhbCwgYnJlYWtzLCBjb3JyZWN0TWluVmFsdWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1pbm9yVGlja0ludGVydmFsID0gdXBkYXRlVGlja0ludGVydmFsKG1pbm9yVGlja0ludGVydmFsLCBmaXJzdE1ham9yLCBmaXJzdE1ham9yLCBmYWN0b3IpO1xyXG4gICAgICAgIGlmICgwID09PSBtaW5vclRpY2tJbnRlcnZhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW11cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN1ciA9IGNvcnJlY3RUaWNrVmFsdWUoY29ycmVjdE1pblZhbHVlKG1pbiwgdGlja0ludGVydmFsLCBtaW4pLCBtaW5vclRpY2tJbnRlcnZhbCk7XHJcbiAgICAgICAgbWlub3JUaWNrSW50ZXJ2YWwgPSB1cGRhdGVUaWNrSW50ZXJ2YWwobWlub3JUaWNrSW50ZXJ2YWwsIGZpcnN0TWFqb3IsIGN1ciwgZmFjdG9yKTtcclxuICAgICAgICB2YXIgdGlja3MgPSBbXTtcclxuICAgICAgICB3aGlsZSAoY3VyIDwgZmlyc3RNYWpvciAmJiAoIXRpY2tCYWxhbmNlIHx8IHRpY2tCYWxhbmNlID4gMCkpIHtcclxuICAgICAgICAgICAgY3VyID49IG1pbiAmJiB0aWNrcy5wdXNoKGN1cik7XHJcbiAgICAgICAgICAgIHRpY2tCYWxhbmNlLS07XHJcbiAgICAgICAgICAgIGN1ciA9IGFkZEludGVydmFsKGN1ciwgbWlub3JUaWNrSW50ZXJ2YWwpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaWRkbGVUaWNrcyA9IG1ham9yVGlja3MucmVkdWNlKChyLCB0aWNrKSA9PiB7XHJcbiAgICAgICAgICAgIHRpY2tCYWxhbmNlID0gbWF4Q291bnQgLSAxO1xyXG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gci5wcmV2VGljaykge1xyXG4gICAgICAgICAgICAgICAgci5wcmV2VGljayA9IHRpY2s7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1pbm9yVGlja0ludGVydmFsID0gdXBkYXRlVGlja0ludGVydmFsKG1pbm9yVGlja0ludGVydmFsLCB0aWNrLCByLnByZXZUaWNrLCBmYWN0b3IpO1xyXG4gICAgICAgICAgICB2YXIgY3VyID0gY29ycmVjdFRpY2tWYWx1ZShyLnByZXZUaWNrLCBtaW5vclRpY2tJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXIgPCB0aWNrICYmICghdGlja0JhbGFuY2UgfHwgdGlja0JhbGFuY2UgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgY3VyICE9PSByLnByZXZUaWNrICYmIHIubWlub3JzLnB1c2goY3VyKTtcclxuICAgICAgICAgICAgICAgIHRpY2tCYWxhbmNlLS07XHJcbiAgICAgICAgICAgICAgICBjdXIgPSBhZGRJbnRlcnZhbChjdXIsIG1pbm9yVGlja0ludGVydmFsKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHIucHJldlRpY2sgPSB0aWNrO1xyXG4gICAgICAgICAgICByZXR1cm4gclxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgICAgcHJldlRpY2s6IG51bGwsXHJcbiAgICAgICAgICAgIG1pbm9yczogW11cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aWNrcyA9IHRpY2tzLmNvbmNhdChtaWRkbGVUaWNrcy5taW5vcnMpO1xyXG4gICAgICAgIHZhciBtYXhWYWx1ZSA9IGNlaWwobWF4LCB0aWNrSW50ZXJ2YWwsIG1pbik7XHJcbiAgICAgICAgbWlub3JUaWNrSW50ZXJ2YWwgPSB1cGRhdGVUaWNrSW50ZXJ2YWwobWlub3JUaWNrSW50ZXJ2YWwsIG1heFZhbHVlLCBtYXhWYWx1ZSwgZmFjdG9yKTtcclxuICAgICAgICBjdXIgPSBjb3JyZWN0VGlja1ZhbHVlKGxhc3RNYWpvciwgbWlub3JUaWNrSW50ZXJ2YWwpO1xyXG4gICAgICAgIHZhciBwcmV2O1xyXG4gICAgICAgIHdoaWxlIChjdXIgPCBtYXggJiYgY3VyICE9PSBwcmV2KSB7XHJcbiAgICAgICAgICAgIHRpY2tzLnB1c2goY3VyKTtcclxuICAgICAgICAgICAgcHJldiA9IGN1cjtcclxuICAgICAgICAgICAgY3VyID0gYWRkSW50ZXJ2YWwoY3VyLCBtaW5vclRpY2tJbnRlcnZhbClcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RNYWpvciAtIG1heCAhPT0gMCAmJiBjdXIgLSBtYXggPT09IDApIHtcclxuICAgICAgICAgICAgdGlja3MucHVzaChjdXIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aWNrc1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJUaWNrcyh0aWNrcywgYnJlYWtzKSB7XHJcbiAgICBpZiAoYnJlYWtzLmxlbmd0aCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBicmVha3MucmVkdWNlKChyZXN1bHQsIGIpID0+IHtcclxuICAgICAgICAgICAgdmFyIHRtcFRpY2tzID0gW107XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSByZXN1bHRbMV07IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpY2tWYWx1ZSA9IHRpY2tzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpY2tWYWx1ZSA8IGIuZnJvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcFRpY2tzLnB1c2godGlja1ZhbHVlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRpY2tWYWx1ZSA+PSBiLnRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdFswXS5jb25jYXQodG1wVGlja3MpLCBpXVxyXG4gICAgICAgIH0sIFtcclxuICAgICAgICAgICAgW10sIDBcclxuICAgICAgICBdKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0WzBdLmNvbmNhdCh0aWNrcy5zbGljZShyZXN1bHRbMV0pKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRpY2tzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcnJlY3RUaWNrVmFsdWVPbkdhcFNpemUoYWRkSW50ZXJ2YWwsIGJyZWFrcykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGdhcFNpemU7XHJcbiAgICAgICAgaWYgKCFicmVha3MuZXZlcnkoaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gaXRlbS5mcm9tICYmIHZhbHVlIDwgaXRlbS50bykge1xyXG4gICAgICAgICAgICAgICAgICAgIGdhcFNpemUgPSBpdGVtLmdhcFNpemVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAhZ2FwU2l6ZVxyXG4gICAgICAgICAgICB9KSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGFkZEludGVydmFsKHZhbHVlLCBnYXBTaXplKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWVcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdG9yKG9wdGlvbnMsIGdldEJ1c2luZXNzRGVsdGEsIGNhbGN1bGF0ZVRpY2tJbnRlcnZhbCwgY2FsY3VsYXRlTWlub3JUaWNrSW50ZXJ2YWwsIGdldE1ham9yVGlja0ludGVydmFsQnlDdXN0b21UaWNrcywgZ2V0TWlub3JUaWNrSW50ZXJ2YWxCeUN1c3RvbVRpY2tzLCBjb252ZXJ0VGlja0ludGVydmFsLCBjYWxjdWxhdGVUaWNrcywgY2FsY3VsYXRlTWlub3JUaWNrcywgcHJvY2Vzc1NjYWxlQnJlYWtzKSB7XHJcbiAgICBmdW5jdGlvbiBjb3JyZWN0VXNlclRpY2tJbnRlcnZhbCh0aWNrSW50ZXJ2YWwsIGJ1c2luZXNzRGVsdGEsIGxpbWl0KSB7XHJcbiAgICAgICAgaWYgKHRpY2tJbnRlcnZhbCAmJiBidXNpbmVzc0RlbHRhIC8gY29udmVydFRpY2tJbnRlcnZhbCh0aWNrSW50ZXJ2YWwpID49IGxpbWl0ICsgMSkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmluY2lkZW50T2NjdXJyZWQoXCJXMjAwM1wiKTtcclxuICAgICAgICAgICAgdGlja0ludGVydmFsID0gdm9pZCAwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aWNrSW50ZXJ2YWxcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbihkYXRhLCBzY3JlZW5EZWx0YSwgdGlja0ludGVydmFsLCBmb3JjZVRpY2tJbnRlcnZhbCwgY3VzdG9tVGlja3MsIG1pbm9yVGlja0ludGVydmFsLCBtaW5vclRpY2tDb3VudCwgYnJlYWtzKSB7XHJcbiAgICAgICAgY3VzdG9tVGlja3MgPSBjdXN0b21UaWNrcyB8fCB7fTtcclxuICAgICAgICB2YXIgYnVzaW5lc3NEZWx0YSA9IGdldEJ1c2luZXNzRGVsdGEoZGF0YSwgYnJlYWtzKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oY3VzdG9tVGlja3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHRpY2tJbnRlcnZhbDogZ2V0TWFqb3JUaWNrSW50ZXJ2YWxCeUN1c3RvbVRpY2tzKGN1c3RvbVRpY2tzLm1ham9ycyksXHJcbiAgICAgICAgICAgICAgICB0aWNrczogY3VzdG9tVGlja3MubWFqb3JzIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgbWlub3JUaWNrSW50ZXJ2YWw6IGdldE1pbm9yVGlja0ludGVydmFsQnlDdXN0b21UaWNrcyhjdXN0b21UaWNrcy5taW5vcnMpLFxyXG4gICAgICAgICAgICAgICAgbWlub3JUaWNrczogY3VzdG9tVGlja3MubWlub3JzIHx8IFtdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KGN1c3RvbVRpY2tzKTtcclxuICAgICAgICBpZiAoIWlzTmFOKGJ1c2luZXNzRGVsdGEpKSB7XHJcbiAgICAgICAgICAgIGlmICgwID09PSBidXNpbmVzc0RlbHRhICYmICFjdXN0b21UaWNrcy5tYWpvcnMpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC50aWNrcyA9IFtkYXRhLm1pbl1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uKHRpY2tzLCBkYXRhLCBidXNpbmVzc0RlbHRhLCBzY3JlZW5EZWx0YSwgdGlja0ludGVydmFsLCBmb3JjZVRpY2tJbnRlcnZhbCwgY3VzdG9tVGlja3MsIGJyZWFrcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXN0b21UaWNrcy5tYWpvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGlja3MuYnJlYWtzID0gYnJlYWtzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGlja3NcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdhcHMgPSBicmVha3MuZmlsdGVyKGIgPT4gYi5nYXBTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFqb3JUaWNrcztcclxuICAgICAgICAgICAgICAgICAgICB0aWNrSW50ZXJ2YWwgPSBvcHRpb25zLnNraXBDYWxjdWxhdGlvbkxpbWl0cyA/IHRpY2tJbnRlcnZhbCA6IGNvcnJlY3RVc2VyVGlja0ludGVydmFsKHRpY2tJbnRlcnZhbCwgYnVzaW5lc3NEZWx0YSwgc2NyZWVuRGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpY2tJbnRlcnZhbCA9IGNhbGN1bGF0ZVRpY2tJbnRlcnZhbChidXNpbmVzc0RlbHRhLCBzY3JlZW5EZWx0YSwgdGlja0ludGVydmFsLCBmb3JjZVRpY2tJbnRlcnZhbCwgb3B0aW9ucy5heGlzRGl2aXNpb25GYWN0b3IsIG9wdGlvbnMubnVtYmVyTXVsdGlwbGllcnMsIG9wdGlvbnMuYWxsb3dEZWNpbWFscywgYnJlYWtzLmxlbmd0aCwgZ2Fwc1swXSAmJiBnYXBzWzBdLmdhcFNpemUuZGF5cywgb3B0aW9ucy5taW5UaWNrSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5za2lwVGlja0dlbmVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFqb3JUaWNrcyA9IGNhbGN1bGF0ZVRpY2tzKGRhdGEsIHRpY2tJbnRlcnZhbCwgb3B0aW9ucy5lbmRPblRpY2ssIGdhcHMsIGJyZWFrcywgYnVzaW5lc3NEZWx0YSwgc2NyZWVuRGVsdGEsIG9wdGlvbnMuYXhpc0RpdmlzaW9uRmFjdG9yLCBvcHRpb25zLmdlbmVyYXRlRXh0cmFUaWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtzID0gcHJvY2Vzc1NjYWxlQnJlYWtzKGJyZWFrcywgbWFqb3JUaWNrcywgdGlja0ludGVydmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFqb3JUaWNrcyA9IGZpbHRlclRpY2tzKG1ham9yVGlja3MsIGJyZWFrcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tzLmJyZWFrcyA9IGJyZWFrcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGlja3MudGlja3MgPSB0aWNrcy50aWNrcy5jb25jYXQobWFqb3JUaWNrcylcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGlja3MudGlja0ludGVydmFsID0gdGlja0ludGVydmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aWNrc1xyXG4gICAgICAgICAgICAgICAgfShyZXN1bHQsIGRhdGEsIGJ1c2luZXNzRGVsdGEsIHNjcmVlbkRlbHRhLCB0aWNrSW50ZXJ2YWwsIGZvcmNlVGlja0ludGVydmFsLCBjdXN0b21UaWNrcywgYnJlYWtzIHx8IFtdKTtcclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5za2lwVGlja0dlbmVyYXRpb24gJiYgYnVzaW5lc3NEZWx0YSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jdGlvbih0aWNrcywgZGF0YSwgYnVzaW5lc3NEZWx0YSwgc2NyZWVuRGVsdGEsIG1pbm9yVGlja0ludGVydmFsLCBtaW5vclRpY2tDb3VudCwgY3VzdG9tVGlja3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNhbGN1bGF0ZU1pbm9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpY2tzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1c3RvbVRpY2tzLm1pbm9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpY2tzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbm9yQnVzaW5lc3NEZWx0YSA9IGNvbnZlcnRUaWNrSW50ZXJ2YWwodGlja3MudGlja0ludGVydmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbm9yU2NyZWVuRGVsdGEgPSBzY3JlZW5EZWx0YSAqIG1pbm9yQnVzaW5lc3NEZWx0YSAvIGJ1c2luZXNzRGVsdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBicmVha3MgPSB0aWNrcy5icmVha3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWlub3JUaWNrSW50ZXJ2YWwgJiYgbWlub3JUaWNrQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbm9yVGlja0ludGVydmFsID0gZ2V0TWlub3JUaWNrSW50ZXJ2YWxCeUN1c3RvbVRpY2tzKFttaW5vckJ1c2luZXNzRGVsdGEgLyAobWlub3JUaWNrQ291bnQgKyAxKSwgbWlub3JCdXNpbmVzc0RlbHRhIC8gKG1pbm9yVGlja0NvdW50ICsgMSkgKiAyXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbm9yVGlja0NvdW50ID0gdm9pZCAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlub3JUaWNrSW50ZXJ2YWwgPSBjb3JyZWN0VXNlclRpY2tJbnRlcnZhbChtaW5vclRpY2tJbnRlcnZhbCwgbWlub3JCdXNpbmVzc0RlbHRhLCBtaW5vclNjcmVlbkRlbHRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlub3JUaWNrSW50ZXJ2YWwgPSBjYWxjdWxhdGVNaW5vclRpY2tJbnRlcnZhbChtaW5vckJ1c2luZXNzRGVsdGEsIG1pbm9yU2NyZWVuRGVsdGEsIG1pbm9yVGlja0ludGVydmFsLCBvcHRpb25zLm1pbm9yQXhpc0RpdmlzaW9uRmFjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGlja3MubWlub3JUaWNrcyA9IGZpbHRlclRpY2tzKHRpY2tzLm1pbm9yVGlja3MuY29uY2F0KGNhbGN1bGF0ZU1pbm9yVGlja3MoZGF0YS5taW4sIGRhdGEubWF4LCB0aWNrcy50aWNrcywgbWlub3JUaWNrSW50ZXJ2YWwsIHRpY2tzLnRpY2tJbnRlcnZhbCwgYnJlYWtzLCBtaW5vclRpY2tDb3VudCkpLCBicmVha3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrcy5taW5vclRpY2tJbnRlcnZhbCA9IG1pbm9yVGlja0ludGVydmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGlja3NcclxuICAgICAgICAgICAgICAgICAgICB9KHJlc3VsdCwgZGF0YSwgYnVzaW5lc3NEZWx0YSwgc2NyZWVuRGVsdGEsIG1pbm9yVGlja0ludGVydmFsLCBtaW5vclRpY2tDb3VudCwgY3VzdG9tVGlja3MpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRCYXNlVGljayhicmVha1ZhbHVlLCBfcmVmLCBpbnRlcnZhbCwgZ2V0VmFsdWUpIHtcclxuICAgIHZhciBbdGljaywgaW5zaWRlVGlja10gPSBfcmVmO1xyXG4gICAgaWYgKCFpc0RlZmluZWQodGljaykgfHwgbWF0aEFicyhnZXRWYWx1ZShicmVha1ZhbHVlKSAtIGdldFZhbHVlKHRpY2spKSAvIGludGVydmFsID4gLjI1KSB7XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZChpbnNpZGVUaWNrKSAmJiBtYXRoQWJzKGdldFZhbHVlKGluc2lkZVRpY2spIC0gZ2V0VmFsdWUodGljaykpIC8gaW50ZXJ2YWwgPCAyKSB7XHJcbiAgICAgICAgICAgIHRpY2sgPSBpbnNpZGVUaWNrXHJcbiAgICAgICAgfSBlbHNlIGlmICghaXNEZWZpbmVkKHRpY2spKSB7XHJcbiAgICAgICAgICAgIHRpY2sgPSBicmVha1ZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRpY2tcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U2NhbGVCcmVha3NQcm9jZXNzb3IoY29udmVydFRpY2tJbnRlcnZhbCwgZ2V0VmFsdWUsIGFkZENvcnJlY3Rpb24pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihicmVha3MsIHRpY2tzLCB0aWNrSW50ZXJ2YWwpIHtcclxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBjb252ZXJ0VGlja0ludGVydmFsKHRpY2tJbnRlcnZhbCk7XHJcbiAgICAgICAgdmFyIGNvcnJlY3Rpb24gPSAuNSAqIGludGVydmFsO1xyXG4gICAgICAgIHJldHVybiBicmVha3MucmVkdWNlKChyZXN1bHQsIGIpID0+IHtcclxuICAgICAgICAgICAgdmFyIGJyZWFrVGlja3MgPSB0aWNrcy5maWx0ZXIodGljayA9PiB0aWNrIDw9IGIuZnJvbSk7XHJcbiAgICAgICAgICAgIHZhciBmcm9tID0gYWRkQ29ycmVjdGlvbihnZXRCYXNlVGljayhiLmZyb20sIFtdLmNvbmNhdChicmVha1RpY2tzW2JyZWFrVGlja3MubGVuZ3RoIC0gMV0sIHRpY2tzW2JyZWFrVGlja3MubGVuZ3RoXSksIGludGVydmFsLCBnZXRWYWx1ZSksIGNvcnJlY3Rpb24pO1xyXG4gICAgICAgICAgICBicmVha1RpY2tzID0gdGlja3MuZmlsdGVyKHRpY2sgPT4gdGljayA+PSBiLnRvKTtcclxuICAgICAgICAgICAgdmFyIHRvID0gYWRkQ29ycmVjdGlvbihnZXRCYXNlVGljayhiLnRvLCBbXS5jb25jYXQoYnJlYWtUaWNrc1swXSwgdGlja3NbdGlja3MubGVuZ3RoIC0gYnJlYWtUaWNrcy5sZW5ndGggLSAxXSksIGludGVydmFsLCBnZXRWYWx1ZSksIC1jb3JyZWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKGdldFZhbHVlKHRvKSAtIGdldFZhbHVlKGZyb20pIDwgaW50ZXJ2YWwgJiYgIWIuZ2FwU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChiLmdhcFNpemUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KFtiXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChbe1xyXG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcclxuICAgICAgICAgICAgICAgIHRvOiB0byxcclxuICAgICAgICAgICAgICAgIGN1bXVsYXRpdmVXaWR0aDogYi5jdW11bGF0aXZlV2lkdGhcclxuICAgICAgICAgICAgfV0pXHJcbiAgICAgICAgfSwgW10pXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG51bWVyaWNHZW5lcmF0b3Iob3B0aW9ucykge1xyXG4gICAgdmFyIGZsb29yID0gY29ycmVjdFZhbHVlQnlJbnRlcnZhbChnZXRWYWx1ZSwgbWF0aEZsb29yLCBnZXRWYWx1ZSk7XHJcbiAgICB2YXIgY2VpbCA9IGNvcnJlY3RWYWx1ZUJ5SW50ZXJ2YWwoZ2V0VmFsdWUsIG1hdGhDZWlsLCBnZXRWYWx1ZSk7XHJcbiAgICB2YXIgY2FsY3VsYXRlVGlja0ludGVydmFsQnlDdXN0b21UaWNrcyA9IGdldFRpY2tJbnRlcnZhbEJ5Q3VzdG9tVGlja3MoZ2V0VmFsdWUsIGdldFZhbHVlKTtcclxuICAgIHJldHVybiBnZW5lcmF0b3Iob3B0aW9ucywgZ2V0QnVzaW5lc3NEZWx0YSwgY2FsY3VsYXRlVGlja0ludGVydmFsLCBjYWxjdWxhdGVNaW5vclRpY2tJbnRlcnZhbCwgY2FsY3VsYXRlVGlja0ludGVydmFsQnlDdXN0b21UaWNrcywgY2FsY3VsYXRlVGlja0ludGVydmFsQnlDdXN0b21UaWNrcywgZ2V0VmFsdWUsIGNhbGN1bGF0ZVRpY2tzKGFkZEludGVydmFsLCBjb3JyZWN0TWluVmFsdWVCeUVuZE9uVGljayhmbG9vciwgY2VpbCwgcmVzb2x2ZUVuZE9uVGljaywgb3B0aW9ucy5lbmRPblRpY2spLCBhZGp1c3RJbnRlcnZhbCwgcmVzb2x2ZUVuZE9uVGljayksIGNhbGN1bGF0ZU1pbm9yVGlja3MoZ2V0VmFsdWUsIGFkZEludGVydmFsLCBmbG9vciwgYWRkSW50ZXJ2YWwsIGdldFZhbHVlKSwgZ2V0U2NhbGVCcmVha3NQcm9jZXNzb3IoZ2V0VmFsdWUsIGdldFZhbHVlLCAodmFsdWUsIGNvcnJlY3Rpb24pID0+IHZhbHVlICsgY29ycmVjdGlvbikpXHJcbn1cclxudmFyIGNvcnJlY3RWYWx1ZUJ5SW50ZXJ2YWxMb2cgPSAocG9zdCwgZ2V0Um91bmQsIGdldFZhbHVlKSA9PiAodmFsdWUsIGludGVydmFsKSA9PiBzaWduKHZhbHVlKSAqIGFkanVzdChwb3N0KGdldFJvdW5kKHZhbHVlKShhZGp1c3QoZ2V0VmFsdWUodmFsdWUpIC8gaW50ZXJ2YWwpKSAqIGludGVydmFsKSk7XHJcblxyXG5mdW5jdGlvbiBsb2dhcml0aG1pY0dlbmVyYXRvcihvcHRpb25zKSB7XHJcbiAgICB2YXIgYmFzZSA9IG9wdGlvbnMubG9nQmFzZTtcclxuICAgIHZhciByYWlzZSA9IHJhaXNlVG8oYmFzZSwgb3B0aW9ucy5hbGxvd05lZ2F0aXZlcywgb3B0aW9ucy5saW5lYXJUaHJlc2hvbGQpO1xyXG4gICAgdmFyIGxvZyA9IGdldExvZ1ZhbHVlKGJhc2UsIG9wdGlvbnMuYWxsb3dOZWdhdGl2ZXMsIG9wdGlvbnMubGluZWFyVGhyZXNob2xkKTtcclxuICAgIHZhciBhYnNMb2cgPSBsb2dBYnNWYWx1ZShiYXNlKTtcclxuICAgIHZhciBhYnNSYWlzZSA9IG1hdGhSYWlzZVRvKGJhc2UpO1xyXG4gICAgdmFyIGZsb29yID0gY29ycmVjdFZhbHVlQnlJbnRlcnZhbExvZyhhYnNSYWlzZSwgdmFsdWUgPT4gdmFsdWUgPCAwID8gbWF0aENlaWwgOiBtYXRoRmxvb3IsIGFic0xvZyk7XHJcbiAgICB2YXIgY2VpbCA9IGNvcnJlY3RWYWx1ZUJ5SW50ZXJ2YWxMb2coYWJzUmFpc2UsIHZhbHVlID0+IHZhbHVlIDwgMCA/IG1hdGhGbG9vciA6IG1hdGhDZWlsLCBhYnNMb2cpO1xyXG4gICAgdmFyIGNlaWxOdW1iZXIgPSBjb3JyZWN0VmFsdWVCeUludGVydmFsKGdldFZhbHVlLCBtYXRoQ2VpbCwgZ2V0VmFsdWUpO1xyXG4gICAgcmV0dXJuIGdlbmVyYXRvcihvcHRpb25zLCBnZXRCdXNpbmVzc0RlbHRhTG9nKGJhc2UsIG9wdGlvbnMuYWxsb3dOZWdhdGl2ZXMsIG9wdGlvbnMubGluZWFyVGhyZXNob2xkKSwgZ2V0Q2FsY3VsYXRlVGlja0ludGVydmFsTG9nKG9wdGlvbnMuc2tpcENhbGN1bGF0aW9uTGltaXRzKSwgY2FsY3VsYXRlTWlub3JUaWNrSW50ZXJ2YWwsIGdldFRpY2tJbnRlcnZhbEJ5Q3VzdG9tVGlja3MobG9nLCBnZXRWYWx1ZSksIGdldFRpY2tJbnRlcnZhbEJ5Q3VzdG9tVGlja3MoZ2V0VmFsdWUsIGdldFZhbHVlKSwgZ2V0VmFsdWUsIGNhbGN1bGF0ZVRpY2tzKGFkZEludGVydmFsTG9nKGxvZywgcmFpc2UpLCBjb3JyZWN0TWluVmFsdWVCeUVuZE9uVGljayhmbG9vciwgY2VpbCwgcmVzb2x2ZUVuZE9uVGlja0xvZyhiYXNlKSwgb3B0aW9ucy5lbmRPblRpY2spLCBnZXRBZGp1c3RJbnRlcnZhbExvZyhvcHRpb25zLnNraXBDYWxjdWxhdGlvbkxpbWl0cyksIHJlc29sdmVFbmRPblRpY2tMb2coYmFzZSkpLCBjYWxjdWxhdGVNaW5vclRpY2tzKChfLCB0aWNrLCBwcmV2VGljaywgZmFjdG9yKSA9PiBNYXRoLm1heChNYXRoLmFicyh0aWNrKSwgTWF0aC5hYnMocHJldlRpY2spKSAvIGZhY3RvciwgYWRkSW50ZXJ2YWwsIGZsb29yLCBjZWlsTnVtYmVyLCBjZWlsKSwgZ2V0U2NhbGVCcmVha3NQcm9jZXNzb3IoZ2V0VmFsdWUsIGxvZywgKHZhbHVlLCBjb3JyZWN0aW9uKSA9PiByYWlzZShsb2codmFsdWUpICsgY29ycmVjdGlvbikpKVxyXG59XHJcblxyXG5mdW5jdGlvbiBkYXRlR2VuZXJhdG9yKG9wdGlvbnMpIHtcclxuICAgIGZ1bmN0aW9uIGZsb29yKHZhbHVlLCBpbnRlcnZhbCkge1xyXG4gICAgICAgIHZhciBmbG9vck51bWJlciA9IGNvcnJlY3RWYWx1ZUJ5SW50ZXJ2YWwoZ2V0VmFsdWUsIG1hdGhGbG9vciwgZ2V0VmFsdWUpO1xyXG4gICAgICAgIHZhciBpbnRlcnZhbE9iamVjdCA9IGlzU3RyaW5nKGludGVydmFsKSA/IGRhdGVVdGlscy5nZXREYXRlSW50ZXJ2YWxCeVN0cmluZyhpbnRlcnZhbC50b0xvd2VyQ2FzZSgpKSA6IGludGVydmFsO1xyXG4gICAgICAgIHZhciBkaXZpZGVyID0gZGF0ZVRvTWlsbGlzZWNvbmRzKGludGVydmFsKTtcclxuICAgICAgICBpZiAoaW50ZXJ2YWxPYmplY3QuZGF5cyAlIDcgPT09IDAgfHwgaW50ZXJ2YWwucXVhcnRlcnMpIHtcclxuICAgICAgICAgICAgaW50ZXJ2YWxPYmplY3QgPSBhZGp1c3RJbnRlcnZhbERhdGVUaW1lKGRpdmlkZXIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb3JyZWN0RGF0ZVdpdGhVbml0QmVnaW5uaW5nID0gdiA9PiBkYXRlVXRpbHMuY29ycmVjdERhdGVXaXRoVW5pdEJlZ2lubmluZyh2LCBpbnRlcnZhbE9iamVjdCwgbnVsbCwgb3B0aW9ucy5maXJzdERheU9mV2Vlayk7XHJcbiAgICAgICAgdmFyIGZsb29yQXRTdGFydERhdGUgPSB2ID0+IG5ldyBEYXRlKG1hdGhGbG9vcigodi5nZXRUaW1lKCkgLSB2LmdldFRpbWV6b25lT2Zmc2V0KCkgKiBNSU5VVEUpIC8gZGl2aWRlcikgKiBkaXZpZGVyICsgdi5nZXRUaW1lem9uZU9mZnNldCgpICogTUlOVVRFKTtcclxuICAgICAgICB2YWx1ZSA9IGNvcnJlY3REYXRlV2l0aFVuaXRCZWdpbm5pbmcodmFsdWUpO1xyXG4gICAgICAgIGlmIChcInllYXJzXCIgaW4gaW50ZXJ2YWxPYmplY3QpIHtcclxuICAgICAgICAgICAgdmFsdWUuc2V0RnVsbFllYXIoZmxvb3JOdW1iZXIodmFsdWUuZ2V0RnVsbFllYXIoKSwgaW50ZXJ2YWxPYmplY3QueWVhcnMpKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoXCJxdWFydGVyc1wiIGluIGludGVydmFsT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gY29ycmVjdERhdGVXaXRoVW5pdEJlZ2lubmluZyhmbG9vckF0U3RhcnREYXRlKHZhbHVlKSlcclxuICAgICAgICB9IGVsc2UgaWYgKFwibW9udGhzXCIgaW4gaW50ZXJ2YWxPYmplY3QpIHtcclxuICAgICAgICAgICAgdmFsdWUuc2V0TW9udGgoZmxvb3JOdW1iZXIodmFsdWUuZ2V0TW9udGgoKSwgaW50ZXJ2YWxPYmplY3QubW9udGhzKSlcclxuICAgICAgICB9IGVsc2UgaWYgKFwid2Vla3NcIiBpbiBpbnRlcnZhbE9iamVjdCB8fCBcImRheXNcIiBpbiBpbnRlcnZhbE9iamVjdCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGNvcnJlY3REYXRlV2l0aFVuaXRCZWdpbm5pbmcoZmxvb3JBdFN0YXJ0RGF0ZSh2YWx1ZSkpXHJcbiAgICAgICAgfSBlbHNlIGlmIChcImhvdXJzXCIgaW4gaW50ZXJ2YWxPYmplY3QpIHtcclxuICAgICAgICAgICAgdmFsdWUuc2V0SG91cnMoZmxvb3JOdW1iZXIodmFsdWUuZ2V0SG91cnMoKSwgaW50ZXJ2YWxPYmplY3QuaG91cnMpKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoXCJtaW51dGVzXCIgaW4gaW50ZXJ2YWxPYmplY3QpIHtcclxuICAgICAgICAgICAgdmFsdWUuc2V0TWludXRlcyhmbG9vck51bWJlcih2YWx1ZS5nZXRNaW51dGVzKCksIGludGVydmFsT2JqZWN0Lm1pbnV0ZXMpKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoXCJzZWNvbmRzXCIgaW4gaW50ZXJ2YWxPYmplY3QpIHtcclxuICAgICAgICAgICAgdmFsdWUuc2V0U2Vjb25kcyhmbG9vck51bWJlcih2YWx1ZS5nZXRTZWNvbmRzKCksIGludGVydmFsT2JqZWN0LnNlY29uZHMpKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoXCJtaWxsaXNlY29uZHNcIiBpbiBpbnRlcnZhbE9iamVjdCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGZsb29yQXRTdGFydERhdGUodmFsdWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgfVxyXG4gICAgdmFyIGNhbGN1bGF0ZVRpY2tJbnRlcnZhbEJ5Q3VzdG9tVGlja3MgPSBnZXRUaWNrSW50ZXJ2YWxCeUN1c3RvbVRpY2tzKGdldFZhbHVlLCBkYXRlVXRpbHMuY29udmVydE1pbGxpc2Vjb25kc1RvRGF0ZVVuaXRzKTtcclxuICAgIHJldHVybiBnZW5lcmF0b3Iob3B0aW9ucywgZ2V0QnVzaW5lc3NEZWx0YSwgY2FsY3VsYXRlVGlja0ludGVydmFsRGF0ZVRpbWUsIGNhbGN1bGF0ZU1pbm9yVGlja0ludGVydmFsRGF0ZVRpbWUsIGNhbGN1bGF0ZVRpY2tJbnRlcnZhbEJ5Q3VzdG9tVGlja3MsIGNhbGN1bGF0ZVRpY2tJbnRlcnZhbEJ5Q3VzdG9tVGlja3MsIGRhdGVUb01pbGxpc2Vjb25kcywgY2FsY3VsYXRlVGlja3MoYWRkSW50ZXJ2YWxEYXRlLCBjb3JyZWN0TWluVmFsdWVCeUVuZE9uVGljayhmbG9vciwgKGZ1bmN0aW9uKHZhbHVlLCBpbnRlcnZhbCkge1xyXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGZsb29yKHZhbHVlLCBpbnRlcnZhbCk7XHJcbiAgICAgICAgd2hpbGUgKHZhbHVlIC0gbmV3VmFsdWUgPiAwKSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gYWRkSW50ZXJ2YWxEYXRlKG5ld1ZhbHVlLCBpbnRlcnZhbClcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlXHJcbiAgICB9KSwgcmVzb2x2ZUVuZE9uVGlja0RhdGUsIG9wdGlvbnMuZW5kT25UaWNrKSwgYWRqdXN0SW50ZXJ2YWxEYXRlVGltZSwgcmVzb2x2ZUVuZE9uVGlja0RhdGUpLCBjYWxjdWxhdGVNaW5vclRpY2tzKGdldFZhbHVlLCBhZGRJbnRlcnZhbERhdGUsIGZsb29yLCBhZGRJbnRlcnZhbERhdGUsIGdldFZhbHVlKSwgZ2V0U2NhbGVCcmVha3NQcm9jZXNzb3IoZGF0ZVRvTWlsbGlzZWNvbmRzLCBnZXRWYWx1ZSwgKHZhbHVlLCBjb3JyZWN0aW9uKSA9PiBuZXcgRGF0ZSh2YWx1ZS5nZXRUaW1lKCkgKyBjb3JyZWN0aW9uKSkpXHJcbn1cclxuZXhwb3J0IHZhciB0aWNrR2VuZXJhdG9yID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIGlmIChvcHRpb25zLnJhbmdlSXNFbXB0eSkge1xyXG4gICAgICAgIHJlc3VsdCA9IGR1bW15R2VuZXJhdG9yKG9wdGlvbnMpXHJcbiAgICB9IGVsc2UgaWYgKFwiZGlzY3JldGVcIiA9PT0gb3B0aW9ucy5heGlzVHlwZSkge1xyXG4gICAgICAgIHJlc3VsdCA9IGRpc2NyZXRlR2VuZXJhdG9yKG9wdGlvbnMpXHJcbiAgICB9IGVsc2UgaWYgKFwibG9nYXJpdGhtaWNcIiA9PT0gb3B0aW9ucy5heGlzVHlwZSkge1xyXG4gICAgICAgIHJlc3VsdCA9IGxvZ2FyaXRobWljR2VuZXJhdG9yKG9wdGlvbnMpXHJcbiAgICB9IGVsc2UgaWYgKFwiZGF0ZXRpbWVcIiA9PT0gb3B0aW9ucy5kYXRhVHlwZSkge1xyXG4gICAgICAgIHJlc3VsdCA9IGRhdGVHZW5lcmF0b3Iob3B0aW9ucylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gbnVtZXJpY0dlbmVyYXRvcihvcHRpb25zKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/axes/tick_generator.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/axes/xy_axes.js":
/*!*********************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/axes/xy_axes.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _translators_range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../translators/range */ \"./node_modules/devextreme/esm/viz/translators/range.js\");\n/* harmony import */ var _format_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../format_helper */ \"./node_modules/devextreme/esm/format_helper.js\");\n/* harmony import */ var _core_utils_date__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/utils/date */ \"./node_modules/devextreme/esm/core/utils/date.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _datetime_breaks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./datetime_breaks */ \"./node_modules/devextreme/esm/viz/axes/datetime_breaks.js\");\n/* harmony import */ var _core_utils_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/utils/common */ \"./node_modules/devextreme/esm/core/utils/common.js\");\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _axes_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./axes_constants */ \"./node_modules/devextreme/esm/viz/axes/axes_constants.js\");\n/**\r\n * DevExtreme (esm/viz/axes/xy_axes.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar getNextDateUnit = _core_utils_date__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getNextDateUnit;\r\nvar correctDateWithUnitBeginning = _core_utils_date__WEBPACK_IMPORTED_MODULE_2__[\"default\"].correctDateWithUnitBeginning;\r\nvar _math = Math;\r\nvar _max = _math.max;\r\nvar TOP = _axes_constants__WEBPACK_IMPORTED_MODULE_8__[\"default\"].top;\r\nvar BOTTOM = _axes_constants__WEBPACK_IMPORTED_MODULE_8__[\"default\"].bottom;\r\nvar LEFT = _axes_constants__WEBPACK_IMPORTED_MODULE_8__[\"default\"].left;\r\nvar RIGHT = _axes_constants__WEBPACK_IMPORTED_MODULE_8__[\"default\"].right;\r\nvar CENTER = _axes_constants__WEBPACK_IMPORTED_MODULE_8__[\"default\"].center;\r\nvar SCALE_BREAK_OFFSET = 3;\r\nvar RANGE_RATIO = .3;\r\nvar WAVED_LINE_CENTER = 2;\r\nvar WAVED_LINE_TOP = 0;\r\nvar WAVED_LINE_BOTTOM = 4;\r\nvar WAVED_LINE_LENGTH = 24;\r\nvar TICKS_CORRECTIONS = {\r\n    left: -1,\r\n    top: -1,\r\n    right: 0,\r\n    bottom: 0,\r\n    center: -.5\r\n};\r\n\r\nfunction prepareDatesDifferences(datesDifferences, tickInterval) {\r\n    var dateUnitInterval;\r\n    var i;\r\n    if (\"week\" === tickInterval) {\r\n        tickInterval = \"day\"\r\n    }\r\n    if (\"quarter\" === tickInterval) {\r\n        tickInterval = \"month\"\r\n    }\r\n    if (datesDifferences[tickInterval]) {\r\n        for (i = 0; i < _core_utils_date__WEBPACK_IMPORTED_MODULE_2__[\"default\"].dateUnitIntervals.length; i++) {\r\n            dateUnitInterval = _core_utils_date__WEBPACK_IMPORTED_MODULE_2__[\"default\"].dateUnitIntervals[i];\r\n            if (datesDifferences[dateUnitInterval]) {\r\n                datesDifferences[dateUnitInterval] = false;\r\n                datesDifferences.count--\r\n            }\r\n            if (dateUnitInterval === tickInterval) {\r\n                break\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction sortingBreaks(breaks) {\r\n    return breaks.sort((function(a, b) {\r\n        return a.from - b.from\r\n    }))\r\n}\r\n\r\nfunction getMarkerDates(min, max, markerInterval) {\r\n    var origMin = min;\r\n    var dates;\r\n    min = correctDateWithUnitBeginning(min, markerInterval);\r\n    max = correctDateWithUnitBeginning(max, markerInterval);\r\n    dates = _core_utils_date__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getSequenceByInterval(min, max, markerInterval);\r\n    if (dates.length && origMin > dates[0]) {\r\n        dates = dates.slice(1)\r\n    }\r\n    return dates\r\n}\r\n\r\nfunction getStripHorizontalAlignmentPosition(alignment) {\r\n    var position = \"start\";\r\n    if (\"center\" === alignment) {\r\n        position = \"center\"\r\n    }\r\n    if (\"right\" === alignment) {\r\n        position = \"end\"\r\n    }\r\n    return position\r\n}\r\n\r\nfunction getStripVerticalAlignmentPosition(alignment) {\r\n    var position = \"start\";\r\n    if (\"center\" === alignment) {\r\n        position = \"center\"\r\n    }\r\n    if (\"bottom\" === alignment) {\r\n        position = \"end\"\r\n    }\r\n    return position\r\n}\r\n\r\nfunction getMarkerInterval(tickInterval) {\r\n    var markerInterval = getNextDateUnit(tickInterval);\r\n    if (\"quarter\" === markerInterval) {\r\n        markerInterval = getNextDateUnit(markerInterval)\r\n    }\r\n    return markerInterval\r\n}\r\n\r\nfunction getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {\r\n    var format = markerInterval;\r\n    var datesDifferences = prevDate && _core_utils_date__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getDatesDifferences(prevDate, curDate);\r\n    if (prevDate && \"year\" !== tickInterval) {\r\n        prepareDatesDifferences(datesDifferences, tickInterval);\r\n        format = _format_helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getDateFormatByDifferences(datesDifferences)\r\n    }\r\n    return format\r\n}\r\n\r\nfunction getMaxSide(act, boxes) {\r\n    return boxes.reduce((function(prevValue, box) {\r\n        return _max(prevValue, act(box))\r\n    }), 0)\r\n}\r\n\r\nfunction getDistanceByAngle(bBox, rotationAngle) {\r\n    rotationAngle = _math.abs(rotationAngle);\r\n    rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;\r\n    var a = rotationAngle * (_math.PI / 180);\r\n    if (a >= _math.atan(bBox.height / bBox.width)) {\r\n        return bBox.height / _math.abs(_math.sin(a))\r\n    } else {\r\n        return bBox.width\r\n    }\r\n}\r\n\r\nfunction getMaxConstantLinePadding(constantLines) {\r\n    return constantLines.reduce((function(padding, options) {\r\n        return _max(padding, options.paddingTopBottom)\r\n    }), 0)\r\n}\r\n\r\nfunction getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {\r\n    return constantLines.some((function(options) {\r\n        return options.label.verticalAlignment === alignment\r\n    })) && labelHeight || 0\r\n}\r\n\r\nfunction getLeftMargin(bBox) {\r\n    return _math.abs(bBox.x) || 0\r\n}\r\n\r\nfunction getRightMargin(bBox) {\r\n    return _math.abs(bBox.width - _math.abs(bBox.x)) || 0\r\n}\r\n\r\nfunction generateRangesOnPoints(points, edgePoints, getRange) {\r\n    var i;\r\n    var length;\r\n    var maxRange = null;\r\n    var ranges = [];\r\n    var curValue;\r\n    var prevValue;\r\n    var curRange;\r\n    for (i = 1, length = points.length; i < length; i++) {\r\n        curValue = points[i];\r\n        prevValue = points[i - 1];\r\n        curRange = getRange(curValue, prevValue);\r\n        if (edgePoints.indexOf(curValue) >= 0) {\r\n            if (!maxRange || curRange > maxRange.length) {\r\n                maxRange = {\r\n                    start: curValue,\r\n                    end: prevValue,\r\n                    length: curRange\r\n                }\r\n            }\r\n        } else {\r\n            if (maxRange && curRange < maxRange.length) {\r\n                ranges.push(maxRange)\r\n            } else {\r\n                ranges.push({\r\n                    start: curValue,\r\n                    end: prevValue,\r\n                    length: curRange\r\n                })\r\n            }\r\n            maxRange = null\r\n        }\r\n    }\r\n    if (maxRange) {\r\n        ranges.push(maxRange)\r\n    }\r\n    return ranges\r\n}\r\n\r\nfunction generateAutoBreaks(_ref, series, _ref2) {\r\n    var {\r\n        logarithmBase: logarithmBase,\r\n        type: type,\r\n        maxAutoBreakCount: maxAutoBreakCount\r\n    } = _ref;\r\n    var {\r\n        minVisible: minVisible,\r\n        maxVisible: maxVisible\r\n    } = _ref2;\r\n    var breaks = [];\r\n    var getRange = \"logarithmic\" === type ? (min, max) => Object(_core_utils__WEBPACK_IMPORTED_MODULE_6__[\"getLog\"])(max / min, logarithmBase) : (min, max) => max - min;\r\n    var visibleRange = getRange(minVisible, maxVisible);\r\n    var points = series.reduce((result, s) => {\r\n        var points = s.getPointsInViewPort();\r\n        result[0] = result[0].concat(points[0]);\r\n        result[1] = result[1].concat(points[1]);\r\n        return result\r\n    }, [\r\n        [],\r\n        []\r\n    ]);\r\n    var sortedAllPoints = points[0].concat(points[1]).sort((a, b) => b - a);\r\n    var edgePoints = points[1].filter(p => points[0].indexOf(p) < 0);\r\n    var minDiff = RANGE_RATIO * visibleRange;\r\n    var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort((a, b) => b.length - a.length);\r\n    var epsilon = _math.min.apply(null, ranges.map(r => r.length)) / 1e3;\r\n    var _maxAutoBreakCount = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;\r\n    for (var i = 0; i < _maxAutoBreakCount; i++) {\r\n        if (ranges[i].length >= minDiff) {\r\n            if (visibleRange <= ranges[i].length) {\r\n                break\r\n            }\r\n            visibleRange -= ranges[i].length;\r\n            if (visibleRange > epsilon || visibleRange < -epsilon) {\r\n                breaks.push({\r\n                    from: ranges[i].start,\r\n                    to: ranges[i].end\r\n                });\r\n                minDiff = RANGE_RATIO * visibleRange\r\n            }\r\n        } else {\r\n            break\r\n        }\r\n    }\r\n    sortingBreaks(breaks);\r\n    return breaks\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    linear: {\r\n        _getStep: function(boxes, rotationAngle) {\r\n            var spacing = this._options.label.minSpacing;\r\n            var func = this._isHorizontal ? function(box) {\r\n                return box.width + spacing\r\n            } : function(box) {\r\n                return box.height\r\n            };\r\n            var maxLabelLength = getMaxSide(func, boxes);\r\n            if (rotationAngle) {\r\n                maxLabelLength = getDistanceByAngle({\r\n                    width: maxLabelLength,\r\n                    height: this._getMaxLabelHeight(boxes, 0)\r\n                }, rotationAngle)\r\n            }\r\n            return _axes_constants__WEBPACK_IMPORTED_MODULE_8__[\"default\"].getTicksCountInRange(this._majorTicks, this._isHorizontal ? \"x\" : \"y\", maxLabelLength)\r\n        },\r\n        _getMaxLabelHeight: function(boxes, spacing) {\r\n            return getMaxSide((function(box) {\r\n                return box.height\r\n            }), boxes) + spacing\r\n        },\r\n        _validateOverlappingMode: function(mode, displayMode) {\r\n            if (this._isHorizontal && (\"rotate\" === displayMode || \"stagger\" === displayMode) || !this._isHorizontal) {\r\n                return _axes_constants__WEBPACK_IMPORTED_MODULE_8__[\"default\"].validateOverlappingMode(mode)\r\n            }\r\n            return mode\r\n        },\r\n        _validateDisplayMode: function(mode) {\r\n            return this._isHorizontal ? mode : \"standard\"\r\n        },\r\n        getMarkerTrackers: function() {\r\n            return this._markerTrackers\r\n        },\r\n        _getSharpParam: function(opposite) {\r\n            return this._isHorizontal ^ opposite ? \"h\" : \"v\"\r\n        },\r\n        _createAxisElement: function() {\r\n            return this._renderer.path([], \"line\")\r\n        },\r\n        _updateAxisElementPosition: function() {\r\n            var axisCoord = this._axisPosition;\r\n            var canvas = this._getCanvasStartEnd();\r\n            this._axisElement.attr({\r\n                points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]\r\n            })\r\n        },\r\n        _getTranslatedCoord: function(value, offset) {\r\n            return this._translator.translate(value, offset)\r\n        },\r\n        _initAxisPositions() {\r\n            if (this.customPositionIsAvailable()) {\r\n                this._customBoundaryPosition = this.getCustomBoundaryPosition()\r\n            }\r\n            if (!this.customPositionIsAvailable() || this.customPositionIsBoundary()) {\r\n                this._axisPosition = this.getPredefinedPosition(this.getResolvedBoundaryPosition())\r\n            } else {\r\n                this._axisPosition = this.getCustomPosition()\r\n            }\r\n        },\r\n        _getTickMarkPoints(coords, length, tickOptions) {\r\n            var isHorizontal = this._isHorizontal;\r\n            var tickOrientation = this._options.tickOrientation;\r\n            var labelPosition = this._options.label.position;\r\n            var tickStartCoord;\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(tickOrientation)) {\r\n                tickStartCoord = TICKS_CORRECTIONS[tickOrientation] * length\r\n            } else {\r\n                var shift = tickOptions.shift || 0;\r\n                if (!isHorizontal && labelPosition === LEFT || isHorizontal && labelPosition !== BOTTOM) {\r\n                    shift = -shift\r\n                }\r\n                tickStartCoord = shift + this.getTickStartPositionShift(length)\r\n            }\r\n            return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)]\r\n        },\r\n        getTickStartPositionShift(length) {\r\n            var width = this._options.width;\r\n            var position = this.getResolvedBoundaryPosition();\r\n            return length % 2 === 1 ? width % 2 === 0 && (position === LEFT || position === TOP) || width % 2 === 1 && (position === RIGHT || position === BOTTOM) && !this.hasNonBoundaryPosition() ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (width % 2 === 0 ? 0 : position === BOTTOM || position === RIGHT ? -1 : 1)\r\n        },\r\n        _getTitleCoords: function() {\r\n            var horizontal = this._isHorizontal;\r\n            var x = this._axisPosition;\r\n            var y = this._axisPosition;\r\n            var align = this._options.title.alignment;\r\n            var canvas = this._getCanvasStartEnd();\r\n            var fromStartToEnd = horizontal || this._options.position === LEFT;\r\n            var canvasStart = fromStartToEnd ? canvas.start : canvas.end;\r\n            var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;\r\n            var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;\r\n            if (horizontal) {\r\n                x = coord\r\n            } else {\r\n                y = coord\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _drawTitleText: function(group, coords) {\r\n            var options = this._options;\r\n            var titleOptions = options.title;\r\n            var attrs = {\r\n                opacity: titleOptions.opacity,\r\n                align: titleOptions.alignment,\r\n                class: titleOptions.cssClass\r\n            };\r\n            if (!titleOptions.text || !group) {\r\n                return\r\n            }\r\n            coords = coords || this._getTitleCoords();\r\n            if (!this._isHorizontal) {\r\n                attrs.rotate = options.position === LEFT ? 270 : 90\r\n            }\r\n            var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css(Object(_core_utils__WEBPACK_IMPORTED_MODULE_6__[\"patchFontOptions\"])(titleOptions.font)).attr(attrs).append(group);\r\n            this._checkTitleOverflow(text);\r\n            return text\r\n        },\r\n        _updateTitleCoords: function() {\r\n            this._title && this._title.element.attr(this._getTitleCoords())\r\n        },\r\n        _drawTitle: function() {\r\n            var title = this._drawTitleText(this._axisTitleGroup);\r\n            if (title) {\r\n                this._title = {\r\n                    element: title\r\n                }\r\n            }\r\n        },\r\n        _measureTitle: function() {\r\n            if (this._title) {\r\n                if (this._title.bBox && !this._title.originalSize) {\r\n                    this._title.originalSize = this._title.bBox\r\n                }\r\n                this._title.bBox = this._title.element.getBBox()\r\n            }\r\n        },\r\n        _drawDateMarker: function(date, options, range) {\r\n            var markerOptions = this._options.marker;\r\n            var invert = this._translator.getBusinessRange().invert;\r\n            var textIndent = markerOptions.width + markerOptions.textLeftIndent;\r\n            var pathElement;\r\n            if (null === options.x) {\r\n                return\r\n            }\r\n            if (!options.withoutStick) {\r\n                pathElement = this._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], \"line\").attr({\r\n                    \"stroke-width\": markerOptions.width,\r\n                    stroke: markerOptions.color,\r\n                    \"stroke-opacity\": markerOptions.opacity,\r\n                    sharp: \"h\"\r\n                }).append(this._axisElementsGroup)\r\n            }\r\n            var text = String(this.formatLabel(date, options.labelOptions, range));\r\n            return {\r\n                date: date,\r\n                x: options.x,\r\n                y: options.y,\r\n                cropped: options.withoutStick,\r\n                label: this._renderer.text(text, options.x, options.y).css(Object(_core_utils__WEBPACK_IMPORTED_MODULE_6__[\"patchFontOptions\"])(markerOptions.label.font)).append(this._axisElementsGroup),\r\n                line: pathElement,\r\n                getContentContainer() {\r\n                    return this.label\r\n                },\r\n                getEnd: function() {\r\n                    return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width)\r\n                },\r\n                setTitle: function() {\r\n                    this.title = text\r\n                },\r\n                hideLabel: function() {\r\n                    this.label.dispose();\r\n                    this.label = null;\r\n                    this.title = text\r\n                },\r\n                hide: function() {\r\n                    if (pathElement) {\r\n                        pathElement.dispose();\r\n                        pathElement = null\r\n                    }\r\n                    this.label.dispose();\r\n                    this.label = null;\r\n                    this.hidden = true\r\n                }\r\n            }\r\n        },\r\n        _drawDateMarkers: function() {\r\n            var that = this;\r\n            var options = that._options;\r\n            var translator = that._translator;\r\n            var viewport = that._getViewportRange();\r\n            var minBound = viewport.minVisible;\r\n            var dateMarkers = [];\r\n            var dateMarker;\r\n\r\n            function draw(markerDate, format, withoutStick) {\r\n                return that._drawDateMarker(markerDate, {\r\n                    x: translator.translate(markerDate),\r\n                    y: markersAreaTop,\r\n                    labelOptions: that._getLabelFormatOptions(format),\r\n                    withoutStick: withoutStick\r\n                }, viewport)\r\n            }\r\n            if (viewport.isEmpty() || !options.marker.visible || \"datetime\" !== options.argumentType || \"discrete\" === options.type || that._majorTicks.length <= 1) {\r\n                return []\r\n            }\r\n            var markersAreaTop = that._axisPosition + options.marker.topIndent;\r\n            var tickInterval = _core_utils_date__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getDateUnitInterval(this._tickInterval);\r\n            var markerInterval = getMarkerInterval(tickInterval);\r\n            var markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);\r\n            if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {\r\n                dateMarkers = markerDates.reduce((function(markers, curDate, i, dates) {\r\n                    var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));\r\n                    marker && markers.push(marker);\r\n                    return markers\r\n                }), []);\r\n                if (minBound < markerDates[0]) {\r\n                    dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);\r\n                    dateMarker && dateMarkers.unshift(dateMarker)\r\n                }\r\n            }\r\n            return dateMarkers\r\n        },\r\n        _adjustDateMarkers: function(offset) {\r\n            offset = offset || 0;\r\n            var that = this;\r\n            var markerOptions = this._options.marker;\r\n            var textIndent = markerOptions.width + markerOptions.textLeftIndent;\r\n            var invert = this._translator.getBusinessRange().invert;\r\n            var canvas = that._getCanvasStartEnd();\r\n            var dateMarkers = this._dateMarkers;\r\n            if (!dateMarkers.length) {\r\n                return offset\r\n            }\r\n            if (dateMarkers[0].cropped) {\r\n                if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {\r\n                    dateMarkers[0].hideLabel()\r\n                }\r\n            }\r\n            var prevDateMarker;\r\n            dateMarkers.forEach((function(marker, i, markers) {\r\n                if (marker.cropped) {\r\n                    return\r\n                }\r\n                if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {\r\n                    marker.hideLabel()\r\n                } else if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {\r\n                    prevDateMarker = marker\r\n                } else {\r\n                    marker.hide()\r\n                }\r\n            }));\r\n            this._dateMarkers.forEach((function(marker) {\r\n                if (marker.label) {\r\n                    var labelBBox = marker.labelBBox;\r\n                    var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;\r\n                    marker.label.attr({\r\n                        translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,\r\n                        translateY: dy + offset\r\n                    })\r\n                }\r\n                if (marker.line) {\r\n                    marker.line.attr({\r\n                        translateY: offset\r\n                    })\r\n                }\r\n            }));\r\n            that._initializeMarkersTrackers(offset);\r\n            return offset + markerOptions.topIndent + markerOptions.separatorHeight\r\n        },\r\n        _checkMarkersPosition: function(invert, dateMarker, prevDateMarker) {\r\n            if (void 0 === prevDateMarker) {\r\n                return true\r\n            }\r\n            return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd()\r\n        },\r\n        _initializeMarkersTrackers: function(offset) {\r\n            var separatorHeight = this._options.marker.separatorHeight;\r\n            var renderer = this._renderer;\r\n            var businessRange = this._translator.getBusinessRange();\r\n            var canvas = this._getCanvasStartEnd();\r\n            var group = this._axisElementsGroup;\r\n            this._markerTrackers = this._dateMarkers.filter((function(marker) {\r\n                return !marker.hidden\r\n            })).map((function(marker, i, markers) {\r\n                var nextMarker = markers[i + 1] || {\r\n                    x: canvas.end,\r\n                    date: businessRange.max\r\n                };\r\n                var x = marker.x;\r\n                var y = marker.y + offset;\r\n                var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], \"area\").attr({\r\n                    \"stroke-width\": 1,\r\n                    stroke: \"grey\",\r\n                    fill: \"grey\",\r\n                    opacity: 1e-4\r\n                }).append(group);\r\n                markerTracker.data(\"range\", {\r\n                    startValue: marker.date,\r\n                    endValue: nextMarker.date\r\n                });\r\n                if (marker.title) {\r\n                    markerTracker.setTitle(marker.title)\r\n                }\r\n                return markerTracker\r\n            }))\r\n        },\r\n        _getLabelFormatOptions: function(formatString) {\r\n            var markerLabelOptions = this._markerLabelOptions;\r\n            if (!markerLabelOptions) {\r\n                this._markerLabelOptions = markerLabelOptions = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_3__[\"extend\"])(true, {}, this._options.marker.label)\r\n            }\r\n            if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(this._options.marker.label.format)) {\r\n                markerLabelOptions.format = formatString\r\n            }\r\n            return markerLabelOptions\r\n        },\r\n        _adjustConstantLineLabels: function(constantLines) {\r\n            var that = this;\r\n            var axisPosition = that._options.position;\r\n            var canvas = that.getCanvas();\r\n            var canvasLeft = canvas.left;\r\n            var canvasRight = canvas.width - canvas.right;\r\n            var canvasTop = canvas.top;\r\n            var canvasBottom = canvas.height - canvas.bottom;\r\n            var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;\r\n            var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;\r\n            var maxLabel = 0;\r\n            constantLines.forEach((function(item) {\r\n                var isHorizontal = that._isHorizontal;\r\n                var linesOptions = item.options;\r\n                var paddingTopBottom = linesOptions.paddingTopBottom;\r\n                var paddingLeftRight = linesOptions.paddingLeftRight;\r\n                var labelOptions = linesOptions.label;\r\n                var labelVerticalAlignment = labelOptions.verticalAlignment;\r\n                var labelHorizontalAlignment = labelOptions.horizontalAlignment;\r\n                var labelIsInside = \"inside\" === labelOptions.position;\r\n                var label = item.label;\r\n                var box = item.labelBBox;\r\n                var translateX;\r\n                var translateY;\r\n                if (null === label || box.isEmpty) {\r\n                    return\r\n                }\r\n                if (isHorizontal) {\r\n                    if (labelIsInside) {\r\n                        if (labelHorizontalAlignment === LEFT) {\r\n                            translateX = item.coord - paddingLeftRight - box.x - box.width\r\n                        } else {\r\n                            translateX = item.coord + paddingLeftRight - box.x\r\n                        }\r\n                        switch (labelVerticalAlignment) {\r\n                            case CENTER:\r\n                                translateY = verticalCenter - box.y - box.height / 2;\r\n                                break;\r\n                            case BOTTOM:\r\n                                translateY = canvasBottom - paddingTopBottom - box.y - box.height;\r\n                                break;\r\n                            default:\r\n                                translateY = canvasTop + paddingTopBottom - box.y\r\n                        }\r\n                    } else {\r\n                        if (axisPosition === labelVerticalAlignment) {\r\n                            maxLabel = _max(maxLabel, box.height + paddingTopBottom)\r\n                        }\r\n                        translateX = item.coord - box.x - box.width / 2;\r\n                        if (labelVerticalAlignment === BOTTOM) {\r\n                            translateY = canvasBottom + paddingTopBottom - box.y\r\n                        } else {\r\n                            translateY = canvasTop - paddingTopBottom - box.y - box.height\r\n                        }\r\n                    }\r\n                } else if (labelIsInside) {\r\n                    if (labelVerticalAlignment === BOTTOM) {\r\n                        translateY = item.coord + paddingTopBottom - box.y\r\n                    } else {\r\n                        translateY = item.coord - paddingTopBottom - box.y - box.height\r\n                    }\r\n                    switch (labelHorizontalAlignment) {\r\n                        case CENTER:\r\n                            translateX = horizontalCenter - box.x - box.width / 2;\r\n                            break;\r\n                        case RIGHT:\r\n                            translateX = canvasRight - paddingLeftRight - box.x - box.width;\r\n                            break;\r\n                        default:\r\n                            translateX = canvasLeft + paddingLeftRight - box.x\r\n                    }\r\n                } else {\r\n                    if (axisPosition === labelHorizontalAlignment) {\r\n                        maxLabel = _max(maxLabel, box.width + paddingLeftRight)\r\n                    }\r\n                    translateY = item.coord - box.y - box.height / 2;\r\n                    if (labelHorizontalAlignment === RIGHT) {\r\n                        translateX = canvasRight + paddingLeftRight - box.x\r\n                    } else {\r\n                        translateX = canvasLeft - paddingLeftRight - box.x - box.width\r\n                    }\r\n                }\r\n                label.attr({\r\n                    translateX: translateX,\r\n                    translateY: translateY\r\n                })\r\n            }));\r\n            return maxLabel\r\n        },\r\n        _drawConstantLinesForEstimating: function(constantLines) {\r\n            var that = this;\r\n            var renderer = this._renderer;\r\n            var group = renderer.g();\r\n            constantLines.forEach((function(options) {\r\n                that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({\r\n                    align: \"center\"\r\n                })\r\n            }));\r\n            return group.append(renderer.root)\r\n        },\r\n        _estimateLabelHeight: function(bBox, labelOptions) {\r\n            var height = bBox.height;\r\n            var drawingType = labelOptions.drawingType;\r\n            if (\"stagger\" === this._validateDisplayMode(drawingType) || \"stagger\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\r\n                height = 2 * height + labelOptions.staggeringSpacing\r\n            }\r\n            if (\"rotate\" === this._validateDisplayMode(drawingType) || \"rotate\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\r\n                var sinCos = Object(_core_utils__WEBPACK_IMPORTED_MODULE_6__[\"getCosAndSin\"])(labelOptions.rotationAngle);\r\n                height = height * sinCos.cos + bBox.width * sinCos.sin\r\n            }\r\n            return height && (height + labelOptions.indentFromAxis || 0) || 0\r\n        },\r\n        estimateMargins: function(canvas) {\r\n            this.updateCanvas(canvas);\r\n            var range = this._getViewportRange();\r\n            var ticksData = this._createTicksAndLabelFormat(range);\r\n            var ticks = ticksData.ticks;\r\n            var tickInterval = ticksData.tickInterval;\r\n            var options = this._options;\r\n            var constantLineOptions = this._outsideConstantLines.filter(l => l.labelOptions.visible).map(l => l.options);\r\n            var rootElement = this._renderer.root;\r\n            var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;\r\n            var labelValue = labelIsVisible && this.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);\r\n            var labelElement = labelIsVisible && this._renderer.text(labelValue, 0, 0).css(this._textFontStyles).attr(this._textOptions).append(rootElement);\r\n            var titleElement = this._drawTitleText(rootElement, {\r\n                x: 0,\r\n                y: 0\r\n            });\r\n            var constantLinesLabelsElement = this._drawConstantLinesForEstimating(constantLineOptions);\r\n            var labelBox = !options.label.template && labelElement && labelElement.getBBox() || {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            var titleBox = titleElement && titleElement.getBBox() || {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            var constantLinesBox = constantLinesLabelsElement.getBBox();\r\n            var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;\r\n            var labelHeight = this._estimateLabelHeight(labelBox, options.label);\r\n            var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;\r\n            var height = labelHeight + titleHeight;\r\n            var margins = {\r\n                left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),\r\n                right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),\r\n                top: (\"top\" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"top\", constantLinesHeight),\r\n                bottom: (\"top\" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"bottom\", constantLinesHeight)\r\n            };\r\n            labelElement && labelElement.remove();\r\n            titleElement && titleElement.remove();\r\n            constantLinesLabelsElement && constantLinesLabelsElement.remove();\r\n            return margins\r\n        },\r\n        _checkAlignmentConstantLineLabels: function(labelOptions) {\r\n            var position = labelOptions.position;\r\n            var verticalAlignment = (labelOptions.verticalAlignment || \"\").toLowerCase();\r\n            var horizontalAlignment = (labelOptions.horizontalAlignment || \"\").toLowerCase();\r\n            if (this._isHorizontal) {\r\n                if (\"outside\" === position) {\r\n                    verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = CENTER\r\n                } else {\r\n                    verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT\r\n                }\r\n            } else if (\"outside\" === position) {\r\n                verticalAlignment = CENTER;\r\n                horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT\r\n            } else {\r\n                verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT\r\n            }\r\n            labelOptions.verticalAlignment = verticalAlignment;\r\n            labelOptions.horizontalAlignment = horizontalAlignment\r\n        },\r\n        _getConstantLineLabelsCoords: function(value, lineLabelOptions) {\r\n            var x = value;\r\n            var y = value;\r\n            if (this._isHorizontal) {\r\n                y = this._orthogonalPositions[\"top\" === lineLabelOptions.verticalAlignment ? \"start\" : \"end\"]\r\n            } else {\r\n                x = this._orthogonalPositions[\"right\" === lineLabelOptions.horizontalAlignment ? \"end\" : \"start\"]\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _getAdjustedStripLabelCoords: function(strip) {\r\n            var stripOptions = strip.options;\r\n            var paddingTopBottom = stripOptions.paddingTopBottom;\r\n            var paddingLeftRight = stripOptions.paddingLeftRight;\r\n            var horizontalAlignment = stripOptions.label.horizontalAlignment;\r\n            var verticalAlignment = stripOptions.label.verticalAlignment;\r\n            var box = strip.labelBBox;\r\n            var labelHeight = box.height;\r\n            var labelWidth = box.width;\r\n            var labelCoords = strip.labelCoords;\r\n            var y = labelCoords.y - box.y;\r\n            var x = labelCoords.x - box.x;\r\n            if (verticalAlignment === TOP) {\r\n                y += paddingTopBottom\r\n            } else if (verticalAlignment === CENTER) {\r\n                y -= labelHeight / 2\r\n            } else if (verticalAlignment === BOTTOM) {\r\n                y -= paddingTopBottom + labelHeight\r\n            }\r\n            if (horizontalAlignment === LEFT) {\r\n                x += paddingLeftRight\r\n            } else if (horizontalAlignment === CENTER) {\r\n                x -= labelWidth / 2\r\n            } else if (horizontalAlignment === RIGHT) {\r\n                x -= paddingLeftRight + labelWidth\r\n            }\r\n            return {\r\n                translateX: x,\r\n                translateY: y\r\n            }\r\n        },\r\n        _adjustTitle: function(offset) {\r\n            offset = offset || 0;\r\n            if (!this._title) {\r\n                return\r\n            }\r\n            var options = this._options;\r\n            var position = options.position;\r\n            var margin = options.title.margin;\r\n            var title = this._title;\r\n            var boxTitle = title.bBox;\r\n            var x = boxTitle.x;\r\n            var y = boxTitle.y;\r\n            var width = boxTitle.width;\r\n            var height = boxTitle.height;\r\n            var axisPosition = this._axisPosition;\r\n            var loCoord = axisPosition - margin - offset;\r\n            var hiCoord = axisPosition + margin + offset;\r\n            var params = {};\r\n            if (this._isHorizontal) {\r\n                if (position === TOP) {\r\n                    params.translateY = loCoord - (y + height)\r\n                } else {\r\n                    params.translateY = hiCoord - y\r\n                }\r\n            } else if (position === LEFT) {\r\n                params.translateX = loCoord - (x + width)\r\n            } else {\r\n                params.translateX = hiCoord - x\r\n            }\r\n            title.element.attr(params)\r\n        },\r\n        _checkTitleOverflow: function(titleElement) {\r\n            if (!this._title && !titleElement) {\r\n                return\r\n            }\r\n            var canvasLength = this._getScreenDelta();\r\n            var title = titleElement ? {\r\n                bBox: titleElement.getBBox(),\r\n                element: titleElement\r\n            } : this._title;\r\n            var titleOptions = this._options.title;\r\n            var boxTitle = title.bBox;\r\n            if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {\r\n                title.element.setMaxSize(canvasLength, void 0, {\r\n                    wordWrap: titleOptions.wordWrap || \"none\",\r\n                    textOverflow: titleOptions.textOverflow || \"ellipsis\"\r\n                });\r\n                this._wrapped = titleOptions.wordWrap && \"none\" !== titleOptions.wordWrap\r\n            } else {\r\n                var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);\r\n                !this._wrapped && moreThanOriginalSize && title.element.restoreText()\r\n            }\r\n        },\r\n        coordsIn: function(x, y) {\r\n            var canvas = this.getCanvas();\r\n            var isHorizontal = this._options.isHorizontal;\r\n            var position = this._options.position;\r\n            var coord = isHorizontal ? y : x;\r\n            if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {\r\n                return false\r\n            }\r\n            if (isHorizontal && position === _axes_constants__WEBPACK_IMPORTED_MODULE_8__[\"default\"].top || !isHorizontal && position === _axes_constants__WEBPACK_IMPORTED_MODULE_8__[\"default\"].left) {\r\n                return coord < canvas[position]\r\n            }\r\n            return coord > canvas[isHorizontal ? \"height\" : \"width\"] - canvas[position]\r\n        },\r\n        _boundaryTicksVisibility: {\r\n            min: true,\r\n            max: true\r\n        },\r\n        adjust() {\r\n            var seriesData = this._seriesData;\r\n            var viewport = this._series.filter(s => s.isVisible()).reduce((range, s) => {\r\n                var seriesRange = s.getViewport();\r\n                range.min = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;\r\n                range.max = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;\r\n                if (s.showZero) {\r\n                    range = new _translators_range__WEBPACK_IMPORTED_MODULE_0__[\"Range\"](range);\r\n                    range.correctValueZeroLevel()\r\n                }\r\n                return range\r\n            }, {});\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(viewport.min) && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(viewport.max)) {\r\n                seriesData.minVisible = viewport.min;\r\n                seriesData.maxVisible = viewport.max\r\n            }\r\n            seriesData.userBreaks = this._getScaleBreaks(this._options, {\r\n                minVisible: seriesData.minVisible,\r\n                maxVisible: seriesData.maxVisible\r\n            }, this._series, this.isArgumentAxis);\r\n            this._translator.updateBusinessRange(this._getViewportRange())\r\n        },\r\n        hasWrap() {\r\n            return this._wrapped\r\n        },\r\n        getAxisPosition() {\r\n            return this._axisPosition\r\n        },\r\n        _getStick: function() {\r\n            return !this._options.valueMarginsEnabled\r\n        },\r\n        _getStripLabelCoords: function(from, to, stripLabelOptions) {\r\n            var orthogonalPositions = this._orthogonalPositions;\r\n            var isHorizontal = this._isHorizontal;\r\n            var horizontalAlignment = stripLabelOptions.horizontalAlignment;\r\n            var verticalAlignment = stripLabelOptions.verticalAlignment;\r\n            var x;\r\n            var y;\r\n            if (isHorizontal) {\r\n                if (horizontalAlignment === CENTER) {\r\n                    x = from + (to - from) / 2\r\n                } else if (horizontalAlignment === LEFT) {\r\n                    x = from\r\n                } else if (horizontalAlignment === RIGHT) {\r\n                    x = to\r\n                }\r\n                y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)]\r\n            } else {\r\n                x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];\r\n                if (verticalAlignment === TOP) {\r\n                    y = from\r\n                } else if (verticalAlignment === CENTER) {\r\n                    y = to + (from - to) / 2\r\n                } else if (verticalAlignment === BOTTOM) {\r\n                    y = to\r\n                }\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _getTranslatedValue: function(value, offset) {\r\n            var pos1 = this._translator.translate(value, offset, \"semidiscrete\" === this._options.type && this._options.tickInterval);\r\n            var pos2 = this._axisPosition;\r\n            var isHorizontal = this._isHorizontal;\r\n            return {\r\n                x: isHorizontal ? pos1 : pos2,\r\n                y: isHorizontal ? pos2 : pos1\r\n            }\r\n        },\r\n        areCoordsOutsideAxis: function(coords) {\r\n            var coord = this._isHorizontal ? coords.x : coords.y;\r\n            var visibleArea = this.getVisibleArea();\r\n            if (coord < visibleArea[0] || coord > visibleArea[1]) {\r\n                return true\r\n            }\r\n            return false\r\n        },\r\n        _getSkippedCategory: function(ticks) {\r\n            var skippedCategory;\r\n            if (this._options.type === _axes_constants__WEBPACK_IMPORTED_MODULE_8__[\"default\"].discrete && this._tickOffset && 0 !== ticks.length) {\r\n                skippedCategory = ticks[ticks.length - 1]\r\n            }\r\n            return skippedCategory\r\n        },\r\n        _filterBreaks: function(breaks, viewport, breakStyle) {\r\n            var minVisible = viewport.minVisible;\r\n            var maxVisible = viewport.maxVisible;\r\n            var breakSize = breakStyle ? breakStyle.width : 0;\r\n            return breaks.reduce((function(result, currentBreak) {\r\n                var from = currentBreak.from;\r\n                var to = currentBreak.to;\r\n                var lastResult = result[result.length - 1];\r\n                var newBreak;\r\n                if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(from) || !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(to)) {\r\n                    return result\r\n                }\r\n                if (from > to) {\r\n                    to = [from, from = to][0]\r\n                }\r\n                if (result.length && from < lastResult.to) {\r\n                    if (to > lastResult.to) {\r\n                        lastResult.to = to > maxVisible ? maxVisible : to;\r\n                        if (lastResult.gapSize) {\r\n                            lastResult.gapSize = void 0;\r\n                            lastResult.cumulativeWidth += breakSize\r\n                        }\r\n                    }\r\n                } else if (from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) {\r\n                    from = from >= minVisible ? from : minVisible;\r\n                    to = to <= maxVisible ? to : maxVisible;\r\n                    if (to - from < maxVisible - minVisible) {\r\n                        var _lastResult$cumulativ;\r\n                        newBreak = {\r\n                            from: from,\r\n                            to: to,\r\n                            cumulativeWidth: (null !== (_lastResult$cumulativ = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ ? _lastResult$cumulativ : 0) + breakSize\r\n                        };\r\n                        if (currentBreak.gapSize) {\r\n                            var _lastResult$cumulativ2;\r\n                            newBreak.gapSize = _core_utils_date__WEBPACK_IMPORTED_MODULE_2__[\"default\"].convertMillisecondsToDateUnits(to - from);\r\n                            newBreak.cumulativeWidth = null !== (_lastResult$cumulativ2 = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ2 ? _lastResult$cumulativ2 : 0\r\n                        }\r\n                        result.push(newBreak)\r\n                    }\r\n                }\r\n                return result\r\n            }), [])\r\n        },\r\n        _getScaleBreaks: function(axisOptions, viewport, series, isArgumentAxis) {\r\n            var that = this;\r\n            var breaks = (axisOptions.breaks || []).map((function(b) {\r\n                return {\r\n                    from: that.parser(b.startValue),\r\n                    to: that.parser(b.endValue)\r\n                }\r\n            }));\r\n            if (\"discrete\" !== axisOptions.type && \"datetime\" === axisOptions.dataType && axisOptions.workdaysOnly) {\r\n                breaks = breaks.concat(Object(_datetime_breaks__WEBPACK_IMPORTED_MODULE_4__[\"generateDateBreaks\"])(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays))\r\n            }\r\n            if (!isArgumentAxis && \"discrete\" !== axisOptions.type && \"datetime\" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {\r\n                breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport))\r\n            }\r\n            return sortingBreaks(breaks)\r\n        },\r\n        _drawBreak: function(translatedEnd, positionFrom, positionTo, width, options, group) {\r\n            var breakStart = translatedEnd - (!this._translator.isInverted() ? width + 1 : 0);\r\n            var attr = {\r\n                \"stroke-width\": 1,\r\n                stroke: options.borderColor,\r\n                sharp: !options.isWaved ? options.isHorizontal ? \"h\" : \"v\" : void 0\r\n            };\r\n            var spaceAttr = {\r\n                stroke: options.color,\r\n                \"stroke-width\": width\r\n            };\r\n            var getPoints = this._isHorizontal ? rotateLine : function(p) {\r\n                return p\r\n            };\r\n            var drawer = getLineDrawer(this._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);\r\n            drawer(width / 2, spaceAttr);\r\n            drawer(0, attr);\r\n            drawer(width, attr)\r\n        },\r\n        _createBreakClipRect: function(from, to) {\r\n            var canvas = this._canvas;\r\n            var clipWidth = to - from;\r\n            var clipRect;\r\n            if (this._isHorizontal) {\r\n                clipRect = this._renderer.clipRect(canvas.left, from, canvas.width, clipWidth)\r\n            } else {\r\n                clipRect = this._renderer.clipRect(from, canvas.top, clipWidth, canvas.height)\r\n            }\r\n            this._breaksElements = this._breaksElements || [];\r\n            this._breaksElements.push(clipRect);\r\n            return clipRect.id\r\n        },\r\n        _createBreaksGroup: function(clipFrom, clipTo) {\r\n            var group = this._renderer.g().attr({\r\n                class: this._axisCssPrefix + \"breaks\",\r\n                \"clip-path\": this._createBreakClipRect(clipFrom, clipTo)\r\n            }).append(this._scaleBreaksGroup);\r\n            this._breaksElements = this._breaksElements || [];\r\n            this._breaksElements.push(group);\r\n            return group\r\n        },\r\n        _disposeBreaksGroup: function() {\r\n            (this._breaksElements || []).forEach((function(clipRect) {\r\n                clipRect.dispose()\r\n            }));\r\n            this._breaksElements = null\r\n        },\r\n        drawScaleBreaks: function(customCanvas) {\r\n            var that = this;\r\n            var options = that._options;\r\n            var breakStyle = options.breakStyle;\r\n            var position = options.position;\r\n            var positionFrom;\r\n            var positionTo;\r\n            var breaks = that._translator.getBusinessRange().breaks || [];\r\n            var additionGroup;\r\n            var additionBreakFrom;\r\n            var additionBreakTo;\r\n            that._disposeBreaksGroup();\r\n            if (!(breaks && breaks.length)) {\r\n                return\r\n            }\r\n            var breakOptions = {\r\n                color: that._options.containerColor,\r\n                borderColor: breakStyle.color,\r\n                isHorizontal: that._isHorizontal,\r\n                isWaved: \"straight\" !== breakStyle.line.toLowerCase()\r\n            };\r\n            if (customCanvas) {\r\n                positionFrom = customCanvas.start;\r\n                positionTo = customCanvas.end\r\n            } else {\r\n                positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (position === LEFT || position === TOP) ? SCALE_BREAK_OFFSET : 0);\r\n                positionTo = that._orthogonalPositions.end + (options.visible && (position === RIGHT || position === BOTTOM) ? SCALE_BREAK_OFFSET : 0)\r\n            }\r\n            var mainGroup = that._createBreaksGroup(positionFrom, positionTo);\r\n            if (that._axisShift && options.visible) {\r\n                additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;\r\n                additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;\r\n                additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo)\r\n            }\r\n            breaks.forEach((function(br) {\r\n                if (!br.gapSize) {\r\n                    var breakCoord = that._getTranslatedCoord(br.to);\r\n                    that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);\r\n                    if (that._axisShift && options.visible) {\r\n                        that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup)\r\n                    }\r\n                }\r\n            }))\r\n        },\r\n        _getSpiderCategoryOption: _core_utils_common__WEBPACK_IMPORTED_MODULE_5__[\"noop\"],\r\n        shift: function(margins) {\r\n            var options = this._options;\r\n            var isHorizontal = options.isHorizontal;\r\n            var axesSpacing = this.getMultipleAxesSpacing();\r\n            var constantLinesGroups = this._axisConstantLineGroups;\r\n\r\n            function shiftGroup(side, group) {\r\n                var attr = {\r\n                    translateX: 0,\r\n                    translateY: 0\r\n                };\r\n                var shift = margins[side] ? margins[side] + axesSpacing : 0;\r\n                attr[isHorizontal ? \"translateY\" : \"translateX\"] = (side === LEFT || side === TOP ? -1 : 1) * shift;\r\n                (group[side] || group).attr(attr);\r\n                return shift\r\n            }\r\n            this._axisShift = shiftGroup(options.position, this._axisGroup);\r\n            shiftGroup(options.position, this._axisElementsGroup);\r\n            (isHorizontal ? [TOP, BOTTOM] : [LEFT, RIGHT]).forEach(side => {\r\n                shiftGroup(side, constantLinesGroups.above);\r\n                shiftGroup(side, constantLinesGroups.under)\r\n            })\r\n        },\r\n        getCustomPosition(position) {\r\n            var orthogonalAxis = this.getOrthogonalAxis();\r\n            var resolvedPosition = null !== position && void 0 !== position ? position : this.getResolvedPositionOption();\r\n            var offset = this.getOptions().offset;\r\n            var orthogonalTranslator = orthogonalAxis.getTranslator();\r\n            var orthogonalAxisType = orthogonalAxis.getOptions().type;\r\n            var validPosition = orthogonalAxis.validateUnit(resolvedPosition);\r\n            var currentPosition;\r\n            if (\"discrete\" === orthogonalAxisType && (!orthogonalTranslator._categories || orthogonalTranslator._categories.indexOf(validPosition) < 0)) {\r\n                validPosition = void 0\r\n            }\r\n            if (this.positionIsBoundary(resolvedPosition)) {\r\n                currentPosition = this.getPredefinedPosition(resolvedPosition)\r\n            } else if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(validPosition)) {\r\n                currentPosition = this.getPredefinedPosition(this.getOptions().position)\r\n            } else {\r\n                currentPosition = orthogonalTranslator.to(validPosition, -1)\r\n            }\r\n            if (isFinite(currentPosition) && isFinite(offset)) {\r\n                currentPosition += offset\r\n            }\r\n            return currentPosition\r\n        },\r\n        getCustomBoundaryPosition(position) {\r\n            var {\r\n                customPosition: customPosition,\r\n                offset: offset\r\n            } = this.getOptions();\r\n            var resolvedPosition = null !== position && void 0 !== position ? position : this.getResolvedPositionOption();\r\n            var orthogonalAxis = this.getOrthogonalAxis();\r\n            var orthogonalTranslator = orthogonalAxis.getTranslator();\r\n            var visibleArea = orthogonalTranslator.getCanvasVisibleArea();\r\n            if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(orthogonalAxis._orthogonalPositions) || 0 === orthogonalTranslator.canvasLength) {\r\n                return\r\n            }\r\n            var currentPosition = this.getCustomPosition(resolvedPosition);\r\n            if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(currentPosition)) {\r\n                return this.getResolvedBoundaryPosition()\r\n            } else if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(customPosition)) {\r\n                if (currentPosition <= visibleArea.min) {\r\n                    return this._isHorizontal ? TOP : LEFT\r\n                } else if (currentPosition >= visibleArea.max) {\r\n                    return this._isHorizontal ? BOTTOM : RIGHT\r\n                }\r\n            } else if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(offset)) {\r\n                if (currentPosition <= this._orthogonalPositions.start) {\r\n                    return this._isHorizontal ? TOP : LEFT\r\n                } else if (currentPosition >= this._orthogonalPositions.end) {\r\n                    return this._isHorizontal ? BOTTOM : RIGHT\r\n                }\r\n            }\r\n            return currentPosition\r\n        },\r\n        getResolvedPositionOption() {\r\n            var _options$customPositi;\r\n            var options = this.getOptions();\r\n            return null !== (_options$customPositi = options.customPosition) && void 0 !== _options$customPositi ? _options$customPositi : options.position\r\n        },\r\n        customPositionIsAvailable() {\r\n            var options = this.getOptions();\r\n            return Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(this.getOrthogonalAxis()) && (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_7__[\"isDefined\"])(options.customPosition) || isFinite(options.offset))\r\n        },\r\n        hasNonBoundaryPosition() {\r\n            return this.customPositionIsAvailable() && !this.customPositionIsBoundary()\r\n        },\r\n        getResolvedBoundaryPosition() {\r\n            return this.customPositionIsBoundary() ? this._customBoundaryPosition : this.getOptions().position\r\n        },\r\n        customPositionEqualsToPredefined() {\r\n            return this.customPositionIsBoundary() && this._customBoundaryPosition === this.getOptions().position\r\n        },\r\n        customPositionIsBoundary() {\r\n            return this.positionIsBoundary(this._customBoundaryPosition)\r\n        },\r\n        positionIsBoundary: position => [TOP, LEFT, BOTTOM, RIGHT].indexOf(position) >= 0,\r\n        getPredefinedPosition(position) {\r\n            var _this$_orthogonalPosi;\r\n            return null === (_this$_orthogonalPosi = this._orthogonalPositions) || void 0 === _this$_orthogonalPosi ? void 0 : _this$_orthogonalPosi[position === TOP || position === LEFT ? \"start\" : \"end\"]\r\n        },\r\n        resolveOverlappingForCustomPositioning(oppositeAxes) {\r\n            var that = this;\r\n            if (!that.hasNonBoundaryPosition() && !that.customPositionIsBoundary() && !oppositeAxes.some(a => a.hasNonBoundaryPosition())) {\r\n                return\r\n            }\r\n            var overlappingObj = {\r\n                axes: [],\r\n                ticks: []\r\n            };\r\n            oppositeAxes.filter(orthogonalAxis => orthogonalAxis.pane === that.pane).forEach(orthogonalAxis => {\r\n                for (var i = 0; i < that._majorTicks.length; i++) {\r\n                    var tick = that._majorTicks[i];\r\n                    var label = tick.label;\r\n                    if (label) {\r\n                        if (overlappingObj.axes.indexOf(orthogonalAxis) < 0 && that._detectElementsOverlapping(label, orthogonalAxis._axisElement)) {\r\n                            overlappingObj.axes.push(orthogonalAxis);\r\n                            that._shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis)\r\n                        }\r\n                        for (var j = 0; j < orthogonalAxis._majorTicks.length; j++) {\r\n                            var oppositeTick = orthogonalAxis._majorTicks[j];\r\n                            var oppositeLabel = oppositeTick.label;\r\n                            if (oppositeLabel && that._detectElementsOverlapping(label, oppositeLabel)) {\r\n                                overlappingObj.ticks.push(tick);\r\n                                that._shiftThroughAxisOverlappedTick(tick);\r\n                                i = that._majorTicks.length;\r\n                                break\r\n                            }\r\n                        }\r\n                    }\r\n                    if (tick.mark && overlappingObj.ticks.indexOf(tick) < 0) {\r\n                        if (that._isHorizontal && tick.mark.attr(\"translateY\")) {\r\n                            tick.mark.attr({\r\n                                translateY: 0\r\n                            })\r\n                        } else if (!that._isHorizontal && tick.mark.attr(\"translateX\")) {\r\n                            tick.mark.attr({\r\n                                translateX: 0\r\n                            })\r\n                        }\r\n                    }\r\n                }\r\n            })\r\n        },\r\n        _shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis) {\r\n            var labelBBox = label.getBBox();\r\n            var orthogonalAxisPosition = orthogonalAxis.getAxisPosition();\r\n            var orthogonalAxisLabelOptions = orthogonalAxis.getOptions().label;\r\n            var orthogonalAxisLabelPosition = orthogonalAxisLabelOptions.position;\r\n            var orthogonalAxisLabelIndent = orthogonalAxisLabelOptions.indentFromAxis / 2;\r\n            var translateCoordName = this._isHorizontal ? \"translateX\" : \"translateY\";\r\n            var defaultOrthogonalAxisLabelPosition = this._isHorizontal ? LEFT : TOP;\r\n            var translate = label.attr(translateCoordName);\r\n            var labelCoord = (this._isHorizontal ? labelBBox.x : labelBBox.y) + translate;\r\n            var labelSize = this._isHorizontal ? labelBBox.width : labelBBox.height;\r\n            var outsidePart = orthogonalAxisPosition - labelCoord;\r\n            var insidePart = labelCoord + labelSize - orthogonalAxisPosition;\r\n            var attr = {};\r\n            attr[translateCoordName] = translate;\r\n            if (outsidePart > 0 && insidePart > 0) {\r\n                if (insidePart - outsidePart > 1) {\r\n                    attr[translateCoordName] += outsidePart + orthogonalAxisLabelIndent\r\n                } else if (outsidePart - insidePart > 1) {\r\n                    attr[translateCoordName] -= insidePart + orthogonalAxisLabelIndent\r\n                } else {\r\n                    attr[translateCoordName] += orthogonalAxisLabelPosition === defaultOrthogonalAxisLabelPosition ? outsidePart + orthogonalAxisLabelIndent : -(insidePart + orthogonalAxisLabelIndent)\r\n                }\r\n                label.attr(attr)\r\n            }\r\n        },\r\n        _shiftThroughAxisOverlappedTick(tick) {\r\n            var _tick$mark;\r\n            var label = tick.label;\r\n            if (!label) {\r\n                return\r\n            }\r\n            var labelBBox = label.getBBox();\r\n            var tickMarkBBox = null === (_tick$mark = tick.mark) || void 0 === _tick$mark ? void 0 : _tick$mark.getBBox();\r\n            var axisPosition = this.getAxisPosition();\r\n            var labelOptions = this.getOptions().label;\r\n            var labelIndent = labelOptions.indentFromAxis;\r\n            var labelPosition = labelOptions.position;\r\n            var defaultLabelPosition = this._isHorizontal ? TOP : LEFT;\r\n            var translateCoordName = this._isHorizontal ? \"translateY\" : \"translateX\";\r\n            var translate = label.attr(translateCoordName);\r\n            var labelCoord = (this._isHorizontal ? labelBBox.y : labelBBox.x) + translate;\r\n            var labelSize = this._isHorizontal ? labelBBox.height : labelBBox.width;\r\n            var attr = {};\r\n            attr[translateCoordName] = translate + (labelPosition === defaultLabelPosition ? axisPosition - labelCoord + labelIndent : -(labelCoord - axisPosition + labelSize + labelIndent));\r\n            label.attr(attr);\r\n            if (tick.mark) {\r\n                var markerSize = this._isHorizontal ? tickMarkBBox.height : tickMarkBBox.width;\r\n                var dir = labelPosition === defaultLabelPosition ? 1 : -1;\r\n                attr[translateCoordName] = dir * (markerSize - 1);\r\n                tick.mark.attr(attr)\r\n            }\r\n        },\r\n        _detectElementsOverlapping(element1, element2) {\r\n            if (!element1 || !element2) {\r\n                return false\r\n            }\r\n            var bBox1 = element1.getBBox();\r\n            var x1 = bBox1.x + element1.attr(\"translateX\");\r\n            var y1 = bBox1.y + element1.attr(\"translateY\");\r\n            var bBox2 = element2.getBBox();\r\n            var x2 = bBox2.x + element2.attr(\"translateX\");\r\n            var y2 = bBox2.y + element2.attr(\"translateY\");\r\n            return (x2 >= x1 && x2 <= x1 + bBox1.width || x1 >= x2 && x1 <= x2 + bBox2.width) && (y2 >= y1 && y2 <= y1 + bBox1.height || y1 >= y2 && y1 <= y2 + bBox2.height)\r\n        }\r\n    }\r\n});\r\n\r\nfunction getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {\r\n    var elementType = isWaved ? \"bezier\" : \"line\";\r\n    var group = renderer.g().append(root);\r\n    return function(offset, attr) {\r\n        renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group)\r\n    }\r\n}\r\n\r\nfunction getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {\r\n    if (!isWaved) {\r\n        return [positionFrom, breakStart + offset, positionTo, breakStart + offset]\r\n    }\r\n    breakStart += offset;\r\n    var currentPosition;\r\n    var topPoint = breakStart + WAVED_LINE_TOP;\r\n    var centerPoint = breakStart + WAVED_LINE_CENTER;\r\n    var bottomPoint = breakStart + WAVED_LINE_BOTTOM;\r\n    var points = [\r\n        [positionFrom, centerPoint]\r\n    ];\r\n    for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {\r\n        points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint])\r\n    }\r\n    return [].concat.apply([], points)\r\n}\r\n\r\nfunction rotateLine(lineCoords) {\r\n    var points = [];\r\n    var i;\r\n    for (i = 0; i < lineCoords.length; i += 2) {\r\n        points.push(lineCoords[i + 1]);\r\n        points.push(lineCoords[i])\r\n    }\r\n    return points\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2F4ZXMveHlfYXhlcy5qcz9iZjA0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUc4QjtBQUNpQjtBQUNEO0FBR2I7QUFHTjtBQUdNO0FBS1Y7QUFHUTtBQUNVO0FBQ3pDLHNCQUFzQix3REFBUztBQUMvQixtQ0FBbUMsd0RBQVM7QUFDNUM7QUFDQTtBQUNBLFVBQVUsdURBQVM7QUFDbkIsYUFBYSx1REFBUztBQUN0QixXQUFXLHVEQUFTO0FBQ3BCLFlBQVksdURBQVM7QUFDckIsYUFBYSx1REFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFLLHdEQUFTLDBCQUEwQjtBQUMzRCwrQkFBK0Isd0RBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qyx3REFBUztBQUNoRDtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFZO0FB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QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Qsa0NBQWtDLHVEQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVyxrRUFBUztBQUNqQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0VBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtFQUFTO0FBQzFCO0FBQ0EsYUFBYSxVQUFVLGtFQUFTO0FBQ2hDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWEsVUFBVSxrRUFBUztBQUNoQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsa0VBQVMsK0JBQStCLGtFQUFTO0FBQ3BFLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZCQUE2QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrREFBa0Q7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS92aXovYXhlcy94eV9heGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS92aXovYXhlcy94eV9heGVzLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQge1xyXG4gICAgUmFuZ2VcclxufSBmcm9tIFwiLi4vdHJhbnNsYXRvcnMvcmFuZ2VcIjtcclxuaW1wb3J0IGZvcm1hdEhlbHBlciBmcm9tIFwiLi4vLi4vZm9ybWF0X2hlbHBlclwiO1xyXG5pbXBvcnQgZGF0ZVV0aWxzIGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2RhdGVcIjtcclxuaW1wb3J0IHtcclxuICAgIGV4dGVuZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2V4dGVuZFwiO1xyXG5pbXBvcnQge1xyXG4gICAgZ2VuZXJhdGVEYXRlQnJlYWtzXHJcbn0gZnJvbSBcIi4vZGF0ZXRpbWVfYnJlYWtzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBub29wXHJcbn0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvY29tbW9uXCI7XHJcbmltcG9ydCB7XHJcbiAgICBnZXRMb2csXHJcbiAgICBwYXRjaEZvbnRPcHRpb25zLFxyXG4gICAgZ2V0Q29zQW5kU2luXHJcbn0gZnJvbSBcIi4uL2NvcmUvdXRpbHNcIjtcclxuaW1wb3J0IHtcclxuICAgIGlzRGVmaW5lZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL3R5cGVcIjtcclxuaW1wb3J0IGNvbnN0YW50cyBmcm9tIFwiLi9heGVzX2NvbnN0YW50c1wiO1xyXG52YXIgZ2V0TmV4dERhdGVVbml0ID0gZGF0ZVV0aWxzLmdldE5leHREYXRlVW5pdDtcclxudmFyIGNvcnJlY3REYXRlV2l0aFVuaXRCZWdpbm5pbmcgPSBkYXRlVXRpbHMuY29ycmVjdERhdGVXaXRoVW5pdEJlZ2lubmluZztcclxudmFyIF9tYXRoID0gTWF0aDtcclxudmFyIF9tYXggPSBfbWF0aC5tYXg7XHJcbnZhciBUT1AgPSBjb25zdGFudHMudG9wO1xyXG52YXIgQk9UVE9NID0gY29uc3RhbnRzLmJvdHRvbTtcclxudmFyIExFRlQgPSBjb25zdGFudHMubGVmdDtcclxudmFyIFJJR0hUID0gY29uc3RhbnRzLnJpZ2h0O1xyXG52YXIgQ0VOVEVSID0gY29uc3RhbnRzLmNlbnRlcjtcclxudmFyIFNDQUxFX0JSRUFLX09GRlNFVCA9IDM7XHJcbnZhciBSQU5HRV9SQVRJTyA9IC4zO1xyXG52YXIgV0FWRURfTElORV9DRU5URVIgPSAyO1xyXG52YXIgV0FWRURfTElORV9UT1AgPSAwO1xyXG52YXIgV0FWRURfTElORV9CT1RUT00gPSA0O1xyXG52YXIgV0FWRURfTElORV9MRU5HVEggPSAyNDtcclxudmFyIFRJQ0tTX0NPUlJFQ1RJT05TID0ge1xyXG4gICAgbGVmdDogLTEsXHJcbiAgICB0b3A6IC0xLFxyXG4gICAgcmlnaHQ6IDAsXHJcbiAgICBib3R0b206IDAsXHJcbiAgICBjZW50ZXI6IC0uNVxyXG59O1xyXG5cclxuZnVuY3Rpb24gcHJlcGFyZURhdGVzRGlmZmVyZW5jZXMoZGF0ZXNEaWZmZXJlbmNlcywgdGlja0ludGVydmFsKSB7XHJcbiAgICB2YXIgZGF0ZVVuaXRJbnRlcnZhbDtcclxuICAgIHZhciBpO1xyXG4gICAgaWYgKFwid2Vla1wiID09PSB0aWNrSW50ZXJ2YWwpIHtcclxuICAgICAgICB0aWNrSW50ZXJ2YWwgPSBcImRheVwiXHJcbiAgICB9XHJcbiAgICBpZiAoXCJxdWFydGVyXCIgPT09IHRpY2tJbnRlcnZhbCkge1xyXG4gICAgICAgIHRpY2tJbnRlcnZhbCA9IFwibW9udGhcIlxyXG4gICAgfVxyXG4gICAgaWYgKGRhdGVzRGlmZmVyZW5jZXNbdGlja0ludGVydmFsXSkge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRlVXRpbHMuZGF0ZVVuaXRJbnRlcnZhbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGF0ZVVuaXRJbnRlcnZhbCA9IGRhdGVVdGlscy5kYXRlVW5pdEludGVydmFsc1tpXTtcclxuICAgICAgICAgICAgaWYgKGRhdGVzRGlmZmVyZW5jZXNbZGF0ZVVuaXRJbnRlcnZhbF0pIHtcclxuICAgICAgICAgICAgICAgIGRhdGVzRGlmZmVyZW5jZXNbZGF0ZVVuaXRJbnRlcnZhbF0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGRhdGVzRGlmZmVyZW5jZXMuY291bnQtLVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRlVW5pdEludGVydmFsID09PSB0aWNrSW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNvcnRpbmdCcmVha3MoYnJlYWtzKSB7XHJcbiAgICByZXR1cm4gYnJlYWtzLnNvcnQoKGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYS5mcm9tIC0gYi5mcm9tXHJcbiAgICB9KSlcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TWFya2VyRGF0ZXMobWluLCBtYXgsIG1hcmtlckludGVydmFsKSB7XHJcbiAgICB2YXIgb3JpZ01pbiA9IG1pbjtcclxuICAgIHZhciBkYXRlcztcclxuICAgIG1pbiA9IGNvcnJlY3REYXRlV2l0aFVuaXRCZWdpbm5pbmcobWluLCBtYXJrZXJJbnRlcnZhbCk7XHJcbiAgICBtYXggPSBjb3JyZWN0RGF0ZVdpdGhVbml0QmVnaW5uaW5nKG1heCwgbWFya2VySW50ZXJ2YWwpO1xyXG4gICAgZGF0ZXMgPSBkYXRlVXRpbHMuZ2V0U2VxdWVuY2VCeUludGVydmFsKG1pbiwgbWF4LCBtYXJrZXJJbnRlcnZhbCk7XHJcbiAgICBpZiAoZGF0ZXMubGVuZ3RoICYmIG9yaWdNaW4gPiBkYXRlc1swXSkge1xyXG4gICAgICAgIGRhdGVzID0gZGF0ZXMuc2xpY2UoMSlcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTdHJpcEhvcml6b250YWxBbGlnbm1lbnRQb3NpdGlvbihhbGlnbm1lbnQpIHtcclxuICAgIHZhciBwb3NpdGlvbiA9IFwic3RhcnRcIjtcclxuICAgIGlmIChcImNlbnRlclwiID09PSBhbGlnbm1lbnQpIHtcclxuICAgICAgICBwb3NpdGlvbiA9IFwiY2VudGVyXCJcclxuICAgIH1cclxuICAgIGlmIChcInJpZ2h0XCIgPT09IGFsaWdubWVudCkge1xyXG4gICAgICAgIHBvc2l0aW9uID0gXCJlbmRcIlxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9uXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFN0cmlwVmVydGljYWxBbGlnbm1lbnRQb3NpdGlvbihhbGlnbm1lbnQpIHtcclxuICAgIHZhciBwb3NpdGlvbiA9IFwic3RhcnRcIjtcclxuICAgIGlmIChcImNlbnRlclwiID09PSBhbGlnbm1lbnQpIHtcclxuICAgICAgICBwb3NpdGlvbiA9IFwiY2VudGVyXCJcclxuICAgIH1cclxuICAgIGlmIChcImJvdHRvbVwiID09PSBhbGlnbm1lbnQpIHtcclxuICAgICAgICBwb3NpdGlvbiA9IFwiZW5kXCJcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvblxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNYXJrZXJJbnRlcnZhbCh0aWNrSW50ZXJ2YWwpIHtcclxuICAgIHZhciBtYXJrZXJJbnRlcnZhbCA9IGdldE5leHREYXRlVW5pdCh0aWNrSW50ZXJ2YWwpO1xyXG4gICAgaWYgKFwicXVhcnRlclwiID09PSBtYXJrZXJJbnRlcnZhbCkge1xyXG4gICAgICAgIG1hcmtlckludGVydmFsID0gZ2V0TmV4dERhdGVVbml0KG1hcmtlckludGVydmFsKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hcmtlckludGVydmFsXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE1hcmtlckZvcm1hdChjdXJEYXRlLCBwcmV2RGF0ZSwgdGlja0ludGVydmFsLCBtYXJrZXJJbnRlcnZhbCkge1xyXG4gICAgdmFyIGZvcm1hdCA9IG1hcmtlckludGVydmFsO1xyXG4gICAgdmFyIGRhdGVzRGlmZmVyZW5jZXMgPSBwcmV2RGF0ZSAmJiBkYXRlVXRpbHMuZ2V0RGF0ZXNEaWZmZXJlbmNlcyhwcmV2RGF0ZSwgY3VyRGF0ZSk7XHJcbiAgICBpZiAocHJldkRhdGUgJiYgXCJ5ZWFyXCIgIT09IHRpY2tJbnRlcnZhbCkge1xyXG4gICAgICAgIHByZXBhcmVEYXRlc0RpZmZlcmVuY2VzKGRhdGVzRGlmZmVyZW5jZXMsIHRpY2tJbnRlcnZhbCk7XHJcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0SGVscGVyLmdldERhdGVGb3JtYXRCeURpZmZlcmVuY2VzKGRhdGVzRGlmZmVyZW5jZXMpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZm9ybWF0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE1heFNpZGUoYWN0LCBib3hlcykge1xyXG4gICAgcmV0dXJuIGJveGVzLnJlZHVjZSgoZnVuY3Rpb24ocHJldlZhbHVlLCBib3gpIHtcclxuICAgICAgICByZXR1cm4gX21heChwcmV2VmFsdWUsIGFjdChib3gpKVxyXG4gICAgfSksIDApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERpc3RhbmNlQnlBbmdsZShiQm94LCByb3RhdGlvbkFuZ2xlKSB7XHJcbiAgICByb3RhdGlvbkFuZ2xlID0gX21hdGguYWJzKHJvdGF0aW9uQW5nbGUpO1xyXG4gICAgcm90YXRpb25BbmdsZSA9IHJvdGF0aW9uQW5nbGUgJSAxODAgPj0gOTAgPyA5MCAtIHJvdGF0aW9uQW5nbGUgJSA5MCA6IHJvdGF0aW9uQW5nbGUgJSA5MDtcclxuICAgIHZhciBhID0gcm90YXRpb25BbmdsZSAqIChfbWF0aC5QSSAvIDE4MCk7XHJcbiAgICBpZiAoYSA+PSBfbWF0aC5hdGFuKGJCb3guaGVpZ2h0IC8gYkJveC53aWR0aCkpIHtcclxuICAgICAgICByZXR1cm4gYkJveC5oZWlnaHQgLyBfbWF0aC5hYnMoX21hdGguc2luKGEpKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYkJveC53aWR0aFxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNYXhDb25zdGFudExpbmVQYWRkaW5nKGNvbnN0YW50TGluZXMpIHtcclxuICAgIHJldHVybiBjb25zdGFudExpbmVzLnJlZHVjZSgoZnVuY3Rpb24ocGFkZGluZywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfbWF4KHBhZGRpbmcsIG9wdGlvbnMucGFkZGluZ1RvcEJvdHRvbSlcclxuICAgIH0pLCAwKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb25zdGFudExpbmVMYWJlbE1hcmdpbkZvclZlcnRpY2FsQWxpZ25tZW50KGNvbnN0YW50TGluZXMsIGFsaWdubWVudCwgbGFiZWxIZWlnaHQpIHtcclxuICAgIHJldHVybiBjb25zdGFudExpbmVzLnNvbWUoKGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gb3B0aW9ucy5sYWJlbC52ZXJ0aWNhbEFsaWdubWVudCA9PT0gYWxpZ25tZW50XHJcbiAgICB9KSkgJiYgbGFiZWxIZWlnaHQgfHwgMFxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRMZWZ0TWFyZ2luKGJCb3gpIHtcclxuICAgIHJldHVybiBfbWF0aC5hYnMoYkJveC54KSB8fCAwXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFJpZ2h0TWFyZ2luKGJCb3gpIHtcclxuICAgIHJldHVybiBfbWF0aC5hYnMoYkJveC53aWR0aCAtIF9tYXRoLmFicyhiQm94LngpKSB8fCAwXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlUmFuZ2VzT25Qb2ludHMocG9pbnRzLCBlZGdlUG9pbnRzLCBnZXRSYW5nZSkge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgbGVuZ3RoO1xyXG4gICAgdmFyIG1heFJhbmdlID0gbnVsbDtcclxuICAgIHZhciByYW5nZXMgPSBbXTtcclxuICAgIHZhciBjdXJWYWx1ZTtcclxuICAgIHZhciBwcmV2VmFsdWU7XHJcbiAgICB2YXIgY3VyUmFuZ2U7XHJcbiAgICBmb3IgKGkgPSAxLCBsZW5ndGggPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjdXJWYWx1ZSA9IHBvaW50c1tpXTtcclxuICAgICAgICBwcmV2VmFsdWUgPSBwb2ludHNbaSAtIDFdO1xyXG4gICAgICAgIGN1clJhbmdlID0gZ2V0UmFuZ2UoY3VyVmFsdWUsIHByZXZWYWx1ZSk7XHJcbiAgICAgICAgaWYgKGVkZ2VQb2ludHMuaW5kZXhPZihjdXJWYWx1ZSkgPj0gMCkge1xyXG4gICAgICAgICAgICBpZiAoIW1heFJhbmdlIHx8IGN1clJhbmdlID4gbWF4UmFuZ2UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhSYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydDogY3VyVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBjdXJSYW5nZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG1heFJhbmdlICYmIGN1clJhbmdlIDwgbWF4UmFuZ2UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChtYXhSYW5nZSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydDogY3VyVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBjdXJSYW5nZVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXhSYW5nZSA9IG51bGxcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobWF4UmFuZ2UpIHtcclxuICAgICAgICByYW5nZXMucHVzaChtYXhSYW5nZSlcclxuICAgIH1cclxuICAgIHJldHVybiByYW5nZXNcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVBdXRvQnJlYWtzKF9yZWYsIHNlcmllcywgX3JlZjIpIHtcclxuICAgIHZhciB7XHJcbiAgICAgICAgbG9nYXJpdGhtQmFzZTogbG9nYXJpdGhtQmFzZSxcclxuICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgIG1heEF1dG9CcmVha0NvdW50OiBtYXhBdXRvQnJlYWtDb3VudFxyXG4gICAgfSA9IF9yZWY7XHJcbiAgICB2YXIge1xyXG4gICAgICAgIG1pblZpc2libGU6IG1pblZpc2libGUsXHJcbiAgICAgICAgbWF4VmlzaWJsZTogbWF4VmlzaWJsZVxyXG4gICAgfSA9IF9yZWYyO1xyXG4gICAgdmFyIGJyZWFrcyA9IFtdO1xyXG4gICAgdmFyIGdldFJhbmdlID0gXCJsb2dhcml0aG1pY1wiID09PSB0eXBlID8gKG1pbiwgbWF4KSA9PiBnZXRMb2cobWF4IC8gbWluLCBsb2dhcml0aG1CYXNlKSA6IChtaW4sIG1heCkgPT4gbWF4IC0gbWluO1xyXG4gICAgdmFyIHZpc2libGVSYW5nZSA9IGdldFJhbmdlKG1pblZpc2libGUsIG1heFZpc2libGUpO1xyXG4gICAgdmFyIHBvaW50cyA9IHNlcmllcy5yZWR1Y2UoKHJlc3VsdCwgcykgPT4ge1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBzLmdldFBvaW50c0luVmlld1BvcnQoKTtcclxuICAgICAgICByZXN1bHRbMF0gPSByZXN1bHRbMF0uY29uY2F0KHBvaW50c1swXSk7XHJcbiAgICAgICAgcmVzdWx0WzFdID0gcmVzdWx0WzFdLmNvbmNhdChwb2ludHNbMV0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRcclxuICAgIH0sIFtcclxuICAgICAgICBbXSxcclxuICAgICAgICBbXVxyXG4gICAgXSk7XHJcbiAgICB2YXIgc29ydGVkQWxsUG9pbnRzID0gcG9pbnRzWzBdLmNvbmNhdChwb2ludHNbMV0pLnNvcnQoKGEsIGIpID0+IGIgLSBhKTtcclxuICAgIHZhciBlZGdlUG9pbnRzID0gcG9pbnRzWzFdLmZpbHRlcihwID0+IHBvaW50c1swXS5pbmRleE9mKHApIDwgMCk7XHJcbiAgICB2YXIgbWluRGlmZiA9IFJBTkdFX1JBVElPICogdmlzaWJsZVJhbmdlO1xyXG4gICAgdmFyIHJhbmdlcyA9IGdlbmVyYXRlUmFuZ2VzT25Qb2ludHMoc29ydGVkQWxsUG9pbnRzLCBlZGdlUG9pbnRzLCBnZXRSYW5nZSkuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7XHJcbiAgICB2YXIgZXBzaWxvbiA9IF9tYXRoLm1pbi5hcHBseShudWxsLCByYW5nZXMubWFwKHIgPT4gci5sZW5ndGgpKSAvIDFlMztcclxuICAgIHZhciBfbWF4QXV0b0JyZWFrQ291bnQgPSBpc0RlZmluZWQobWF4QXV0b0JyZWFrQ291bnQpID8gX21hdGgubWluKG1heEF1dG9CcmVha0NvdW50LCByYW5nZXMubGVuZ3RoKSA6IHJhbmdlcy5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9tYXhBdXRvQnJlYWtDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHJhbmdlc1tpXS5sZW5ndGggPj0gbWluRGlmZikge1xyXG4gICAgICAgICAgICBpZiAodmlzaWJsZVJhbmdlIDw9IHJhbmdlc1tpXS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmlzaWJsZVJhbmdlIC09IHJhbmdlc1tpXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmICh2aXNpYmxlUmFuZ2UgPiBlcHNpbG9uIHx8IHZpc2libGVSYW5nZSA8IC1lcHNpbG9uKSB7XHJcbiAgICAgICAgICAgICAgICBicmVha3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcmFuZ2VzW2ldLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRvOiByYW5nZXNbaV0uZW5kXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG1pbkRpZmYgPSBSQU5HRV9SQVRJTyAqIHZpc2libGVSYW5nZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzb3J0aW5nQnJlYWtzKGJyZWFrcyk7XHJcbiAgICByZXR1cm4gYnJlYWtzXHJcbn1cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgbGluZWFyOiB7XHJcbiAgICAgICAgX2dldFN0ZXA6IGZ1bmN0aW9uKGJveGVzLCByb3RhdGlvbkFuZ2xlKSB7XHJcbiAgICAgICAgICAgIHZhciBzcGFjaW5nID0gdGhpcy5fb3B0aW9ucy5sYWJlbC5taW5TcGFjaW5nO1xyXG4gICAgICAgICAgICB2YXIgZnVuYyA9IHRoaXMuX2lzSG9yaXpvbnRhbCA/IGZ1bmN0aW9uKGJveCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJveC53aWR0aCArIHNwYWNpbmdcclxuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKGJveCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJveC5oZWlnaHRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIG1heExhYmVsTGVuZ3RoID0gZ2V0TWF4U2lkZShmdW5jLCBib3hlcyk7XHJcbiAgICAgICAgICAgIGlmIChyb3RhdGlvbkFuZ2xlKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhMYWJlbExlbmd0aCA9IGdldERpc3RhbmNlQnlBbmdsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG1heExhYmVsTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5fZ2V0TWF4TGFiZWxIZWlnaHQoYm94ZXMsIDApXHJcbiAgICAgICAgICAgICAgICB9LCByb3RhdGlvbkFuZ2xlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb25zdGFudHMuZ2V0VGlja3NDb3VudEluUmFuZ2UodGhpcy5fbWFqb3JUaWNrcywgdGhpcy5faXNIb3Jpem9udGFsID8gXCJ4XCIgOiBcInlcIiwgbWF4TGFiZWxMZW5ndGgpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0TWF4TGFiZWxIZWlnaHQ6IGZ1bmN0aW9uKGJveGVzLCBzcGFjaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRNYXhTaWRlKChmdW5jdGlvbihib3gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBib3guaGVpZ2h0XHJcbiAgICAgICAgICAgIH0pLCBib3hlcykgKyBzcGFjaW5nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfdmFsaWRhdGVPdmVybGFwcGluZ01vZGU6IGZ1bmN0aW9uKG1vZGUsIGRpc3BsYXlNb2RlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0hvcml6b250YWwgJiYgKFwicm90YXRlXCIgPT09IGRpc3BsYXlNb2RlIHx8IFwic3RhZ2dlclwiID09PSBkaXNwbGF5TW9kZSkgfHwgIXRoaXMuX2lzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50cy52YWxpZGF0ZU92ZXJsYXBwaW5nTW9kZShtb2RlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtb2RlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfdmFsaWRhdGVEaXNwbGF5TW9kZTogZnVuY3Rpb24obW9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNIb3Jpem9udGFsID8gbW9kZSA6IFwic3RhbmRhcmRcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0TWFya2VyVHJhY2tlcnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFya2VyVHJhY2tlcnNcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRTaGFycFBhcmFtOiBmdW5jdGlvbihvcHBvc2l0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNIb3Jpem9udGFsIF4gb3Bwb3NpdGUgPyBcImhcIiA6IFwidlwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfY3JlYXRlQXhpc0VsZW1lbnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIucGF0aChbXSwgXCJsaW5lXCIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfdXBkYXRlQXhpc0VsZW1lbnRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBheGlzQ29vcmQgPSB0aGlzLl9heGlzUG9zaXRpb247XHJcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9nZXRDYW52YXNTdGFydEVuZCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9heGlzRWxlbWVudC5hdHRyKHtcclxuICAgICAgICAgICAgICAgIHBvaW50czogdGhpcy5faXNIb3Jpem9udGFsID8gW2NhbnZhcy5zdGFydCwgYXhpc0Nvb3JkLCBjYW52YXMuZW5kLCBheGlzQ29vcmRdIDogW2F4aXNDb29yZCwgY2FudmFzLnN0YXJ0LCBheGlzQ29vcmQsIGNhbnZhcy5lbmRdXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0VHJhbnNsYXRlZENvb3JkOiBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2xhdG9yLnRyYW5zbGF0ZSh2YWx1ZSwgb2Zmc2V0KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2luaXRBeGlzUG9zaXRpb25zKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXN0b21Qb3NpdGlvbklzQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1c3RvbUJvdW5kYXJ5UG9zaXRpb24gPSB0aGlzLmdldEN1c3RvbUJvdW5kYXJ5UG9zaXRpb24oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXN0b21Qb3NpdGlvbklzQXZhaWxhYmxlKCkgfHwgdGhpcy5jdXN0b21Qb3NpdGlvbklzQm91bmRhcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXhpc1Bvc2l0aW9uID0gdGhpcy5nZXRQcmVkZWZpbmVkUG9zaXRpb24odGhpcy5nZXRSZXNvbHZlZEJvdW5kYXJ5UG9zaXRpb24oKSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2F4aXNQb3NpdGlvbiA9IHRoaXMuZ2V0Q3VzdG9tUG9zaXRpb24oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0VGlja01hcmtQb2ludHMoY29vcmRzLCBsZW5ndGgsIHRpY2tPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBpc0hvcml6b250YWwgPSB0aGlzLl9pc0hvcml6b250YWw7XHJcbiAgICAgICAgICAgIHZhciB0aWNrT3JpZW50YXRpb24gPSB0aGlzLl9vcHRpb25zLnRpY2tPcmllbnRhdGlvbjtcclxuICAgICAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSB0aGlzLl9vcHRpb25zLmxhYmVsLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB2YXIgdGlja1N0YXJ0Q29vcmQ7XHJcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQodGlja09yaWVudGF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdGlja1N0YXJ0Q29vcmQgPSBUSUNLU19DT1JSRUNUSU9OU1t0aWNrT3JpZW50YXRpb25dICogbGVuZ3RoXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hpZnQgPSB0aWNrT3B0aW9ucy5zaGlmdCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0hvcml6b250YWwgJiYgbGFiZWxQb3NpdGlvbiA9PT0gTEVGVCB8fCBpc0hvcml6b250YWwgJiYgbGFiZWxQb3NpdGlvbiAhPT0gQk9UVE9NKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAtc2hpZnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRpY2tTdGFydENvb3JkID0gc2hpZnQgKyB0aGlzLmdldFRpY2tTdGFydFBvc2l0aW9uU2hpZnQobGVuZ3RoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbY29vcmRzLnggKyAoaXNIb3Jpem9udGFsID8gMCA6IHRpY2tTdGFydENvb3JkKSwgY29vcmRzLnkgKyAoaXNIb3Jpem9udGFsID8gdGlja1N0YXJ0Q29vcmQgOiAwKSwgY29vcmRzLnggKyAoaXNIb3Jpem9udGFsID8gMCA6IHRpY2tTdGFydENvb3JkICsgbGVuZ3RoKSwgY29vcmRzLnkgKyAoaXNIb3Jpem9udGFsID8gdGlja1N0YXJ0Q29vcmQgKyBsZW5ndGggOiAwKV1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFRpY2tTdGFydFBvc2l0aW9uU2hpZnQobGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX29wdGlvbnMud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0UmVzb2x2ZWRCb3VuZGFyeVBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGggJSAyID09PSAxID8gd2lkdGggJSAyID09PSAwICYmIChwb3NpdGlvbiA9PT0gTEVGVCB8fCBwb3NpdGlvbiA9PT0gVE9QKSB8fCB3aWR0aCAlIDIgPT09IDEgJiYgKHBvc2l0aW9uID09PSBSSUdIVCB8fCBwb3NpdGlvbiA9PT0gQk9UVE9NKSAmJiAhdGhpcy5oYXNOb25Cb3VuZGFyeVBvc2l0aW9uKCkgPyBNYXRoLmZsb29yKC1sZW5ndGggLyAyKSA6IC1NYXRoLmZsb29yKGxlbmd0aCAvIDIpIDogLWxlbmd0aCAvIDIgKyAod2lkdGggJSAyID09PSAwID8gMCA6IHBvc2l0aW9uID09PSBCT1RUT00gfHwgcG9zaXRpb24gPT09IFJJR0hUID8gLTEgOiAxKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFRpdGxlQ29vcmRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWwgPSB0aGlzLl9pc0hvcml6b250YWw7XHJcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5fYXhpc1Bvc2l0aW9uO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHRoaXMuX2F4aXNQb3NpdGlvbjtcclxuICAgICAgICAgICAgdmFyIGFsaWduID0gdGhpcy5fb3B0aW9ucy50aXRsZS5hbGlnbm1lbnQ7XHJcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9nZXRDYW52YXNTdGFydEVuZCgpO1xyXG4gICAgICAgICAgICB2YXIgZnJvbVN0YXJ0VG9FbmQgPSBob3Jpem9udGFsIHx8IHRoaXMuX29wdGlvbnMucG9zaXRpb24gPT09IExFRlQ7XHJcbiAgICAgICAgICAgIHZhciBjYW52YXNTdGFydCA9IGZyb21TdGFydFRvRW5kID8gY2FudmFzLnN0YXJ0IDogY2FudmFzLmVuZDtcclxuICAgICAgICAgICAgdmFyIGNhbnZhc0VuZCA9IGZyb21TdGFydFRvRW5kID8gY2FudmFzLmVuZCA6IGNhbnZhcy5zdGFydDtcclxuICAgICAgICAgICAgdmFyIGNvb3JkID0gYWxpZ24gPT09IExFRlQgPyBjYW52YXNTdGFydCA6IGFsaWduID09PSBSSUdIVCA/IGNhbnZhc0VuZCA6IGNhbnZhcy5zdGFydCArIChjYW52YXMuZW5kIC0gY2FudmFzLnN0YXJ0KSAvIDI7XHJcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gY29vcmRcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHkgPSBjb29yZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgeTogeVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZHJhd1RpdGxlVGV4dDogZnVuY3Rpb24oZ3JvdXAsIGNvb3Jkcykge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnM7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZU9wdGlvbnMgPSBvcHRpb25zLnRpdGxlO1xyXG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB7XHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aXRsZU9wdGlvbnMub3BhY2l0eSxcclxuICAgICAgICAgICAgICAgIGFsaWduOiB0aXRsZU9wdGlvbnMuYWxpZ25tZW50LFxyXG4gICAgICAgICAgICAgICAgY2xhc3M6IHRpdGxlT3B0aW9ucy5jc3NDbGFzc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoIXRpdGxlT3B0aW9ucy50ZXh0IHx8ICFncm91cCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29vcmRzID0gY29vcmRzIHx8IHRoaXMuX2dldFRpdGxlQ29vcmRzKCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRycy5yb3RhdGUgPSBvcHRpb25zLnBvc2l0aW9uID09PSBMRUZUID8gMjcwIDogOTBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX3JlbmRlcmVyLnRleHQodGl0bGVPcHRpb25zLnRleHQsIGNvb3Jkcy54LCBjb29yZHMueSkuY3NzKHBhdGNoRm9udE9wdGlvbnModGl0bGVPcHRpb25zLmZvbnQpKS5hdHRyKGF0dHJzKS5hcHBlbmQoZ3JvdXApO1xyXG4gICAgICAgICAgICB0aGlzLl9jaGVja1RpdGxlT3ZlcmZsb3codGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZXh0XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfdXBkYXRlVGl0bGVDb29yZHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLl90aXRsZSAmJiB0aGlzLl90aXRsZS5lbGVtZW50LmF0dHIodGhpcy5fZ2V0VGl0bGVDb29yZHMoKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9kcmF3VGl0bGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLl9kcmF3VGl0bGVUZXh0KHRoaXMuX2F4aXNUaXRsZUdyb3VwKTtcclxuICAgICAgICAgICAgaWYgKHRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aXRsZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB0aXRsZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfbWVhc3VyZVRpdGxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3RpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGl0bGUuYkJveCAmJiAhdGhpcy5fdGl0bGUub3JpZ2luYWxTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGl0bGUub3JpZ2luYWxTaXplID0gdGhpcy5fdGl0bGUuYkJveFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGl0bGUuYkJveCA9IHRoaXMuX3RpdGxlLmVsZW1lbnQuZ2V0QkJveCgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9kcmF3RGF0ZU1hcmtlcjogZnVuY3Rpb24oZGF0ZSwgb3B0aW9ucywgcmFuZ2UpIHtcclxuICAgICAgICAgICAgdmFyIG1hcmtlck9wdGlvbnMgPSB0aGlzLl9vcHRpb25zLm1hcmtlcjtcclxuICAgICAgICAgICAgdmFyIGludmVydCA9IHRoaXMuX3RyYW5zbGF0b3IuZ2V0QnVzaW5lc3NSYW5nZSgpLmludmVydDtcclxuICAgICAgICAgICAgdmFyIHRleHRJbmRlbnQgPSBtYXJrZXJPcHRpb25zLndpZHRoICsgbWFya2VyT3B0aW9ucy50ZXh0TGVmdEluZGVudDtcclxuICAgICAgICAgICAgdmFyIHBhdGhFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gb3B0aW9ucy54KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMud2l0aG91dFN0aWNrKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoRWxlbWVudCA9IHRoaXMuX3JlbmRlcmVyLnBhdGgoW29wdGlvbnMueCwgb3B0aW9ucy55LCBvcHRpb25zLngsIG9wdGlvbnMueSArIG1hcmtlck9wdGlvbnMuc2VwYXJhdG9ySGVpZ2h0XSwgXCJsaW5lXCIpLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IG1hcmtlck9wdGlvbnMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBtYXJrZXJPcHRpb25zLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogbWFya2VyT3B0aW9ucy5vcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgIHNoYXJwOiBcImhcIlxyXG4gICAgICAgICAgICAgICAgfSkuYXBwZW5kKHRoaXMuX2F4aXNFbGVtZW50c0dyb3VwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gU3RyaW5nKHRoaXMuZm9ybWF0TGFiZWwoZGF0ZSwgb3B0aW9ucy5sYWJlbE9wdGlvbnMsIHJhbmdlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLFxyXG4gICAgICAgICAgICAgICAgeDogb3B0aW9ucy54LFxyXG4gICAgICAgICAgICAgICAgeTogb3B0aW9ucy55LFxyXG4gICAgICAgICAgICAgICAgY3JvcHBlZDogb3B0aW9ucy53aXRob3V0U3RpY2ssXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5fcmVuZGVyZXIudGV4dCh0ZXh0LCBvcHRpb25zLngsIG9wdGlvbnMueSkuY3NzKHBhdGNoRm9udE9wdGlvbnMobWFya2VyT3B0aW9ucy5sYWJlbC5mb250KSkuYXBwZW5kKHRoaXMuX2F4aXNFbGVtZW50c0dyb3VwKSxcclxuICAgICAgICAgICAgICAgIGxpbmU6IHBhdGhFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgZ2V0Q29udGVudENvbnRhaW5lcigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdldEVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueCArIChpbnZlcnQgPyAtMSA6IDEpICogKHRleHRJbmRlbnQgKyB0aGlzLmxhYmVsQkJveC53aWR0aClcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXRUaXRsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aXRsZSA9IHRleHRcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBoaWRlTGFiZWw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFiZWwuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFiZWwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGl0bGUgPSB0ZXh0XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhFbGVtZW50LmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aEVsZW1lbnQgPSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFiZWwuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFiZWwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZHJhd0RhdGVNYXJrZXJzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoYXQuX29wdGlvbnM7XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2xhdG9yID0gdGhhdC5fdHJhbnNsYXRvcjtcclxuICAgICAgICAgICAgdmFyIHZpZXdwb3J0ID0gdGhhdC5fZ2V0Vmlld3BvcnRSYW5nZSgpO1xyXG4gICAgICAgICAgICB2YXIgbWluQm91bmQgPSB2aWV3cG9ydC5taW5WaXNpYmxlO1xyXG4gICAgICAgICAgICB2YXIgZGF0ZU1hcmtlcnMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGRhdGVNYXJrZXI7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBkcmF3KG1hcmtlckRhdGUsIGZvcm1hdCwgd2l0aG91dFN0aWNrKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5fZHJhd0RhdGVNYXJrZXIobWFya2VyRGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHRyYW5zbGF0b3IudHJhbnNsYXRlKG1hcmtlckRhdGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IG1hcmtlcnNBcmVhVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsT3B0aW9uczogdGhhdC5fZ2V0TGFiZWxGb3JtYXRPcHRpb25zKGZvcm1hdCksXHJcbiAgICAgICAgICAgICAgICAgICAgd2l0aG91dFN0aWNrOiB3aXRob3V0U3RpY2tcclxuICAgICAgICAgICAgICAgIH0sIHZpZXdwb3J0KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2aWV3cG9ydC5pc0VtcHR5KCkgfHwgIW9wdGlvbnMubWFya2VyLnZpc2libGUgfHwgXCJkYXRldGltZVwiICE9PSBvcHRpb25zLmFyZ3VtZW50VHlwZSB8fCBcImRpc2NyZXRlXCIgPT09IG9wdGlvbnMudHlwZSB8fCB0aGF0Ll9tYWpvclRpY2tzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW11cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWFya2Vyc0FyZWFUb3AgPSB0aGF0Ll9heGlzUG9zaXRpb24gKyBvcHRpb25zLm1hcmtlci50b3BJbmRlbnQ7XHJcbiAgICAgICAgICAgIHZhciB0aWNrSW50ZXJ2YWwgPSBkYXRlVXRpbHMuZ2V0RGF0ZVVuaXRJbnRlcnZhbCh0aGlzLl90aWNrSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB2YXIgbWFya2VySW50ZXJ2YWwgPSBnZXRNYXJrZXJJbnRlcnZhbCh0aWNrSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB2YXIgbWFya2VyRGF0ZXMgPSBnZXRNYXJrZXJEYXRlcyhtaW5Cb3VuZCwgdmlld3BvcnQubWF4VmlzaWJsZSwgbWFya2VySW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICBpZiAobWFya2VyRGF0ZXMubGVuZ3RoID4gMSB8fCAxID09PSBtYXJrZXJEYXRlcy5sZW5ndGggJiYgbWluQm91bmQgPCBtYXJrZXJEYXRlc1swXSkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcnMgPSBtYXJrZXJEYXRlcy5yZWR1Y2UoKGZ1bmN0aW9uKG1hcmtlcnMsIGN1ckRhdGUsIGksIGRhdGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtlciA9IGRyYXcoY3VyRGF0ZSwgZ2V0TWFya2VyRm9ybWF0KGN1ckRhdGUsIGRhdGVzW2kgLSAxXSB8fCBtaW5Cb3VuZCA8IGN1ckRhdGUgJiYgbWluQm91bmQsIHRpY2tJbnRlcnZhbCwgbWFya2VySW50ZXJ2YWwpKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIgJiYgbWFya2Vycy5wdXNoKG1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlcnNcclxuICAgICAgICAgICAgICAgIH0pLCBbXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWluQm91bmQgPCBtYXJrZXJEYXRlc1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVNYXJrZXIgPSBkcmF3KG1pbkJvdW5kLCBnZXRNYXJrZXJGb3JtYXQobWluQm91bmQsIG1hcmtlckRhdGVzWzBdLCB0aWNrSW50ZXJ2YWwsIG1hcmtlckludGVydmFsKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlciAmJiBkYXRlTWFya2Vycy51bnNoaWZ0KGRhdGVNYXJrZXIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVNYXJrZXJzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYWRqdXN0RGF0ZU1hcmtlcnM6IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgbWFya2VyT3B0aW9ucyA9IHRoaXMuX29wdGlvbnMubWFya2VyO1xyXG4gICAgICAgICAgICB2YXIgdGV4dEluZGVudCA9IG1hcmtlck9wdGlvbnMud2lkdGggKyBtYXJrZXJPcHRpb25zLnRleHRMZWZ0SW5kZW50O1xyXG4gICAgICAgICAgICB2YXIgaW52ZXJ0ID0gdGhpcy5fdHJhbnNsYXRvci5nZXRCdXNpbmVzc1JhbmdlKCkuaW52ZXJ0O1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gdGhhdC5fZ2V0Q2FudmFzU3RhcnRFbmQoKTtcclxuICAgICAgICAgICAgdmFyIGRhdGVNYXJrZXJzID0gdGhpcy5fZGF0ZU1hcmtlcnM7XHJcbiAgICAgICAgICAgIGlmICghZGF0ZU1hcmtlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGVNYXJrZXJzWzBdLmNyb3BwZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2hlY2tNYXJrZXJzUG9zaXRpb24oaW52ZXJ0LCBkYXRlTWFya2Vyc1sxXSwgZGF0ZU1hcmtlcnNbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlcnNbMF0uaGlkZUxhYmVsKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcHJldkRhdGVNYXJrZXI7XHJcbiAgICAgICAgICAgIGRhdGVNYXJrZXJzLmZvckVhY2goKGZ1bmN0aW9uKG1hcmtlciwgaSwgbWFya2Vycykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci5jcm9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaW52ZXJ0ID8gbWFya2VyLmdldEVuZCgpIDwgY2FudmFzLmVuZCA6IG1hcmtlci5nZXRFbmQoKSA+IGNhbnZhcy5lbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIuaGlkZUxhYmVsKClcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhhdC5fY2hlY2tNYXJrZXJzUG9zaXRpb24oaW52ZXJ0LCBtYXJrZXIsIHByZXZEYXRlTWFya2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZEYXRlTWFya2VyID0gbWFya2VyXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5oaWRlKClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRlTWFya2Vycy5mb3JFYWNoKChmdW5jdGlvbihtYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxCQm94ID0gbWFya2VyLmxhYmVsQkJveDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSBtYXJrZXIueSArIG1hcmtlck9wdGlvbnMudGV4dFRvcEluZGVudCAtIGxhYmVsQkJveC55O1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5sYWJlbC5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogaW52ZXJ0ID8gbWFya2VyLnggLSB0ZXh0SW5kZW50IC0gbGFiZWxCQm94LnggLSBsYWJlbEJCb3gud2lkdGggOiBtYXJrZXIueCArIHRleHRJbmRlbnQgLSBsYWJlbEJCb3gueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogZHkgKyBvZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLmxpbmUuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IG9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhhdC5faW5pdGlhbGl6ZU1hcmtlcnNUcmFja2VycyhvZmZzZXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgbWFya2VyT3B0aW9ucy50b3BJbmRlbnQgKyBtYXJrZXJPcHRpb25zLnNlcGFyYXRvckhlaWdodFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2NoZWNrTWFya2Vyc1Bvc2l0aW9uOiBmdW5jdGlvbihpbnZlcnQsIGRhdGVNYXJrZXIsIHByZXZEYXRlTWFya2VyKSB7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHByZXZEYXRlTWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZlcnQgPyBkYXRlTWFya2VyLnggPCBwcmV2RGF0ZU1hcmtlci5nZXRFbmQoKSA6IGRhdGVNYXJrZXIueCA+IHByZXZEYXRlTWFya2VyLmdldEVuZCgpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaW5pdGlhbGl6ZU1hcmtlcnNUcmFja2VyczogZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3JIZWlnaHQgPSB0aGlzLl9vcHRpb25zLm1hcmtlci5zZXBhcmF0b3JIZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xyXG4gICAgICAgICAgICB2YXIgYnVzaW5lc3NSYW5nZSA9IHRoaXMuX3RyYW5zbGF0b3IuZ2V0QnVzaW5lc3NSYW5nZSgpO1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5fZ2V0Q2FudmFzU3RhcnRFbmQoKTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5fYXhpc0VsZW1lbnRzR3JvdXA7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtlclRyYWNrZXJzID0gdGhpcy5fZGF0ZU1hcmtlcnMuZmlsdGVyKChmdW5jdGlvbihtYXJrZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhbWFya2VyLmhpZGRlblxyXG4gICAgICAgICAgICB9KSkubWFwKChmdW5jdGlvbihtYXJrZXIsIGksIG1hcmtlcnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0TWFya2VyID0gbWFya2Vyc1tpICsgMV0gfHwge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IGNhbnZhcy5lbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogYnVzaW5lc3NSYW5nZS5tYXhcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IG1hcmtlci54O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBtYXJrZXIueSArIG9mZnNldDtcclxuICAgICAgICAgICAgICAgIHZhciBtYXJrZXJUcmFja2VyID0gcmVuZGVyZXIucGF0aChbeCwgeSwgeCwgeSArIHNlcGFyYXRvckhlaWdodCwgbmV4dE1hcmtlci54LCB5ICsgc2VwYXJhdG9ySGVpZ2h0LCBuZXh0TWFya2VyLngsIHksIHgsIHldLCBcImFyZWFcIikuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMSxcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IFwiZ3JleVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IFwiZ3JleVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFlLTRcclxuICAgICAgICAgICAgICAgIH0pLmFwcGVuZChncm91cCk7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXJUcmFja2VyLmRhdGEoXCJyYW5nZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogbWFya2VyLmRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kVmFsdWU6IG5leHRNYXJrZXIuZGF0ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyLnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyVHJhY2tlci5zZXRUaXRsZShtYXJrZXIudGl0bGUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyVHJhY2tlclxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRMYWJlbEZvcm1hdE9wdGlvbnM6IGZ1bmN0aW9uKGZvcm1hdFN0cmluZykge1xyXG4gICAgICAgICAgICB2YXIgbWFya2VyTGFiZWxPcHRpb25zID0gdGhpcy5fbWFya2VyTGFiZWxPcHRpb25zO1xyXG4gICAgICAgICAgICBpZiAoIW1hcmtlckxhYmVsT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya2VyTGFiZWxPcHRpb25zID0gbWFya2VyTGFiZWxPcHRpb25zID0gZXh0ZW5kKHRydWUsIHt9LCB0aGlzLl9vcHRpb25zLm1hcmtlci5sYWJlbClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLl9vcHRpb25zLm1hcmtlci5sYWJlbC5mb3JtYXQpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXJMYWJlbE9wdGlvbnMuZm9ybWF0ID0gZm9ybWF0U3RyaW5nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1hcmtlckxhYmVsT3B0aW9uc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2FkanVzdENvbnN0YW50TGluZUxhYmVsczogZnVuY3Rpb24oY29uc3RhbnRMaW5lcykge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBheGlzUG9zaXRpb24gPSB0aGF0Ll9vcHRpb25zLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gdGhhdC5nZXRDYW52YXMoKTtcclxuICAgICAgICAgICAgdmFyIGNhbnZhc0xlZnQgPSBjYW52YXMubGVmdDtcclxuICAgICAgICAgICAgdmFyIGNhbnZhc1JpZ2h0ID0gY2FudmFzLndpZHRoIC0gY2FudmFzLnJpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzVG9wID0gY2FudmFzLnRvcDtcclxuICAgICAgICAgICAgdmFyIGNhbnZhc0JvdHRvbSA9IGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuYm90dG9tO1xyXG4gICAgICAgICAgICB2YXIgdmVydGljYWxDZW50ZXIgPSBjYW52YXNUb3AgKyAoY2FudmFzQm90dG9tIC0gY2FudmFzVG9wKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciBob3Jpem9udGFsQ2VudGVyID0gY2FudmFzTGVmdCArIChjYW52YXNSaWdodCAtIGNhbnZhc0xlZnQpIC8gMjtcclxuICAgICAgICAgICAgdmFyIG1heExhYmVsID0gMDtcclxuICAgICAgICAgICAgY29uc3RhbnRMaW5lcy5mb3JFYWNoKChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNIb3Jpem9udGFsID0gdGhhdC5faXNIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVzT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcclxuICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nVG9wQm90dG9tID0gbGluZXNPcHRpb25zLnBhZGRpbmdUb3BCb3R0b207XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0xlZnRSaWdodCA9IGxpbmVzT3B0aW9ucy5wYWRkaW5nTGVmdFJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsT3B0aW9ucyA9IGxpbmVzT3B0aW9ucy5sYWJlbDtcclxuICAgICAgICAgICAgICAgIHZhciBsYWJlbFZlcnRpY2FsQWxpZ25tZW50ID0gbGFiZWxPcHRpb25zLnZlcnRpY2FsQWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsSG9yaXpvbnRhbEFsaWdubWVudCA9IGxhYmVsT3B0aW9ucy5ob3Jpem9udGFsQWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsSXNJbnNpZGUgPSBcImluc2lkZVwiID09PSBsYWJlbE9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBpdGVtLmxhYmVsO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJveCA9IGl0ZW0ubGFiZWxCQm94O1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZVg7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRlWTtcclxuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBsYWJlbCB8fCBib3guaXNFbXB0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbElzSW5zaWRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbEhvcml6b250YWxBbGlnbm1lbnQgPT09IExFRlQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSBpdGVtLmNvb3JkIC0gcGFkZGluZ0xlZnRSaWdodCAtIGJveC54IC0gYm94LndpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYID0gaXRlbS5jb29yZCArIHBhZGRpbmdMZWZ0UmlnaHQgLSBib3gueFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobGFiZWxWZXJ0aWNhbEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDRU5URVI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWSA9IHZlcnRpY2FsQ2VudGVyIC0gYm94LnkgLSBib3guaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQk9UVE9NOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVkgPSBjYW52YXNCb3R0b20gLSBwYWRkaW5nVG9wQm90dG9tIC0gYm94LnkgLSBib3guaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZID0gY2FudmFzVG9wICsgcGFkZGluZ1RvcEJvdHRvbSAtIGJveC55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXhpc1Bvc2l0aW9uID09PSBsYWJlbFZlcnRpY2FsQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhMYWJlbCA9IF9tYXgobWF4TGFiZWwsIGJveC5oZWlnaHQgKyBwYWRkaW5nVG9wQm90dG9tKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSBpdGVtLmNvb3JkIC0gYm94LnggLSBib3gud2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxWZXJ0aWNhbEFsaWdubWVudCA9PT0gQk9UVE9NKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZID0gY2FudmFzQm90dG9tICsgcGFkZGluZ1RvcEJvdHRvbSAtIGJveC55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZID0gY2FudmFzVG9wIC0gcGFkZGluZ1RvcEJvdHRvbSAtIGJveC55IC0gYm94LmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYWJlbElzSW5zaWRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsVmVydGljYWxBbGlnbm1lbnQgPT09IEJPVFRPTSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZID0gaXRlbS5jb29yZCArIHBhZGRpbmdUb3BCb3R0b20gLSBib3gueVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVkgPSBpdGVtLmNvb3JkIC0gcGFkZGluZ1RvcEJvdHRvbSAtIGJveC55IC0gYm94LmhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGxhYmVsSG9yaXpvbnRhbEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENFTlRFUjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSBob3Jpem9udGFsQ2VudGVyIC0gYm94LnggLSBib3gud2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUklHSFQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYID0gY2FudmFzUmlnaHQgLSBwYWRkaW5nTGVmdFJpZ2h0IC0gYm94LnggLSBib3gud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVggPSBjYW52YXNMZWZ0ICsgcGFkZGluZ0xlZnRSaWdodCAtIGJveC54XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpc1Bvc2l0aW9uID09PSBsYWJlbEhvcml6b250YWxBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4TGFiZWwgPSBfbWF4KG1heExhYmVsLCBib3gud2lkdGggKyBwYWRkaW5nTGVmdFJpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZID0gaXRlbS5jb29yZCAtIGJveC55IC0gYm94LmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsSG9yaXpvbnRhbEFsaWdubWVudCA9PT0gUklHSFQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWCA9IGNhbnZhc1JpZ2h0ICsgcGFkZGluZ0xlZnRSaWdodCAtIGJveC54XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWCA9IGNhbnZhc0xlZnQgLSBwYWRkaW5nTGVmdFJpZ2h0IC0gYm94LnggLSBib3gud2lkdGhcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYWJlbC5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYOiB0cmFuc2xhdGVYLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IHRyYW5zbGF0ZVlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1heExhYmVsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZHJhd0NvbnN0YW50TGluZXNGb3JFc3RpbWF0aW5nOiBmdW5jdGlvbihjb25zdGFudExpbmVzKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IHJlbmRlcmVyLmcoKTtcclxuICAgICAgICAgICAgY29uc3RhbnRMaW5lcy5mb3JFYWNoKChmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9kcmF3Q29uc3RhbnRMaW5lTGFiZWxUZXh0KG9wdGlvbnMubGFiZWwudGV4dCwgMCwgMCwgb3B0aW9ucy5sYWJlbCwgZ3JvdXApLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWduOiBcImNlbnRlclwiXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBncm91cC5hcHBlbmQocmVuZGVyZXIucm9vdClcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9lc3RpbWF0ZUxhYmVsSGVpZ2h0OiBmdW5jdGlvbihiQm94LCBsYWJlbE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGJCb3guaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgZHJhd2luZ1R5cGUgPSBsYWJlbE9wdGlvbnMuZHJhd2luZ1R5cGU7XHJcbiAgICAgICAgICAgIGlmIChcInN0YWdnZXJcIiA9PT0gdGhpcy5fdmFsaWRhdGVEaXNwbGF5TW9kZShkcmF3aW5nVHlwZSkgfHwgXCJzdGFnZ2VyXCIgPT09IHRoaXMuX3ZhbGlkYXRlT3ZlcmxhcHBpbmdNb2RlKGxhYmVsT3B0aW9ucy5vdmVybGFwcGluZ0JlaGF2aW9yLCBkcmF3aW5nVHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IDIgKiBoZWlnaHQgKyBsYWJlbE9wdGlvbnMuc3RhZ2dlcmluZ1NwYWNpbmdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoXCJyb3RhdGVcIiA9PT0gdGhpcy5fdmFsaWRhdGVEaXNwbGF5TW9kZShkcmF3aW5nVHlwZSkgfHwgXCJyb3RhdGVcIiA9PT0gdGhpcy5fdmFsaWRhdGVPdmVybGFwcGluZ01vZGUobGFiZWxPcHRpb25zLm92ZXJsYXBwaW5nQmVoYXZpb3IsIGRyYXdpbmdUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpbkNvcyA9IGdldENvc0FuZFNpbihsYWJlbE9wdGlvbnMucm90YXRpb25BbmdsZSk7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKiBzaW5Db3MuY29zICsgYkJveC53aWR0aCAqIHNpbkNvcy5zaW5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaGVpZ2h0ICYmIChoZWlnaHQgKyBsYWJlbE9wdGlvbnMuaW5kZW50RnJvbUF4aXMgfHwgMCkgfHwgMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXN0aW1hdGVNYXJnaW5zOiBmdW5jdGlvbihjYW52YXMpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYW52YXMoY2FudmFzKTtcclxuICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5fZ2V0Vmlld3BvcnRSYW5nZSgpO1xyXG4gICAgICAgICAgICB2YXIgdGlja3NEYXRhID0gdGhpcy5fY3JlYXRlVGlja3NBbmRMYWJlbEZvcm1hdChyYW5nZSk7XHJcbiAgICAgICAgICAgIHZhciB0aWNrcyA9IHRpY2tzRGF0YS50aWNrcztcclxuICAgICAgICAgICAgdmFyIHRpY2tJbnRlcnZhbCA9IHRpY2tzRGF0YS50aWNrSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICAgICAgdmFyIGNvbnN0YW50TGluZU9wdGlvbnMgPSB0aGlzLl9vdXRzaWRlQ29uc3RhbnRMaW5lcy5maWx0ZXIobCA9PiBsLmxhYmVsT3B0aW9ucy52aXNpYmxlKS5tYXAobCA9PiBsLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJlci5yb290O1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxJc1Zpc2libGUgPSBvcHRpb25zLmxhYmVsLnZpc2libGUgJiYgIXJhbmdlLmlzRW1wdHkoKSAmJiB0aWNrcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbFZhbHVlID0gbGFiZWxJc1Zpc2libGUgJiYgdGhpcy5mb3JtYXRMYWJlbCh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSwgb3B0aW9ucy5sYWJlbCwgdm9pZCAwLCB2b2lkIDAsIHRpY2tJbnRlcnZhbCwgdGlja3MpO1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxFbGVtZW50ID0gbGFiZWxJc1Zpc2libGUgJiYgdGhpcy5fcmVuZGVyZXIudGV4dChsYWJlbFZhbHVlLCAwLCAwKS5jc3ModGhpcy5fdGV4dEZvbnRTdHlsZXMpLmF0dHIodGhpcy5fdGV4dE9wdGlvbnMpLmFwcGVuZChyb290RWxlbWVudCk7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZUVsZW1lbnQgPSB0aGlzLl9kcmF3VGl0bGVUZXh0KHJvb3RFbGVtZW50LCB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGNvbnN0YW50TGluZXNMYWJlbHNFbGVtZW50ID0gdGhpcy5fZHJhd0NvbnN0YW50TGluZXNGb3JFc3RpbWF0aW5nKGNvbnN0YW50TGluZU9wdGlvbnMpO1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxCb3ggPSAhb3B0aW9ucy5sYWJlbC50ZW1wbGF0ZSAmJiBsYWJlbEVsZW1lbnQgJiYgbGFiZWxFbGVtZW50LmdldEJCb3goKSB8fCB7XHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciB0aXRsZUJveCA9IHRpdGxlRWxlbWVudCAmJiB0aXRsZUVsZW1lbnQuZ2V0QkJveCgpIHx8IHtcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGNvbnN0YW50TGluZXNCb3ggPSBjb25zdGFudExpbmVzTGFiZWxzRWxlbWVudC5nZXRCQm94KCk7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZUhlaWdodCA9IHRpdGxlQm94LmhlaWdodCA/IHRpdGxlQm94LmhlaWdodCArIG9wdGlvbnMudGl0bGUubWFyZ2luIDogMDtcclxuICAgICAgICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gdGhpcy5fZXN0aW1hdGVMYWJlbEhlaWdodChsYWJlbEJveCwgb3B0aW9ucy5sYWJlbCk7XHJcbiAgICAgICAgICAgIHZhciBjb25zdGFudExpbmVzSGVpZ2h0ID0gY29uc3RhbnRMaW5lc0JveC5oZWlnaHQgPyBjb25zdGFudExpbmVzQm94LmhlaWdodCArIGdldE1heENvbnN0YW50TGluZVBhZGRpbmcoY29uc3RhbnRMaW5lT3B0aW9ucykgOiAwO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gbGFiZWxIZWlnaHQgKyB0aXRsZUhlaWdodDtcclxuICAgICAgICAgICAgdmFyIG1hcmdpbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBfbWF4KGdldExlZnRNYXJnaW4obGFiZWxCb3gpLCBnZXRMZWZ0TWFyZ2luKGNvbnN0YW50TGluZXNCb3gpKSxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiBfbWF4KGdldFJpZ2h0TWFyZ2luKGxhYmVsQm94KSwgZ2V0UmlnaHRNYXJnaW4oY29uc3RhbnRMaW5lc0JveCkpLFxyXG4gICAgICAgICAgICAgICAgdG9wOiAoXCJ0b3BcIiA9PT0gb3B0aW9ucy5wb3NpdGlvbiA/IGhlaWdodCA6IDApICsgZ2V0Q29uc3RhbnRMaW5lTGFiZWxNYXJnaW5Gb3JWZXJ0aWNhbEFsaWdubWVudChjb25zdGFudExpbmVPcHRpb25zLCBcInRvcFwiLCBjb25zdGFudExpbmVzSGVpZ2h0KSxcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogKFwidG9wXCIgIT09IG9wdGlvbnMucG9zaXRpb24gPyBoZWlnaHQgOiAwKSArIGdldENvbnN0YW50TGluZUxhYmVsTWFyZ2luRm9yVmVydGljYWxBbGlnbm1lbnQoY29uc3RhbnRMaW5lT3B0aW9ucywgXCJib3R0b21cIiwgY29uc3RhbnRMaW5lc0hlaWdodClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGFiZWxFbGVtZW50ICYmIGxhYmVsRWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGl0bGVFbGVtZW50ICYmIHRpdGxlRWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgY29uc3RhbnRMaW5lc0xhYmVsc0VsZW1lbnQgJiYgY29uc3RhbnRMaW5lc0xhYmVsc0VsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXJnaW5zXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfY2hlY2tBbGlnbm1lbnRDb25zdGFudExpbmVMYWJlbHM6IGZ1bmN0aW9uKGxhYmVsT3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBsYWJlbE9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbEFsaWdubWVudCA9IChsYWJlbE9wdGlvbnMudmVydGljYWxBbGlnbm1lbnQgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxBbGlnbm1lbnQgPSAobGFiZWxPcHRpb25zLmhvcml6b250YWxBbGlnbm1lbnQgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwib3V0c2lkZVwiID09PSBwb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ25tZW50ID0gdmVydGljYWxBbGlnbm1lbnQgPT09IEJPVFRPTSA/IEJPVFRPTSA6IFRPUDtcclxuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsQWxpZ25tZW50ID0gQ0VOVEVSXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ25tZW50ID0gdmVydGljYWxBbGlnbm1lbnQgPT09IENFTlRFUiA/IENFTlRFUiA6IHZlcnRpY2FsQWxpZ25tZW50ID09PSBCT1RUT00gPyBCT1RUT00gOiBUT1A7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbEFsaWdubWVudCA9IGhvcml6b250YWxBbGlnbm1lbnQgPT09IExFRlQgPyBMRUZUIDogUklHSFRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIm91dHNpZGVcIiA9PT0gcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ25tZW50ID0gQ0VOVEVSO1xyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEFsaWdubWVudCA9IGhvcml6b250YWxBbGlnbm1lbnQgPT09IExFRlQgPyBMRUZUIDogUklHSFRcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ25tZW50ID0gdmVydGljYWxBbGlnbm1lbnQgPT09IEJPVFRPTSA/IEJPVFRPTSA6IFRPUDtcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWxBbGlnbm1lbnQgPSBob3Jpem9udGFsQWxpZ25tZW50ID09PSBSSUdIVCA/IFJJR0hUIDogaG9yaXpvbnRhbEFsaWdubWVudCA9PT0gQ0VOVEVSID8gQ0VOVEVSIDogTEVGVFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhYmVsT3B0aW9ucy52ZXJ0aWNhbEFsaWdubWVudCA9IHZlcnRpY2FsQWxpZ25tZW50O1xyXG4gICAgICAgICAgICBsYWJlbE9wdGlvbnMuaG9yaXpvbnRhbEFsaWdubWVudCA9IGhvcml6b250YWxBbGlnbm1lbnRcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRDb25zdGFudExpbmVMYWJlbHNDb29yZHM6IGZ1bmN0aW9uKHZhbHVlLCBsaW5lTGFiZWxPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHZhciB5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLl9vcnRob2dvbmFsUG9zaXRpb25zW1widG9wXCIgPT09IGxpbmVMYWJlbE9wdGlvbnMudmVydGljYWxBbGlnbm1lbnQgPyBcInN0YXJ0XCIgOiBcImVuZFwiXVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuX29ydGhvZ29uYWxQb3NpdGlvbnNbXCJyaWdodFwiID09PSBsaW5lTGFiZWxPcHRpb25zLmhvcml6b250YWxBbGlnbm1lbnQgPyBcImVuZFwiIDogXCJzdGFydFwiXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgeTogeVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0QWRqdXN0ZWRTdHJpcExhYmVsQ29vcmRzOiBmdW5jdGlvbihzdHJpcCkge1xyXG4gICAgICAgICAgICB2YXIgc3RyaXBPcHRpb25zID0gc3RyaXAub3B0aW9ucztcclxuICAgICAgICAgICAgdmFyIHBhZGRpbmdUb3BCb3R0b20gPSBzdHJpcE9wdGlvbnMucGFkZGluZ1RvcEJvdHRvbTtcclxuICAgICAgICAgICAgdmFyIHBhZGRpbmdMZWZ0UmlnaHQgPSBzdHJpcE9wdGlvbnMucGFkZGluZ0xlZnRSaWdodDtcclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxBbGlnbm1lbnQgPSBzdHJpcE9wdGlvbnMubGFiZWwuaG9yaXpvbnRhbEFsaWdubWVudDtcclxuICAgICAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ25tZW50ID0gc3RyaXBPcHRpb25zLmxhYmVsLnZlcnRpY2FsQWxpZ25tZW50O1xyXG4gICAgICAgICAgICB2YXIgYm94ID0gc3RyaXAubGFiZWxCQm94O1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSBib3guaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IGJveC53aWR0aDtcclxuICAgICAgICAgICAgdmFyIGxhYmVsQ29vcmRzID0gc3RyaXAubGFiZWxDb29yZHM7XHJcbiAgICAgICAgICAgIHZhciB5ID0gbGFiZWxDb29yZHMueSAtIGJveC55O1xyXG4gICAgICAgICAgICB2YXIgeCA9IGxhYmVsQ29vcmRzLnggLSBib3gueDtcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2FsQWxpZ25tZW50ID09PSBUT1ApIHtcclxuICAgICAgICAgICAgICAgIHkgKz0gcGFkZGluZ1RvcEJvdHRvbVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZlcnRpY2FsQWxpZ25tZW50ID09PSBDRU5URVIpIHtcclxuICAgICAgICAgICAgICAgIHkgLT0gbGFiZWxIZWlnaHQgLyAyXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmVydGljYWxBbGlnbm1lbnQgPT09IEJPVFRPTSkge1xyXG4gICAgICAgICAgICAgICAgeSAtPSBwYWRkaW5nVG9wQm90dG9tICsgbGFiZWxIZWlnaHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbEFsaWdubWVudCA9PT0gTEVGVCkge1xyXG4gICAgICAgICAgICAgICAgeCArPSBwYWRkaW5nTGVmdFJpZ2h0XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG9yaXpvbnRhbEFsaWdubWVudCA9PT0gQ0VOVEVSKSB7XHJcbiAgICAgICAgICAgICAgICB4IC09IGxhYmVsV2lkdGggLyAyXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG9yaXpvbnRhbEFsaWdubWVudCA9PT0gUklHSFQpIHtcclxuICAgICAgICAgICAgICAgIHggLT0gcGFkZGluZ0xlZnRSaWdodCArIGxhYmVsV2lkdGhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogeCxcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IHlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2FkanVzdFRpdGxlOiBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgdmFyIG1hcmdpbiA9IG9wdGlvbnMudGl0bGUubWFyZ2luO1xyXG4gICAgICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLl90aXRsZTtcclxuICAgICAgICAgICAgdmFyIGJveFRpdGxlID0gdGl0bGUuYkJveDtcclxuICAgICAgICAgICAgdmFyIHggPSBib3hUaXRsZS54O1xyXG4gICAgICAgICAgICB2YXIgeSA9IGJveFRpdGxlLnk7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGJveFRpdGxlLndpZHRoO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYm94VGl0bGUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgYXhpc1Bvc2l0aW9uID0gdGhpcy5fYXhpc1Bvc2l0aW9uO1xyXG4gICAgICAgICAgICB2YXIgbG9Db29yZCA9IGF4aXNQb3NpdGlvbiAtIG1hcmdpbiAtIG9mZnNldDtcclxuICAgICAgICAgICAgdmFyIGhpQ29vcmQgPSBheGlzUG9zaXRpb24gKyBtYXJnaW4gKyBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBUT1ApIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudHJhbnNsYXRlWSA9IGxvQ29vcmQgLSAoeSArIGhlaWdodClcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnRyYW5zbGF0ZVkgPSBoaUNvb3JkIC0geVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBMRUZUKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudHJhbnNsYXRlWCA9IGxvQ29vcmQgLSAoeCArIHdpZHRoKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnRyYW5zbGF0ZVggPSBoaUNvb3JkIC0geFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpdGxlLmVsZW1lbnQuYXR0cihwYXJhbXMpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfY2hlY2tUaXRsZU92ZXJmbG93OiBmdW5jdGlvbih0aXRsZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl90aXRsZSAmJiAhdGl0bGVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY2FudmFzTGVuZ3RoID0gdGhpcy5fZ2V0U2NyZWVuRGVsdGEoKTtcclxuICAgICAgICAgICAgdmFyIHRpdGxlID0gdGl0bGVFbGVtZW50ID8ge1xyXG4gICAgICAgICAgICAgICAgYkJveDogdGl0bGVFbGVtZW50LmdldEJCb3goKSxcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRpdGxlRWxlbWVudFxyXG4gICAgICAgICAgICB9IDogdGhpcy5fdGl0bGU7XHJcbiAgICAgICAgICAgIHZhciB0aXRsZU9wdGlvbnMgPSB0aGlzLl9vcHRpb25zLnRpdGxlO1xyXG4gICAgICAgICAgICB2YXIgYm94VGl0bGUgPSB0aXRsZS5iQm94O1xyXG4gICAgICAgICAgICBpZiAoKHRoaXMuX2lzSG9yaXpvbnRhbCA/IGJveFRpdGxlLndpZHRoIDogYm94VGl0bGUuaGVpZ2h0KSA+IGNhbnZhc0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGl0bGUuZWxlbWVudC5zZXRNYXhTaXplKGNhbnZhc0xlbmd0aCwgdm9pZCAwLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgd29yZFdyYXA6IHRpdGxlT3B0aW9ucy53b3JkV3JhcCB8fCBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IHRpdGxlT3B0aW9ucy50ZXh0T3ZlcmZsb3cgfHwgXCJlbGxpcHNpc1wiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dyYXBwZWQgPSB0aXRsZU9wdGlvbnMud29yZFdyYXAgJiYgXCJub25lXCIgIT09IHRpdGxlT3B0aW9ucy53b3JkV3JhcFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vcmVUaGFuT3JpZ2luYWxTaXplID0gdGl0bGUub3JpZ2luYWxTaXplICYmIGNhbnZhc0xlbmd0aCA+ICh0aGlzLl9pc0hvcml6b250YWwgPyB0aXRsZS5vcmlnaW5hbFNpemUud2lkdGggOiB0aXRsZS5vcmlnaW5hbFNpemUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICF0aGlzLl93cmFwcGVkICYmIG1vcmVUaGFuT3JpZ2luYWxTaXplICYmIHRpdGxlLmVsZW1lbnQucmVzdG9yZVRleHQoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb29yZHNJbjogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcclxuICAgICAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IHRoaXMuX29wdGlvbnMuaXNIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9vcHRpb25zLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB2YXIgY29vcmQgPSBpc0hvcml6b250YWwgPyB5IDogeDtcclxuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCAmJiAoeCA8IGNhbnZhcy5sZWZ0IHx8IHggPiBjYW52YXMud2lkdGggLSBjYW52YXMucmlnaHQpIHx8ICFpc0hvcml6b250YWwgJiYgKHkgPCBjYW52YXMudG9wIHx8IHkgPiBjYW52YXMuaGVpZ2h0IC0gY2FudmFzLmJvdHRvbSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwgJiYgcG9zaXRpb24gPT09IGNvbnN0YW50cy50b3AgfHwgIWlzSG9yaXpvbnRhbCAmJiBwb3NpdGlvbiA9PT0gY29uc3RhbnRzLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb29yZCA8IGNhbnZhc1twb3NpdGlvbl1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29vcmQgPiBjYW52YXNbaXNIb3Jpem9udGFsID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIl0gLSBjYW52YXNbcG9zaXRpb25dXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYm91bmRhcnlUaWNrc1Zpc2liaWxpdHk6IHtcclxuICAgICAgICAgICAgbWluOiB0cnVlLFxyXG4gICAgICAgICAgICBtYXg6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkanVzdCgpIHtcclxuICAgICAgICAgICAgdmFyIHNlcmllc0RhdGEgPSB0aGlzLl9zZXJpZXNEYXRhO1xyXG4gICAgICAgICAgICB2YXIgdmlld3BvcnQgPSB0aGlzLl9zZXJpZXMuZmlsdGVyKHMgPT4gcy5pc1Zpc2libGUoKSkucmVkdWNlKChyYW5nZSwgcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlcmllc1JhbmdlID0gcy5nZXRWaWV3cG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgcmFuZ2UubWluID0gaXNEZWZpbmVkKHNlcmllc1JhbmdlLm1pbikgPyByYW5nZS5taW4gPCBzZXJpZXNSYW5nZS5taW4gPyByYW5nZS5taW4gOiBzZXJpZXNSYW5nZS5taW4gOiByYW5nZS5taW47XHJcbiAgICAgICAgICAgICAgICByYW5nZS5tYXggPSBpc0RlZmluZWQoc2VyaWVzUmFuZ2UubWF4KSA/IHJhbmdlLm1heCA+IHNlcmllc1JhbmdlLm1heCA/IHJhbmdlLm1heCA6IHNlcmllc1JhbmdlLm1heCA6IHJhbmdlLm1heDtcclxuICAgICAgICAgICAgICAgIGlmIChzLnNob3daZXJvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmNvcnJlY3RWYWx1ZVplcm9MZXZlbCgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VcclxuICAgICAgICAgICAgfSwge30pO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZpZXdwb3J0Lm1pbikgJiYgaXNEZWZpbmVkKHZpZXdwb3J0Lm1heCkpIHtcclxuICAgICAgICAgICAgICAgIHNlcmllc0RhdGEubWluVmlzaWJsZSA9IHZpZXdwb3J0Lm1pbjtcclxuICAgICAgICAgICAgICAgIHNlcmllc0RhdGEubWF4VmlzaWJsZSA9IHZpZXdwb3J0Lm1heFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlcmllc0RhdGEudXNlckJyZWFrcyA9IHRoaXMuX2dldFNjYWxlQnJlYWtzKHRoaXMuX29wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgIG1pblZpc2libGU6IHNlcmllc0RhdGEubWluVmlzaWJsZSxcclxuICAgICAgICAgICAgICAgIG1heFZpc2libGU6IHNlcmllc0RhdGEubWF4VmlzaWJsZVxyXG4gICAgICAgICAgICB9LCB0aGlzLl9zZXJpZXMsIHRoaXMuaXNBcmd1bWVudEF4aXMpO1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2xhdG9yLnVwZGF0ZUJ1c2luZXNzUmFuZ2UodGhpcy5fZ2V0Vmlld3BvcnRSYW5nZSgpKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzV3JhcCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBwZWRcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEF4aXNQb3NpdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F4aXNQb3NpdGlvblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFN0aWNrOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9vcHRpb25zLnZhbHVlTWFyZ2luc0VuYWJsZWRcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRTdHJpcExhYmVsQ29vcmRzOiBmdW5jdGlvbihmcm9tLCB0bywgc3RyaXBMYWJlbE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIG9ydGhvZ29uYWxQb3NpdGlvbnMgPSB0aGlzLl9vcnRob2dvbmFsUG9zaXRpb25zO1xyXG4gICAgICAgICAgICB2YXIgaXNIb3Jpem9udGFsID0gdGhpcy5faXNIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICB2YXIgaG9yaXpvbnRhbEFsaWdubWVudCA9IHN0cmlwTGFiZWxPcHRpb25zLmhvcml6b250YWxBbGlnbm1lbnQ7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbEFsaWdubWVudCA9IHN0cmlwTGFiZWxPcHRpb25zLnZlcnRpY2FsQWxpZ25tZW50O1xyXG4gICAgICAgICAgICB2YXIgeDtcclxuICAgICAgICAgICAgdmFyIHk7XHJcbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChob3Jpem9udGFsQWxpZ25tZW50ID09PSBDRU5URVIpIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gZnJvbSArICh0byAtIGZyb20pIC8gMlxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChob3Jpem9udGFsQWxpZ25tZW50ID09PSBMRUZUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IGZyb21cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaG9yaXpvbnRhbEFsaWdubWVudCA9PT0gUklHSFQpIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gdG9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHkgPSBvcnRob2dvbmFsUG9zaXRpb25zW2dldFN0cmlwVmVydGljYWxBbGlnbm1lbnRQb3NpdGlvbih2ZXJ0aWNhbEFsaWdubWVudCldXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gb3J0aG9nb25hbFBvc2l0aW9uc1tnZXRTdHJpcEhvcml6b250YWxBbGlnbm1lbnRQb3NpdGlvbihob3Jpem9udGFsQWxpZ25tZW50KV07XHJcbiAgICAgICAgICAgICAgICBpZiAodmVydGljYWxBbGlnbm1lbnQgPT09IFRPUCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBmcm9tXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZlcnRpY2FsQWxpZ25tZW50ID09PSBDRU5URVIpIHtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gdG8gKyAoZnJvbSAtIHRvKSAvIDJcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmVydGljYWxBbGlnbm1lbnQgPT09IEJPVFRPTSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSB0b1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgeTogeVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0VHJhbnNsYXRlZFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBwb3MxID0gdGhpcy5fdHJhbnNsYXRvci50cmFuc2xhdGUodmFsdWUsIG9mZnNldCwgXCJzZW1pZGlzY3JldGVcIiA9PT0gdGhpcy5fb3B0aW9ucy50eXBlICYmIHRoaXMuX29wdGlvbnMudGlja0ludGVydmFsKTtcclxuICAgICAgICAgICAgdmFyIHBvczIgPSB0aGlzLl9heGlzUG9zaXRpb247XHJcbiAgICAgICAgICAgIHZhciBpc0hvcml6b250YWwgPSB0aGlzLl9pc0hvcml6b250YWw7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBpc0hvcml6b250YWwgPyBwb3MxIDogcG9zMixcclxuICAgICAgICAgICAgICAgIHk6IGlzSG9yaXpvbnRhbCA/IHBvczIgOiBwb3MxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFyZUNvb3Jkc091dHNpZGVBeGlzOiBmdW5jdGlvbihjb29yZHMpIHtcclxuICAgICAgICAgICAgdmFyIGNvb3JkID0gdGhpcy5faXNIb3Jpem9udGFsID8gY29vcmRzLnggOiBjb29yZHMueTtcclxuICAgICAgICAgICAgdmFyIHZpc2libGVBcmVhID0gdGhpcy5nZXRWaXNpYmxlQXJlYSgpO1xyXG4gICAgICAgICAgICBpZiAoY29vcmQgPCB2aXNpYmxlQXJlYVswXSB8fCBjb29yZCA+IHZpc2libGVBcmVhWzFdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFNraXBwZWRDYXRlZ29yeTogZnVuY3Rpb24odGlja3MpIHtcclxuICAgICAgICAgICAgdmFyIHNraXBwZWRDYXRlZ29yeTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudHlwZSA9PT0gY29uc3RhbnRzLmRpc2NyZXRlICYmIHRoaXMuX3RpY2tPZmZzZXQgJiYgMCAhPT0gdGlja3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBza2lwcGVkQ2F0ZWdvcnkgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBza2lwcGVkQ2F0ZWdvcnlcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9maWx0ZXJCcmVha3M6IGZ1bmN0aW9uKGJyZWFrcywgdmlld3BvcnQsIGJyZWFrU3R5bGUpIHtcclxuICAgICAgICAgICAgdmFyIG1pblZpc2libGUgPSB2aWV3cG9ydC5taW5WaXNpYmxlO1xyXG4gICAgICAgICAgICB2YXIgbWF4VmlzaWJsZSA9IHZpZXdwb3J0Lm1heFZpc2libGU7XHJcbiAgICAgICAgICAgIHZhciBicmVha1NpemUgPSBicmVha1N0eWxlID8gYnJlYWtTdHlsZS53aWR0aCA6IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBicmVha3MucmVkdWNlKChmdW5jdGlvbihyZXN1bHQsIGN1cnJlbnRCcmVhaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSBjdXJyZW50QnJlYWsuZnJvbTtcclxuICAgICAgICAgICAgICAgIHZhciB0byA9IGN1cnJlbnRCcmVhay50bztcclxuICAgICAgICAgICAgICAgIHZhciBsYXN0UmVzdWx0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdCcmVhaztcclxuICAgICAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKGZyb20pIHx8ICFpc0RlZmluZWQodG8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiB0bykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvID0gW2Zyb20sIGZyb20gPSB0b11bMF1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICYmIGZyb20gPCBsYXN0UmVzdWx0LnRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvID4gbGFzdFJlc3VsdC50bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVzdWx0LnRvID0gdG8gPiBtYXhWaXNpYmxlID8gbWF4VmlzaWJsZSA6IHRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFJlc3VsdC5nYXBTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVzdWx0LmdhcFNpemUgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVzdWx0LmN1bXVsYXRpdmVXaWR0aCArPSBicmVha1NpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJvbSA+PSBtaW5WaXNpYmxlICYmIGZyb20gPCBtYXhWaXNpYmxlIHx8IHRvIDw9IG1heFZpc2libGUgJiYgdG8gPiBtaW5WaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IGZyb20gPj0gbWluVmlzaWJsZSA/IGZyb20gOiBtaW5WaXNpYmxlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvID0gdG8gPD0gbWF4VmlzaWJsZSA/IHRvIDogbWF4VmlzaWJsZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG8gLSBmcm9tIDwgbWF4VmlzaWJsZSAtIG1pblZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9sYXN0UmVzdWx0JGN1bXVsYXRpdjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QnJlYWsgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VtdWxhdGl2ZVdpZHRoOiAobnVsbCAhPT0gKF9sYXN0UmVzdWx0JGN1bXVsYXRpdiA9IG51bGwgPT09IGxhc3RSZXN1bHQgfHwgdm9pZCAwID09PSBsYXN0UmVzdWx0ID8gdm9pZCAwIDogbGFzdFJlc3VsdC5jdW11bGF0aXZlV2lkdGgpICYmIHZvaWQgMCAhPT0gX2xhc3RSZXN1bHQkY3VtdWxhdGl2ID8gX2xhc3RSZXN1bHQkY3VtdWxhdGl2IDogMCkgKyBicmVha1NpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCcmVhay5nYXBTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2xhc3RSZXN1bHQkY3VtdWxhdGl2MjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0JyZWFrLmdhcFNpemUgPSBkYXRlVXRpbHMuY29udmVydE1pbGxpc2Vjb25kc1RvRGF0ZVVuaXRzKHRvIC0gZnJvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdCcmVhay5jdW11bGF0aXZlV2lkdGggPSBudWxsICE9PSAoX2xhc3RSZXN1bHQkY3VtdWxhdGl2MiA9IG51bGwgPT09IGxhc3RSZXN1bHQgfHwgdm9pZCAwID09PSBsYXN0UmVzdWx0ID8gdm9pZCAwIDogbGFzdFJlc3VsdC5jdW11bGF0aXZlV2lkdGgpICYmIHZvaWQgMCAhPT0gX2xhc3RSZXN1bHQkY3VtdWxhdGl2MiA/IF9sYXN0UmVzdWx0JGN1bXVsYXRpdjIgOiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3QnJlYWspXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICAgICAgICB9KSwgW10pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0U2NhbGVCcmVha3M6IGZ1bmN0aW9uKGF4aXNPcHRpb25zLCB2aWV3cG9ydCwgc2VyaWVzLCBpc0FyZ3VtZW50QXhpcykge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBicmVha3MgPSAoYXhpc09wdGlvbnMuYnJlYWtzIHx8IFtdKS5tYXAoKGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdGhhdC5wYXJzZXIoYi5zdGFydFZhbHVlKSxcclxuICAgICAgICAgICAgICAgICAgICB0bzogdGhhdC5wYXJzZXIoYi5lbmRWYWx1ZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBpZiAoXCJkaXNjcmV0ZVwiICE9PSBheGlzT3B0aW9ucy50eXBlICYmIFwiZGF0ZXRpbWVcIiA9PT0gYXhpc09wdGlvbnMuZGF0YVR5cGUgJiYgYXhpc09wdGlvbnMud29ya2RheXNPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICBicmVha3MgPSBicmVha3MuY29uY2F0KGdlbmVyYXRlRGF0ZUJyZWFrcyh2aWV3cG9ydC5taW5WaXNpYmxlLCB2aWV3cG9ydC5tYXhWaXNpYmxlLCBheGlzT3B0aW9ucy53b3JrV2VlaywgYXhpc09wdGlvbnMuc2luZ2xlV29ya2RheXMsIGF4aXNPcHRpb25zLmhvbGlkYXlzKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzQXJndW1lbnRBeGlzICYmIFwiZGlzY3JldGVcIiAhPT0gYXhpc09wdGlvbnMudHlwZSAmJiBcImRhdGV0aW1lXCIgIT09IGF4aXNPcHRpb25zLmRhdGFUeXBlICYmIGF4aXNPcHRpb25zLmF1dG9CcmVha3NFbmFibGVkICYmIDAgIT09IGF4aXNPcHRpb25zLm1heEF1dG9CcmVha0NvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBicmVha3MgPSBicmVha3MuY29uY2F0KGdlbmVyYXRlQXV0b0JyZWFrcyhheGlzT3B0aW9ucywgc2VyaWVzLCB2aWV3cG9ydCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNvcnRpbmdCcmVha3MoYnJlYWtzKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2RyYXdCcmVhazogZnVuY3Rpb24odHJhbnNsYXRlZEVuZCwgcG9zaXRpb25Gcm9tLCBwb3NpdGlvblRvLCB3aWR0aCwgb3B0aW9ucywgZ3JvdXApIHtcclxuICAgICAgICAgICAgdmFyIGJyZWFrU3RhcnQgPSB0cmFuc2xhdGVkRW5kIC0gKCF0aGlzLl90cmFuc2xhdG9yLmlzSW52ZXJ0ZWQoKSA/IHdpZHRoICsgMSA6IDApO1xyXG4gICAgICAgICAgICB2YXIgYXR0ciA9IHtcclxuICAgICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDEsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBzaGFycDogIW9wdGlvbnMuaXNXYXZlZCA/IG9wdGlvbnMuaXNIb3Jpem9udGFsID8gXCJoXCIgOiBcInZcIiA6IHZvaWQgMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgc3BhY2VBdHRyID0ge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBvcHRpb25zLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogd2lkdGhcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGdldFBvaW50cyA9IHRoaXMuX2lzSG9yaXpvbnRhbCA/IHJvdGF0ZUxpbmUgOiBmdW5jdGlvbihwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZHJhd2VyID0gZ2V0TGluZURyYXdlcih0aGlzLl9yZW5kZXJlciwgZ3JvdXAsIGdldFBvaW50cywgcG9zaXRpb25Gcm9tLCBicmVha1N0YXJ0LCBwb3NpdGlvblRvLCBvcHRpb25zLmlzV2F2ZWQpO1xyXG4gICAgICAgICAgICBkcmF3ZXIod2lkdGggLyAyLCBzcGFjZUF0dHIpO1xyXG4gICAgICAgICAgICBkcmF3ZXIoMCwgYXR0cik7XHJcbiAgICAgICAgICAgIGRyYXdlcih3aWR0aCwgYXR0cilcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9jcmVhdGVCcmVha0NsaXBSZWN0OiBmdW5jdGlvbihmcm9tLCB0bykge1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xyXG4gICAgICAgICAgICB2YXIgY2xpcFdpZHRoID0gdG8gLSBmcm9tO1xyXG4gICAgICAgICAgICB2YXIgY2xpcFJlY3Q7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgIGNsaXBSZWN0ID0gdGhpcy5fcmVuZGVyZXIuY2xpcFJlY3QoY2FudmFzLmxlZnQsIGZyb20sIGNhbnZhcy53aWR0aCwgY2xpcFdpZHRoKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xpcFJlY3QgPSB0aGlzLl9yZW5kZXJlci5jbGlwUmVjdChmcm9tLCBjYW52YXMudG9wLCBjbGlwV2lkdGgsIGNhbnZhcy5oZWlnaHQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYnJlYWtzRWxlbWVudHMgPSB0aGlzLl9icmVha3NFbGVtZW50cyB8fCBbXTtcclxuICAgICAgICAgICAgdGhpcy5fYnJlYWtzRWxlbWVudHMucHVzaChjbGlwUmVjdCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjbGlwUmVjdC5pZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2NyZWF0ZUJyZWFrc0dyb3VwOiBmdW5jdGlvbihjbGlwRnJvbSwgY2xpcFRvKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuX3JlbmRlcmVyLmcoKS5hdHRyKHtcclxuICAgICAgICAgICAgICAgIGNsYXNzOiB0aGlzLl9heGlzQ3NzUHJlZml4ICsgXCJicmVha3NcIixcclxuICAgICAgICAgICAgICAgIFwiY2xpcC1wYXRoXCI6IHRoaXMuX2NyZWF0ZUJyZWFrQ2xpcFJlY3QoY2xpcEZyb20sIGNsaXBUbylcclxuICAgICAgICAgICAgfSkuYXBwZW5kKHRoaXMuX3NjYWxlQnJlYWtzR3JvdXApO1xyXG4gICAgICAgICAgICB0aGlzLl9icmVha3NFbGVtZW50cyA9IHRoaXMuX2JyZWFrc0VsZW1lbnRzIHx8IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9icmVha3NFbGVtZW50cy5wdXNoKGdyb3VwKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZGlzcG9zZUJyZWFrc0dyb3VwOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgKHRoaXMuX2JyZWFrc0VsZW1lbnRzIHx8IFtdKS5mb3JFYWNoKChmdW5jdGlvbihjbGlwUmVjdCkge1xyXG4gICAgICAgICAgICAgICAgY2xpcFJlY3QuZGlzcG9zZSgpXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5fYnJlYWtzRWxlbWVudHMgPSBudWxsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkcmF3U2NhbGVCcmVha3M6IGZ1bmN0aW9uKGN1c3RvbUNhbnZhcykge1xyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhhdC5fb3B0aW9ucztcclxuICAgICAgICAgICAgdmFyIGJyZWFrU3R5bGUgPSBvcHRpb25zLmJyZWFrU3R5bGU7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkZyb207XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvblRvO1xyXG4gICAgICAgICAgICB2YXIgYnJlYWtzID0gdGhhdC5fdHJhbnNsYXRvci5nZXRCdXNpbmVzc1JhbmdlKCkuYnJlYWtzIHx8IFtdO1xyXG4gICAgICAgICAgICB2YXIgYWRkaXRpb25Hcm91cDtcclxuICAgICAgICAgICAgdmFyIGFkZGl0aW9uQnJlYWtGcm9tO1xyXG4gICAgICAgICAgICB2YXIgYWRkaXRpb25CcmVha1RvO1xyXG4gICAgICAgICAgICB0aGF0Ll9kaXNwb3NlQnJlYWtzR3JvdXAoKTtcclxuICAgICAgICAgICAgaWYgKCEoYnJlYWtzICYmIGJyZWFrcy5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYnJlYWtPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoYXQuX29wdGlvbnMuY29udGFpbmVyQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogYnJlYWtTdHlsZS5jb2xvcixcclxuICAgICAgICAgICAgICAgIGlzSG9yaXpvbnRhbDogdGhhdC5faXNIb3Jpem9udGFsLFxyXG4gICAgICAgICAgICAgICAgaXNXYXZlZDogXCJzdHJhaWdodFwiICE9PSBicmVha1N0eWxlLmxpbmUudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoY3VzdG9tQ2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkZyb20gPSBjdXN0b21DYW52YXMuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvblRvID0gY3VzdG9tQ2FudmFzLmVuZFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25Gcm9tID0gdGhhdC5fb3J0aG9nb25hbFBvc2l0aW9ucy5zdGFydCAtIChvcHRpb25zLnZpc2libGUgJiYgIXRoYXQuX2F4aXNTaGlmdCAmJiAocG9zaXRpb24gPT09IExFRlQgfHwgcG9zaXRpb24gPT09IFRPUCkgPyBTQ0FMRV9CUkVBS19PRkZTRVQgOiAwKTtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uVG8gPSB0aGF0Ll9vcnRob2dvbmFsUG9zaXRpb25zLmVuZCArIChvcHRpb25zLnZpc2libGUgJiYgKHBvc2l0aW9uID09PSBSSUdIVCB8fCBwb3NpdGlvbiA9PT0gQk9UVE9NKSA/IFNDQUxFX0JSRUFLX09GRlNFVCA6IDApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1haW5Hcm91cCA9IHRoYXQuX2NyZWF0ZUJyZWFrc0dyb3VwKHBvc2l0aW9uRnJvbSwgcG9zaXRpb25Ubyk7XHJcbiAgICAgICAgICAgIGlmICh0aGF0Ll9heGlzU2hpZnQgJiYgb3B0aW9ucy52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRpdGlvbkJyZWFrRnJvbSA9IHRoYXQuX2F4aXNQb3NpdGlvbiAtIHRoYXQuX2F4aXNTaGlmdCAtIFNDQUxFX0JSRUFLX09GRlNFVDtcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uQnJlYWtUbyA9IGFkZGl0aW9uQnJlYWtGcm9tICsgMiAqIFNDQUxFX0JSRUFLX09GRlNFVDtcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uR3JvdXAgPSB0aGF0Ll9jcmVhdGVCcmVha3NHcm91cChhZGRpdGlvbkJyZWFrRnJvbSwgYWRkaXRpb25CcmVha1RvKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrcy5mb3JFYWNoKChmdW5jdGlvbihicikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFici5nYXBTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJyZWFrQ29vcmQgPSB0aGF0Ll9nZXRUcmFuc2xhdGVkQ29vcmQoYnIudG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX2RyYXdCcmVhayhicmVha0Nvb3JkLCBwb3NpdGlvbkZyb20sIHBvc2l0aW9uVG8sIGJyZWFrU3R5bGUud2lkdGgsIGJyZWFrT3B0aW9ucywgbWFpbkdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5fYXhpc1NoaWZ0ICYmIG9wdGlvbnMudmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9kcmF3QnJlYWsoYnJlYWtDb29yZCwgYWRkaXRpb25CcmVha0Zyb20sIGFkZGl0aW9uQnJlYWtUbywgYnJlYWtTdHlsZS53aWR0aCwgYnJlYWtPcHRpb25zLCBhZGRpdGlvbkdyb3VwKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0U3BpZGVyQ2F0ZWdvcnlPcHRpb246IG5vb3AsXHJcbiAgICAgICAgc2hpZnQ6IGZ1bmN0aW9uKG1hcmdpbnMpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xyXG4gICAgICAgICAgICB2YXIgaXNIb3Jpem9udGFsID0gb3B0aW9ucy5pc0hvcml6b250YWw7XHJcbiAgICAgICAgICAgIHZhciBheGVzU3BhY2luZyA9IHRoaXMuZ2V0TXVsdGlwbGVBeGVzU3BhY2luZygpO1xyXG4gICAgICAgICAgICB2YXIgY29uc3RhbnRMaW5lc0dyb3VwcyA9IHRoaXMuX2F4aXNDb25zdGFudExpbmVHcm91cHM7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzaGlmdEdyb3VwKHNpZGUsIGdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IDBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hpZnQgPSBtYXJnaW5zW3NpZGVdID8gbWFyZ2luc1tzaWRlXSArIGF4ZXNTcGFjaW5nIDogMDtcclxuICAgICAgICAgICAgICAgIGF0dHJbaXNIb3Jpem9udGFsID8gXCJ0cmFuc2xhdGVZXCIgOiBcInRyYW5zbGF0ZVhcIl0gPSAoc2lkZSA9PT0gTEVGVCB8fCBzaWRlID09PSBUT1AgPyAtMSA6IDEpICogc2hpZnQ7XHJcbiAgICAgICAgICAgICAgICAoZ3JvdXBbc2lkZV0gfHwgZ3JvdXApLmF0dHIoYXR0cik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hpZnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9heGlzU2hpZnQgPSBzaGlmdEdyb3VwKG9wdGlvbnMucG9zaXRpb24sIHRoaXMuX2F4aXNHcm91cCk7XHJcbiAgICAgICAgICAgIHNoaWZ0R3JvdXAob3B0aW9ucy5wb3NpdGlvbiwgdGhpcy5fYXhpc0VsZW1lbnRzR3JvdXApO1xyXG4gICAgICAgICAgICAoaXNIb3Jpem9udGFsID8gW1RPUCwgQk9UVE9NXSA6IFtMRUZULCBSSUdIVF0pLmZvckVhY2goc2lkZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzaGlmdEdyb3VwKHNpZGUsIGNvbnN0YW50TGluZXNHcm91cHMuYWJvdmUpO1xyXG4gICAgICAgICAgICAgICAgc2hpZnRHcm91cChzaWRlLCBjb25zdGFudExpbmVzR3JvdXBzLnVuZGVyKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0Q3VzdG9tUG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIG9ydGhvZ29uYWxBeGlzID0gdGhpcy5nZXRPcnRob2dvbmFsQXhpcygpO1xyXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZWRQb3NpdGlvbiA9IG51bGwgIT09IHBvc2l0aW9uICYmIHZvaWQgMCAhPT0gcG9zaXRpb24gPyBwb3NpdGlvbiA6IHRoaXMuZ2V0UmVzb2x2ZWRQb3NpdGlvbk9wdGlvbigpO1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5nZXRPcHRpb25zKCkub2Zmc2V0O1xyXG4gICAgICAgICAgICB2YXIgb3J0aG9nb25hbFRyYW5zbGF0b3IgPSBvcnRob2dvbmFsQXhpcy5nZXRUcmFuc2xhdG9yKCk7XHJcbiAgICAgICAgICAgIHZhciBvcnRob2dvbmFsQXhpc1R5cGUgPSBvcnRob2dvbmFsQXhpcy5nZXRPcHRpb25zKCkudHlwZTtcclxuICAgICAgICAgICAgdmFyIHZhbGlkUG9zaXRpb24gPSBvcnRob2dvbmFsQXhpcy52YWxpZGF0ZVVuaXQocmVzb2x2ZWRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50UG9zaXRpb247XHJcbiAgICAgICAgICAgIGlmIChcImRpc2NyZXRlXCIgPT09IG9ydGhvZ29uYWxBeGlzVHlwZSAmJiAoIW9ydGhvZ29uYWxUcmFuc2xhdG9yLl9jYXRlZ29yaWVzIHx8IG9ydGhvZ29uYWxUcmFuc2xhdG9yLl9jYXRlZ29yaWVzLmluZGV4T2YodmFsaWRQb3NpdGlvbikgPCAwKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRQb3NpdGlvbiA9IHZvaWQgMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uSXNCb3VuZGFyeShyZXNvbHZlZFBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uID0gdGhpcy5nZXRQcmVkZWZpbmVkUG9zaXRpb24ocmVzb2x2ZWRQb3NpdGlvbilcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNEZWZpbmVkKHZhbGlkUG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gPSB0aGlzLmdldFByZWRlZmluZWRQb3NpdGlvbih0aGlzLmdldE9wdGlvbnMoKS5wb3NpdGlvbilcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiA9IG9ydGhvZ29uYWxUcmFuc2xhdG9yLnRvKHZhbGlkUG9zaXRpb24sIC0xKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShjdXJyZW50UG9zaXRpb24pICYmIGlzRmluaXRlKG9mZnNldCkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSBvZmZzZXRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFBvc2l0aW9uXHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRDdXN0b21Cb3VuZGFyeVBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21Qb3NpdGlvbjogY3VzdG9tUG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxyXG4gICAgICAgICAgICB9ID0gdGhpcy5nZXRPcHRpb25zKCk7XHJcbiAgICAgICAgICAgIHZhciByZXNvbHZlZFBvc2l0aW9uID0gbnVsbCAhPT0gcG9zaXRpb24gJiYgdm9pZCAwICE9PSBwb3NpdGlvbiA/IHBvc2l0aW9uIDogdGhpcy5nZXRSZXNvbHZlZFBvc2l0aW9uT3B0aW9uKCk7XHJcbiAgICAgICAgICAgIHZhciBvcnRob2dvbmFsQXhpcyA9IHRoaXMuZ2V0T3J0aG9nb25hbEF4aXMoKTtcclxuICAgICAgICAgICAgdmFyIG9ydGhvZ29uYWxUcmFuc2xhdG9yID0gb3J0aG9nb25hbEF4aXMuZ2V0VHJhbnNsYXRvcigpO1xyXG4gICAgICAgICAgICB2YXIgdmlzaWJsZUFyZWEgPSBvcnRob2dvbmFsVHJhbnNsYXRvci5nZXRDYW52YXNWaXNpYmxlQXJlYSgpO1xyXG4gICAgICAgICAgICBpZiAoIWlzRGVmaW5lZChvcnRob2dvbmFsQXhpcy5fb3J0aG9nb25hbFBvc2l0aW9ucykgfHwgMCA9PT0gb3J0aG9nb25hbFRyYW5zbGF0b3IuY2FudmFzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gdGhpcy5nZXRDdXN0b21Qb3NpdGlvbihyZXNvbHZlZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQoY3VycmVudFBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVzb2x2ZWRCb3VuZGFyeVBvc2l0aW9uKClcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0RlZmluZWQoY3VzdG9tUG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uIDw9IHZpc2libGVBcmVhLm1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0hvcml6b250YWwgPyBUT1AgOiBMRUZUXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRQb3NpdGlvbiA+PSB2aXNpYmxlQXJlYS5tYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNIb3Jpem9udGFsID8gQk9UVE9NIDogUklHSFRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0RlZmluZWQob2Zmc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQb3NpdGlvbiA8PSB0aGlzLl9vcnRob2dvbmFsUG9zaXRpb25zLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzSG9yaXpvbnRhbCA/IFRPUCA6IExFRlRcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFBvc2l0aW9uID49IHRoaXMuX29ydGhvZ29uYWxQb3NpdGlvbnMuZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzSG9yaXpvbnRhbCA/IEJPVFRPTSA6IFJJR0hUXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQb3NpdGlvblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmVzb2x2ZWRQb3NpdGlvbk9wdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIF9vcHRpb25zJGN1c3RvbVBvc2l0aTtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGwgIT09IChfb3B0aW9ucyRjdXN0b21Qb3NpdGkgPSBvcHRpb25zLmN1c3RvbVBvc2l0aW9uKSAmJiB2b2lkIDAgIT09IF9vcHRpb25zJGN1c3RvbVBvc2l0aSA/IF9vcHRpb25zJGN1c3RvbVBvc2l0aSA6IG9wdGlvbnMucG9zaXRpb25cclxuICAgICAgICB9LFxyXG4gICAgICAgIGN1c3RvbVBvc2l0aW9uSXNBdmFpbGFibGUoKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0RlZmluZWQodGhpcy5nZXRPcnRob2dvbmFsQXhpcygpKSAmJiAoaXNEZWZpbmVkKG9wdGlvbnMuY3VzdG9tUG9zaXRpb24pIHx8IGlzRmluaXRlKG9wdGlvbnMub2Zmc2V0KSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhc05vbkJvdW5kYXJ5UG9zaXRpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbVBvc2l0aW9uSXNBdmFpbGFibGUoKSAmJiAhdGhpcy5jdXN0b21Qb3NpdGlvbklzQm91bmRhcnkoKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmVzb2x2ZWRCb3VuZGFyeVBvc2l0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21Qb3NpdGlvbklzQm91bmRhcnkoKSA/IHRoaXMuX2N1c3RvbUJvdW5kYXJ5UG9zaXRpb24gOiB0aGlzLmdldE9wdGlvbnMoKS5wb3NpdGlvblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3VzdG9tUG9zaXRpb25FcXVhbHNUb1ByZWRlZmluZWQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbVBvc2l0aW9uSXNCb3VuZGFyeSgpICYmIHRoaXMuX2N1c3RvbUJvdW5kYXJ5UG9zaXRpb24gPT09IHRoaXMuZ2V0T3B0aW9ucygpLnBvc2l0aW9uXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjdXN0b21Qb3NpdGlvbklzQm91bmRhcnkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uSXNCb3VuZGFyeSh0aGlzLl9jdXN0b21Cb3VuZGFyeVBvc2l0aW9uKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcG9zaXRpb25Jc0JvdW5kYXJ5OiBwb3NpdGlvbiA9PiBbVE9QLCBMRUZULCBCT1RUT00sIFJJR0hUXS5pbmRleE9mKHBvc2l0aW9uKSA+PSAwLFxyXG4gICAgICAgIGdldFByZWRlZmluZWRQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMkX29ydGhvZ29uYWxQb3NpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PT0gKF90aGlzJF9vcnRob2dvbmFsUG9zaSA9IHRoaXMuX29ydGhvZ29uYWxQb3NpdGlvbnMpIHx8IHZvaWQgMCA9PT0gX3RoaXMkX29ydGhvZ29uYWxQb3NpID8gdm9pZCAwIDogX3RoaXMkX29ydGhvZ29uYWxQb3NpW3Bvc2l0aW9uID09PSBUT1AgfHwgcG9zaXRpb24gPT09IExFRlQgPyBcInN0YXJ0XCIgOiBcImVuZFwiXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzb2x2ZU92ZXJsYXBwaW5nRm9yQ3VzdG9tUG9zaXRpb25pbmcob3Bwb3NpdGVBeGVzKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCF0aGF0Lmhhc05vbkJvdW5kYXJ5UG9zaXRpb24oKSAmJiAhdGhhdC5jdXN0b21Qb3NpdGlvbklzQm91bmRhcnkoKSAmJiAhb3Bwb3NpdGVBeGVzLnNvbWUoYSA9PiBhLmhhc05vbkJvdW5kYXJ5UG9zaXRpb24oKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBvdmVybGFwcGluZ09iaiA9IHtcclxuICAgICAgICAgICAgICAgIGF4ZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgdGlja3M6IFtdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG9wcG9zaXRlQXhlcy5maWx0ZXIob3J0aG9nb25hbEF4aXMgPT4gb3J0aG9nb25hbEF4aXMucGFuZSA9PT0gdGhhdC5wYW5lKS5mb3JFYWNoKG9ydGhvZ29uYWxBeGlzID0+IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5fbWFqb3JUaWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aWNrID0gdGhhdC5fbWFqb3JUaWNrc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSB0aWNrLmxhYmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcHBpbmdPYmouYXhlcy5pbmRleE9mKG9ydGhvZ29uYWxBeGlzKSA8IDAgJiYgdGhhdC5fZGV0ZWN0RWxlbWVudHNPdmVybGFwcGluZyhsYWJlbCwgb3J0aG9nb25hbEF4aXMuX2F4aXNFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdPYmouYXhlcy5wdXNoKG9ydGhvZ29uYWxBeGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3NoaWZ0VGhyb3VnaE9ydGhvZ29uYWxBeGlzT3ZlcmxhcHBlZFRpY2sobGFiZWwsIG9ydGhvZ29uYWxBeGlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3J0aG9nb25hbEF4aXMuX21ham9yVGlja3MubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHBvc2l0ZVRpY2sgPSBvcnRob2dvbmFsQXhpcy5fbWFqb3JUaWNrc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHBvc2l0ZUxhYmVsID0gb3Bwb3NpdGVUaWNrLmxhYmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wcG9zaXRlTGFiZWwgJiYgdGhhdC5fZGV0ZWN0RWxlbWVudHNPdmVybGFwcGluZyhsYWJlbCwgb3Bwb3NpdGVMYWJlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ09iai50aWNrcy5wdXNoKHRpY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3NoaWZ0VGhyb3VnaEF4aXNPdmVybGFwcGVkVGljayh0aWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gdGhhdC5fbWFqb3JUaWNrcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGljay5tYXJrICYmIG92ZXJsYXBwaW5nT2JqLnRpY2tzLmluZGV4T2YodGljaykgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9pc0hvcml6b250YWwgJiYgdGljay5tYXJrLmF0dHIoXCJ0cmFuc2xhdGVZXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWNrLm1hcmsuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhhdC5faXNIb3Jpem9udGFsICYmIHRpY2subWFyay5hdHRyKFwidHJhbnNsYXRlWFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGljay5tYXJrLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2hpZnRUaHJvdWdoT3J0aG9nb25hbEF4aXNPdmVybGFwcGVkVGljayhsYWJlbCwgb3J0aG9nb25hbEF4aXMpIHtcclxuICAgICAgICAgICAgdmFyIGxhYmVsQkJveCA9IGxhYmVsLmdldEJCb3goKTtcclxuICAgICAgICAgICAgdmFyIG9ydGhvZ29uYWxBeGlzUG9zaXRpb24gPSBvcnRob2dvbmFsQXhpcy5nZXRBeGlzUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdmFyIG9ydGhvZ29uYWxBeGlzTGFiZWxPcHRpb25zID0gb3J0aG9nb25hbEF4aXMuZ2V0T3B0aW9ucygpLmxhYmVsO1xyXG4gICAgICAgICAgICB2YXIgb3J0aG9nb25hbEF4aXNMYWJlbFBvc2l0aW9uID0gb3J0aG9nb25hbEF4aXNMYWJlbE9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgICAgICAgIHZhciBvcnRob2dvbmFsQXhpc0xhYmVsSW5kZW50ID0gb3J0aG9nb25hbEF4aXNMYWJlbE9wdGlvbnMuaW5kZW50RnJvbUF4aXMgLyAyO1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRlQ29vcmROYW1lID0gdGhpcy5faXNIb3Jpem9udGFsID8gXCJ0cmFuc2xhdGVYXCIgOiBcInRyYW5zbGF0ZVlcIjtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRPcnRob2dvbmFsQXhpc0xhYmVsUG9zaXRpb24gPSB0aGlzLl9pc0hvcml6b250YWwgPyBMRUZUIDogVE9QO1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRlID0gbGFiZWwuYXR0cih0cmFuc2xhdGVDb29yZE5hbWUpO1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxDb29yZCA9ICh0aGlzLl9pc0hvcml6b250YWwgPyBsYWJlbEJCb3gueCA6IGxhYmVsQkJveC55KSArIHRyYW5zbGF0ZTtcclxuICAgICAgICAgICAgdmFyIGxhYmVsU2l6ZSA9IHRoaXMuX2lzSG9yaXpvbnRhbCA/IGxhYmVsQkJveC53aWR0aCA6IGxhYmVsQkJveC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBvdXRzaWRlUGFydCA9IG9ydGhvZ29uYWxBeGlzUG9zaXRpb24gLSBsYWJlbENvb3JkO1xyXG4gICAgICAgICAgICB2YXIgaW5zaWRlUGFydCA9IGxhYmVsQ29vcmQgKyBsYWJlbFNpemUgLSBvcnRob2dvbmFsQXhpc1Bvc2l0aW9uO1xyXG4gICAgICAgICAgICB2YXIgYXR0ciA9IHt9O1xyXG4gICAgICAgICAgICBhdHRyW3RyYW5zbGF0ZUNvb3JkTmFtZV0gPSB0cmFuc2xhdGU7XHJcbiAgICAgICAgICAgIGlmIChvdXRzaWRlUGFydCA+IDAgJiYgaW5zaWRlUGFydCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnNpZGVQYXJ0IC0gb3V0c2lkZVBhcnQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0clt0cmFuc2xhdGVDb29yZE5hbWVdICs9IG91dHNpZGVQYXJ0ICsgb3J0aG9nb25hbEF4aXNMYWJlbEluZGVudFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvdXRzaWRlUGFydCAtIGluc2lkZVBhcnQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0clt0cmFuc2xhdGVDb29yZE5hbWVdIC09IGluc2lkZVBhcnQgKyBvcnRob2dvbmFsQXhpc0xhYmVsSW5kZW50XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJbdHJhbnNsYXRlQ29vcmROYW1lXSArPSBvcnRob2dvbmFsQXhpc0xhYmVsUG9zaXRpb24gPT09IGRlZmF1bHRPcnRob2dvbmFsQXhpc0xhYmVsUG9zaXRpb24gPyBvdXRzaWRlUGFydCArIG9ydGhvZ29uYWxBeGlzTGFiZWxJbmRlbnQgOiAtKGluc2lkZVBhcnQgKyBvcnRob2dvbmFsQXhpc0xhYmVsSW5kZW50KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFiZWwuYXR0cihhdHRyKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfc2hpZnRUaHJvdWdoQXhpc092ZXJsYXBwZWRUaWNrKHRpY2spIHtcclxuICAgICAgICAgICAgdmFyIF90aWNrJG1hcms7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IHRpY2subGFiZWw7XHJcbiAgICAgICAgICAgIGlmICghbGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsYWJlbEJCb3ggPSBsYWJlbC5nZXRCQm94KCk7XHJcbiAgICAgICAgICAgIHZhciB0aWNrTWFya0JCb3ggPSBudWxsID09PSAoX3RpY2skbWFyayA9IHRpY2subWFyaykgfHwgdm9pZCAwID09PSBfdGljayRtYXJrID8gdm9pZCAwIDogX3RpY2skbWFyay5nZXRCQm94KCk7XHJcbiAgICAgICAgICAgIHZhciBheGlzUG9zaXRpb24gPSB0aGlzLmdldEF4aXNQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxPcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCkubGFiZWw7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbEluZGVudCA9IGxhYmVsT3B0aW9ucy5pbmRlbnRGcm9tQXhpcztcclxuICAgICAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSBsYWJlbE9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgICAgICAgIHZhciBkZWZhdWx0TGFiZWxQb3NpdGlvbiA9IHRoaXMuX2lzSG9yaXpvbnRhbCA/IFRPUCA6IExFRlQ7XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2xhdGVDb29yZE5hbWUgPSB0aGlzLl9pc0hvcml6b250YWwgPyBcInRyYW5zbGF0ZVlcIiA6IFwidHJhbnNsYXRlWFwiO1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRlID0gbGFiZWwuYXR0cih0cmFuc2xhdGVDb29yZE5hbWUpO1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxDb29yZCA9ICh0aGlzLl9pc0hvcml6b250YWwgPyBsYWJlbEJCb3gueSA6IGxhYmVsQkJveC54KSArIHRyYW5zbGF0ZTtcclxuICAgICAgICAgICAgdmFyIGxhYmVsU2l6ZSA9IHRoaXMuX2lzSG9yaXpvbnRhbCA/IGxhYmVsQkJveC5oZWlnaHQgOiBsYWJlbEJCb3gud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBhdHRyID0ge307XHJcbiAgICAgICAgICAgIGF0dHJbdHJhbnNsYXRlQ29vcmROYW1lXSA9IHRyYW5zbGF0ZSArIChsYWJlbFBvc2l0aW9uID09PSBkZWZhdWx0TGFiZWxQb3NpdGlvbiA/IGF4aXNQb3NpdGlvbiAtIGxhYmVsQ29vcmQgKyBsYWJlbEluZGVudCA6IC0obGFiZWxDb29yZCAtIGF4aXNQb3NpdGlvbiArIGxhYmVsU2l6ZSArIGxhYmVsSW5kZW50KSk7XHJcbiAgICAgICAgICAgIGxhYmVsLmF0dHIoYXR0cik7XHJcbiAgICAgICAgICAgIGlmICh0aWNrLm1hcmspIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXJrZXJTaXplID0gdGhpcy5faXNIb3Jpem9udGFsID8gdGlja01hcmtCQm94LmhlaWdodCA6IHRpY2tNYXJrQkJveC53aWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciBkaXIgPSBsYWJlbFBvc2l0aW9uID09PSBkZWZhdWx0TGFiZWxQb3NpdGlvbiA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICAgIGF0dHJbdHJhbnNsYXRlQ29vcmROYW1lXSA9IGRpciAqIChtYXJrZXJTaXplIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB0aWNrLm1hcmsuYXR0cihhdHRyKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZGV0ZWN0RWxlbWVudHNPdmVybGFwcGluZyhlbGVtZW50MSwgZWxlbWVudDIpIHtcclxuICAgICAgICAgICAgaWYgKCFlbGVtZW50MSB8fCAhZWxlbWVudDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBiQm94MSA9IGVsZW1lbnQxLmdldEJCb3goKTtcclxuICAgICAgICAgICAgdmFyIHgxID0gYkJveDEueCArIGVsZW1lbnQxLmF0dHIoXCJ0cmFuc2xhdGVYXCIpO1xyXG4gICAgICAgICAgICB2YXIgeTEgPSBiQm94MS55ICsgZWxlbWVudDEuYXR0cihcInRyYW5zbGF0ZVlcIik7XHJcbiAgICAgICAgICAgIHZhciBiQm94MiA9IGVsZW1lbnQyLmdldEJCb3goKTtcclxuICAgICAgICAgICAgdmFyIHgyID0gYkJveDIueCArIGVsZW1lbnQyLmF0dHIoXCJ0cmFuc2xhdGVYXCIpO1xyXG4gICAgICAgICAgICB2YXIgeTIgPSBiQm94Mi55ICsgZWxlbWVudDIuYXR0cihcInRyYW5zbGF0ZVlcIik7XHJcbiAgICAgICAgICAgIHJldHVybiAoeDIgPj0geDEgJiYgeDIgPD0geDEgKyBiQm94MS53aWR0aCB8fCB4MSA+PSB4MiAmJiB4MSA8PSB4MiArIGJCb3gyLndpZHRoKSAmJiAoeTIgPj0geTEgJiYgeTIgPD0geTEgKyBiQm94MS5oZWlnaHQgfHwgeTEgPj0geTIgJiYgeTEgPD0geTIgKyBiQm94Mi5oZWlnaHQpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0TGluZURyYXdlcihyZW5kZXJlciwgcm9vdCwgcm90YXRlUG9pbnRzLCBwb3NpdGlvbkZyb20sIGJyZWFrU3RhcnQsIHBvc2l0aW9uVG8sIGlzV2F2ZWQpIHtcclxuICAgIHZhciBlbGVtZW50VHlwZSA9IGlzV2F2ZWQgPyBcImJlemllclwiIDogXCJsaW5lXCI7XHJcbiAgICB2YXIgZ3JvdXAgPSByZW5kZXJlci5nKCkuYXBwZW5kKHJvb3QpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9mZnNldCwgYXR0cikge1xyXG4gICAgICAgIHJlbmRlcmVyLnBhdGgocm90YXRlUG9pbnRzKGdldFBvaW50cyhwb3NpdGlvbkZyb20sIGJyZWFrU3RhcnQsIHBvc2l0aW9uVG8sIG9mZnNldCwgaXNXYXZlZCkpLCBlbGVtZW50VHlwZSkuYXR0cihhdHRyKS5hcHBlbmQoZ3JvdXApXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFBvaW50cyhwb3NpdGlvbkZyb20sIGJyZWFrU3RhcnQsIHBvc2l0aW9uVG8sIG9mZnNldCwgaXNXYXZlZCkge1xyXG4gICAgaWYgKCFpc1dhdmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIFtwb3NpdGlvbkZyb20sIGJyZWFrU3RhcnQgKyBvZmZzZXQsIHBvc2l0aW9uVG8sIGJyZWFrU3RhcnQgKyBvZmZzZXRdXHJcbiAgICB9XHJcbiAgICBicmVha1N0YXJ0ICs9IG9mZnNldDtcclxuICAgIHZhciBjdXJyZW50UG9zaXRpb247XHJcbiAgICB2YXIgdG9wUG9pbnQgPSBicmVha1N0YXJ0ICsgV0FWRURfTElORV9UT1A7XHJcbiAgICB2YXIgY2VudGVyUG9pbnQgPSBicmVha1N0YXJ0ICsgV0FWRURfTElORV9DRU5URVI7XHJcbiAgICB2YXIgYm90dG9tUG9pbnQgPSBicmVha1N0YXJ0ICsgV0FWRURfTElORV9CT1RUT007XHJcbiAgICB2YXIgcG9pbnRzID0gW1xyXG4gICAgICAgIFtwb3NpdGlvbkZyb20sIGNlbnRlclBvaW50XVxyXG4gICAgXTtcclxuICAgIGZvciAoY3VycmVudFBvc2l0aW9uID0gcG9zaXRpb25Gcm9tOyBjdXJyZW50UG9zaXRpb24gPCBwb3NpdGlvblRvICsgV0FWRURfTElORV9MRU5HVEg7IGN1cnJlbnRQb3NpdGlvbiArPSBXQVZFRF9MSU5FX0xFTkdUSCkge1xyXG4gICAgICAgIHBvaW50cy5wdXNoKFtjdXJyZW50UG9zaXRpb24gKyA2LCB0b3BQb2ludCwgY3VycmVudFBvc2l0aW9uICsgNiwgdG9wUG9pbnQsIGN1cnJlbnRQb3NpdGlvbiArIDEyLCBjZW50ZXJQb2ludCwgY3VycmVudFBvc2l0aW9uICsgMTgsIGJvdHRvbVBvaW50LCBjdXJyZW50UG9zaXRpb24gKyAxOCwgYm90dG9tUG9pbnQsIGN1cnJlbnRQb3NpdGlvbiArIDI0LCBjZW50ZXJQb2ludF0pXHJcbiAgICB9XHJcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBwb2ludHMpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJvdGF0ZUxpbmUobGluZUNvb3Jkcykge1xyXG4gICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGluZUNvb3Jkcy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgIHBvaW50cy5wdXNoKGxpbmVDb29yZHNbaSArIDFdKTtcclxuICAgICAgICBwb2ludHMucHVzaChsaW5lQ29vcmRzW2ldKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvaW50c1xyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/axes/xy_axes.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/chart.js":
/*!**************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/chart.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_utils_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils/size */ \"./node_modules/devextreme/esm/core/utils/size.js\");\n/* harmony import */ var _core_utils_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils/common */ \"./node_modules/devextreme/esm/core/utils/common.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _core_utils_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/utils/array */ \"./node_modules/devextreme/esm/core/utils/array.js\");\n/* harmony import */ var _core_utils_window__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/utils/window */ \"./node_modules/devextreme/esm/core/utils/window.js\");\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/* harmony import */ var _core_component_registrator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/component_registrator */ \"./node_modules/devextreme/esm/core/component_registrator.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils */ \"./node_modules/devextreme/esm/viz/utils.js\");\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/utils/math */ \"./node_modules/devextreme/esm/core/utils/math.js\");\n/* harmony import */ var _chart_components_base_chart__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./chart_components/base_chart */ \"./node_modules/devextreme/esm/viz/chart_components/base_chart.js\");\n/* harmony import */ var _chart_components_multi_axes_synchronizer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./chart_components/multi_axes_synchronizer */ \"./node_modules/devextreme/esm/viz/chart_components/multi_axes_synchronizer.js\");\n/* harmony import */ var _chart_components_advanced_chart__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./chart_components/advanced_chart */ \"./node_modules/devextreme/esm/viz/chart_components/advanced_chart.js\");\n/* harmony import */ var _chart_components_scroll_bar__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./chart_components/scroll_bar */ \"./node_modules/devextreme/esm/viz/chart_components/scroll_bar.js\");\n/* harmony import */ var _chart_components_crosshair__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./chart_components/crosshair */ \"./node_modules/devextreme/esm/viz/chart_components/crosshair.js\");\n/* harmony import */ var _series_helpers_range_data_calculator__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./series/helpers/range_data_calculator */ \"./node_modules/devextreme/esm/viz/series/helpers/range_data_calculator.js\");\n/* harmony import */ var _chart_components_layout_manager__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./chart_components/layout_manager */ \"./node_modules/devextreme/esm/viz/chart_components/layout_manager.js\");\n/* harmony import */ var _translators_range__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./translators/range */ \"./node_modules/devextreme/esm/viz/translators/range.js\");\n/* harmony import */ var _chart_components_shutter_zoom__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./chart_components/shutter_zoom */ \"./node_modules/devextreme/esm/viz/chart_components/shutter_zoom.js\");\n/* harmony import */ var _chart_components_zoom_and_pan__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./chart_components/zoom_and_pan */ \"./node_modules/devextreme/esm/viz/chart_components/zoom_and_pan.js\");\n/* harmony import */ var _core_annotations__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./core/annotations */ \"./node_modules/devextreme/esm/viz/core/annotations.js\");\n/**\r\n * DevExtreme (esm/viz/chart.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar DEFAULT_PANE_NAME = \"default\";\r\nvar VISUAL_RANGE = \"VISUAL_RANGE\";\r\nvar DEFAULT_PANES = [{\r\n    name: DEFAULT_PANE_NAME,\r\n    border: {}\r\n}];\r\nvar DISCRETE = \"discrete\";\r\nvar _isArray = Array.isArray;\r\n\r\nfunction getFirstAxisNameForPane(axes, paneName, defaultPane) {\r\n    var result;\r\n    for (var i = 0; i < axes.length; i++) {\r\n        if (axes[i].pane === paneName || void 0 === axes[i].pane && paneName === defaultPane) {\r\n            result = axes[i].name;\r\n            break\r\n        }\r\n    }\r\n    if (!result) {\r\n        result = axes[0].name\r\n    }\r\n    return result\r\n}\r\n\r\nfunction changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility) {\r\n    var gridOpt = axis.getOptions().grid;\r\n    var minorGridOpt = axis.getOptions().minorGrid;\r\n    gridOpt.visible = gridVisibility;\r\n    minorGridOpt && (minorGridOpt.visible = minorGridVisibility)\r\n}\r\n\r\nfunction hideGridsOnNonFirstValueAxisForPane(axesForPane) {\r\n    var axisShown = false;\r\n    var hiddenStubAxis = [];\r\n    var minorGridVisibility = axesForPane.some((function(axis) {\r\n        var minorGridOptions = axis.getOptions().minorGrid;\r\n        return minorGridOptions && minorGridOptions.visible\r\n    }));\r\n    var gridVisibility = axesForPane.some((function(axis) {\r\n        var gridOptions = axis.getOptions().grid;\r\n        return gridOptions && gridOptions.visible\r\n    }));\r\n    if (axesForPane.length > 1) {\r\n        axesForPane.forEach((function(axis) {\r\n            var gridOpt = axis.getOptions().grid;\r\n            if (axisShown) {\r\n                changeVisibilityAxisGrids(axis, false, false)\r\n            } else if (gridOpt && gridOpt.visible) {\r\n                if (axis.getTranslator().getBusinessRange().isEmpty()) {\r\n                    changeVisibilityAxisGrids(axis, false, false);\r\n                    hiddenStubAxis.push(axis)\r\n                } else {\r\n                    axisShown = true;\r\n                    changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility)\r\n                }\r\n            }\r\n        }));\r\n        !axisShown && hiddenStubAxis.length && changeVisibilityAxisGrids(hiddenStubAxis[0], gridVisibility, minorGridVisibility)\r\n    }\r\n}\r\n\r\nfunction findAxisOptions(valueAxes, valueAxesOptions, axisName) {\r\n    var result;\r\n    var axInd;\r\n    for (axInd = 0; axInd < valueAxesOptions.length; axInd++) {\r\n        if (valueAxesOptions[axInd].name === axisName) {\r\n            result = valueAxesOptions[axInd];\r\n            result.priority = axInd;\r\n            break\r\n        }\r\n    }\r\n    if (!result) {\r\n        for (axInd = 0; axInd < valueAxes.length; axInd++) {\r\n            if (valueAxes[axInd].name === axisName) {\r\n                result = valueAxes[axInd].getOptions();\r\n                result.priority = valueAxes[axInd].priority;\r\n                break\r\n            }\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nfunction findAxis(paneName, axisName, axes) {\r\n    var axis;\r\n    var i;\r\n    for (i = 0; i < axes.length; i++) {\r\n        axis = axes[i];\r\n        if (axis.name === axisName && axis.pane === paneName) {\r\n            return axis\r\n        }\r\n    }\r\n    if (paneName) {\r\n        return findAxis(void 0, axisName, axes)\r\n    }\r\n}\r\n\r\nfunction compareAxes(a, b) {\r\n    return a.priority - b.priority\r\n}\r\n\r\nfunction doesPaneExist(panes, paneName) {\r\n    var found = false;\r\n    Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_5__[\"each\"])(panes, (function(_, pane) {\r\n        if (pane.name === paneName) {\r\n            found = true;\r\n            return false\r\n        }\r\n    }));\r\n    return found\r\n}\r\n\r\nfunction accumulate(field, src1, src2, auxSpacing) {\r\n    var val1 = src1[field] || 0;\r\n    var val2 = src2[field] || 0;\r\n    return val1 + val2 + (val1 && val2 ? auxSpacing : 0)\r\n}\r\n\r\nfunction pickMax(field, src1, src2) {\r\n    return pickMaxValue(src1[field], src2[field])\r\n}\r\n\r\nfunction pickMaxValue(val1, val2) {\r\n    return Math.max(val1 || 0, val2 || 0)\r\n}\r\n\r\nfunction getAxisMargins(axis) {\r\n    return axis.getMargins()\r\n}\r\n\r\nfunction getHorizontalAxesMargins(axes, getMarginsFunc) {\r\n    return axes.reduce((function(margins, axis) {\r\n        var _axis$getOrthogonalAx;\r\n        var axisMargins = getMarginsFunc(axis);\r\n        var paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};\r\n        var spacing = axis.getMultipleAxesSpacing();\r\n        paneMargins.top = accumulate(\"top\", paneMargins, axisMargins, spacing);\r\n        paneMargins.bottom = accumulate(\"bottom\", paneMargins, axisMargins, spacing);\r\n        paneMargins.left = pickMax(\"left\", paneMargins, axisMargins);\r\n        paneMargins.right = pickMax(\"right\", paneMargins, axisMargins);\r\n        margins.top = pickMax(\"top\", paneMargins, margins);\r\n        margins.bottom = pickMax(\"bottom\", paneMargins, margins);\r\n        margins.left = pickMax(\"left\", paneMargins, margins);\r\n        margins.right = pickMax(\"right\", paneMargins, margins);\r\n        var orthogonalAxis = null === (_axis$getOrthogonalAx = axis.getOrthogonalAxis) || void 0 === _axis$getOrthogonalAx ? void 0 : _axis$getOrthogonalAx.call(axis);\r\n        if (orthogonalAxis && orthogonalAxis.customPositionIsAvailable() && (!axis.customPositionIsBoundaryOrthogonalAxis() || !orthogonalAxis.customPositionEqualsToPredefined())) {\r\n            margins[orthogonalAxis.getResolvedBoundaryPosition()] = 0\r\n        }\r\n        return margins\r\n    }), {\r\n        panes: {}\r\n    })\r\n}\r\n\r\nfunction getVerticalAxesMargins(axes) {\r\n    return axes.reduce((function(margins, axis) {\r\n        var axisMargins = axis.getMargins();\r\n        var paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};\r\n        var spacing = axis.getMultipleAxesSpacing();\r\n        paneMargins.top = pickMax(\"top\", paneMargins, axisMargins);\r\n        paneMargins.bottom = pickMax(\"bottom\", paneMargins, axisMargins);\r\n        paneMargins.left = accumulate(\"left\", paneMargins, axisMargins, spacing);\r\n        paneMargins.right = accumulate(\"right\", paneMargins, axisMargins, spacing);\r\n        margins.top = pickMax(\"top\", paneMargins, margins);\r\n        margins.bottom = pickMax(\"bottom\", paneMargins, margins);\r\n        margins.left = pickMax(\"left\", paneMargins, margins);\r\n        margins.right = pickMax(\"right\", paneMargins, margins);\r\n        return margins\r\n    }), {\r\n        panes: {}\r\n    })\r\n}\r\n\r\nfunction performActionOnAxes(axes, action, actionArgument1, actionArgument2, actionArgument3) {\r\n    axes.forEach((function(axis) {\r\n        axis[action](actionArgument1 && actionArgument1[axis.pane], actionArgument2 && actionArgument2[axis.pane] || actionArgument2, actionArgument3)\r\n    }))\r\n}\r\n\r\nfunction shrinkCanvases(isRotated, canvases, sizes, verticalMargins, horizontalMargins) {\r\n    function getMargin(side, margins, pane) {\r\n        var m = -1 === (isRotated ? [\"left\", \"right\"] : [\"top\", \"bottom\"]).indexOf(side) ? margins : margins.panes[pane] || {};\r\n        return m[side]\r\n    }\r\n\r\n    function getMaxMargin(side, margins1, margins2, pane) {\r\n        return pickMaxValue(getMargin(side, margins1, pane), getMargin(side, margins2, pane))\r\n    }\r\n    var getOriginalField = field => \"original\".concat(field[0].toUpperCase()).concat(field.slice(1));\r\n\r\n    function shrink(canvases, paneNames, sizeField, startMargin, endMargin, oppositeMargins) {\r\n        paneNames = paneNames.sort((p1, p2) => canvases[p2][startMargin] - canvases[p1][startMargin]);\r\n        paneNames.forEach(pane => {\r\n            var canvas = canvases[pane];\r\n            oppositeMargins.forEach(margin => {\r\n                canvas[margin] = canvas[getOriginalField(margin)] + getMaxMargin(margin, verticalMargins, horizontalMargins, pane)\r\n            })\r\n        });\r\n        var firstPane = canvases[paneNames[0]];\r\n        var emptySpace = paneNames.reduce((space, paneName) => {\r\n            space -= getMaxMargin(startMargin, verticalMargins, horizontalMargins, paneName) + getMaxMargin(endMargin, verticalMargins, horizontalMargins, paneName);\r\n            return space\r\n        }, firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - canvases[paneNames[paneNames.length - 1]][getOriginalField(startMargin)]) - _core_utils__WEBPACK_IMPORTED_MODULE_8__[\"PANE_PADDING\"] * (paneNames.length - 1);\r\n        emptySpace -= Object.keys(sizes).reduce((prev, key) => prev + (!Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__[\"isRelativeHeightPane\"])(sizes[key]) ? sizes[key].height : 0), 0);\r\n        paneNames.reduce((offset, pane) => {\r\n            var canvas = canvases[pane];\r\n            var paneSize = sizes[pane];\r\n            offset -= getMaxMargin(endMargin, verticalMargins, horizontalMargins, pane);\r\n            canvas[endMargin] = firstPane[sizeField] - offset;\r\n            offset -= !Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__[\"isRelativeHeightPane\"])(paneSize) ? paneSize.height : Math.floor(emptySpace * paneSize.height);\r\n            canvas[startMargin] = offset;\r\n            offset -= getMaxMargin(startMargin, verticalMargins, horizontalMargins, pane) + _core_utils__WEBPACK_IMPORTED_MODULE_8__[\"PANE_PADDING\"];\r\n            return offset\r\n        }, firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - (emptySpace < 0 ? emptySpace : 0))\r\n    }\r\n    var paneNames = Object.keys(canvases);\r\n    if (!isRotated) {\r\n        shrink(canvases, paneNames, \"height\", \"top\", \"bottom\", [\"left\", \"right\"])\r\n    } else {\r\n        shrink(canvases, paneNames, \"width\", \"left\", \"right\", [\"top\", \"bottom\"])\r\n    }\r\n    return canvases\r\n}\r\n\r\nfunction drawAxesWithTicks(axes, condition, canvases, panesBorderOptions) {\r\n    if (condition) {\r\n        performActionOnAxes(axes, \"createTicks\", canvases);\r\n        _chart_components_multi_axes_synchronizer__WEBPACK_IMPORTED_MODULE_12__[\"default\"].synchronize(axes)\r\n    }\r\n    performActionOnAxes(axes, \"draw\", !condition && canvases, panesBorderOptions)\r\n}\r\n\r\nfunction shiftAxis(side1, side2) {\r\n    var shifts = {};\r\n    return function(axis) {\r\n        if (!axis.customPositionIsAvailable() || axis.customPositionEqualsToPredefined()) {\r\n            var shift = shifts[axis.pane] = shifts[axis.pane] || {\r\n                top: 0,\r\n                left: 0,\r\n                bottom: 0,\r\n                right: 0\r\n            };\r\n            var spacing = axis.getMultipleAxesSpacing();\r\n            var margins = axis.getMargins();\r\n            axis.shift(shift);\r\n            shift[side1] = accumulate(side1, shift, margins, spacing);\r\n            shift[side2] = accumulate(side2, shift, margins, spacing)\r\n        } else {\r\n            axis.shift({\r\n                top: 0,\r\n                left: 0,\r\n                bottom: 0,\r\n                right: 0\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\nfunction getCommonSize(side, margins) {\r\n    var size = 0;\r\n    var pane;\r\n    var paneMargins;\r\n    for (pane in margins.panes) {\r\n        paneMargins = margins.panes[pane];\r\n        size += \"height\" === side ? paneMargins.top + paneMargins.bottom : paneMargins.left + paneMargins.right\r\n    }\r\n    return size\r\n}\r\n\r\nfunction checkUsedSpace(sizeShortage, side, axes, getMarginFunc) {\r\n    var size = 0;\r\n    if (sizeShortage[side] > 0) {\r\n        size = getCommonSize(side, getMarginFunc(axes, getAxisMargins));\r\n        performActionOnAxes(axes, \"hideTitle\");\r\n        sizeShortage[side] -= size - getCommonSize(side, getMarginFunc(axes, getAxisMargins))\r\n    }\r\n    if (sizeShortage[side] > 0) {\r\n        performActionOnAxes(axes, \"hideOuterElements\")\r\n    }\r\n}\r\n\r\nfunction axisAnimationEnabled(drawOptions, pointsToAnimation) {\r\n    var pointsCount = pointsToAnimation.reduce((sum, count) => sum + count, 0) / pointsToAnimation.length;\r\n    return drawOptions.animate && pointsCount <= drawOptions.animationPointsLimit\r\n}\r\n\r\nfunction collectMarkersInfoBySeries(allSeries, filteredSeries, argAxis) {\r\n    var series = [];\r\n    var overloadedSeries = {};\r\n    var argVisualRange = argAxis.visualRange();\r\n    var argTranslator = argAxis.getTranslator();\r\n    var argViewPortFilter = _series_helpers_range_data_calculator__WEBPACK_IMPORTED_MODULE_16__[\"default\"].getViewPortFilter(argVisualRange || {});\r\n    filteredSeries.forEach(s => {\r\n        var valAxis = s.getValueAxis();\r\n        var valVisualRange = valAxis.getCanvasRange();\r\n        var valTranslator = valAxis.getTranslator();\r\n        var seriesIndex = allSeries.indexOf(s);\r\n        var valViewPortFilter = _series_helpers_range_data_calculator__WEBPACK_IMPORTED_MODULE_16__[\"default\"].getViewPortFilter(valVisualRange || {});\r\n        overloadedSeries[seriesIndex] = {};\r\n        filteredSeries.forEach(sr => overloadedSeries[seriesIndex][allSeries.indexOf(sr)] = 0);\r\n        var seriesPoints = [];\r\n        s.getPoints().filter(p => p.getOptions().visible && argViewPortFilter(p.argument) && (valViewPortFilter(p.getMinValue(true)) || valViewPortFilter(p.getMaxValue(true)))).forEach(p => {\r\n            var tp = {\r\n                seriesIndex: seriesIndex,\r\n                argument: p.argument,\r\n                value: p.getMaxValue(true),\r\n                size: p.bubbleSize || p.getOptions().size\r\n            };\r\n            if (p.getMinValue(true) !== p.getMaxValue(true)) {\r\n                var mp = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])({}, tp);\r\n                mp.value = p.getMinValue(true);\r\n                mp.x = argTranslator.to(mp.argument, 1);\r\n                mp.y = valTranslator.to(mp.value, 1);\r\n                seriesPoints.push(mp)\r\n            }\r\n            tp.x = argTranslator.to(tp.argument, 1);\r\n            tp.y = valTranslator.to(tp.value, 1);\r\n            seriesPoints.push(tp)\r\n        });\r\n        overloadedSeries[seriesIndex].pointsCount = seriesPoints.length;\r\n        overloadedSeries[seriesIndex].total = 0;\r\n        overloadedSeries[seriesIndex].continuousSeries = 0;\r\n        series.push({\r\n            name: s.name,\r\n            index: seriesIndex,\r\n            points: seriesPoints\r\n        })\r\n    });\r\n    return {\r\n        series: series,\r\n        overloadedSeries: overloadedSeries\r\n    }\r\n}\r\n\r\nfunction applyAutoHidePointMarkers(allSeries, filteredSeries, overloadedSeries, argAxis) {\r\n    var argAxisType = argAxis.getOptions().type;\r\n    filteredSeries.forEach(s => {\r\n        var seriesIndex = allSeries.indexOf(s);\r\n        s.autoHidePointMarkers = false;\r\n        var tickCount = argAxis.getTicksValues().majorTicksValues.length;\r\n        if (s.autoHidePointMarkersEnabled() && (argAxisType === DISCRETE || overloadedSeries[seriesIndex].pointsCount > tickCount)) {\r\n            for (var index in overloadedSeries[seriesIndex]) {\r\n                var i = parseInt(index);\r\n                if (isNaN(i) || overloadedSeries[seriesIndex].total / overloadedSeries[seriesIndex].continuousSeries < 3) {\r\n                    continue\r\n                }\r\n                if (i === seriesIndex) {\r\n                    if (2 * overloadedSeries[i][i] >= overloadedSeries[i].pointsCount) {\r\n                        s.autoHidePointMarkers = true;\r\n                        break\r\n                    }\r\n                } else if (overloadedSeries[seriesIndex].total >= overloadedSeries[seriesIndex].pointsCount) {\r\n                    s.autoHidePointMarkers = true;\r\n                    break\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nfunction fastHidingPointMarkersByArea(canvas, markersInfo, series) {\r\n    var area = canvas.width * canvas.height;\r\n    var seriesPoints = markersInfo.series;\r\n    var _loop = function(i) {\r\n        var currentSeries = series.filter(s => s.name === seriesPoints[i].name)[0];\r\n        var points = seriesPoints[i].points;\r\n        var pointSize = points.length ? points[0].size : 0;\r\n        var pointsArea = pointSize * pointSize * points.length;\r\n        if (currentSeries.autoHidePointMarkersEnabled() && pointsArea >= area / seriesPoints.length) {\r\n            var index = seriesPoints[i].index;\r\n            currentSeries.autoHidePointMarkers = true;\r\n            seriesPoints.splice(i, 1);\r\n            series.splice(series.indexOf(currentSeries), 1);\r\n            delete markersInfo.overloadedSeries[index]\r\n        }\r\n    };\r\n    for (var i = seriesPoints.length - 1; i >= 0; i--) {\r\n        _loop(i)\r\n    }\r\n}\r\n\r\nfunction updateMarkersInfo(points, overloadedSeries) {\r\n    var isContinuousSeries = false;\r\n    for (var i = 0; i < points.length - 1; i++) {\r\n        var curPoint = points[i];\r\n        var size = curPoint.size;\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(curPoint.x) && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(curPoint.y)) {\r\n            for (var j = i + 1; j < points.length; j++) {\r\n                var nextPoint = points[j];\r\n                var next_x = null === nextPoint || void 0 === nextPoint ? void 0 : nextPoint.x;\r\n                var next_y = null === nextPoint || void 0 === nextPoint ? void 0 : nextPoint.y;\r\n                if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(next_x) || Math.abs(curPoint.x - next_x) >= size) {\r\n                    isContinuousSeries &= j !== i + 1;\r\n                    break\r\n                } else {\r\n                    var distance = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(next_x) && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(next_y) && Math.sqrt(Math.pow(curPoint.x - next_x, 2) + Math.pow(curPoint.y - next_y, 2));\r\n                    if (distance && distance < size) {\r\n                        overloadedSeries[curPoint.seriesIndex][nextPoint.seriesIndex]++;\r\n                        overloadedSeries[curPoint.seriesIndex].total++;\r\n                        if (!isContinuousSeries) {\r\n                            overloadedSeries[curPoint.seriesIndex].continuousSeries++;\r\n                            isContinuousSeries = true\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nvar dxChart = _chart_components_advanced_chart__WEBPACK_IMPORTED_MODULE_13__[\"AdvancedChart\"].inherit({\r\n    _themeSection: \"chart\",\r\n    _fontFields: [\"crosshair.label.font\"],\r\n    _initCore: function() {\r\n        this.paneAxis = {};\r\n        this.callBase()\r\n    },\r\n    _init() {\r\n        this._containerInitialHeight = Object(_core_utils_window__WEBPACK_IMPORTED_MODULE_4__[\"hasWindow\"])() ? Object(_core_utils_size__WEBPACK_IMPORTED_MODULE_0__[\"getHeight\"])(this._$element) : 0;\r\n        this.callBase()\r\n    },\r\n    _correctAxes: function() {\r\n        this._correctValueAxes(true)\r\n    },\r\n    _getExtraOptions: _core_utils_common__WEBPACK_IMPORTED_MODULE_1__[\"noop\"],\r\n    _createPanes: function() {\r\n        var panes = this.option(\"panes\");\r\n        var panesNameCounter = 0;\r\n        var defaultPane;\r\n        if (!panes || _isArray(panes) && !panes.length) {\r\n            panes = DEFAULT_PANES\r\n        }\r\n        this.callBase();\r\n        defaultPane = this.option(\"defaultPane\");\r\n        panes = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])(true, [], _isArray(panes) ? panes : [panes]);\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_5__[\"each\"])(panes, (function(_, pane) {\r\n            pane.name = !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(pane.name) ? DEFAULT_PANE_NAME + panesNameCounter++ : pane.name\r\n        }));\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(defaultPane)) {\r\n            if (!doesPaneExist(panes, defaultPane)) {\r\n                this._incidentOccurred(\"W2101\", [defaultPane]);\r\n                defaultPane = panes[panes.length - 1].name\r\n            }\r\n        } else {\r\n            defaultPane = panes[panes.length - 1].name\r\n        }\r\n        this.defaultPane = defaultPane;\r\n        panes = this._isRotated() ? panes.reverse() : panes;\r\n        return panes\r\n    },\r\n    _getAxisRenderingOptions: function() {\r\n        return {\r\n            axisType: \"xyAxes\",\r\n            drawingType: \"linear\"\r\n        }\r\n    },\r\n    _prepareAxisOptions: function(typeSelector, userOptions, rotated) {\r\n        return {\r\n            isHorizontal: \"argumentAxis\" === typeSelector !== rotated,\r\n            containerColor: this._themeManager.getOptions(\"containerBackgroundColor\")\r\n        }\r\n    },\r\n    _checkPaneName: function(seriesTheme) {\r\n        var paneList = Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__[\"map\"])(this.panes, (function(pane) {\r\n            return pane.name\r\n        }));\r\n        seriesTheme.pane = seriesTheme.pane || this.defaultPane;\r\n        return -1 !== Object(_core_utils_array__WEBPACK_IMPORTED_MODULE_3__[\"inArray\"])(seriesTheme.pane, paneList)\r\n    },\r\n    _initCustomPositioningAxes() {\r\n        var that = this;\r\n        var argumentAxis = that.getArgumentAxis();\r\n        var valueAxisName = argumentAxis.getOptions().customPositionAxis;\r\n        var valueAxis = that._valueAxes.filter(v => v.pane === argumentAxis.pane && (!valueAxisName || valueAxisName === v.name))[0];\r\n        that._valueAxes.forEach(v => {\r\n            if (argumentAxis !== v.getOrthogonalAxis()) {\r\n                v.getOrthogonalAxis = () => argumentAxis;\r\n                v.customPositionIsBoundaryOrthogonalAxis = () => argumentAxis.customPositionIsBoundary()\r\n            }\r\n        });\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(valueAxis) && valueAxis !== argumentAxis.getOrthogonalAxis()) {\r\n            argumentAxis.getOrthogonalAxis = () => valueAxis;\r\n            argumentAxis.customPositionIsBoundaryOrthogonalAxis = () => that._valueAxes.some(v => v.customPositionIsBoundary())\r\n        } else if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(argumentAxis.getOrthogonalAxis()) && !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(valueAxis)) {\r\n            argumentAxis.getOrthogonalAxis = _core_utils_common__WEBPACK_IMPORTED_MODULE_1__[\"noop\"]\r\n        }\r\n    },\r\n    _getAllAxes() {\r\n        return this._argumentAxes.concat(this._valueAxes)\r\n    },\r\n    _resetAxesAnimation(isFirstDrawing, isHorizontal) {\r\n        var axes = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(isHorizontal) ? isHorizontal ^ this._isRotated() ? this._argumentAxes : this._valueAxes : this._getAllAxes();\r\n        axes.forEach(a => {\r\n            a.resetApplyingAnimation(isFirstDrawing)\r\n        })\r\n    },\r\n    _axesBoundaryPositioning() {\r\n        var allAxes = this._getAllAxes();\r\n        var boundaryStateChanged = false;\r\n        allAxes.forEach(a => {\r\n            if (!a.customPositionIsAvailable()) {\r\n                return false\r\n            }\r\n            var prevBoundaryState = a.customPositionIsBoundary();\r\n            a._customBoundaryPosition = a.getCustomBoundaryPosition();\r\n            boundaryStateChanged |= prevBoundaryState !== a.customPositionIsBoundary()\r\n        });\r\n        return boundaryStateChanged\r\n    },\r\n    _getCrosshairMargins: function() {\r\n        var crosshairOptions = this._getCrosshairOptions() || {};\r\n        var crosshairEnabled = crosshairOptions.enabled;\r\n        var margins = Object(_chart_components_crosshair__WEBPACK_IMPORTED_MODULE_15__[\"getMargins\"])();\r\n        var horizontalLabel = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])(true, {}, crosshairOptions.label, crosshairOptions.horizontalLine.label);\r\n        var verticalLabel = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])(true, {}, crosshairOptions.label, crosshairOptions.verticalLine.label);\r\n        return {\r\n            x: crosshairEnabled && crosshairOptions.horizontalLine.visible && horizontalLabel.visible ? margins.x : 0,\r\n            y: crosshairEnabled && crosshairOptions.verticalLine.visible && verticalLabel.visible ? margins.y : 0\r\n        }\r\n    },\r\n    _getValueAxis: function(paneName, axisName) {\r\n        var valueAxes = this._valueAxes;\r\n        var valueAxisOptions = this.option(\"valueAxis\") || {};\r\n        var valueAxesOptions = _isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions];\r\n        var rotated = this._isRotated();\r\n        var crosshairMargins = this._getCrosshairMargins();\r\n        var axisOptions;\r\n        var axis;\r\n        axisName = axisName || getFirstAxisNameForPane(valueAxes, paneName, this.defaultPane);\r\n        axis = findAxis(paneName, axisName, valueAxes);\r\n        if (!axis) {\r\n            axisOptions = findAxisOptions(valueAxes, valueAxesOptions, axisName);\r\n            if (!axisOptions) {\r\n                this._incidentOccurred(\"W2102\", [axisName]);\r\n                axisOptions = {\r\n                    name: axisName,\r\n                    priority: valueAxes.length\r\n                }\r\n            }\r\n            axis = this._createAxis(false, this._populateAxesOptions(\"valueAxis\", axisOptions, {\r\n                pane: paneName,\r\n                name: axisName,\r\n                optionPath: _isArray(valueAxisOptions) ? \"valueAxis[\".concat(axisOptions.priority, \"]\") : \"valueAxis\",\r\n                crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x\r\n            }, rotated));\r\n            axis.applyVisualRangeSetter(this._getVisualRangeSetter());\r\n            valueAxes.push(axis)\r\n        }\r\n        axis.setPane(paneName);\r\n        return axis\r\n    },\r\n    _correctValueAxes: function(needHideGrids) {\r\n        var that = this;\r\n        var synchronizeMultiAxes = that._themeManager.getOptions(\"synchronizeMultiAxes\");\r\n        var valueAxes = that._valueAxes;\r\n        var paneWithAxis = {};\r\n        that.series.forEach((function(series) {\r\n            var axis = series.getValueAxis();\r\n            paneWithAxis[axis.pane] = true\r\n        }));\r\n        that.panes.forEach((function(pane) {\r\n            var paneName = pane.name;\r\n            if (!paneWithAxis[paneName]) {\r\n                that._getValueAxis(paneName)\r\n            }\r\n            if (needHideGrids && synchronizeMultiAxes) {\r\n                hideGridsOnNonFirstValueAxisForPane(valueAxes.filter((function(axis) {\r\n                    return axis.pane === paneName\r\n                })))\r\n            }\r\n        }));\r\n        that._valueAxes = valueAxes.filter((function(axis) {\r\n            if (!axis.pane) {\r\n                axis.setPane(that.defaultPane)\r\n            }\r\n            var paneExists = doesPaneExist(that.panes, axis.pane);\r\n            if (!paneExists) {\r\n                axis.dispose();\r\n                axis = null\r\n            }\r\n            return paneExists\r\n        })).sort(compareAxes);\r\n        var defaultAxis = this.getValueAxis();\r\n        that._valueAxes.forEach(axis => {\r\n            var optionPath = axis.getOptions().optionPath;\r\n            if (optionPath) {\r\n                var axesWithSamePath = that._valueAxes.filter(a => a.getOptions().optionPath === optionPath);\r\n                if (axesWithSamePath.length > 1) {\r\n                    if (axesWithSamePath.some(a => a === defaultAxis)) {\r\n                        axesWithSamePath.forEach(a => {\r\n                            if (a !== defaultAxis) {\r\n                                a.getOptions().optionPath = null\r\n                            }\r\n                        })\r\n                    } else {\r\n                        axesWithSamePath.forEach((a, i) => {\r\n                            if (0 !== i) {\r\n                                a.getOptions().optionPath = null\r\n                            }\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    },\r\n    _getSeriesForPane: function(paneName) {\r\n        var paneSeries = [];\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_5__[\"each\"])(this.series, (function(_, oneSeries) {\r\n            if (oneSeries.pane === paneName) {\r\n                paneSeries.push(oneSeries)\r\n            }\r\n        }));\r\n        return paneSeries\r\n    },\r\n    _createPanesBorderOptions: function() {\r\n        var commonBorderOptions = this._themeManager.getOptions(\"commonPaneSettings\").border;\r\n        var panesBorderOptions = {};\r\n        this.panes.forEach(pane => panesBorderOptions[pane.name] = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])(true, {}, commonBorderOptions, pane.border));\r\n        return panesBorderOptions\r\n    },\r\n    _createScrollBar: function() {\r\n        var scrollBarOptions = this._themeManager.getOptions(\"scrollBar\") || {};\r\n        var scrollBarGroup = this._scrollBarGroup;\r\n        if (scrollBarOptions.visible) {\r\n            scrollBarOptions.rotated = this._isRotated();\r\n            this._scrollBar = (this._scrollBar || new _chart_components_scroll_bar__WEBPACK_IMPORTED_MODULE_14__[\"ScrollBar\"](this._renderer, scrollBarGroup)).update(scrollBarOptions)\r\n        } else {\r\n            scrollBarGroup.linkRemove();\r\n            this._scrollBar && this._scrollBar.dispose();\r\n            this._scrollBar = null\r\n        }\r\n    },\r\n    _executeAppendAfterSeries(append) {\r\n        append()\r\n    },\r\n    _prepareToRender(drawOptions) {\r\n        var panesBorderOptions = this._createPanesBorderOptions();\r\n        this._createPanesBackground();\r\n        this._appendAxesGroups();\r\n        this._adjustViewport();\r\n        return panesBorderOptions\r\n    },\r\n    _adjustViewport() {\r\n        var adjustOnZoom = this._themeManager.getOptions(\"adjustOnZoom\");\r\n        if (!adjustOnZoom) {\r\n            return\r\n        }\r\n        this._valueAxes.forEach(axis => axis.adjust())\r\n    },\r\n    _recreateSizeDependentObjects(isCanvasChanged) {\r\n        var that = this;\r\n        var series = that._getVisibleSeries();\r\n        var useAggregation = series.some(s => s.useAggregation());\r\n        var zoomChanged = that._isZooming();\r\n        if (!useAggregation) {\r\n            return\r\n        }\r\n        that._argumentAxes.forEach((function(axis) {\r\n            axis.updateCanvas(that._canvas, true)\r\n        }));\r\n        series.forEach((function(series) {\r\n            if (series.useAggregation() && (isCanvasChanged || zoomChanged || !series._useAllAggregatedPoints)) {\r\n                series.createPoints()\r\n            }\r\n        }));\r\n        that._processSeriesFamilies()\r\n    },\r\n    _isZooming() {\r\n        var argumentAxis = this.getArgumentAxis();\r\n        if (!argumentAxis || !argumentAxis.getTranslator()) {\r\n            return false\r\n        }\r\n        var businessRange = argumentAxis.getTranslator().getBusinessRange();\r\n        var zoomRange = argumentAxis.getViewport();\r\n        var min = zoomRange ? zoomRange.min : 0;\r\n        var max = zoomRange ? zoomRange.max : 0;\r\n        if (\"logarithmic\" === businessRange.axisType) {\r\n            min = Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__[\"getLog\"])(min, businessRange.base);\r\n            max = Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__[\"getLog\"])(max, businessRange.base)\r\n        }\r\n        var viewportDistance = businessRange.axisType === DISCRETE ? Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__[\"getCategoriesInfo\"])(businessRange.categories, min, max).categories.length : Math.abs(max - min);\r\n        var precision = Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_10__[\"getPrecision\"])(viewportDistance);\r\n        precision = precision > 1 ? Math.pow(10, precision - 2) : 1;\r\n        var zoomChanged = Math.round((this._zoomLength - viewportDistance) * precision) / precision !== 0;\r\n        this._zoomLength = viewportDistance;\r\n        return zoomChanged\r\n    },\r\n    _handleSeriesDataUpdated: function() {\r\n        var that = this;\r\n        var viewport = new _translators_range__WEBPACK_IMPORTED_MODULE_18__[\"Range\"];\r\n        that.series.forEach((function(s) {\r\n            viewport.addRange(s.getArgumentRange())\r\n        }));\r\n        that._argumentAxes.forEach((function(axis) {\r\n            axis.updateCanvas(that._canvas, true);\r\n            axis.setBusinessRange(viewport, that._axesReinitialized)\r\n        }));\r\n        that.callBase()\r\n    },\r\n    _isLegendInside: function() {\r\n        return this._legend && \"inside\" === this._legend.getPosition()\r\n    },\r\n    _isRotated: function() {\r\n        return this._themeManager.getOptions(\"rotated\")\r\n    },\r\n    _getLayoutTargets: function() {\r\n        return this.panes\r\n    },\r\n    _applyClipRects: function(panesBorderOptions) {\r\n        this._drawPanesBorders(panesBorderOptions);\r\n        this._createClipRectsForPanes();\r\n        this._applyClipRectsForAxes();\r\n        this._fillPanesBackground()\r\n    },\r\n    _updateLegendPosition: function(drawOptions, legendHasInsidePosition) {\r\n        if (drawOptions.drawLegend && this._legend && legendHasInsidePosition) {\r\n            var panes = this.panes;\r\n            var newCanvas = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])({}, panes[0].canvas);\r\n            var layoutManager = new _chart_components_layout_manager__WEBPACK_IMPORTED_MODULE_17__[\"LayoutManager\"];\r\n            newCanvas.right = panes[panes.length - 1].canvas.right;\r\n            newCanvas.bottom = panes[panes.length - 1].canvas.bottom;\r\n            layoutManager.layoutInsideLegend(this._legend, newCanvas)\r\n        }\r\n    },\r\n    _allowLegendInsidePosition: () => true,\r\n    _applyExtraSettings: function(series) {\r\n        var paneIndex = this._getPaneIndex(series.pane);\r\n        var panesClipRects = this._panesClipRects;\r\n        var wideClipRect = panesClipRects.wide[paneIndex];\r\n        series.setClippingParams(panesClipRects.base[paneIndex].id, wideClipRect && wideClipRect.id, this._getPaneBorderVisibility(paneIndex))\r\n    },\r\n    _updatePanesCanvases: function(drawOptions) {\r\n        if (!drawOptions.recreateCanvas) {\r\n            return\r\n        }\r\n        Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__[\"updatePanesCanvases\"])(this.panes, this._canvas, this._isRotated())\r\n    },\r\n    _normalizePanesHeight: function() {\r\n        Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__[\"normalizePanesHeight\"])(this.panes)\r\n    },\r\n    _renderScaleBreaks: function() {\r\n        this._valueAxes.concat(this._argumentAxes).forEach((function(axis) {\r\n            axis.drawScaleBreaks()\r\n        }))\r\n    },\r\n    _getArgFilter() {\r\n        return _series_helpers_range_data_calculator__WEBPACK_IMPORTED_MODULE_16__[\"default\"].getViewPortFilter(this.getArgumentAxis().visualRange() || {})\r\n    },\r\n    _applyPointMarkersAutoHiding() {\r\n        var that = this;\r\n        var allSeries = that.series;\r\n        if (!that._themeManager.getOptions(\"autoHidePointMarkers\")) {\r\n            allSeries.forEach(s => s.autoHidePointMarkers = false);\r\n            return\r\n        }\r\n        that.panes.forEach(_ref => {\r\n            var {\r\n                borderCoords: borderCoords,\r\n                name: name\r\n            } = _ref;\r\n            var series = allSeries.filter(s => s.pane === name && s.usePointsToDefineAutoHiding());\r\n            var argAxis = that.getArgumentAxis();\r\n            var markersInfo = collectMarkersInfoBySeries(allSeries, series, argAxis);\r\n            fastHidingPointMarkersByArea(borderCoords, markersInfo, series);\r\n            if (markersInfo.series.length) {\r\n                var argVisualRange = argAxis.visualRange();\r\n                var argAxisIsDiscrete = argAxis.getOptions().type === DISCRETE;\r\n                var sortingCallback = argAxisIsDiscrete ? (p1, p2) => argVisualRange.categories.indexOf(p1.argument) - argVisualRange.categories.indexOf(p2.argument) : (p1, p2) => p1.argument - p2.argument;\r\n                var points = [];\r\n                markersInfo.series.forEach(s => points = points.concat(s.points));\r\n                points.sort(sortingCallback);\r\n                updateMarkersInfo(points, markersInfo.overloadedSeries);\r\n                applyAutoHidePointMarkers(allSeries, series, markersInfo.overloadedSeries, argAxis)\r\n            }\r\n        })\r\n    },\r\n    _renderAxes: function(drawOptions, panesBorderOptions) {\r\n        function calculateTitlesWidth(axes) {\r\n            return axes.map(axis => {\r\n                if (!axis.getTitle) {\r\n                    return 0\r\n                }\r\n                var title = axis.getTitle();\r\n                return title ? title.bBox.width : 0\r\n            })\r\n        }\r\n        var that = this;\r\n        var rotated = that._isRotated();\r\n        var synchronizeMultiAxes = that._themeManager.getOptions(\"synchronizeMultiAxes\");\r\n        var scrollBar = that._scrollBar ? [that._scrollBar] : [];\r\n        var extendedArgAxes = that._isArgumentAxisBeforeScrollBar() ? that._argumentAxes.concat(scrollBar) : scrollBar.concat(that._argumentAxes);\r\n        var verticalAxes = rotated ? that._argumentAxes : that._valueAxes;\r\n        var verticalElements = rotated ? extendedArgAxes : that._valueAxes;\r\n        var horizontalAxes = rotated ? that._valueAxes : that._argumentAxes;\r\n        var horizontalElements = rotated ? that._valueAxes : extendedArgAxes;\r\n        var allAxes = verticalAxes.concat(horizontalAxes);\r\n        var allElements = allAxes.concat(scrollBar);\r\n        var verticalAxesFirstDrawing = verticalAxes.some(v => v.isFirstDrawing());\r\n        that._normalizePanesHeight();\r\n        that._updatePanesCanvases(drawOptions);\r\n        var panesCanvases = that.panes.reduce((function(canvases, pane) {\r\n            canvases[pane.name] = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])({}, pane.canvas);\r\n            return canvases\r\n        }), {});\r\n        var paneSizes = that.panes.reduce((sizes, pane) => {\r\n            sizes[pane.name] = {\r\n                height: pane.height,\r\n                unit: pane.unit\r\n            };\r\n            return sizes\r\n        }, {});\r\n        var cleanPanesCanvases = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])(true, {}, panesCanvases);\r\n        that._initCustomPositioningAxes();\r\n        var needCustomAdjustAxes = that._axesBoundaryPositioning();\r\n        if (!drawOptions.adjustAxes && !needCustomAdjustAxes) {\r\n            drawAxesWithTicks(verticalAxes, !rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);\r\n            drawAxesWithTicks(horizontalAxes, rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);\r\n            performActionOnAxes(allAxes, \"prepareAnimation\");\r\n            that._renderScaleBreaks();\r\n            horizontalAxes.forEach(a => a.resolveOverlappingForCustomPositioning(verticalAxes));\r\n            verticalAxes.forEach(a => a.resolveOverlappingForCustomPositioning(horizontalAxes));\r\n            return false\r\n        }\r\n        if (needCustomAdjustAxes) {\r\n            allAxes.forEach(a => a.customPositionIsAvailable() && a.shift({\r\n                top: 0,\r\n                left: 0,\r\n                bottom: 0,\r\n                right: 0\r\n            }))\r\n        }\r\n        if (that._scrollBar) {\r\n            that._scrollBar.setPane(that.panes)\r\n        }\r\n        var vAxesMargins = {\r\n            panes: {}\r\n        };\r\n        var hAxesMargins = getHorizontalAxesMargins(horizontalElements, axis => axis.estimateMargins(panesCanvases[axis.pane]));\r\n        panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);\r\n        var drawAxesAndSetCanvases = isHorizontal => {\r\n            var axes = isHorizontal ? horizontalAxes : verticalAxes;\r\n            var condition = (isHorizontal ? rotated : !rotated) && synchronizeMultiAxes;\r\n            drawAxesWithTicks(axes, condition, panesCanvases, panesBorderOptions);\r\n            if (isHorizontal) {\r\n                hAxesMargins = getHorizontalAxesMargins(horizontalElements, getAxisMargins)\r\n            } else {\r\n                vAxesMargins = getVerticalAxesMargins(verticalElements)\r\n            }\r\n            panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins)\r\n        };\r\n        drawAxesAndSetCanvases(false);\r\n        drawAxesAndSetCanvases(true);\r\n        if (!that._changesApplying && that._estimateTickIntervals(verticalAxes, panesCanvases)) {\r\n            drawAxesAndSetCanvases(false)\r\n        }\r\n        var oldTitlesWidth = calculateTitlesWidth(verticalAxes);\r\n        var visibleSeries = that._getVisibleSeries();\r\n        var pointsToAnimation = that._getPointsToAnimation(visibleSeries);\r\n        var axesIsAnimated = axisAnimationEnabled(drawOptions, pointsToAnimation);\r\n        performActionOnAxes(allElements, \"updateSize\", panesCanvases, axesIsAnimated);\r\n        horizontalElements.forEach(shiftAxis(\"top\", \"bottom\"));\r\n        verticalElements.forEach(shiftAxis(\"left\", \"right\"));\r\n        that._renderScaleBreaks();\r\n        that.panes.forEach((function(pane) {\r\n            Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])(pane.canvas, panesCanvases[pane.name])\r\n        }));\r\n        that._valueAxes.forEach(axis => {\r\n            axis.setInitRange()\r\n        });\r\n        verticalAxes.forEach((axis, i) => {\r\n            var _axis$hasWrap;\r\n            if (null !== (_axis$hasWrap = axis.hasWrap) && void 0 !== _axis$hasWrap && _axis$hasWrap.call(axis)) {\r\n                var title = axis.getTitle();\r\n                var newTitleWidth = title ? title.bBox.width : 0;\r\n                var offset = newTitleWidth - oldTitlesWidth[i];\r\n                if (\"right\" === axis.getOptions().position) {\r\n                    vAxesMargins.right += offset\r\n                } else {\r\n                    vAxesMargins.left += offset;\r\n                    that.panes.forEach(_ref2 => {\r\n                        var {\r\n                            name: name\r\n                        } = _ref2;\r\n                        return vAxesMargins.panes[name].left += offset\r\n                    })\r\n                }\r\n                panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);\r\n                performActionOnAxes(allElements, \"updateSize\", panesCanvases, false, false);\r\n                oldTitlesWidth = calculateTitlesWidth(verticalAxes)\r\n            }\r\n        });\r\n        if (verticalAxes.some(v => v.customPositionIsAvailable() && v.getCustomPosition() !== v._axisPosition)) {\r\n            axesIsAnimated && that._resetAxesAnimation(verticalAxesFirstDrawing, false);\r\n            performActionOnAxes(verticalAxes, \"updateSize\", panesCanvases, axesIsAnimated)\r\n        }\r\n        horizontalAxes.forEach(a => a.resolveOverlappingForCustomPositioning(verticalAxes));\r\n        verticalAxes.forEach(a => a.resolveOverlappingForCustomPositioning(horizontalAxes));\r\n        return cleanPanesCanvases\r\n    },\r\n    _getExtraTemplatesItems() {\r\n        var allAxes = (this._argumentAxes || []).concat(this._valueAxes || []);\r\n        var elements = this._collectTemplatesFromItems(allAxes);\r\n        return {\r\n            items: elements.items,\r\n            groups: elements.groups,\r\n            launchRequest() {\r\n                allAxes.forEach((function(a) {\r\n                    a.setRenderedState(true)\r\n                }))\r\n            },\r\n            doneRequest() {\r\n                allAxes.forEach((function(a) {\r\n                    a.setRenderedState(false)\r\n                }))\r\n            }\r\n        }\r\n    },\r\n    _estimateTickIntervals: (axes, canvases) => axes.some(axis => axis.estimateTickInterval(canvases[axis.pane])),\r\n    checkForMoreSpaceForPanesCanvas() {\r\n        var rotated = this._isRotated();\r\n        var panesAreCustomSized = this.panes.filter(p => p.unit).length === this.panes.length;\r\n        var needSpace = false;\r\n        if (panesAreCustomSized) {\r\n            var needHorizontalSpace = 0;\r\n            var needVerticalSpace = 0;\r\n            if (rotated) {\r\n                var argAxisRightMargin = this.getArgumentAxis().getMargins().right;\r\n                var rightPanesIndent = Math.min.apply(Math, this.panes.map(p => p.canvas.right));\r\n                needHorizontalSpace = this._canvas.right + argAxisRightMargin - rightPanesIndent\r\n            } else {\r\n                var argAxisBottomMargin = this.getArgumentAxis().getMargins().bottom;\r\n                var bottomPanesIndent = Math.min.apply(Math, this.panes.map(p => p.canvas.bottom));\r\n                needVerticalSpace = this._canvas.bottom + argAxisBottomMargin - bottomPanesIndent\r\n            }\r\n            needSpace = needHorizontalSpace > 0 || needVerticalSpace > 0 ? {\r\n                width: needHorizontalSpace,\r\n                height: needVerticalSpace\r\n            } : false;\r\n            if (0 !== needVerticalSpace) {\r\n                var realSize = this.getSize();\r\n                var customSize = this.option(\"size\");\r\n                var container = this._$element[0];\r\n                var containerHasStyledHeight = !!parseInt(container.style.height) || 0 !== this._containerInitialHeight;\r\n                if (!rotated && !(customSize && customSize.height) && !containerHasStyledHeight) {\r\n                    this._forceResize(realSize.width, realSize.height + needVerticalSpace);\r\n                    needSpace = false\r\n                }\r\n            }\r\n        } else {\r\n            needSpace = this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), rotated, pane => ({\r\n                width: rotated && !!pane.unit,\r\n                height: !rotated && !!pane.unit\r\n            }))\r\n        }\r\n        return needSpace\r\n    },\r\n    _forceResize(width, height) {\r\n        this._renderer.resize(width, height);\r\n        this._updateSize();\r\n        this._setContentSize();\r\n        this._preserveOriginalCanvas();\r\n        this._updateCanvasClipRect(this._canvas)\r\n    },\r\n    _shrinkAxes(sizeShortage, panesCanvases) {\r\n        if (!sizeShortage || !panesCanvases) {\r\n            return\r\n        }\r\n        this._renderer.stopAllAnimations(true);\r\n        var rotated = this._isRotated();\r\n        var scrollBar = this._scrollBar ? [this._scrollBar] : [];\r\n        var extendedArgAxes = this._isArgumentAxisBeforeScrollBar() ? this._argumentAxes.concat(scrollBar) : scrollBar.concat(this._argumentAxes);\r\n        var verticalAxes = rotated ? extendedArgAxes : this._valueAxes;\r\n        var horizontalAxes = rotated ? this._valueAxes : extendedArgAxes;\r\n        var allAxes = verticalAxes.concat(horizontalAxes);\r\n        if (sizeShortage.width || sizeShortage.height) {\r\n            checkUsedSpace(sizeShortage, \"height\", horizontalAxes, getHorizontalAxesMargins);\r\n            checkUsedSpace(sizeShortage, \"width\", verticalAxes, getVerticalAxesMargins);\r\n            performActionOnAxes(allAxes, \"updateSize\", panesCanvases);\r\n            var paneSizes = this.panes.reduce((sizes, pane) => {\r\n                sizes[pane.name] = {\r\n                    height: pane.height,\r\n                    unit: pane.unit\r\n                };\r\n                return sizes\r\n            }, {});\r\n            panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, getVerticalAxesMargins(verticalAxes), getHorizontalAxesMargins(horizontalAxes, getAxisMargins));\r\n            performActionOnAxes(allAxes, \"updateSize\", panesCanvases);\r\n            horizontalAxes.forEach(shiftAxis(\"top\", \"bottom\"));\r\n            verticalAxes.forEach(shiftAxis(\"left\", \"right\"));\r\n            this.panes.forEach(pane => Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])(pane.canvas, panesCanvases[pane.name]))\r\n        }\r\n    },\r\n    _isArgumentAxisBeforeScrollBar() {\r\n        var argumentAxis = this.getArgumentAxis();\r\n        if (this._scrollBar) {\r\n            var _argumentAxis$getOpti;\r\n            var argAxisPosition = argumentAxis.getResolvedBoundaryPosition();\r\n            var argAxisLabelPosition = null === (_argumentAxis$getOpti = argumentAxis.getOptions().label) || void 0 === _argumentAxis$getOpti ? void 0 : _argumentAxis$getOpti.position;\r\n            var scrollBarPosition = this._scrollBar.getOptions().position;\r\n            return argumentAxis.hasNonBoundaryPosition() || scrollBarPosition === argAxisPosition && argAxisLabelPosition !== scrollBarPosition\r\n        }\r\n        return false\r\n    },\r\n    _getPanesParameters: function() {\r\n        var panes = this.panes;\r\n        var i;\r\n        var params = [];\r\n        for (i = 0; i < panes.length; i++) {\r\n            if (this._getPaneBorderVisibility(i)) {\r\n                params.push({\r\n                    coords: panes[i].borderCoords,\r\n                    clipRect: this._panesClipRects.fixed[i]\r\n                })\r\n            }\r\n        }\r\n        return params\r\n    },\r\n    _createCrosshairCursor: function() {\r\n        var options = this._themeManager.getOptions(\"crosshair\") || {};\r\n        var argumentAxis = this.getArgumentAxis();\r\n        var axes = !this._isRotated() ? [\r\n            [argumentAxis], this._valueAxes\r\n        ] : [this._valueAxes, [argumentAxis]];\r\n        var parameters = {\r\n            canvas: this._getCommonCanvas(),\r\n            panes: this._getPanesParameters(),\r\n            axes: axes\r\n        };\r\n        if (!options || !options.enabled) {\r\n            return\r\n        }\r\n        if (!this._crosshair) {\r\n            this._crosshair = new _chart_components_crosshair__WEBPACK_IMPORTED_MODULE_15__[\"Crosshair\"](this._renderer, options, parameters, this._crosshairCursorGroup)\r\n        } else {\r\n            this._crosshair.update(options, parameters)\r\n        }\r\n        this._crosshair.render()\r\n    },\r\n    _getCommonCanvas: function() {\r\n        var i;\r\n        var canvas;\r\n        var commonCanvas;\r\n        var panes = this.panes;\r\n        for (i = 0; i < panes.length; i++) {\r\n            canvas = panes[i].canvas;\r\n            if (!commonCanvas) {\r\n                commonCanvas = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])({}, canvas)\r\n            } else {\r\n                commonCanvas.right = canvas.right;\r\n                commonCanvas.bottom = canvas.bottom\r\n            }\r\n        }\r\n        return commonCanvas\r\n    },\r\n    _createPanesBackground: function() {\r\n        var defaultBackgroundColor = this._themeManager.getOptions(\"commonPaneSettings\").backgroundColor;\r\n        var backgroundColor;\r\n        var renderer = this._renderer;\r\n        var rect;\r\n        var i;\r\n        var rects = [];\r\n        this._panesBackgroundGroup.clear();\r\n        for (i = 0; i < this.panes.length; i++) {\r\n            backgroundColor = this.panes[i].backgroundColor || defaultBackgroundColor;\r\n            if (!backgroundColor || \"none\" === backgroundColor) {\r\n                rects.push(null);\r\n                continue\r\n            }\r\n            rect = renderer.rect(0, 0, 0, 0).attr({\r\n                fill: backgroundColor,\r\n                \"stroke-width\": 0\r\n            }).append(this._panesBackgroundGroup);\r\n            rects.push(rect)\r\n        }\r\n        this.panesBackground = rects\r\n    },\r\n    _fillPanesBackground: function() {\r\n        var that = this;\r\n        var bc;\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_5__[\"each\"])(that.panes, (function(i, pane) {\r\n            bc = pane.borderCoords;\r\n            if (null !== that.panesBackground[i]) {\r\n                that.panesBackground[i].attr({\r\n                    x: bc.left,\r\n                    y: bc.top,\r\n                    width: bc.width,\r\n                    height: bc.height\r\n                })\r\n            }\r\n        }))\r\n    },\r\n    _calcPaneBorderCoords: function(pane) {\r\n        var canvas = pane.canvas;\r\n        var bc = pane.borderCoords = pane.borderCoords || {};\r\n        bc.left = canvas.left;\r\n        bc.top = canvas.top;\r\n        bc.right = canvas.width - canvas.right;\r\n        bc.bottom = canvas.height - canvas.bottom;\r\n        bc.width = Math.max(bc.right - bc.left, 0);\r\n        bc.height = Math.max(bc.bottom - bc.top, 0)\r\n    },\r\n    _drawPanesBorders: function(panesBorderOptions) {\r\n        var that = this;\r\n        var rotated = that._isRotated();\r\n        that._panesBorderGroup.linkRemove().clear();\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_5__[\"each\"])(that.panes, (function(i, pane) {\r\n            var borderOptions = panesBorderOptions[pane.name];\r\n            var attr = {\r\n                fill: \"none\",\r\n                stroke: borderOptions.color,\r\n                \"stroke-opacity\": borderOptions.opacity,\r\n                \"stroke-width\": borderOptions.width,\r\n                dashStyle: borderOptions.dashStyle,\r\n                \"stroke-linecap\": \"square\"\r\n            };\r\n            that._calcPaneBorderCoords(pane, rotated);\r\n            if (!borderOptions.visible) {\r\n                return\r\n            }\r\n            var bc = pane.borderCoords;\r\n            var segmentRectParams = Object(_utils__WEBPACK_IMPORTED_MODULE_7__[\"prepareSegmentRectPoints\"])(bc.left, bc.top, bc.width, bc.height, borderOptions);\r\n            that._renderer.path(segmentRectParams.points, segmentRectParams.pathType).attr(attr).append(that._panesBorderGroup)\r\n        }));\r\n        that._panesBorderGroup.linkAppend()\r\n    },\r\n    _createClipRect: function(clipArray, index, left, top, width, height) {\r\n        var clipRect = clipArray[index];\r\n        if (!clipRect) {\r\n            clipRect = this._renderer.clipRect(left, top, width, height);\r\n            clipArray[index] = clipRect\r\n        } else {\r\n            clipRect.attr({\r\n                x: left,\r\n                y: top,\r\n                width: width,\r\n                height: height\r\n            })\r\n        }\r\n    },\r\n    _createClipRectsForPanes: function() {\r\n        var that = this;\r\n        var canvas = that._canvas;\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_5__[\"each\"])(that.panes, (function(i, pane) {\r\n            var needWideClipRect = false;\r\n            var bc = pane.borderCoords;\r\n            var left = bc.left;\r\n            var top = bc.top;\r\n            var width = bc.width;\r\n            var height = bc.height;\r\n            var panesClipRects = that._panesClipRects;\r\n            that._createClipRect(panesClipRects.fixed, i, left, top, width, height);\r\n            that._createClipRect(panesClipRects.base, i, left, top, width, height);\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_5__[\"each\"])(that.series, (function(_, series) {\r\n                if (series.pane === pane.name && (series.isFinancialSeries() || series.areErrorBarsVisible())) {\r\n                    needWideClipRect = true\r\n                }\r\n            }));\r\n            if (needWideClipRect) {\r\n                if (that._isRotated()) {\r\n                    top = 0;\r\n                    height = canvas.height\r\n                } else {\r\n                    left = 0;\r\n                    width = canvas.width\r\n                }\r\n                that._createClipRect(panesClipRects.wide, i, left, top, width, height)\r\n            } else {\r\n                panesClipRects.wide[i] = null\r\n            }\r\n        }))\r\n    },\r\n    _applyClipRectsForAxes() {\r\n        var axes = this._getAllAxes();\r\n        var chartCanvasClipRectID = this._getCanvasClipRectID();\r\n        for (var i = 0; i < axes.length; i++) {\r\n            var elementsClipRectID = this._getElementsClipRectID(axes[i].pane);\r\n            axes[i].applyClipRects(elementsClipRectID, chartCanvasClipRectID)\r\n        }\r\n    },\r\n    _getPaneBorderVisibility: function(paneIndex) {\r\n        var commonPaneBorderVisible = this._themeManager.getOptions(\"commonPaneSettings\").border.visible;\r\n        var pane = this.panes[paneIndex] || {};\r\n        var paneBorder = pane.border || {};\r\n        return \"visible\" in paneBorder ? paneBorder.visible : commonPaneBorderVisible\r\n    },\r\n    _getCanvasForPane: function(paneName) {\r\n        var panes = this.panes;\r\n        var panesNumber = panes.length;\r\n        var i;\r\n        for (i = 0; i < panesNumber; i++) {\r\n            if (panes[i].name === paneName) {\r\n                return panes[i].canvas\r\n            }\r\n        }\r\n    },\r\n    _getTrackerSettings: function() {\r\n        var themeManager = this._themeManager;\r\n        return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])(this.callBase(), {\r\n            chart: this,\r\n            rotated: this._isRotated(),\r\n            crosshair: this._getCrosshairOptions().enabled ? this._crosshair : null,\r\n            stickyHovering: themeManager.getOptions(\"stickyHovering\")\r\n        })\r\n    },\r\n    _resolveLabelOverlappingStack: function() {\r\n        var that = this;\r\n        var isRotated = that._isRotated();\r\n        var shiftDirection = isRotated ? function(box, length) {\r\n            return {\r\n                x: box.x - length,\r\n                y: box.y\r\n            }\r\n        } : function(box, length) {\r\n            return {\r\n                x: box.x,\r\n                y: box.y - length\r\n            }\r\n        };\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_5__[\"each\"])(that._getStackPoints(), (function(_, stacks) {\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_5__[\"each\"])(stacks, (function(_, points) {\r\n                var isInverted = points[0].series.getValueAxis().getOptions().inverted;\r\n                _chart_components_base_chart__WEBPACK_IMPORTED_MODULE_11__[\"overlapping\"].resolveLabelOverlappingInOneDirection(points, that._getCommonCanvas(), isRotated, isInverted, shiftDirection, (a, b) => {\r\n                    var coordPosition = isRotated ? 1 : 0;\r\n                    var figureCenter1 = a.labels[0].getFigureCenter()[coordPosition];\r\n                    var figureCenter12 = b.labels[0].getFigureCenter()[coordPosition];\r\n                    if (figureCenter1 - figureCenter12 === 0) {\r\n                        return (a.value() - b.value()) * (a.labels[0].getPoint().series.getValueAxis().getTranslator().isInverted() ? -1 : 1)\r\n                    }\r\n                    return 0\r\n                })\r\n            }))\r\n        }))\r\n    },\r\n    _getStackPoints: function() {\r\n        var stackPoints = {};\r\n        var visibleSeries = this._getVisibleSeries();\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_5__[\"each\"])(visibleSeries, (function(_, singleSeries) {\r\n            var points = singleSeries.getPoints();\r\n            var stackName = singleSeries.getStackName() || null;\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_5__[\"each\"])(points, (function(_, point) {\r\n                var argument = point.argument;\r\n                if (!stackPoints[argument]) {\r\n                    stackPoints[argument] = {}\r\n                }\r\n                if (!stackPoints[argument][stackName]) {\r\n                    stackPoints[argument][stackName] = []\r\n                }\r\n                stackPoints[argument][stackName].push(point)\r\n            }))\r\n        }));\r\n        return stackPoints\r\n    },\r\n    _getCrosshairOptions: function() {\r\n        return this._getOption(\"crosshair\")\r\n    },\r\n    zoomArgument(min, max) {\r\n        if (!this._initialized || !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(min) && !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(max)) {\r\n            return\r\n        }\r\n        this.getArgumentAxis().visualRange([min, max])\r\n    },\r\n    resetVisualRange() {\r\n        var that = this;\r\n        var axes = that._argumentAxes;\r\n        var nonVirtualArgumentAxis = that.getArgumentAxis();\r\n        axes.forEach(axis => {\r\n            axis.resetVisualRange(nonVirtualArgumentAxis !== axis);\r\n            that._applyCustomVisualRangeOption(axis)\r\n        });\r\n        that.callBase()\r\n    },\r\n    getVisibleArgumentBounds: function() {\r\n        var translator = this._argumentAxes[0].getTranslator();\r\n        var range = translator.getBusinessRange();\r\n        var isDiscrete = range.axisType === DISCRETE;\r\n        var categories = range.categories;\r\n        return {\r\n            minVisible: isDiscrete ? range.minVisible || categories[0] : range.minVisible,\r\n            maxVisible: isDiscrete ? range.maxVisible || categories[categories.length - 1] : range.maxVisible\r\n        }\r\n    },\r\n    _change_FULL_RENDER() {\r\n        this.callBase();\r\n        if (this._changes.has(VISUAL_RANGE)) {\r\n            this._raiseZoomEndHandlers()\r\n        }\r\n    },\r\n    _getAxesForScaling() {\r\n        return [this.getArgumentAxis()].concat(this._valueAxes)\r\n    },\r\n    _applyVisualRangeByVirtualAxes(axis, range) {\r\n        if (axis.isArgumentAxis) {\r\n            if (axis !== this.getArgumentAxis()) {\r\n                return true\r\n            }\r\n            this._argumentAxes.filter(a => a !== axis).forEach(a => a.visualRange(range, {\r\n                start: true,\r\n                end: true\r\n            }))\r\n        }\r\n        return false\r\n    },\r\n    _raiseZoomEndHandlers() {\r\n        this._argumentAxes.forEach(axis => axis.handleZoomEnd());\r\n        this.callBase()\r\n    },\r\n    _setOptionsByReference() {\r\n        this.callBase();\r\n        Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])(this._optionsByReference, {\r\n            \"argumentAxis.visualRange\": true\r\n        })\r\n    },\r\n    option() {\r\n        var option = this.callBase.apply(this, arguments);\r\n        var valueAxis = this._options.silent(\"valueAxis\");\r\n        if (\"array\" === Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"type\"])(valueAxis)) {\r\n            for (var i = 0; i < valueAxis.length; i++) {\r\n                var optionPath = \"valueAxis[\".concat(i, \"].visualRange\");\r\n                this._optionsByReference[optionPath] = true\r\n            }\r\n        }\r\n        return option\r\n    },\r\n    _notifyVisualRange() {\r\n        var argAxis = this._argumentAxes[0];\r\n        var argumentVisualRange = Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__[\"convertVisualRangeObject\"])(argAxis.visualRange(), !_isArray(this.option(\"argumentAxis.visualRange\")));\r\n        if (!argAxis.skipEventRising || !Object(_core_utils__WEBPACK_IMPORTED_MODULE_8__[\"rangesAreEqual\"])(argumentVisualRange, this.option(\"argumentAxis.visualRange\"))) {\r\n            this.option(\"argumentAxis.visualRange\", argumentVisualRange)\r\n        } else {\r\n            argAxis.skipEventRising = null\r\n        }\r\n        this.callBase()\r\n    }\r\n});\r\n\r\n\r\n\r\ndxChart.addPlugin(_chart_components_shutter_zoom__WEBPACK_IMPORTED_MODULE_19__[\"default\"]);\r\ndxChart.addPlugin(_chart_components_zoom_and_pan__WEBPACK_IMPORTED_MODULE_20__[\"default\"]);\r\ndxChart.addPlugin(_core_annotations__WEBPACK_IMPORTED_MODULE_21__[\"plugins\"].core);\r\ndxChart.addPlugin(_core_annotations__WEBPACK_IMPORTED_MODULE_21__[\"plugins\"].chart);\r\nObject(_core_component_registrator__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(\"dxChart\", dxChart);\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (dxChart);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2NoYXJ0LmpzPzQzZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHNEI7QUFHRTtBQUdBO0FBR0Q7QUFHQztBQUdFO0FBQzhCO0FBRzdDO0FBV0s7QUFJTTtBQUdBO0FBR1c7QUFDd0M7QUFHcEM7QUFHSjtBQUlEO0FBQ21DO0FBRzlCO0FBR2Q7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQWlDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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REFBTztBQUN6QixrQkFBa0IsMERBQU87QUFDekIsMkVBQWlCO0FBQ0Ysc0VBQU8sRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS92aXovY2hhcnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3Zpei9jaGFydC5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IHtcclxuICAgIGdldEhlaWdodFxyXG59IGZyb20gXCIuLi9jb3JlL3V0aWxzL3NpemVcIjtcclxuaW1wb3J0IHtcclxuICAgIG5vb3BcclxufSBmcm9tIFwiLi4vY29yZS91dGlscy9jb21tb25cIjtcclxuaW1wb3J0IHtcclxuICAgIGV4dGVuZCBhcyBfZXh0ZW5kXHJcbn0gZnJvbSBcIi4uL2NvcmUvdXRpbHMvZXh0ZW5kXCI7XHJcbmltcG9ydCB7XHJcbiAgICBpbkFycmF5XHJcbn0gZnJvbSBcIi4uL2NvcmUvdXRpbHMvYXJyYXlcIjtcclxuaW1wb3J0IHtcclxuICAgIGhhc1dpbmRvd1xyXG59IGZyb20gXCIuLi9jb3JlL3V0aWxzL3dpbmRvd1wiO1xyXG5pbXBvcnQge1xyXG4gICAgZWFjaCBhcyBfZWFjaFxyXG59IGZyb20gXCIuLi9jb3JlL3V0aWxzL2l0ZXJhdG9yXCI7XHJcbmltcG9ydCByZWdpc3RlckNvbXBvbmVudCBmcm9tIFwiLi4vY29yZS9jb21wb25lbnRfcmVnaXN0cmF0b3JcIjtcclxuaW1wb3J0IHtcclxuICAgIHByZXBhcmVTZWdtZW50UmVjdFBvaW50c1xyXG59IGZyb20gXCIuL3V0aWxzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBtYXAgYXMgX21hcCxcclxuICAgIGdldExvZyxcclxuICAgIGdldENhdGVnb3JpZXNJbmZvLFxyXG4gICAgdXBkYXRlUGFuZXNDYW52YXNlcyxcclxuICAgIGNvbnZlcnRWaXN1YWxSYW5nZU9iamVjdCxcclxuICAgIFBBTkVfUEFERElORyxcclxuICAgIG5vcm1hbGl6ZVBhbmVzSGVpZ2h0LFxyXG4gICAgcmFuZ2VzQXJlRXF1YWwsXHJcbiAgICBpc1JlbGF0aXZlSGVpZ2h0UGFuZVxyXG59IGZyb20gXCIuL2NvcmUvdXRpbHNcIjtcclxuaW1wb3J0IHtcclxuICAgIHR5cGUsXHJcbiAgICBpc0RlZmluZWQgYXMgX2lzRGVmaW5lZFxyXG59IGZyb20gXCIuLi9jb3JlL3V0aWxzL3R5cGVcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldFByZWNpc2lvblxyXG59IGZyb20gXCIuLi9jb3JlL3V0aWxzL21hdGhcIjtcclxuaW1wb3J0IHtcclxuICAgIG92ZXJsYXBwaW5nXHJcbn0gZnJvbSBcIi4vY2hhcnRfY29tcG9uZW50cy9iYXNlX2NoYXJ0XCI7XHJcbmltcG9ydCBtdWx0aUF4ZXNTeW5jaHJvbml6ZXIgZnJvbSBcIi4vY2hhcnRfY29tcG9uZW50cy9tdWx0aV9heGVzX3N5bmNocm9uaXplclwiO1xyXG5pbXBvcnQge1xyXG4gICAgQWR2YW5jZWRDaGFydFxyXG59IGZyb20gXCIuL2NoYXJ0X2NvbXBvbmVudHMvYWR2YW5jZWRfY2hhcnRcIjtcclxuaW1wb3J0IHtcclxuICAgIFNjcm9sbEJhclxyXG59IGZyb20gXCIuL2NoYXJ0X2NvbXBvbmVudHMvc2Nyb2xsX2JhclwiO1xyXG5pbXBvcnQge1xyXG4gICAgQ3Jvc3NoYWlyLFxyXG4gICAgZ2V0TWFyZ2luc1xyXG59IGZyb20gXCIuL2NoYXJ0X2NvbXBvbmVudHMvY3Jvc3NoYWlyXCI7XHJcbmltcG9ydCByYW5nZURhdGFDYWxjdWxhdG9yIGZyb20gXCIuL3Nlcmllcy9oZWxwZXJzL3JhbmdlX2RhdGFfY2FsY3VsYXRvclwiO1xyXG5pbXBvcnQge1xyXG4gICAgTGF5b3V0TWFuYWdlclxyXG59IGZyb20gXCIuL2NoYXJ0X2NvbXBvbmVudHMvbGF5b3V0X21hbmFnZXJcIjtcclxuaW1wb3J0IHtcclxuICAgIFJhbmdlXHJcbn0gZnJvbSBcIi4vdHJhbnNsYXRvcnMvcmFuZ2VcIjtcclxudmFyIERFRkFVTFRfUEFORV9OQU1FID0gXCJkZWZhdWx0XCI7XHJcbnZhciBWSVNVQUxfUkFOR0UgPSBcIlZJU1VBTF9SQU5HRVwiO1xyXG52YXIgREVGQVVMVF9QQU5FUyA9IFt7XHJcbiAgICBuYW1lOiBERUZBVUxUX1BBTkVfTkFNRSxcclxuICAgIGJvcmRlcjoge31cclxufV07XHJcbnZhciBESVNDUkVURSA9IFwiZGlzY3JldGVcIjtcclxudmFyIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxuXHJcbmZ1bmN0aW9uIGdldEZpcnN0QXhpc05hbWVGb3JQYW5lKGF4ZXMsIHBhbmVOYW1lLCBkZWZhdWx0UGFuZSkge1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChheGVzW2ldLnBhbmUgPT09IHBhbmVOYW1lIHx8IHZvaWQgMCA9PT0gYXhlc1tpXS5wYW5lICYmIHBhbmVOYW1lID09PSBkZWZhdWx0UGFuZSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBheGVzW2ldLm5hbWU7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICByZXN1bHQgPSBheGVzWzBdLm5hbWVcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRcclxufVxyXG5cclxuZnVuY3Rpb24gY2hhbmdlVmlzaWJpbGl0eUF4aXNHcmlkcyhheGlzLCBncmlkVmlzaWJpbGl0eSwgbWlub3JHcmlkVmlzaWJpbGl0eSkge1xyXG4gICAgdmFyIGdyaWRPcHQgPSBheGlzLmdldE9wdGlvbnMoKS5ncmlkO1xyXG4gICAgdmFyIG1pbm9yR3JpZE9wdCA9IGF4aXMuZ2V0T3B0aW9ucygpLm1pbm9yR3JpZDtcclxuICAgIGdyaWRPcHQudmlzaWJsZSA9IGdyaWRWaXNpYmlsaXR5O1xyXG4gICAgbWlub3JHcmlkT3B0ICYmIChtaW5vckdyaWRPcHQudmlzaWJsZSA9IG1pbm9yR3JpZFZpc2liaWxpdHkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhpZGVHcmlkc09uTm9uRmlyc3RWYWx1ZUF4aXNGb3JQYW5lKGF4ZXNGb3JQYW5lKSB7XHJcbiAgICB2YXIgYXhpc1Nob3duID0gZmFsc2U7XHJcbiAgICB2YXIgaGlkZGVuU3R1YkF4aXMgPSBbXTtcclxuICAgIHZhciBtaW5vckdyaWRWaXNpYmlsaXR5ID0gYXhlc0ZvclBhbmUuc29tZSgoZnVuY3Rpb24oYXhpcykge1xyXG4gICAgICAgIHZhciBtaW5vckdyaWRPcHRpb25zID0gYXhpcy5nZXRPcHRpb25zKCkubWlub3JHcmlkO1xyXG4gICAgICAgIHJldHVybiBtaW5vckdyaWRPcHRpb25zICYmIG1pbm9yR3JpZE9wdGlvbnMudmlzaWJsZVxyXG4gICAgfSkpO1xyXG4gICAgdmFyIGdyaWRWaXNpYmlsaXR5ID0gYXhlc0ZvclBhbmUuc29tZSgoZnVuY3Rpb24oYXhpcykge1xyXG4gICAgICAgIHZhciBncmlkT3B0aW9ucyA9IGF4aXMuZ2V0T3B0aW9ucygpLmdyaWQ7XHJcbiAgICAgICAgcmV0dXJuIGdyaWRPcHRpb25zICYmIGdyaWRPcHRpb25zLnZpc2libGVcclxuICAgIH0pKTtcclxuICAgIGlmIChheGVzRm9yUGFuZS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgYXhlc0ZvclBhbmUuZm9yRWFjaCgoZnVuY3Rpb24oYXhpcykge1xyXG4gICAgICAgICAgICB2YXIgZ3JpZE9wdCA9IGF4aXMuZ2V0T3B0aW9ucygpLmdyaWQ7XHJcbiAgICAgICAgICAgIGlmIChheGlzU2hvd24pIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZVZpc2liaWxpdHlBeGlzR3JpZHMoYXhpcywgZmFsc2UsIGZhbHNlKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdyaWRPcHQgJiYgZ3JpZE9wdC52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5nZXRUcmFuc2xhdG9yKCkuZ2V0QnVzaW5lc3NSYW5nZSgpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVZpc2liaWxpdHlBeGlzR3JpZHMoYXhpcywgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBoaWRkZW5TdHViQXhpcy5wdXNoKGF4aXMpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXNTaG93biA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlVmlzaWJpbGl0eUF4aXNHcmlkcyhheGlzLCBncmlkVmlzaWJpbGl0eSwgbWlub3JHcmlkVmlzaWJpbGl0eSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICAhYXhpc1Nob3duICYmIGhpZGRlblN0dWJBeGlzLmxlbmd0aCAmJiBjaGFuZ2VWaXNpYmlsaXR5QXhpc0dyaWRzKGhpZGRlblN0dWJBeGlzWzBdLCBncmlkVmlzaWJpbGl0eSwgbWlub3JHcmlkVmlzaWJpbGl0eSlcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZmluZEF4aXNPcHRpb25zKHZhbHVlQXhlcywgdmFsdWVBeGVzT3B0aW9ucywgYXhpc05hbWUpIHtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICB2YXIgYXhJbmQ7XHJcbiAgICBmb3IgKGF4SW5kID0gMDsgYXhJbmQgPCB2YWx1ZUF4ZXNPcHRpb25zLmxlbmd0aDsgYXhJbmQrKykge1xyXG4gICAgICAgIGlmICh2YWx1ZUF4ZXNPcHRpb25zW2F4SW5kXS5uYW1lID09PSBheGlzTmFtZSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZUF4ZXNPcHRpb25zW2F4SW5kXTtcclxuICAgICAgICAgICAgcmVzdWx0LnByaW9yaXR5ID0gYXhJbmQ7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICBmb3IgKGF4SW5kID0gMDsgYXhJbmQgPCB2YWx1ZUF4ZXMubGVuZ3RoOyBheEluZCsrKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZUF4ZXNbYXhJbmRdLm5hbWUgPT09IGF4aXNOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZUF4ZXNbYXhJbmRdLmdldE9wdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wcmlvcml0eSA9IHZhbHVlQXhlc1theEluZF0ucHJpb3JpdHk7XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG59XHJcblxyXG5mdW5jdGlvbiBmaW5kQXhpcyhwYW5lTmFtZSwgYXhpc05hbWUsIGF4ZXMpIHtcclxuICAgIHZhciBheGlzO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGF4aXMgPSBheGVzW2ldO1xyXG4gICAgICAgIGlmIChheGlzLm5hbWUgPT09IGF4aXNOYW1lICYmIGF4aXMucGFuZSA9PT0gcGFuZU5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF4aXNcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocGFuZU5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZmluZEF4aXModm9pZCAwLCBheGlzTmFtZSwgYXhlcylcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGFyZUF4ZXMoYSwgYikge1xyXG4gICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRvZXNQYW5lRXhpc3QocGFuZXMsIHBhbmVOYW1lKSB7XHJcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgIF9lYWNoKHBhbmVzLCAoZnVuY3Rpb24oXywgcGFuZSkge1xyXG4gICAgICAgIGlmIChwYW5lLm5hbWUgPT09IHBhbmVOYW1lKSB7XHJcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfSkpO1xyXG4gICAgcmV0dXJuIGZvdW5kXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFjY3VtdWxhdGUoZmllbGQsIHNyYzEsIHNyYzIsIGF1eFNwYWNpbmcpIHtcclxuICAgIHZhciB2YWwxID0gc3JjMVtmaWVsZF0gfHwgMDtcclxuICAgIHZhciB2YWwyID0gc3JjMltmaWVsZF0gfHwgMDtcclxuICAgIHJldHVybiB2YWwxICsgdmFsMiArICh2YWwxICYmIHZhbDIgPyBhdXhTcGFjaW5nIDogMClcclxufVxyXG5cclxuZnVuY3Rpb24gcGlja01heChmaWVsZCwgc3JjMSwgc3JjMikge1xyXG4gICAgcmV0dXJuIHBpY2tNYXhWYWx1ZShzcmMxW2ZpZWxkXSwgc3JjMltmaWVsZF0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBpY2tNYXhWYWx1ZSh2YWwxLCB2YWwyKSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgodmFsMSB8fCAwLCB2YWwyIHx8IDApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEF4aXNNYXJnaW5zKGF4aXMpIHtcclxuICAgIHJldHVybiBheGlzLmdldE1hcmdpbnMoKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsQXhlc01hcmdpbnMoYXhlcywgZ2V0TWFyZ2luc0Z1bmMpIHtcclxuICAgIHJldHVybiBheGVzLnJlZHVjZSgoZnVuY3Rpb24obWFyZ2lucywgYXhpcykge1xyXG4gICAgICAgIHZhciBfYXhpcyRnZXRPcnRob2dvbmFsQXg7XHJcbiAgICAgICAgdmFyIGF4aXNNYXJnaW5zID0gZ2V0TWFyZ2luc0Z1bmMoYXhpcyk7XHJcbiAgICAgICAgdmFyIHBhbmVNYXJnaW5zID0gbWFyZ2lucy5wYW5lc1theGlzLnBhbmVdID0gbWFyZ2lucy5wYW5lc1theGlzLnBhbmVdIHx8IHt9O1xyXG4gICAgICAgIHZhciBzcGFjaW5nID0gYXhpcy5nZXRNdWx0aXBsZUF4ZXNTcGFjaW5nKCk7XHJcbiAgICAgICAgcGFuZU1hcmdpbnMudG9wID0gYWNjdW11bGF0ZShcInRvcFwiLCBwYW5lTWFyZ2lucywgYXhpc01hcmdpbnMsIHNwYWNpbmcpO1xyXG4gICAgICAgIHBhbmVNYXJnaW5zLmJvdHRvbSA9IGFjY3VtdWxhdGUoXCJib3R0b21cIiwgcGFuZU1hcmdpbnMsIGF4aXNNYXJnaW5zLCBzcGFjaW5nKTtcclxuICAgICAgICBwYW5lTWFyZ2lucy5sZWZ0ID0gcGlja01heChcImxlZnRcIiwgcGFuZU1hcmdpbnMsIGF4aXNNYXJnaW5zKTtcclxuICAgICAgICBwYW5lTWFyZ2lucy5yaWdodCA9IHBpY2tNYXgoXCJyaWdodFwiLCBwYW5lTWFyZ2lucywgYXhpc01hcmdpbnMpO1xyXG4gICAgICAgIG1hcmdpbnMudG9wID0gcGlja01heChcInRvcFwiLCBwYW5lTWFyZ2lucywgbWFyZ2lucyk7XHJcbiAgICAgICAgbWFyZ2lucy5ib3R0b20gPSBwaWNrTWF4KFwiYm90dG9tXCIsIHBhbmVNYXJnaW5zLCBtYXJnaW5zKTtcclxuICAgICAgICBtYXJnaW5zLmxlZnQgPSBwaWNrTWF4KFwibGVmdFwiLCBwYW5lTWFyZ2lucywgbWFyZ2lucyk7XHJcbiAgICAgICAgbWFyZ2lucy5yaWdodCA9IHBpY2tNYXgoXCJyaWdodFwiLCBwYW5lTWFyZ2lucywgbWFyZ2lucyk7XHJcbiAgICAgICAgdmFyIG9ydGhvZ29uYWxBeGlzID0gbnVsbCA9PT0gKF9heGlzJGdldE9ydGhvZ29uYWxBeCA9IGF4aXMuZ2V0T3J0aG9nb25hbEF4aXMpIHx8IHZvaWQgMCA9PT0gX2F4aXMkZ2V0T3J0aG9nb25hbEF4ID8gdm9pZCAwIDogX2F4aXMkZ2V0T3J0aG9nb25hbEF4LmNhbGwoYXhpcyk7XHJcbiAgICAgICAgaWYgKG9ydGhvZ29uYWxBeGlzICYmIG9ydGhvZ29uYWxBeGlzLmN1c3RvbVBvc2l0aW9uSXNBdmFpbGFibGUoKSAmJiAoIWF4aXMuY3VzdG9tUG9zaXRpb25Jc0JvdW5kYXJ5T3J0aG9nb25hbEF4aXMoKSB8fCAhb3J0aG9nb25hbEF4aXMuY3VzdG9tUG9zaXRpb25FcXVhbHNUb1ByZWRlZmluZWQoKSkpIHtcclxuICAgICAgICAgICAgbWFyZ2luc1tvcnRob2dvbmFsQXhpcy5nZXRSZXNvbHZlZEJvdW5kYXJ5UG9zaXRpb24oKV0gPSAwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXJnaW5zXHJcbiAgICB9KSwge1xyXG4gICAgICAgIHBhbmVzOiB7fVxyXG4gICAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VmVydGljYWxBeGVzTWFyZ2lucyhheGVzKSB7XHJcbiAgICByZXR1cm4gYXhlcy5yZWR1Y2UoKGZ1bmN0aW9uKG1hcmdpbnMsIGF4aXMpIHtcclxuICAgICAgICB2YXIgYXhpc01hcmdpbnMgPSBheGlzLmdldE1hcmdpbnMoKTtcclxuICAgICAgICB2YXIgcGFuZU1hcmdpbnMgPSBtYXJnaW5zLnBhbmVzW2F4aXMucGFuZV0gPSBtYXJnaW5zLnBhbmVzW2F4aXMucGFuZV0gfHwge307XHJcbiAgICAgICAgdmFyIHNwYWNpbmcgPSBheGlzLmdldE11bHRpcGxlQXhlc1NwYWNpbmcoKTtcclxuICAgICAgICBwYW5lTWFyZ2lucy50b3AgPSBwaWNrTWF4KFwidG9wXCIsIHBhbmVNYXJnaW5zLCBheGlzTWFyZ2lucyk7XHJcbiAgICAgICAgcGFuZU1hcmdpbnMuYm90dG9tID0gcGlja01heChcImJvdHRvbVwiLCBwYW5lTWFyZ2lucywgYXhpc01hcmdpbnMpO1xyXG4gICAgICAgIHBhbmVNYXJnaW5zLmxlZnQgPSBhY2N1bXVsYXRlKFwibGVmdFwiLCBwYW5lTWFyZ2lucywgYXhpc01hcmdpbnMsIHNwYWNpbmcpO1xyXG4gICAgICAgIHBhbmVNYXJnaW5zLnJpZ2h0ID0gYWNjdW11bGF0ZShcInJpZ2h0XCIsIHBhbmVNYXJnaW5zLCBheGlzTWFyZ2lucywgc3BhY2luZyk7XHJcbiAgICAgICAgbWFyZ2lucy50b3AgPSBwaWNrTWF4KFwidG9wXCIsIHBhbmVNYXJnaW5zLCBtYXJnaW5zKTtcclxuICAgICAgICBtYXJnaW5zLmJvdHRvbSA9IHBpY2tNYXgoXCJib3R0b21cIiwgcGFuZU1hcmdpbnMsIG1hcmdpbnMpO1xyXG4gICAgICAgIG1hcmdpbnMubGVmdCA9IHBpY2tNYXgoXCJsZWZ0XCIsIHBhbmVNYXJnaW5zLCBtYXJnaW5zKTtcclxuICAgICAgICBtYXJnaW5zLnJpZ2h0ID0gcGlja01heChcInJpZ2h0XCIsIHBhbmVNYXJnaW5zLCBtYXJnaW5zKTtcclxuICAgICAgICByZXR1cm4gbWFyZ2luc1xyXG4gICAgfSksIHtcclxuICAgICAgICBwYW5lczoge31cclxuICAgIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBlcmZvcm1BY3Rpb25PbkF4ZXMoYXhlcywgYWN0aW9uLCBhY3Rpb25Bcmd1bWVudDEsIGFjdGlvbkFyZ3VtZW50MiwgYWN0aW9uQXJndW1lbnQzKSB7XHJcbiAgICBheGVzLmZvckVhY2goKGZ1bmN0aW9uKGF4aXMpIHtcclxuICAgICAgICBheGlzW2FjdGlvbl0oYWN0aW9uQXJndW1lbnQxICYmIGFjdGlvbkFyZ3VtZW50MVtheGlzLnBhbmVdLCBhY3Rpb25Bcmd1bWVudDIgJiYgYWN0aW9uQXJndW1lbnQyW2F4aXMucGFuZV0gfHwgYWN0aW9uQXJndW1lbnQyLCBhY3Rpb25Bcmd1bWVudDMpXHJcbiAgICB9KSlcclxufVxyXG5cclxuZnVuY3Rpb24gc2hyaW5rQ2FudmFzZXMoaXNSb3RhdGVkLCBjYW52YXNlcywgc2l6ZXMsIHZlcnRpY2FsTWFyZ2lucywgaG9yaXpvbnRhbE1hcmdpbnMpIHtcclxuICAgIGZ1bmN0aW9uIGdldE1hcmdpbihzaWRlLCBtYXJnaW5zLCBwYW5lKSB7XHJcbiAgICAgICAgdmFyIG0gPSAtMSA9PT0gKGlzUm90YXRlZCA/IFtcImxlZnRcIiwgXCJyaWdodFwiXSA6IFtcInRvcFwiLCBcImJvdHRvbVwiXSkuaW5kZXhPZihzaWRlKSA/IG1hcmdpbnMgOiBtYXJnaW5zLnBhbmVzW3BhbmVdIHx8IHt9O1xyXG4gICAgICAgIHJldHVybiBtW3NpZGVdXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TWF4TWFyZ2luKHNpZGUsIG1hcmdpbnMxLCBtYXJnaW5zMiwgcGFuZSkge1xyXG4gICAgICAgIHJldHVybiBwaWNrTWF4VmFsdWUoZ2V0TWFyZ2luKHNpZGUsIG1hcmdpbnMxLCBwYW5lKSwgZ2V0TWFyZ2luKHNpZGUsIG1hcmdpbnMyLCBwYW5lKSlcclxuICAgIH1cclxuICAgIHZhciBnZXRPcmlnaW5hbEZpZWxkID0gZmllbGQgPT4gXCJvcmlnaW5hbFwiLmNvbmNhdChmaWVsZFswXS50b1VwcGVyQ2FzZSgpKS5jb25jYXQoZmllbGQuc2xpY2UoMSkpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNocmluayhjYW52YXNlcywgcGFuZU5hbWVzLCBzaXplRmllbGQsIHN0YXJ0TWFyZ2luLCBlbmRNYXJnaW4sIG9wcG9zaXRlTWFyZ2lucykge1xyXG4gICAgICAgIHBhbmVOYW1lcyA9IHBhbmVOYW1lcy5zb3J0KChwMSwgcDIpID0+IGNhbnZhc2VzW3AyXVtzdGFydE1hcmdpbl0gLSBjYW52YXNlc1twMV1bc3RhcnRNYXJnaW5dKTtcclxuICAgICAgICBwYW5lTmFtZXMuZm9yRWFjaChwYW5lID0+IHtcclxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGNhbnZhc2VzW3BhbmVdO1xyXG4gICAgICAgICAgICBvcHBvc2l0ZU1hcmdpbnMuZm9yRWFjaChtYXJnaW4gPT4ge1xyXG4gICAgICAgICAgICAgICAgY2FudmFzW21hcmdpbl0gPSBjYW52YXNbZ2V0T3JpZ2luYWxGaWVsZChtYXJnaW4pXSArIGdldE1heE1hcmdpbihtYXJnaW4sIHZlcnRpY2FsTWFyZ2lucywgaG9yaXpvbnRhbE1hcmdpbnMsIHBhbmUpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGZpcnN0UGFuZSA9IGNhbnZhc2VzW3BhbmVOYW1lc1swXV07XHJcbiAgICAgICAgdmFyIGVtcHR5U3BhY2UgPSBwYW5lTmFtZXMucmVkdWNlKChzcGFjZSwgcGFuZU5hbWUpID0+IHtcclxuICAgICAgICAgICAgc3BhY2UgLT0gZ2V0TWF4TWFyZ2luKHN0YXJ0TWFyZ2luLCB2ZXJ0aWNhbE1hcmdpbnMsIGhvcml6b250YWxNYXJnaW5zLCBwYW5lTmFtZSkgKyBnZXRNYXhNYXJnaW4oZW5kTWFyZ2luLCB2ZXJ0aWNhbE1hcmdpbnMsIGhvcml6b250YWxNYXJnaW5zLCBwYW5lTmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzcGFjZVxyXG4gICAgICAgIH0sIGZpcnN0UGFuZVtzaXplRmllbGRdIC0gZmlyc3RQYW5lW2dldE9yaWdpbmFsRmllbGQoZW5kTWFyZ2luKV0gLSBjYW52YXNlc1twYW5lTmFtZXNbcGFuZU5hbWVzLmxlbmd0aCAtIDFdXVtnZXRPcmlnaW5hbEZpZWxkKHN0YXJ0TWFyZ2luKV0pIC0gUEFORV9QQURESU5HICogKHBhbmVOYW1lcy5sZW5ndGggLSAxKTtcclxuICAgICAgICBlbXB0eVNwYWNlIC09IE9iamVjdC5rZXlzKHNpemVzKS5yZWR1Y2UoKHByZXYsIGtleSkgPT4gcHJldiArICghaXNSZWxhdGl2ZUhlaWdodFBhbmUoc2l6ZXNba2V5XSkgPyBzaXplc1trZXldLmhlaWdodCA6IDApLCAwKTtcclxuICAgICAgICBwYW5lTmFtZXMucmVkdWNlKChvZmZzZXQsIHBhbmUpID0+IHtcclxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGNhbnZhc2VzW3BhbmVdO1xyXG4gICAgICAgICAgICB2YXIgcGFuZVNpemUgPSBzaXplc1twYW5lXTtcclxuICAgICAgICAgICAgb2Zmc2V0IC09IGdldE1heE1hcmdpbihlbmRNYXJnaW4sIHZlcnRpY2FsTWFyZ2lucywgaG9yaXpvbnRhbE1hcmdpbnMsIHBhbmUpO1xyXG4gICAgICAgICAgICBjYW52YXNbZW5kTWFyZ2luXSA9IGZpcnN0UGFuZVtzaXplRmllbGRdIC0gb2Zmc2V0O1xyXG4gICAgICAgICAgICBvZmZzZXQgLT0gIWlzUmVsYXRpdmVIZWlnaHRQYW5lKHBhbmVTaXplKSA/IHBhbmVTaXplLmhlaWdodCA6IE1hdGguZmxvb3IoZW1wdHlTcGFjZSAqIHBhbmVTaXplLmhlaWdodCk7XHJcbiAgICAgICAgICAgIGNhbnZhc1tzdGFydE1hcmdpbl0gPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIG9mZnNldCAtPSBnZXRNYXhNYXJnaW4oc3RhcnRNYXJnaW4sIHZlcnRpY2FsTWFyZ2lucywgaG9yaXpvbnRhbE1hcmdpbnMsIHBhbmUpICsgUEFORV9QQURESU5HO1xyXG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0XHJcbiAgICAgICAgfSwgZmlyc3RQYW5lW3NpemVGaWVsZF0gLSBmaXJzdFBhbmVbZ2V0T3JpZ2luYWxGaWVsZChlbmRNYXJnaW4pXSAtIChlbXB0eVNwYWNlIDwgMCA/IGVtcHR5U3BhY2UgOiAwKSlcclxuICAgIH1cclxuICAgIHZhciBwYW5lTmFtZXMgPSBPYmplY3Qua2V5cyhjYW52YXNlcyk7XHJcbiAgICBpZiAoIWlzUm90YXRlZCkge1xyXG4gICAgICAgIHNocmluayhjYW52YXNlcywgcGFuZU5hbWVzLCBcImhlaWdodFwiLCBcInRvcFwiLCBcImJvdHRvbVwiLCBbXCJsZWZ0XCIsIFwicmlnaHRcIl0pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNocmluayhjYW52YXNlcywgcGFuZU5hbWVzLCBcIndpZHRoXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFtcInRvcFwiLCBcImJvdHRvbVwiXSlcclxuICAgIH1cclxuICAgIHJldHVybiBjYW52YXNlc1xyXG59XHJcblxyXG5mdW5jdGlvbiBkcmF3QXhlc1dpdGhUaWNrcyhheGVzLCBjb25kaXRpb24sIGNhbnZhc2VzLCBwYW5lc0JvcmRlck9wdGlvbnMpIHtcclxuICAgIGlmIChjb25kaXRpb24pIHtcclxuICAgICAgICBwZXJmb3JtQWN0aW9uT25BeGVzKGF4ZXMsIFwiY3JlYXRlVGlja3NcIiwgY2FudmFzZXMpO1xyXG4gICAgICAgIG11bHRpQXhlc1N5bmNocm9uaXplci5zeW5jaHJvbml6ZShheGVzKVxyXG4gICAgfVxyXG4gICAgcGVyZm9ybUFjdGlvbk9uQXhlcyhheGVzLCBcImRyYXdcIiwgIWNvbmRpdGlvbiAmJiBjYW52YXNlcywgcGFuZXNCb3JkZXJPcHRpb25zKVxyXG59XHJcblxyXG5mdW5jdGlvbiBzaGlmdEF4aXMoc2lkZTEsIHNpZGUyKSB7XHJcbiAgICB2YXIgc2hpZnRzID0ge307XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oYXhpcykge1xyXG4gICAgICAgIGlmICghYXhpcy5jdXN0b21Qb3NpdGlvbklzQXZhaWxhYmxlKCkgfHwgYXhpcy5jdXN0b21Qb3NpdGlvbkVxdWFsc1RvUHJlZGVmaW5lZCgpKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGlmdCA9IHNoaWZ0c1theGlzLnBhbmVdID0gc2hpZnRzW2F4aXMucGFuZV0gfHwge1xyXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBzcGFjaW5nID0gYXhpcy5nZXRNdWx0aXBsZUF4ZXNTcGFjaW5nKCk7XHJcbiAgICAgICAgICAgIHZhciBtYXJnaW5zID0gYXhpcy5nZXRNYXJnaW5zKCk7XHJcbiAgICAgICAgICAgIGF4aXMuc2hpZnQoc2hpZnQpO1xyXG4gICAgICAgICAgICBzaGlmdFtzaWRlMV0gPSBhY2N1bXVsYXRlKHNpZGUxLCBzaGlmdCwgbWFyZ2lucywgc3BhY2luZyk7XHJcbiAgICAgICAgICAgIHNoaWZ0W3NpZGUyXSA9IGFjY3VtdWxhdGUoc2lkZTIsIHNoaWZ0LCBtYXJnaW5zLCBzcGFjaW5nKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGF4aXMuc2hpZnQoe1xyXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiAwXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb21tb25TaXplKHNpZGUsIG1hcmdpbnMpIHtcclxuICAgIHZhciBzaXplID0gMDtcclxuICAgIHZhciBwYW5lO1xyXG4gICAgdmFyIHBhbmVNYXJnaW5zO1xyXG4gICAgZm9yIChwYW5lIGluIG1hcmdpbnMucGFuZXMpIHtcclxuICAgICAgICBwYW5lTWFyZ2lucyA9IG1hcmdpbnMucGFuZXNbcGFuZV07XHJcbiAgICAgICAgc2l6ZSArPSBcImhlaWdodFwiID09PSBzaWRlID8gcGFuZU1hcmdpbnMudG9wICsgcGFuZU1hcmdpbnMuYm90dG9tIDogcGFuZU1hcmdpbnMubGVmdCArIHBhbmVNYXJnaW5zLnJpZ2h0XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2l6ZVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja1VzZWRTcGFjZShzaXplU2hvcnRhZ2UsIHNpZGUsIGF4ZXMsIGdldE1hcmdpbkZ1bmMpIHtcclxuICAgIHZhciBzaXplID0gMDtcclxuICAgIGlmIChzaXplU2hvcnRhZ2Vbc2lkZV0gPiAwKSB7XHJcbiAgICAgICAgc2l6ZSA9IGdldENvbW1vblNpemUoc2lkZSwgZ2V0TWFyZ2luRnVuYyhheGVzLCBnZXRBeGlzTWFyZ2lucykpO1xyXG4gICAgICAgIHBlcmZvcm1BY3Rpb25PbkF4ZXMoYXhlcywgXCJoaWRlVGl0bGVcIik7XHJcbiAgICAgICAgc2l6ZVNob3J0YWdlW3NpZGVdIC09IHNpemUgLSBnZXRDb21tb25TaXplKHNpZGUsIGdldE1hcmdpbkZ1bmMoYXhlcywgZ2V0QXhpc01hcmdpbnMpKVxyXG4gICAgfVxyXG4gICAgaWYgKHNpemVTaG9ydGFnZVtzaWRlXSA+IDApIHtcclxuICAgICAgICBwZXJmb3JtQWN0aW9uT25BeGVzKGF4ZXMsIFwiaGlkZU91dGVyRWxlbWVudHNcIilcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXhpc0FuaW1hdGlvbkVuYWJsZWQoZHJhd09wdGlvbnMsIHBvaW50c1RvQW5pbWF0aW9uKSB7XHJcbiAgICB2YXIgcG9pbnRzQ291bnQgPSBwb2ludHNUb0FuaW1hdGlvbi5yZWR1Y2UoKHN1bSwgY291bnQpID0+IHN1bSArIGNvdW50LCAwKSAvIHBvaW50c1RvQW5pbWF0aW9uLmxlbmd0aDtcclxuICAgIHJldHVybiBkcmF3T3B0aW9ucy5hbmltYXRlICYmIHBvaW50c0NvdW50IDw9IGRyYXdPcHRpb25zLmFuaW1hdGlvblBvaW50c0xpbWl0XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbGxlY3RNYXJrZXJzSW5mb0J5U2VyaWVzKGFsbFNlcmllcywgZmlsdGVyZWRTZXJpZXMsIGFyZ0F4aXMpIHtcclxuICAgIHZhciBzZXJpZXMgPSBbXTtcclxuICAgIHZhciBvdmVybG9hZGVkU2VyaWVzID0ge307XHJcbiAgICB2YXIgYXJnVmlzdWFsUmFuZ2UgPSBhcmdBeGlzLnZpc3VhbFJhbmdlKCk7XHJcbiAgICB2YXIgYXJnVHJhbnNsYXRvciA9IGFyZ0F4aXMuZ2V0VHJhbnNsYXRvcigpO1xyXG4gICAgdmFyIGFyZ1ZpZXdQb3J0RmlsdGVyID0gcmFuZ2VEYXRhQ2FsY3VsYXRvci5nZXRWaWV3UG9ydEZpbHRlcihhcmdWaXN1YWxSYW5nZSB8fCB7fSk7XHJcbiAgICBmaWx0ZXJlZFNlcmllcy5mb3JFYWNoKHMgPT4ge1xyXG4gICAgICAgIHZhciB2YWxBeGlzID0gcy5nZXRWYWx1ZUF4aXMoKTtcclxuICAgICAgICB2YXIgdmFsVmlzdWFsUmFuZ2UgPSB2YWxBeGlzLmdldENhbnZhc1JhbmdlKCk7XHJcbiAgICAgICAgdmFyIHZhbFRyYW5zbGF0b3IgPSB2YWxBeGlzLmdldFRyYW5zbGF0b3IoKTtcclxuICAgICAgICB2YXIgc2VyaWVzSW5kZXggPSBhbGxTZXJpZXMuaW5kZXhPZihzKTtcclxuICAgICAgICB2YXIgdmFsVmlld1BvcnRGaWx0ZXIgPSByYW5nZURhdGFDYWxjdWxhdG9yLmdldFZpZXdQb3J0RmlsdGVyKHZhbFZpc3VhbFJhbmdlIHx8IHt9KTtcclxuICAgICAgICBvdmVybG9hZGVkU2VyaWVzW3Nlcmllc0luZGV4XSA9IHt9O1xyXG4gICAgICAgIGZpbHRlcmVkU2VyaWVzLmZvckVhY2goc3IgPT4gb3ZlcmxvYWRlZFNlcmllc1tzZXJpZXNJbmRleF1bYWxsU2VyaWVzLmluZGV4T2Yoc3IpXSA9IDApO1xyXG4gICAgICAgIHZhciBzZXJpZXNQb2ludHMgPSBbXTtcclxuICAgICAgICBzLmdldFBvaW50cygpLmZpbHRlcihwID0+IHAuZ2V0T3B0aW9ucygpLnZpc2libGUgJiYgYXJnVmlld1BvcnRGaWx0ZXIocC5hcmd1bWVudCkgJiYgKHZhbFZpZXdQb3J0RmlsdGVyKHAuZ2V0TWluVmFsdWUodHJ1ZSkpIHx8IHZhbFZpZXdQb3J0RmlsdGVyKHAuZ2V0TWF4VmFsdWUodHJ1ZSkpKSkuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgICAgdmFyIHRwID0ge1xyXG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxyXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IHAuYXJndW1lbnQsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogcC5nZXRNYXhWYWx1ZSh0cnVlKSxcclxuICAgICAgICAgICAgICAgIHNpemU6IHAuYnViYmxlU2l6ZSB8fCBwLmdldE9wdGlvbnMoKS5zaXplXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChwLmdldE1pblZhbHVlKHRydWUpICE9PSBwLmdldE1heFZhbHVlKHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXAgPSBfZXh0ZW5kKHt9LCB0cCk7XHJcbiAgICAgICAgICAgICAgICBtcC52YWx1ZSA9IHAuZ2V0TWluVmFsdWUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBtcC54ID0gYXJnVHJhbnNsYXRvci50byhtcC5hcmd1bWVudCwgMSk7XHJcbiAgICAgICAgICAgICAgICBtcC55ID0gdmFsVHJhbnNsYXRvci50byhtcC52YWx1ZSwgMSk7XHJcbiAgICAgICAgICAgICAgICBzZXJpZXNQb2ludHMucHVzaChtcClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cC54ID0gYXJnVHJhbnNsYXRvci50byh0cC5hcmd1bWVudCwgMSk7XHJcbiAgICAgICAgICAgIHRwLnkgPSB2YWxUcmFuc2xhdG9yLnRvKHRwLnZhbHVlLCAxKTtcclxuICAgICAgICAgICAgc2VyaWVzUG9pbnRzLnB1c2godHApXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb3ZlcmxvYWRlZFNlcmllc1tzZXJpZXNJbmRleF0ucG9pbnRzQ291bnQgPSBzZXJpZXNQb2ludHMubGVuZ3RoO1xyXG4gICAgICAgIG92ZXJsb2FkZWRTZXJpZXNbc2VyaWVzSW5kZXhdLnRvdGFsID0gMDtcclxuICAgICAgICBvdmVybG9hZGVkU2VyaWVzW3Nlcmllc0luZGV4XS5jb250aW51b3VzU2VyaWVzID0gMDtcclxuICAgICAgICBzZXJpZXMucHVzaCh7XHJcbiAgICAgICAgICAgIG5hbWU6IHMubmFtZSxcclxuICAgICAgICAgICAgaW5kZXg6IHNlcmllc0luZGV4LFxyXG4gICAgICAgICAgICBwb2ludHM6IHNlcmllc1BvaW50c1xyXG4gICAgICAgIH0pXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VyaWVzOiBzZXJpZXMsXHJcbiAgICAgICAgb3ZlcmxvYWRlZFNlcmllczogb3ZlcmxvYWRlZFNlcmllc1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseUF1dG9IaWRlUG9pbnRNYXJrZXJzKGFsbFNlcmllcywgZmlsdGVyZWRTZXJpZXMsIG92ZXJsb2FkZWRTZXJpZXMsIGFyZ0F4aXMpIHtcclxuICAgIHZhciBhcmdBeGlzVHlwZSA9IGFyZ0F4aXMuZ2V0T3B0aW9ucygpLnR5cGU7XHJcbiAgICBmaWx0ZXJlZFNlcmllcy5mb3JFYWNoKHMgPT4ge1xyXG4gICAgICAgIHZhciBzZXJpZXNJbmRleCA9IGFsbFNlcmllcy5pbmRleE9mKHMpO1xyXG4gICAgICAgIHMuYXV0b0hpZGVQb2ludE1hcmtlcnMgPSBmYWxzZTtcclxuICAgICAgICB2YXIgdGlja0NvdW50ID0gYXJnQXhpcy5nZXRUaWNrc1ZhbHVlcygpLm1ham9yVGlja3NWYWx1ZXMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChzLmF1dG9IaWRlUG9pbnRNYXJrZXJzRW5hYmxlZCgpICYmIChhcmdBeGlzVHlwZSA9PT0gRElTQ1JFVEUgfHwgb3ZlcmxvYWRlZFNlcmllc1tzZXJpZXNJbmRleF0ucG9pbnRzQ291bnQgPiB0aWNrQ291bnQpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4IGluIG92ZXJsb2FkZWRTZXJpZXNbc2VyaWVzSW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHBhcnNlSW50KGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihpKSB8fCBvdmVybG9hZGVkU2VyaWVzW3Nlcmllc0luZGV4XS50b3RhbCAvIG92ZXJsb2FkZWRTZXJpZXNbc2VyaWVzSW5kZXhdLmNvbnRpbnVvdXNTZXJpZXMgPCAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpID09PSBzZXJpZXNJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgyICogb3ZlcmxvYWRlZFNlcmllc1tpXVtpXSA+PSBvdmVybG9hZGVkU2VyaWVzW2ldLnBvaW50c0NvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuYXV0b0hpZGVQb2ludE1hcmtlcnMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcmxvYWRlZFNlcmllc1tzZXJpZXNJbmRleF0udG90YWwgPj0gb3ZlcmxvYWRlZFNlcmllc1tzZXJpZXNJbmRleF0ucG9pbnRzQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzLmF1dG9IaWRlUG9pbnRNYXJrZXJzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gZmFzdEhpZGluZ1BvaW50TWFya2Vyc0J5QXJlYShjYW52YXMsIG1hcmtlcnNJbmZvLCBzZXJpZXMpIHtcclxuICAgIHZhciBhcmVhID0gY2FudmFzLndpZHRoICogY2FudmFzLmhlaWdodDtcclxuICAgIHZhciBzZXJpZXNQb2ludHMgPSBtYXJrZXJzSW5mby5zZXJpZXM7XHJcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbihpKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRTZXJpZXMgPSBzZXJpZXMuZmlsdGVyKHMgPT4gcy5uYW1lID09PSBzZXJpZXNQb2ludHNbaV0ubmFtZSlbMF07XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IHNlcmllc1BvaW50c1tpXS5wb2ludHM7XHJcbiAgICAgICAgdmFyIHBvaW50U2l6ZSA9IHBvaW50cy5sZW5ndGggPyBwb2ludHNbMF0uc2l6ZSA6IDA7XHJcbiAgICAgICAgdmFyIHBvaW50c0FyZWEgPSBwb2ludFNpemUgKiBwb2ludFNpemUgKiBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChjdXJyZW50U2VyaWVzLmF1dG9IaWRlUG9pbnRNYXJrZXJzRW5hYmxlZCgpICYmIHBvaW50c0FyZWEgPj0gYXJlYSAvIHNlcmllc1BvaW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gc2VyaWVzUG9pbnRzW2ldLmluZGV4O1xyXG4gICAgICAgICAgICBjdXJyZW50U2VyaWVzLmF1dG9IaWRlUG9pbnRNYXJrZXJzID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2VyaWVzUG9pbnRzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgc2VyaWVzLnNwbGljZShzZXJpZXMuaW5kZXhPZihjdXJyZW50U2VyaWVzKSwgMSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBtYXJrZXJzSW5mby5vdmVybG9hZGVkU2VyaWVzW2luZGV4XVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBpID0gc2VyaWVzUG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgX2xvb3AoaSlcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTWFya2Vyc0luZm8ocG9pbnRzLCBvdmVybG9hZGVkU2VyaWVzKSB7XHJcbiAgICB2YXIgaXNDb250aW51b3VzU2VyaWVzID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICB2YXIgY3VyUG9pbnQgPSBwb2ludHNbaV07XHJcbiAgICAgICAgdmFyIHNpemUgPSBjdXJQb2ludC5zaXplO1xyXG4gICAgICAgIGlmIChfaXNEZWZpbmVkKGN1clBvaW50LngpICYmIF9pc0RlZmluZWQoY3VyUG9pbnQueSkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgcG9pbnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFBvaW50ID0gcG9pbnRzW2pdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRfeCA9IG51bGwgPT09IG5leHRQb2ludCB8fCB2b2lkIDAgPT09IG5leHRQb2ludCA/IHZvaWQgMCA6IG5leHRQb2ludC54O1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRfeSA9IG51bGwgPT09IG5leHRQb2ludCB8fCB2b2lkIDAgPT09IG5leHRQb2ludCA/IHZvaWQgMCA6IG5leHRQb2ludC55O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfaXNEZWZpbmVkKG5leHRfeCkgfHwgTWF0aC5hYnMoY3VyUG9pbnQueCAtIG5leHRfeCkgPj0gc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ29udGludW91c1NlcmllcyAmPSBqICE9PSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBfaXNEZWZpbmVkKG5leHRfeCkgJiYgX2lzRGVmaW5lZChuZXh0X3kpICYmIE1hdGguc3FydChNYXRoLnBvdyhjdXJQb2ludC54IC0gbmV4dF94LCAyKSArIE1hdGgucG93KGN1clBvaW50LnkgLSBuZXh0X3ksIDIpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgJiYgZGlzdGFuY2UgPCBzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsb2FkZWRTZXJpZXNbY3VyUG9pbnQuc2VyaWVzSW5kZXhdW25leHRQb2ludC5zZXJpZXNJbmRleF0rKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxvYWRlZFNlcmllc1tjdXJQb2ludC5zZXJpZXNJbmRleF0udG90YWwrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NvbnRpbnVvdXNTZXJpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsb2FkZWRTZXJpZXNbY3VyUG9pbnQuc2VyaWVzSW5kZXhdLmNvbnRpbnVvdXNTZXJpZXMrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29udGludW91c1NlcmllcyA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG52YXIgZHhDaGFydCA9IEFkdmFuY2VkQ2hhcnQuaW5oZXJpdCh7XHJcbiAgICBfdGhlbWVTZWN0aW9uOiBcImNoYXJ0XCIsXHJcbiAgICBfZm9udEZpZWxkczogW1wiY3Jvc3NoYWlyLmxhYmVsLmZvbnRcIl0sXHJcbiAgICBfaW5pdENvcmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMucGFuZUF4aXMgPSB7fTtcclxuICAgICAgICB0aGlzLmNhbGxCYXNlKClcclxuICAgIH0sXHJcbiAgICBfaW5pdCgpIHtcclxuICAgICAgICB0aGlzLl9jb250YWluZXJJbml0aWFsSGVpZ2h0ID0gaGFzV2luZG93KCkgPyBnZXRIZWlnaHQodGhpcy5fJGVsZW1lbnQpIDogMDtcclxuICAgICAgICB0aGlzLmNhbGxCYXNlKClcclxuICAgIH0sXHJcbiAgICBfY29ycmVjdEF4ZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2NvcnJlY3RWYWx1ZUF4ZXModHJ1ZSlcclxuICAgIH0sXHJcbiAgICBfZ2V0RXh0cmFPcHRpb25zOiBub29wLFxyXG4gICAgX2NyZWF0ZVBhbmVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcGFuZXMgPSB0aGlzLm9wdGlvbihcInBhbmVzXCIpO1xyXG4gICAgICAgIHZhciBwYW5lc05hbWVDb3VudGVyID0gMDtcclxuICAgICAgICB2YXIgZGVmYXVsdFBhbmU7XHJcbiAgICAgICAgaWYgKCFwYW5lcyB8fCBfaXNBcnJheShwYW5lcykgJiYgIXBhbmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBwYW5lcyA9IERFRkFVTFRfUEFORVNcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZSgpO1xyXG4gICAgICAgIGRlZmF1bHRQYW5lID0gdGhpcy5vcHRpb24oXCJkZWZhdWx0UGFuZVwiKTtcclxuICAgICAgICBwYW5lcyA9IF9leHRlbmQodHJ1ZSwgW10sIF9pc0FycmF5KHBhbmVzKSA/IHBhbmVzIDogW3BhbmVzXSk7XHJcbiAgICAgICAgX2VhY2gocGFuZXMsIChmdW5jdGlvbihfLCBwYW5lKSB7XHJcbiAgICAgICAgICAgIHBhbmUubmFtZSA9ICFfaXNEZWZpbmVkKHBhbmUubmFtZSkgPyBERUZBVUxUX1BBTkVfTkFNRSArIHBhbmVzTmFtZUNvdW50ZXIrKyA6IHBhbmUubmFtZVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBpZiAoX2lzRGVmaW5lZChkZWZhdWx0UGFuZSkpIHtcclxuICAgICAgICAgICAgaWYgKCFkb2VzUGFuZUV4aXN0KHBhbmVzLCBkZWZhdWx0UGFuZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luY2lkZW50T2NjdXJyZWQoXCJXMjEwMVwiLCBbZGVmYXVsdFBhbmVdKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRQYW5lID0gcGFuZXNbcGFuZXMubGVuZ3RoIC0gMV0ubmFtZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGVmYXVsdFBhbmUgPSBwYW5lc1twYW5lcy5sZW5ndGggLSAxXS5uYW1lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGVmYXVsdFBhbmUgPSBkZWZhdWx0UGFuZTtcclxuICAgICAgICBwYW5lcyA9IHRoaXMuX2lzUm90YXRlZCgpID8gcGFuZXMucmV2ZXJzZSgpIDogcGFuZXM7XHJcbiAgICAgICAgcmV0dXJuIHBhbmVzXHJcbiAgICB9LFxyXG4gICAgX2dldEF4aXNSZW5kZXJpbmdPcHRpb25zOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBheGlzVHlwZTogXCJ4eUF4ZXNcIixcclxuICAgICAgICAgICAgZHJhd2luZ1R5cGU6IFwibGluZWFyXCJcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3ByZXBhcmVBeGlzT3B0aW9uczogZnVuY3Rpb24odHlwZVNlbGVjdG9yLCB1c2VyT3B0aW9ucywgcm90YXRlZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbDogXCJhcmd1bWVudEF4aXNcIiA9PT0gdHlwZVNlbGVjdG9yICE9PSByb3RhdGVkLFxyXG4gICAgICAgICAgICBjb250YWluZXJDb2xvcjogdGhpcy5fdGhlbWVNYW5hZ2VyLmdldE9wdGlvbnMoXCJjb250YWluZXJCYWNrZ3JvdW5kQ29sb3JcIilcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2NoZWNrUGFuZU5hbWU6IGZ1bmN0aW9uKHNlcmllc1RoZW1lKSB7XHJcbiAgICAgICAgdmFyIHBhbmVMaXN0ID0gX21hcCh0aGlzLnBhbmVzLCAoZnVuY3Rpb24ocGFuZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFuZS5uYW1lXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHNlcmllc1RoZW1lLnBhbmUgPSBzZXJpZXNUaGVtZS5wYW5lIHx8IHRoaXMuZGVmYXVsdFBhbmU7XHJcbiAgICAgICAgcmV0dXJuIC0xICE9PSBpbkFycmF5KHNlcmllc1RoZW1lLnBhbmUsIHBhbmVMaXN0KVxyXG4gICAgfSxcclxuICAgIF9pbml0Q3VzdG9tUG9zaXRpb25pbmdBeGVzKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgYXJndW1lbnRBeGlzID0gdGhhdC5nZXRBcmd1bWVudEF4aXMoKTtcclxuICAgICAgICB2YXIgdmFsdWVBeGlzTmFtZSA9IGFyZ3VtZW50QXhpcy5nZXRPcHRpb25zKCkuY3VzdG9tUG9zaXRpb25BeGlzO1xyXG4gICAgICAgIHZhciB2YWx1ZUF4aXMgPSB0aGF0Ll92YWx1ZUF4ZXMuZmlsdGVyKHYgPT4gdi5wYW5lID09PSBhcmd1bWVudEF4aXMucGFuZSAmJiAoIXZhbHVlQXhpc05hbWUgfHwgdmFsdWVBeGlzTmFtZSA9PT0gdi5uYW1lKSlbMF07XHJcbiAgICAgICAgdGhhdC5fdmFsdWVBeGVzLmZvckVhY2godiA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudEF4aXMgIT09IHYuZ2V0T3J0aG9nb25hbEF4aXMoKSkge1xyXG4gICAgICAgICAgICAgICAgdi5nZXRPcnRob2dvbmFsQXhpcyA9ICgpID0+IGFyZ3VtZW50QXhpcztcclxuICAgICAgICAgICAgICAgIHYuY3VzdG9tUG9zaXRpb25Jc0JvdW5kYXJ5T3J0aG9nb25hbEF4aXMgPSAoKSA9PiBhcmd1bWVudEF4aXMuY3VzdG9tUG9zaXRpb25Jc0JvdW5kYXJ5KClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChfaXNEZWZpbmVkKHZhbHVlQXhpcykgJiYgdmFsdWVBeGlzICE9PSBhcmd1bWVudEF4aXMuZ2V0T3J0aG9nb25hbEF4aXMoKSkge1xyXG4gICAgICAgICAgICBhcmd1bWVudEF4aXMuZ2V0T3J0aG9nb25hbEF4aXMgPSAoKSA9PiB2YWx1ZUF4aXM7XHJcbiAgICAgICAgICAgIGFyZ3VtZW50QXhpcy5jdXN0b21Qb3NpdGlvbklzQm91bmRhcnlPcnRob2dvbmFsQXhpcyA9ICgpID0+IHRoYXQuX3ZhbHVlQXhlcy5zb21lKHYgPT4gdi5jdXN0b21Qb3NpdGlvbklzQm91bmRhcnkoKSlcclxuICAgICAgICB9IGVsc2UgaWYgKF9pc0RlZmluZWQoYXJndW1lbnRBeGlzLmdldE9ydGhvZ29uYWxBeGlzKCkpICYmICFfaXNEZWZpbmVkKHZhbHVlQXhpcykpIHtcclxuICAgICAgICAgICAgYXJndW1lbnRBeGlzLmdldE9ydGhvZ29uYWxBeGlzID0gbm9vcFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0QWxsQXhlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXJndW1lbnRBeGVzLmNvbmNhdCh0aGlzLl92YWx1ZUF4ZXMpXHJcbiAgICB9LFxyXG4gICAgX3Jlc2V0QXhlc0FuaW1hdGlvbihpc0ZpcnN0RHJhd2luZywgaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgdmFyIGF4ZXMgPSBfaXNEZWZpbmVkKGlzSG9yaXpvbnRhbCkgPyBpc0hvcml6b250YWwgXiB0aGlzLl9pc1JvdGF0ZWQoKSA/IHRoaXMuX2FyZ3VtZW50QXhlcyA6IHRoaXMuX3ZhbHVlQXhlcyA6IHRoaXMuX2dldEFsbEF4ZXMoKTtcclxuICAgICAgICBheGVzLmZvckVhY2goYSA9PiB7XHJcbiAgICAgICAgICAgIGEucmVzZXRBcHBseWluZ0FuaW1hdGlvbihpc0ZpcnN0RHJhd2luZylcclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuICAgIF9heGVzQm91bmRhcnlQb3NpdGlvbmluZygpIHtcclxuICAgICAgICB2YXIgYWxsQXhlcyA9IHRoaXMuX2dldEFsbEF4ZXMoKTtcclxuICAgICAgICB2YXIgYm91bmRhcnlTdGF0ZUNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICBhbGxBeGVzLmZvckVhY2goYSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghYS5jdXN0b21Qb3NpdGlvbklzQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwcmV2Qm91bmRhcnlTdGF0ZSA9IGEuY3VzdG9tUG9zaXRpb25Jc0JvdW5kYXJ5KCk7XHJcbiAgICAgICAgICAgIGEuX2N1c3RvbUJvdW5kYXJ5UG9zaXRpb24gPSBhLmdldEN1c3RvbUJvdW5kYXJ5UG9zaXRpb24oKTtcclxuICAgICAgICAgICAgYm91bmRhcnlTdGF0ZUNoYW5nZWQgfD0gcHJldkJvdW5kYXJ5U3RhdGUgIT09IGEuY3VzdG9tUG9zaXRpb25Jc0JvdW5kYXJ5KClcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYm91bmRhcnlTdGF0ZUNoYW5nZWRcclxuICAgIH0sXHJcbiAgICBfZ2V0Q3Jvc3NoYWlyTWFyZ2luczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGNyb3NzaGFpck9wdGlvbnMgPSB0aGlzLl9nZXRDcm9zc2hhaXJPcHRpb25zKCkgfHwge307XHJcbiAgICAgICAgdmFyIGNyb3NzaGFpckVuYWJsZWQgPSBjcm9zc2hhaXJPcHRpb25zLmVuYWJsZWQ7XHJcbiAgICAgICAgdmFyIG1hcmdpbnMgPSBnZXRNYXJnaW5zKCk7XHJcbiAgICAgICAgdmFyIGhvcml6b250YWxMYWJlbCA9IF9leHRlbmQodHJ1ZSwge30sIGNyb3NzaGFpck9wdGlvbnMubGFiZWwsIGNyb3NzaGFpck9wdGlvbnMuaG9yaXpvbnRhbExpbmUubGFiZWwpO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNhbExhYmVsID0gX2V4dGVuZCh0cnVlLCB7fSwgY3Jvc3NoYWlyT3B0aW9ucy5sYWJlbCwgY3Jvc3NoYWlyT3B0aW9ucy52ZXJ0aWNhbExpbmUubGFiZWwpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IGNyb3NzaGFpckVuYWJsZWQgJiYgY3Jvc3NoYWlyT3B0aW9ucy5ob3Jpem9udGFsTGluZS52aXNpYmxlICYmIGhvcml6b250YWxMYWJlbC52aXNpYmxlID8gbWFyZ2lucy54IDogMCxcclxuICAgICAgICAgICAgeTogY3Jvc3NoYWlyRW5hYmxlZCAmJiBjcm9zc2hhaXJPcHRpb25zLnZlcnRpY2FsTGluZS52aXNpYmxlICYmIHZlcnRpY2FsTGFiZWwudmlzaWJsZSA/IG1hcmdpbnMueSA6IDBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2dldFZhbHVlQXhpczogZnVuY3Rpb24ocGFuZU5hbWUsIGF4aXNOYW1lKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlQXhlcyA9IHRoaXMuX3ZhbHVlQXhlcztcclxuICAgICAgICB2YXIgdmFsdWVBeGlzT3B0aW9ucyA9IHRoaXMub3B0aW9uKFwidmFsdWVBeGlzXCIpIHx8IHt9O1xyXG4gICAgICAgIHZhciB2YWx1ZUF4ZXNPcHRpb25zID0gX2lzQXJyYXkodmFsdWVBeGlzT3B0aW9ucykgPyB2YWx1ZUF4aXNPcHRpb25zIDogW3ZhbHVlQXhpc09wdGlvbnNdO1xyXG4gICAgICAgIHZhciByb3RhdGVkID0gdGhpcy5faXNSb3RhdGVkKCk7XHJcbiAgICAgICAgdmFyIGNyb3NzaGFpck1hcmdpbnMgPSB0aGlzLl9nZXRDcm9zc2hhaXJNYXJnaW5zKCk7XHJcbiAgICAgICAgdmFyIGF4aXNPcHRpb25zO1xyXG4gICAgICAgIHZhciBheGlzO1xyXG4gICAgICAgIGF4aXNOYW1lID0gYXhpc05hbWUgfHwgZ2V0Rmlyc3RBeGlzTmFtZUZvclBhbmUodmFsdWVBeGVzLCBwYW5lTmFtZSwgdGhpcy5kZWZhdWx0UGFuZSk7XHJcbiAgICAgICAgYXhpcyA9IGZpbmRBeGlzKHBhbmVOYW1lLCBheGlzTmFtZSwgdmFsdWVBeGVzKTtcclxuICAgICAgICBpZiAoIWF4aXMpIHtcclxuICAgICAgICAgICAgYXhpc09wdGlvbnMgPSBmaW5kQXhpc09wdGlvbnModmFsdWVBeGVzLCB2YWx1ZUF4ZXNPcHRpb25zLCBheGlzTmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghYXhpc09wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luY2lkZW50T2NjdXJyZWQoXCJXMjEwMlwiLCBbYXhpc05hbWVdKTtcclxuICAgICAgICAgICAgICAgIGF4aXNPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGF4aXNOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiB2YWx1ZUF4ZXMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXhpcyA9IHRoaXMuX2NyZWF0ZUF4aXMoZmFsc2UsIHRoaXMuX3BvcHVsYXRlQXhlc09wdGlvbnMoXCJ2YWx1ZUF4aXNcIiwgYXhpc09wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgIHBhbmU6IHBhbmVOYW1lLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogYXhpc05hbWUsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25QYXRoOiBfaXNBcnJheSh2YWx1ZUF4aXNPcHRpb25zKSA/IFwidmFsdWVBeGlzW1wiLmNvbmNhdChheGlzT3B0aW9ucy5wcmlvcml0eSwgXCJdXCIpIDogXCJ2YWx1ZUF4aXNcIixcclxuICAgICAgICAgICAgICAgIGNyb3NzaGFpck1hcmdpbjogcm90YXRlZCA/IGNyb3NzaGFpck1hcmdpbnMueSA6IGNyb3NzaGFpck1hcmdpbnMueFxyXG4gICAgICAgICAgICB9LCByb3RhdGVkKSk7XHJcbiAgICAgICAgICAgIGF4aXMuYXBwbHlWaXN1YWxSYW5nZVNldHRlcih0aGlzLl9nZXRWaXN1YWxSYW5nZVNldHRlcigpKTtcclxuICAgICAgICAgICAgdmFsdWVBeGVzLnB1c2goYXhpcylcclxuICAgICAgICB9XHJcbiAgICAgICAgYXhpcy5zZXRQYW5lKHBhbmVOYW1lKTtcclxuICAgICAgICByZXR1cm4gYXhpc1xyXG4gICAgfSxcclxuICAgIF9jb3JyZWN0VmFsdWVBeGVzOiBmdW5jdGlvbihuZWVkSGlkZUdyaWRzKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBzeW5jaHJvbml6ZU11bHRpQXhlcyA9IHRoYXQuX3RoZW1lTWFuYWdlci5nZXRPcHRpb25zKFwic3luY2hyb25pemVNdWx0aUF4ZXNcIik7XHJcbiAgICAgICAgdmFyIHZhbHVlQXhlcyA9IHRoYXQuX3ZhbHVlQXhlcztcclxuICAgICAgICB2YXIgcGFuZVdpdGhBeGlzID0ge307XHJcbiAgICAgICAgdGhhdC5zZXJpZXMuZm9yRWFjaCgoZnVuY3Rpb24oc2VyaWVzKSB7XHJcbiAgICAgICAgICAgIHZhciBheGlzID0gc2VyaWVzLmdldFZhbHVlQXhpcygpO1xyXG4gICAgICAgICAgICBwYW5lV2l0aEF4aXNbYXhpcy5wYW5lXSA9IHRydWVcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhhdC5wYW5lcy5mb3JFYWNoKChmdW5jdGlvbihwYW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBwYW5lTmFtZSA9IHBhbmUubmFtZTtcclxuICAgICAgICAgICAgaWYgKCFwYW5lV2l0aEF4aXNbcGFuZU5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll9nZXRWYWx1ZUF4aXMocGFuZU5hbWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5lZWRIaWRlR3JpZHMgJiYgc3luY2hyb25pemVNdWx0aUF4ZXMpIHtcclxuICAgICAgICAgICAgICAgIGhpZGVHcmlkc09uTm9uRmlyc3RWYWx1ZUF4aXNGb3JQYW5lKHZhbHVlQXhlcy5maWx0ZXIoKGZ1bmN0aW9uKGF4aXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXhpcy5wYW5lID09PSBwYW5lTmFtZVxyXG4gICAgICAgICAgICAgICAgfSkpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoYXQuX3ZhbHVlQXhlcyA9IHZhbHVlQXhlcy5maWx0ZXIoKGZ1bmN0aW9uKGF4aXMpIHtcclxuICAgICAgICAgICAgaWYgKCFheGlzLnBhbmUpIHtcclxuICAgICAgICAgICAgICAgIGF4aXMuc2V0UGFuZSh0aGF0LmRlZmF1bHRQYW5lKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYW5lRXhpc3RzID0gZG9lc1BhbmVFeGlzdCh0aGF0LnBhbmVzLCBheGlzLnBhbmUpO1xyXG4gICAgICAgICAgICBpZiAoIXBhbmVFeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgIGF4aXMuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgYXhpcyA9IG51bGxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGFuZUV4aXN0c1xyXG4gICAgICAgIH0pKS5zb3J0KGNvbXBhcmVBeGVzKTtcclxuICAgICAgICB2YXIgZGVmYXVsdEF4aXMgPSB0aGlzLmdldFZhbHVlQXhpcygpO1xyXG4gICAgICAgIHRoYXQuX3ZhbHVlQXhlcy5mb3JFYWNoKGF4aXMgPT4ge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uUGF0aCA9IGF4aXMuZ2V0T3B0aW9ucygpLm9wdGlvblBhdGg7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25QYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXhlc1dpdGhTYW1lUGF0aCA9IHRoYXQuX3ZhbHVlQXhlcy5maWx0ZXIoYSA9PiBhLmdldE9wdGlvbnMoKS5vcHRpb25QYXRoID09PSBvcHRpb25QYXRoKTtcclxuICAgICAgICAgICAgICAgIGlmIChheGVzV2l0aFNhbWVQYXRoLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXhlc1dpdGhTYW1lUGF0aC5zb21lKGEgPT4gYSA9PT0gZGVmYXVsdEF4aXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4ZXNXaXRoU2FtZVBhdGguZm9yRWFjaChhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhICE9PSBkZWZhdWx0QXhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZ2V0T3B0aW9ucygpLm9wdGlvblBhdGggPSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXhlc1dpdGhTYW1lUGF0aC5mb3JFYWNoKChhLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCAhPT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZ2V0T3B0aW9ucygpLm9wdGlvblBhdGggPSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBfZ2V0U2VyaWVzRm9yUGFuZTogZnVuY3Rpb24ocGFuZU5hbWUpIHtcclxuICAgICAgICB2YXIgcGFuZVNlcmllcyA9IFtdO1xyXG4gICAgICAgIF9lYWNoKHRoaXMuc2VyaWVzLCAoZnVuY3Rpb24oXywgb25lU2VyaWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChvbmVTZXJpZXMucGFuZSA9PT0gcGFuZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHBhbmVTZXJpZXMucHVzaChvbmVTZXJpZXMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuIHBhbmVTZXJpZXNcclxuICAgIH0sXHJcbiAgICBfY3JlYXRlUGFuZXNCb3JkZXJPcHRpb25zOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgY29tbW9uQm9yZGVyT3B0aW9ucyA9IHRoaXMuX3RoZW1lTWFuYWdlci5nZXRPcHRpb25zKFwiY29tbW9uUGFuZVNldHRpbmdzXCIpLmJvcmRlcjtcclxuICAgICAgICB2YXIgcGFuZXNCb3JkZXJPcHRpb25zID0ge307XHJcbiAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKHBhbmUgPT4gcGFuZXNCb3JkZXJPcHRpb25zW3BhbmUubmFtZV0gPSBfZXh0ZW5kKHRydWUsIHt9LCBjb21tb25Cb3JkZXJPcHRpb25zLCBwYW5lLmJvcmRlcikpO1xyXG4gICAgICAgIHJldHVybiBwYW5lc0JvcmRlck9wdGlvbnNcclxuICAgIH0sXHJcbiAgICBfY3JlYXRlU2Nyb2xsQmFyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc2Nyb2xsQmFyT3B0aW9ucyA9IHRoaXMuX3RoZW1lTWFuYWdlci5nZXRPcHRpb25zKFwic2Nyb2xsQmFyXCIpIHx8IHt9O1xyXG4gICAgICAgIHZhciBzY3JvbGxCYXJHcm91cCA9IHRoaXMuX3Njcm9sbEJhckdyb3VwO1xyXG4gICAgICAgIGlmIChzY3JvbGxCYXJPcHRpb25zLnZpc2libGUpIHtcclxuICAgICAgICAgICAgc2Nyb2xsQmFyT3B0aW9ucy5yb3RhdGVkID0gdGhpcy5faXNSb3RhdGVkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEJhciA9ICh0aGlzLl9zY3JvbGxCYXIgfHwgbmV3IFNjcm9sbEJhcih0aGlzLl9yZW5kZXJlciwgc2Nyb2xsQmFyR3JvdXApKS51cGRhdGUoc2Nyb2xsQmFyT3B0aW9ucylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzY3JvbGxCYXJHcm91cC5saW5rUmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEJhciAmJiB0aGlzLl9zY3JvbGxCYXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxCYXIgPSBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9leGVjdXRlQXBwZW5kQWZ0ZXJTZXJpZXMoYXBwZW5kKSB7XHJcbiAgICAgICAgYXBwZW5kKClcclxuICAgIH0sXHJcbiAgICBfcHJlcGFyZVRvUmVuZGVyKGRyYXdPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHBhbmVzQm9yZGVyT3B0aW9ucyA9IHRoaXMuX2NyZWF0ZVBhbmVzQm9yZGVyT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZVBhbmVzQmFja2dyb3VuZCgpO1xyXG4gICAgICAgIHRoaXMuX2FwcGVuZEF4ZXNHcm91cHMoKTtcclxuICAgICAgICB0aGlzLl9hZGp1c3RWaWV3cG9ydCgpO1xyXG4gICAgICAgIHJldHVybiBwYW5lc0JvcmRlck9wdGlvbnNcclxuICAgIH0sXHJcbiAgICBfYWRqdXN0Vmlld3BvcnQoKSB7XHJcbiAgICAgICAgdmFyIGFkanVzdE9uWm9vbSA9IHRoaXMuX3RoZW1lTWFuYWdlci5nZXRPcHRpb25zKFwiYWRqdXN0T25ab29tXCIpO1xyXG4gICAgICAgIGlmICghYWRqdXN0T25ab29tKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl92YWx1ZUF4ZXMuZm9yRWFjaChheGlzID0+IGF4aXMuYWRqdXN0KCkpXHJcbiAgICB9LFxyXG4gICAgX3JlY3JlYXRlU2l6ZURlcGVuZGVudE9iamVjdHMoaXNDYW52YXNDaGFuZ2VkKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBzZXJpZXMgPSB0aGF0Ll9nZXRWaXNpYmxlU2VyaWVzKCk7XHJcbiAgICAgICAgdmFyIHVzZUFnZ3JlZ2F0aW9uID0gc2VyaWVzLnNvbWUocyA9PiBzLnVzZUFnZ3JlZ2F0aW9uKCkpO1xyXG4gICAgICAgIHZhciB6b29tQ2hhbmdlZCA9IHRoYXQuX2lzWm9vbWluZygpO1xyXG4gICAgICAgIGlmICghdXNlQWdncmVnYXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoYXQuX2FyZ3VtZW50QXhlcy5mb3JFYWNoKChmdW5jdGlvbihheGlzKSB7XHJcbiAgICAgICAgICAgIGF4aXMudXBkYXRlQ2FudmFzKHRoYXQuX2NhbnZhcywgdHJ1ZSlcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgc2VyaWVzLmZvckVhY2goKGZ1bmN0aW9uKHNlcmllcykge1xyXG4gICAgICAgICAgICBpZiAoc2VyaWVzLnVzZUFnZ3JlZ2F0aW9uKCkgJiYgKGlzQ2FudmFzQ2hhbmdlZCB8fCB6b29tQ2hhbmdlZCB8fCAhc2VyaWVzLl91c2VBbGxBZ2dyZWdhdGVkUG9pbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgc2VyaWVzLmNyZWF0ZVBvaW50cygpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhhdC5fcHJvY2Vzc1Nlcmllc0ZhbWlsaWVzKClcclxuICAgIH0sXHJcbiAgICBfaXNab29taW5nKCkge1xyXG4gICAgICAgIHZhciBhcmd1bWVudEF4aXMgPSB0aGlzLmdldEFyZ3VtZW50QXhpcygpO1xyXG4gICAgICAgIGlmICghYXJndW1lbnRBeGlzIHx8ICFhcmd1bWVudEF4aXMuZ2V0VHJhbnNsYXRvcigpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVzaW5lc3NSYW5nZSA9IGFyZ3VtZW50QXhpcy5nZXRUcmFuc2xhdG9yKCkuZ2V0QnVzaW5lc3NSYW5nZSgpO1xyXG4gICAgICAgIHZhciB6b29tUmFuZ2UgPSBhcmd1bWVudEF4aXMuZ2V0Vmlld3BvcnQoKTtcclxuICAgICAgICB2YXIgbWluID0gem9vbVJhbmdlID8gem9vbVJhbmdlLm1pbiA6IDA7XHJcbiAgICAgICAgdmFyIG1heCA9IHpvb21SYW5nZSA/IHpvb21SYW5nZS5tYXggOiAwO1xyXG4gICAgICAgIGlmIChcImxvZ2FyaXRobWljXCIgPT09IGJ1c2luZXNzUmFuZ2UuYXhpc1R5cGUpIHtcclxuICAgICAgICAgICAgbWluID0gZ2V0TG9nKG1pbiwgYnVzaW5lc3NSYW5nZS5iYXNlKTtcclxuICAgICAgICAgICAgbWF4ID0gZ2V0TG9nKG1heCwgYnVzaW5lc3NSYW5nZS5iYXNlKVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmlld3BvcnREaXN0YW5jZSA9IGJ1c2luZXNzUmFuZ2UuYXhpc1R5cGUgPT09IERJU0NSRVRFID8gZ2V0Q2F0ZWdvcmllc0luZm8oYnVzaW5lc3NSYW5nZS5jYXRlZ29yaWVzLCBtaW4sIG1heCkuY2F0ZWdvcmllcy5sZW5ndGggOiBNYXRoLmFicyhtYXggLSBtaW4pO1xyXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBnZXRQcmVjaXNpb24odmlld3BvcnREaXN0YW5jZSk7XHJcbiAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID4gMSA/IE1hdGgucG93KDEwLCBwcmVjaXNpb24gLSAyKSA6IDE7XHJcbiAgICAgICAgdmFyIHpvb21DaGFuZ2VkID0gTWF0aC5yb3VuZCgodGhpcy5fem9vbUxlbmd0aCAtIHZpZXdwb3J0RGlzdGFuY2UpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbiAhPT0gMDtcclxuICAgICAgICB0aGlzLl96b29tTGVuZ3RoID0gdmlld3BvcnREaXN0YW5jZTtcclxuICAgICAgICByZXR1cm4gem9vbUNoYW5nZWRcclxuICAgIH0sXHJcbiAgICBfaGFuZGxlU2VyaWVzRGF0YVVwZGF0ZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgdmlld3BvcnQgPSBuZXcgUmFuZ2U7XHJcbiAgICAgICAgdGhhdC5zZXJpZXMuZm9yRWFjaCgoZnVuY3Rpb24ocykge1xyXG4gICAgICAgICAgICB2aWV3cG9ydC5hZGRSYW5nZShzLmdldEFyZ3VtZW50UmFuZ2UoKSlcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhhdC5fYXJndW1lbnRBeGVzLmZvckVhY2goKGZ1bmN0aW9uKGF4aXMpIHtcclxuICAgICAgICAgICAgYXhpcy51cGRhdGVDYW52YXModGhhdC5fY2FudmFzLCB0cnVlKTtcclxuICAgICAgICAgICAgYXhpcy5zZXRCdXNpbmVzc1JhbmdlKHZpZXdwb3J0LCB0aGF0Ll9heGVzUmVpbml0aWFsaXplZClcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhhdC5jYWxsQmFzZSgpXHJcbiAgICB9LFxyXG4gICAgX2lzTGVnZW5kSW5zaWRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGVnZW5kICYmIFwiaW5zaWRlXCIgPT09IHRoaXMuX2xlZ2VuZC5nZXRQb3NpdGlvbigpXHJcbiAgICB9LFxyXG4gICAgX2lzUm90YXRlZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW1lTWFuYWdlci5nZXRPcHRpb25zKFwicm90YXRlZFwiKVxyXG4gICAgfSxcclxuICAgIF9nZXRMYXlvdXRUYXJnZXRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYW5lc1xyXG4gICAgfSxcclxuICAgIF9hcHBseUNsaXBSZWN0czogZnVuY3Rpb24ocGFuZXNCb3JkZXJPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fZHJhd1BhbmVzQm9yZGVycyhwYW5lc0JvcmRlck9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUNsaXBSZWN0c0ZvclBhbmVzKCk7XHJcbiAgICAgICAgdGhpcy5fYXBwbHlDbGlwUmVjdHNGb3JBeGVzKCk7XHJcbiAgICAgICAgdGhpcy5fZmlsbFBhbmVzQmFja2dyb3VuZCgpXHJcbiAgICB9LFxyXG4gICAgX3VwZGF0ZUxlZ2VuZFBvc2l0aW9uOiBmdW5jdGlvbihkcmF3T3B0aW9ucywgbGVnZW5kSGFzSW5zaWRlUG9zaXRpb24pIHtcclxuICAgICAgICBpZiAoZHJhd09wdGlvbnMuZHJhd0xlZ2VuZCAmJiB0aGlzLl9sZWdlbmQgJiYgbGVnZW5kSGFzSW5zaWRlUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIHBhbmVzID0gdGhpcy5wYW5lcztcclxuICAgICAgICAgICAgdmFyIG5ld0NhbnZhcyA9IF9leHRlbmQoe30sIHBhbmVzWzBdLmNhbnZhcyk7XHJcbiAgICAgICAgICAgIHZhciBsYXlvdXRNYW5hZ2VyID0gbmV3IExheW91dE1hbmFnZXI7XHJcbiAgICAgICAgICAgIG5ld0NhbnZhcy5yaWdodCA9IHBhbmVzW3BhbmVzLmxlbmd0aCAtIDFdLmNhbnZhcy5yaWdodDtcclxuICAgICAgICAgICAgbmV3Q2FudmFzLmJvdHRvbSA9IHBhbmVzW3BhbmVzLmxlbmd0aCAtIDFdLmNhbnZhcy5ib3R0b207XHJcbiAgICAgICAgICAgIGxheW91dE1hbmFnZXIubGF5b3V0SW5zaWRlTGVnZW5kKHRoaXMuX2xlZ2VuZCwgbmV3Q2FudmFzKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfYWxsb3dMZWdlbmRJbnNpZGVQb3NpdGlvbjogKCkgPT4gdHJ1ZSxcclxuICAgIF9hcHBseUV4dHJhU2V0dGluZ3M6IGZ1bmN0aW9uKHNlcmllcykge1xyXG4gICAgICAgIHZhciBwYW5lSW5kZXggPSB0aGlzLl9nZXRQYW5lSW5kZXgoc2VyaWVzLnBhbmUpO1xyXG4gICAgICAgIHZhciBwYW5lc0NsaXBSZWN0cyA9IHRoaXMuX3BhbmVzQ2xpcFJlY3RzO1xyXG4gICAgICAgIHZhciB3aWRlQ2xpcFJlY3QgPSBwYW5lc0NsaXBSZWN0cy53aWRlW3BhbmVJbmRleF07XHJcbiAgICAgICAgc2VyaWVzLnNldENsaXBwaW5nUGFyYW1zKHBhbmVzQ2xpcFJlY3RzLmJhc2VbcGFuZUluZGV4XS5pZCwgd2lkZUNsaXBSZWN0ICYmIHdpZGVDbGlwUmVjdC5pZCwgdGhpcy5fZ2V0UGFuZUJvcmRlclZpc2liaWxpdHkocGFuZUluZGV4KSlcclxuICAgIH0sXHJcbiAgICBfdXBkYXRlUGFuZXNDYW52YXNlczogZnVuY3Rpb24oZHJhd09wdGlvbnMpIHtcclxuICAgICAgICBpZiAoIWRyYXdPcHRpb25zLnJlY3JlYXRlQ2FudmFzKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVQYW5lc0NhbnZhc2VzKHRoaXMucGFuZXMsIHRoaXMuX2NhbnZhcywgdGhpcy5faXNSb3RhdGVkKCkpXHJcbiAgICB9LFxyXG4gICAgX25vcm1hbGl6ZVBhbmVzSGVpZ2h0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICBub3JtYWxpemVQYW5lc0hlaWdodCh0aGlzLnBhbmVzKVxyXG4gICAgfSxcclxuICAgIF9yZW5kZXJTY2FsZUJyZWFrczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fdmFsdWVBeGVzLmNvbmNhdCh0aGlzLl9hcmd1bWVudEF4ZXMpLmZvckVhY2goKGZ1bmN0aW9uKGF4aXMpIHtcclxuICAgICAgICAgICAgYXhpcy5kcmF3U2NhbGVCcmVha3MoKVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSxcclxuICAgIF9nZXRBcmdGaWx0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhbmdlRGF0YUNhbGN1bGF0b3IuZ2V0Vmlld1BvcnRGaWx0ZXIodGhpcy5nZXRBcmd1bWVudEF4aXMoKS52aXN1YWxSYW5nZSgpIHx8IHt9KVxyXG4gICAgfSxcclxuICAgIF9hcHBseVBvaW50TWFya2Vyc0F1dG9IaWRpbmcoKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBhbGxTZXJpZXMgPSB0aGF0LnNlcmllcztcclxuICAgICAgICBpZiAoIXRoYXQuX3RoZW1lTWFuYWdlci5nZXRPcHRpb25zKFwiYXV0b0hpZGVQb2ludE1hcmtlcnNcIikpIHtcclxuICAgICAgICAgICAgYWxsU2VyaWVzLmZvckVhY2gocyA9PiBzLmF1dG9IaWRlUG9pbnRNYXJrZXJzID0gZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhhdC5wYW5lcy5mb3JFYWNoKF9yZWYgPT4ge1xyXG4gICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29vcmRzOiBib3JkZXJDb29yZHMsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXHJcbiAgICAgICAgICAgIH0gPSBfcmVmO1xyXG4gICAgICAgICAgICB2YXIgc2VyaWVzID0gYWxsU2VyaWVzLmZpbHRlcihzID0+IHMucGFuZSA9PT0gbmFtZSAmJiBzLnVzZVBvaW50c1RvRGVmaW5lQXV0b0hpZGluZygpKTtcclxuICAgICAgICAgICAgdmFyIGFyZ0F4aXMgPSB0aGF0LmdldEFyZ3VtZW50QXhpcygpO1xyXG4gICAgICAgICAgICB2YXIgbWFya2Vyc0luZm8gPSBjb2xsZWN0TWFya2Vyc0luZm9CeVNlcmllcyhhbGxTZXJpZXMsIHNlcmllcywgYXJnQXhpcyk7XHJcbiAgICAgICAgICAgIGZhc3RIaWRpbmdQb2ludE1hcmtlcnNCeUFyZWEoYm9yZGVyQ29vcmRzLCBtYXJrZXJzSW5mbywgc2VyaWVzKTtcclxuICAgICAgICAgICAgaWYgKG1hcmtlcnNJbmZvLnNlcmllcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdWaXN1YWxSYW5nZSA9IGFyZ0F4aXMudmlzdWFsUmFuZ2UoKTtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdBeGlzSXNEaXNjcmV0ZSA9IGFyZ0F4aXMuZ2V0T3B0aW9ucygpLnR5cGUgPT09IERJU0NSRVRFO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvcnRpbmdDYWxsYmFjayA9IGFyZ0F4aXNJc0Rpc2NyZXRlID8gKHAxLCBwMikgPT4gYXJnVmlzdWFsUmFuZ2UuY2F0ZWdvcmllcy5pbmRleE9mKHAxLmFyZ3VtZW50KSAtIGFyZ1Zpc3VhbFJhbmdlLmNhdGVnb3JpZXMuaW5kZXhPZihwMi5hcmd1bWVudCkgOiAocDEsIHAyKSA9PiBwMS5hcmd1bWVudCAtIHAyLmFyZ3VtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbWFya2Vyc0luZm8uc2VyaWVzLmZvckVhY2gocyA9PiBwb2ludHMgPSBwb2ludHMuY29uY2F0KHMucG9pbnRzKSk7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMuc29ydChzb3J0aW5nQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlTWFya2Vyc0luZm8ocG9pbnRzLCBtYXJrZXJzSW5mby5vdmVybG9hZGVkU2VyaWVzKTtcclxuICAgICAgICAgICAgICAgIGFwcGx5QXV0b0hpZGVQb2ludE1hcmtlcnMoYWxsU2VyaWVzLCBzZXJpZXMsIG1hcmtlcnNJbmZvLm92ZXJsb2FkZWRTZXJpZXMsIGFyZ0F4aXMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuICAgIF9yZW5kZXJBeGVzOiBmdW5jdGlvbihkcmF3T3B0aW9ucywgcGFuZXNCb3JkZXJPcHRpb25zKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gY2FsY3VsYXRlVGl0bGVzV2lkdGgoYXhlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gYXhlcy5tYXAoYXhpcyA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWF4aXMuZ2V0VGl0bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gYXhpcy5nZXRUaXRsZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpdGxlID8gdGl0bGUuYkJveC53aWR0aCA6IDBcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciByb3RhdGVkID0gdGhhdC5faXNSb3RhdGVkKCk7XHJcbiAgICAgICAgdmFyIHN5bmNocm9uaXplTXVsdGlBeGVzID0gdGhhdC5fdGhlbWVNYW5hZ2VyLmdldE9wdGlvbnMoXCJzeW5jaHJvbml6ZU11bHRpQXhlc1wiKTtcclxuICAgICAgICB2YXIgc2Nyb2xsQmFyID0gdGhhdC5fc2Nyb2xsQmFyID8gW3RoYXQuX3Njcm9sbEJhcl0gOiBbXTtcclxuICAgICAgICB2YXIgZXh0ZW5kZWRBcmdBeGVzID0gdGhhdC5faXNBcmd1bWVudEF4aXNCZWZvcmVTY3JvbGxCYXIoKSA/IHRoYXQuX2FyZ3VtZW50QXhlcy5jb25jYXQoc2Nyb2xsQmFyKSA6IHNjcm9sbEJhci5jb25jYXQodGhhdC5fYXJndW1lbnRBeGVzKTtcclxuICAgICAgICB2YXIgdmVydGljYWxBeGVzID0gcm90YXRlZCA/IHRoYXQuX2FyZ3VtZW50QXhlcyA6IHRoYXQuX3ZhbHVlQXhlcztcclxuICAgICAgICB2YXIgdmVydGljYWxFbGVtZW50cyA9IHJvdGF0ZWQgPyBleHRlbmRlZEFyZ0F4ZXMgOiB0aGF0Ll92YWx1ZUF4ZXM7XHJcbiAgICAgICAgdmFyIGhvcml6b250YWxBeGVzID0gcm90YXRlZCA/IHRoYXQuX3ZhbHVlQXhlcyA6IHRoYXQuX2FyZ3VtZW50QXhlcztcclxuICAgICAgICB2YXIgaG9yaXpvbnRhbEVsZW1lbnRzID0gcm90YXRlZCA/IHRoYXQuX3ZhbHVlQXhlcyA6IGV4dGVuZGVkQXJnQXhlcztcclxuICAgICAgICB2YXIgYWxsQXhlcyA9IHZlcnRpY2FsQXhlcy5jb25jYXQoaG9yaXpvbnRhbEF4ZXMpO1xyXG4gICAgICAgIHZhciBhbGxFbGVtZW50cyA9IGFsbEF4ZXMuY29uY2F0KHNjcm9sbEJhcik7XHJcbiAgICAgICAgdmFyIHZlcnRpY2FsQXhlc0ZpcnN0RHJhd2luZyA9IHZlcnRpY2FsQXhlcy5zb21lKHYgPT4gdi5pc0ZpcnN0RHJhd2luZygpKTtcclxuICAgICAgICB0aGF0Ll9ub3JtYWxpemVQYW5lc0hlaWdodCgpO1xyXG4gICAgICAgIHRoYXQuX3VwZGF0ZVBhbmVzQ2FudmFzZXMoZHJhd09wdGlvbnMpO1xyXG4gICAgICAgIHZhciBwYW5lc0NhbnZhc2VzID0gdGhhdC5wYW5lcy5yZWR1Y2UoKGZ1bmN0aW9uKGNhbnZhc2VzLCBwYW5lKSB7XHJcbiAgICAgICAgICAgIGNhbnZhc2VzW3BhbmUubmFtZV0gPSBfZXh0ZW5kKHt9LCBwYW5lLmNhbnZhcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjYW52YXNlc1xyXG4gICAgICAgIH0pLCB7fSk7XHJcbiAgICAgICAgdmFyIHBhbmVTaXplcyA9IHRoYXQucGFuZXMucmVkdWNlKChzaXplcywgcGFuZSkgPT4ge1xyXG4gICAgICAgICAgICBzaXplc1twYW5lLm5hbWVdID0ge1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwYW5lLmhlaWdodCxcclxuICAgICAgICAgICAgICAgIHVuaXQ6IHBhbmUudW5pdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZXNcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICAgICAgdmFyIGNsZWFuUGFuZXNDYW52YXNlcyA9IF9leHRlbmQodHJ1ZSwge30sIHBhbmVzQ2FudmFzZXMpO1xyXG4gICAgICAgIHRoYXQuX2luaXRDdXN0b21Qb3NpdGlvbmluZ0F4ZXMoKTtcclxuICAgICAgICB2YXIgbmVlZEN1c3RvbUFkanVzdEF4ZXMgPSB0aGF0Ll9heGVzQm91bmRhcnlQb3NpdGlvbmluZygpO1xyXG4gICAgICAgIGlmICghZHJhd09wdGlvbnMuYWRqdXN0QXhlcyAmJiAhbmVlZEN1c3RvbUFkanVzdEF4ZXMpIHtcclxuICAgICAgICAgICAgZHJhd0F4ZXNXaXRoVGlja3ModmVydGljYWxBeGVzLCAhcm90YXRlZCAmJiBzeW5jaHJvbml6ZU11bHRpQXhlcywgcGFuZXNDYW52YXNlcywgcGFuZXNCb3JkZXJPcHRpb25zKTtcclxuICAgICAgICAgICAgZHJhd0F4ZXNXaXRoVGlja3MoaG9yaXpvbnRhbEF4ZXMsIHJvdGF0ZWQgJiYgc3luY2hyb25pemVNdWx0aUF4ZXMsIHBhbmVzQ2FudmFzZXMsIHBhbmVzQm9yZGVyT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHBlcmZvcm1BY3Rpb25PbkF4ZXMoYWxsQXhlcywgXCJwcmVwYXJlQW5pbWF0aW9uXCIpO1xyXG4gICAgICAgICAgICB0aGF0Ll9yZW5kZXJTY2FsZUJyZWFrcygpO1xyXG4gICAgICAgICAgICBob3Jpem9udGFsQXhlcy5mb3JFYWNoKGEgPT4gYS5yZXNvbHZlT3ZlcmxhcHBpbmdGb3JDdXN0b21Qb3NpdGlvbmluZyh2ZXJ0aWNhbEF4ZXMpKTtcclxuICAgICAgICAgICAgdmVydGljYWxBeGVzLmZvckVhY2goYSA9PiBhLnJlc29sdmVPdmVybGFwcGluZ0ZvckN1c3RvbVBvc2l0aW9uaW5nKGhvcml6b250YWxBeGVzKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmVlZEN1c3RvbUFkanVzdEF4ZXMpIHtcclxuICAgICAgICAgICAgYWxsQXhlcy5mb3JFYWNoKGEgPT4gYS5jdXN0b21Qb3NpdGlvbklzQXZhaWxhYmxlKCkgJiYgYS5zaGlmdCh7XHJcbiAgICAgICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDBcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGF0Ll9zY3JvbGxCYXIpIHtcclxuICAgICAgICAgICAgdGhhdC5fc2Nyb2xsQmFyLnNldFBhbmUodGhhdC5wYW5lcylcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZBeGVzTWFyZ2lucyA9IHtcclxuICAgICAgICAgICAgcGFuZXM6IHt9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgaEF4ZXNNYXJnaW5zID0gZ2V0SG9yaXpvbnRhbEF4ZXNNYXJnaW5zKGhvcml6b250YWxFbGVtZW50cywgYXhpcyA9PiBheGlzLmVzdGltYXRlTWFyZ2lucyhwYW5lc0NhbnZhc2VzW2F4aXMucGFuZV0pKTtcclxuICAgICAgICBwYW5lc0NhbnZhc2VzID0gc2hyaW5rQ2FudmFzZXMocm90YXRlZCwgcGFuZXNDYW52YXNlcywgcGFuZVNpemVzLCB2QXhlc01hcmdpbnMsIGhBeGVzTWFyZ2lucyk7XHJcbiAgICAgICAgdmFyIGRyYXdBeGVzQW5kU2V0Q2FudmFzZXMgPSBpc0hvcml6b250YWwgPT4ge1xyXG4gICAgICAgICAgICB2YXIgYXhlcyA9IGlzSG9yaXpvbnRhbCA/IGhvcml6b250YWxBeGVzIDogdmVydGljYWxBeGVzO1xyXG4gICAgICAgICAgICB2YXIgY29uZGl0aW9uID0gKGlzSG9yaXpvbnRhbCA/IHJvdGF0ZWQgOiAhcm90YXRlZCkgJiYgc3luY2hyb25pemVNdWx0aUF4ZXM7XHJcbiAgICAgICAgICAgIGRyYXdBeGVzV2l0aFRpY2tzKGF4ZXMsIGNvbmRpdGlvbiwgcGFuZXNDYW52YXNlcywgcGFuZXNCb3JkZXJPcHRpb25zKTtcclxuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgaEF4ZXNNYXJnaW5zID0gZ2V0SG9yaXpvbnRhbEF4ZXNNYXJnaW5zKGhvcml6b250YWxFbGVtZW50cywgZ2V0QXhpc01hcmdpbnMpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2QXhlc01hcmdpbnMgPSBnZXRWZXJ0aWNhbEF4ZXNNYXJnaW5zKHZlcnRpY2FsRWxlbWVudHMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFuZXNDYW52YXNlcyA9IHNocmlua0NhbnZhc2VzKHJvdGF0ZWQsIHBhbmVzQ2FudmFzZXMsIHBhbmVTaXplcywgdkF4ZXNNYXJnaW5zLCBoQXhlc01hcmdpbnMpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBkcmF3QXhlc0FuZFNldENhbnZhc2VzKGZhbHNlKTtcclxuICAgICAgICBkcmF3QXhlc0FuZFNldENhbnZhc2VzKHRydWUpO1xyXG4gICAgICAgIGlmICghdGhhdC5fY2hhbmdlc0FwcGx5aW5nICYmIHRoYXQuX2VzdGltYXRlVGlja0ludGVydmFscyh2ZXJ0aWNhbEF4ZXMsIHBhbmVzQ2FudmFzZXMpKSB7XHJcbiAgICAgICAgICAgIGRyYXdBeGVzQW5kU2V0Q2FudmFzZXMoZmFsc2UpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvbGRUaXRsZXNXaWR0aCA9IGNhbGN1bGF0ZVRpdGxlc1dpZHRoKHZlcnRpY2FsQXhlcyk7XHJcbiAgICAgICAgdmFyIHZpc2libGVTZXJpZXMgPSB0aGF0Ll9nZXRWaXNpYmxlU2VyaWVzKCk7XHJcbiAgICAgICAgdmFyIHBvaW50c1RvQW5pbWF0aW9uID0gdGhhdC5fZ2V0UG9pbnRzVG9BbmltYXRpb24odmlzaWJsZVNlcmllcyk7XHJcbiAgICAgICAgdmFyIGF4ZXNJc0FuaW1hdGVkID0gYXhpc0FuaW1hdGlvbkVuYWJsZWQoZHJhd09wdGlvbnMsIHBvaW50c1RvQW5pbWF0aW9uKTtcclxuICAgICAgICBwZXJmb3JtQWN0aW9uT25BeGVzKGFsbEVsZW1lbnRzLCBcInVwZGF0ZVNpemVcIiwgcGFuZXNDYW52YXNlcywgYXhlc0lzQW5pbWF0ZWQpO1xyXG4gICAgICAgIGhvcml6b250YWxFbGVtZW50cy5mb3JFYWNoKHNoaWZ0QXhpcyhcInRvcFwiLCBcImJvdHRvbVwiKSk7XHJcbiAgICAgICAgdmVydGljYWxFbGVtZW50cy5mb3JFYWNoKHNoaWZ0QXhpcyhcImxlZnRcIiwgXCJyaWdodFwiKSk7XHJcbiAgICAgICAgdGhhdC5fcmVuZGVyU2NhbGVCcmVha3MoKTtcclxuICAgICAgICB0aGF0LnBhbmVzLmZvckVhY2goKGZ1bmN0aW9uKHBhbmUpIHtcclxuICAgICAgICAgICAgX2V4dGVuZChwYW5lLmNhbnZhcywgcGFuZXNDYW52YXNlc1twYW5lLm5hbWVdKVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGF0Ll92YWx1ZUF4ZXMuZm9yRWFjaChheGlzID0+IHtcclxuICAgICAgICAgICAgYXhpcy5zZXRJbml0UmFuZ2UoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZlcnRpY2FsQXhlcy5mb3JFYWNoKChheGlzLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYXhpcyRoYXNXcmFwO1xyXG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gKF9heGlzJGhhc1dyYXAgPSBheGlzLmhhc1dyYXApICYmIHZvaWQgMCAhPT0gX2F4aXMkaGFzV3JhcCAmJiBfYXhpcyRoYXNXcmFwLmNhbGwoYXhpcykpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IGF4aXMuZ2V0VGl0bGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdUaXRsZVdpZHRoID0gdGl0bGUgPyB0aXRsZS5iQm94LndpZHRoIDogMDtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBuZXdUaXRsZVdpZHRoIC0gb2xkVGl0bGVzV2lkdGhbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJyaWdodFwiID09PSBheGlzLmdldE9wdGlvbnMoKS5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZBeGVzTWFyZ2lucy5yaWdodCArPSBvZmZzZXRcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdkF4ZXNNYXJnaW5zLmxlZnQgKz0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQucGFuZXMuZm9yRWFjaChfcmVmMiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gPSBfcmVmMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZBeGVzTWFyZ2lucy5wYW5lc1tuYW1lXS5sZWZ0ICs9IG9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYW5lc0NhbnZhc2VzID0gc2hyaW5rQ2FudmFzZXMocm90YXRlZCwgcGFuZXNDYW52YXNlcywgcGFuZVNpemVzLCB2QXhlc01hcmdpbnMsIGhBeGVzTWFyZ2lucyk7XHJcbiAgICAgICAgICAgICAgICBwZXJmb3JtQWN0aW9uT25BeGVzKGFsbEVsZW1lbnRzLCBcInVwZGF0ZVNpemVcIiwgcGFuZXNDYW52YXNlcywgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIG9sZFRpdGxlc1dpZHRoID0gY2FsY3VsYXRlVGl0bGVzV2lkdGgodmVydGljYWxBeGVzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHZlcnRpY2FsQXhlcy5zb21lKHYgPT4gdi5jdXN0b21Qb3NpdGlvbklzQXZhaWxhYmxlKCkgJiYgdi5nZXRDdXN0b21Qb3NpdGlvbigpICE9PSB2Ll9heGlzUG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgIGF4ZXNJc0FuaW1hdGVkICYmIHRoYXQuX3Jlc2V0QXhlc0FuaW1hdGlvbih2ZXJ0aWNhbEF4ZXNGaXJzdERyYXdpbmcsIGZhbHNlKTtcclxuICAgICAgICAgICAgcGVyZm9ybUFjdGlvbk9uQXhlcyh2ZXJ0aWNhbEF4ZXMsIFwidXBkYXRlU2l6ZVwiLCBwYW5lc0NhbnZhc2VzLCBheGVzSXNBbmltYXRlZClcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9yaXpvbnRhbEF4ZXMuZm9yRWFjaChhID0+IGEucmVzb2x2ZU92ZXJsYXBwaW5nRm9yQ3VzdG9tUG9zaXRpb25pbmcodmVydGljYWxBeGVzKSk7XHJcbiAgICAgICAgdmVydGljYWxBeGVzLmZvckVhY2goYSA9PiBhLnJlc29sdmVPdmVybGFwcGluZ0ZvckN1c3RvbVBvc2l0aW9uaW5nKGhvcml6b250YWxBeGVzKSk7XHJcbiAgICAgICAgcmV0dXJuIGNsZWFuUGFuZXNDYW52YXNlc1xyXG4gICAgfSxcclxuICAgIF9nZXRFeHRyYVRlbXBsYXRlc0l0ZW1zKCkge1xyXG4gICAgICAgIHZhciBhbGxBeGVzID0gKHRoaXMuX2FyZ3VtZW50QXhlcyB8fCBbXSkuY29uY2F0KHRoaXMuX3ZhbHVlQXhlcyB8fCBbXSk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5fY29sbGVjdFRlbXBsYXRlc0Zyb21JdGVtcyhhbGxBeGVzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpdGVtczogZWxlbWVudHMuaXRlbXMsXHJcbiAgICAgICAgICAgIGdyb3VwczogZWxlbWVudHMuZ3JvdXBzLFxyXG4gICAgICAgICAgICBsYXVuY2hSZXF1ZXN0KCkge1xyXG4gICAgICAgICAgICAgICAgYWxsQXhlcy5mb3JFYWNoKChmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5zZXRSZW5kZXJlZFN0YXRlKHRydWUpXHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZG9uZVJlcXVlc3QoKSB7XHJcbiAgICAgICAgICAgICAgICBhbGxBeGVzLmZvckVhY2goKGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBhLnNldFJlbmRlcmVkU3RhdGUoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZXN0aW1hdGVUaWNrSW50ZXJ2YWxzOiAoYXhlcywgY2FudmFzZXMpID0+IGF4ZXMuc29tZShheGlzID0+IGF4aXMuZXN0aW1hdGVUaWNrSW50ZXJ2YWwoY2FudmFzZXNbYXhpcy5wYW5lXSkpLFxyXG4gICAgY2hlY2tGb3JNb3JlU3BhY2VGb3JQYW5lc0NhbnZhcygpIHtcclxuICAgICAgICB2YXIgcm90YXRlZCA9IHRoaXMuX2lzUm90YXRlZCgpO1xyXG4gICAgICAgIHZhciBwYW5lc0FyZUN1c3RvbVNpemVkID0gdGhpcy5wYW5lcy5maWx0ZXIocCA9PiBwLnVuaXQpLmxlbmd0aCA9PT0gdGhpcy5wYW5lcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIG5lZWRTcGFjZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChwYW5lc0FyZUN1c3RvbVNpemVkKSB7XHJcbiAgICAgICAgICAgIHZhciBuZWVkSG9yaXpvbnRhbFNwYWNlID0gMDtcclxuICAgICAgICAgICAgdmFyIG5lZWRWZXJ0aWNhbFNwYWNlID0gMDtcclxuICAgICAgICAgICAgaWYgKHJvdGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdBeGlzUmlnaHRNYXJnaW4gPSB0aGlzLmdldEFyZ3VtZW50QXhpcygpLmdldE1hcmdpbnMoKS5yaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciByaWdodFBhbmVzSW5kZW50ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdGhpcy5wYW5lcy5tYXAocCA9PiBwLmNhbnZhcy5yaWdodCkpO1xyXG4gICAgICAgICAgICAgICAgbmVlZEhvcml6b250YWxTcGFjZSA9IHRoaXMuX2NhbnZhcy5yaWdodCArIGFyZ0F4aXNSaWdodE1hcmdpbiAtIHJpZ2h0UGFuZXNJbmRlbnRcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdBeGlzQm90dG9tTWFyZ2luID0gdGhpcy5nZXRBcmd1bWVudEF4aXMoKS5nZXRNYXJnaW5zKCkuYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJvdHRvbVBhbmVzSW5kZW50ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdGhpcy5wYW5lcy5tYXAocCA9PiBwLmNhbnZhcy5ib3R0b20pKTtcclxuICAgICAgICAgICAgICAgIG5lZWRWZXJ0aWNhbFNwYWNlID0gdGhpcy5fY2FudmFzLmJvdHRvbSArIGFyZ0F4aXNCb3R0b21NYXJnaW4gLSBib3R0b21QYW5lc0luZGVudFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5lZWRTcGFjZSA9IG5lZWRIb3Jpem9udGFsU3BhY2UgPiAwIHx8IG5lZWRWZXJ0aWNhbFNwYWNlID4gMCA/IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBuZWVkSG9yaXpvbnRhbFNwYWNlLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBuZWVkVmVydGljYWxTcGFjZVxyXG4gICAgICAgICAgICB9IDogZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICgwICE9PSBuZWVkVmVydGljYWxTcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlYWxTaXplID0gdGhpcy5nZXRTaXplKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VzdG9tU2l6ZSA9IHRoaXMub3B0aW9uKFwic2l6ZVwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl8kZWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJIYXNTdHlsZWRIZWlnaHQgPSAhIXBhcnNlSW50KGNvbnRhaW5lci5zdHlsZS5oZWlnaHQpIHx8IDAgIT09IHRoaXMuX2NvbnRhaW5lckluaXRpYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJvdGF0ZWQgJiYgIShjdXN0b21TaXplICYmIGN1c3RvbVNpemUuaGVpZ2h0KSAmJiAhY29udGFpbmVySGFzU3R5bGVkSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9yY2VSZXNpemUocmVhbFNpemUud2lkdGgsIHJlYWxTaXplLmhlaWdodCArIG5lZWRWZXJ0aWNhbFNwYWNlKTtcclxuICAgICAgICAgICAgICAgICAgICBuZWVkU3BhY2UgPSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmVlZFNwYWNlID0gdGhpcy5sYXlvdXRNYW5hZ2VyLm5lZWRNb3JlU3BhY2VGb3JQYW5lc0NhbnZhcyh0aGlzLl9nZXRMYXlvdXRUYXJnZXRzKCksIHJvdGF0ZWQsIHBhbmUgPT4gKHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiByb3RhdGVkICYmICEhcGFuZS51bml0LFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAhcm90YXRlZCAmJiAhIXBhbmUudW5pdFxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5lZWRTcGFjZVxyXG4gICAgfSxcclxuICAgIF9mb3JjZVJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVNpemUoKTtcclxuICAgICAgICB0aGlzLl9zZXRDb250ZW50U2l6ZSgpO1xyXG4gICAgICAgIHRoaXMuX3ByZXNlcnZlT3JpZ2luYWxDYW52YXMoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVDYW52YXNDbGlwUmVjdCh0aGlzLl9jYW52YXMpXHJcbiAgICB9LFxyXG4gICAgX3Nocmlua0F4ZXMoc2l6ZVNob3J0YWdlLCBwYW5lc0NhbnZhc2VzKSB7XHJcbiAgICAgICAgaWYgKCFzaXplU2hvcnRhZ2UgfHwgIXBhbmVzQ2FudmFzZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnN0b3BBbGxBbmltYXRpb25zKHRydWUpO1xyXG4gICAgICAgIHZhciByb3RhdGVkID0gdGhpcy5faXNSb3RhdGVkKCk7XHJcbiAgICAgICAgdmFyIHNjcm9sbEJhciA9IHRoaXMuX3Njcm9sbEJhciA/IFt0aGlzLl9zY3JvbGxCYXJdIDogW107XHJcbiAgICAgICAgdmFyIGV4dGVuZGVkQXJnQXhlcyA9IHRoaXMuX2lzQXJndW1lbnRBeGlzQmVmb3JlU2Nyb2xsQmFyKCkgPyB0aGlzLl9hcmd1bWVudEF4ZXMuY29uY2F0KHNjcm9sbEJhcikgOiBzY3JvbGxCYXIuY29uY2F0KHRoaXMuX2FyZ3VtZW50QXhlcyk7XHJcbiAgICAgICAgdmFyIHZlcnRpY2FsQXhlcyA9IHJvdGF0ZWQgPyBleHRlbmRlZEFyZ0F4ZXMgOiB0aGlzLl92YWx1ZUF4ZXM7XHJcbiAgICAgICAgdmFyIGhvcml6b250YWxBeGVzID0gcm90YXRlZCA/IHRoaXMuX3ZhbHVlQXhlcyA6IGV4dGVuZGVkQXJnQXhlcztcclxuICAgICAgICB2YXIgYWxsQXhlcyA9IHZlcnRpY2FsQXhlcy5jb25jYXQoaG9yaXpvbnRhbEF4ZXMpO1xyXG4gICAgICAgIGlmIChzaXplU2hvcnRhZ2Uud2lkdGggfHwgc2l6ZVNob3J0YWdlLmhlaWdodCkge1xyXG4gICAgICAgICAgICBjaGVja1VzZWRTcGFjZShzaXplU2hvcnRhZ2UsIFwiaGVpZ2h0XCIsIGhvcml6b250YWxBeGVzLCBnZXRIb3Jpem9udGFsQXhlc01hcmdpbnMpO1xyXG4gICAgICAgICAgICBjaGVja1VzZWRTcGFjZShzaXplU2hvcnRhZ2UsIFwid2lkdGhcIiwgdmVydGljYWxBeGVzLCBnZXRWZXJ0aWNhbEF4ZXNNYXJnaW5zKTtcclxuICAgICAgICAgICAgcGVyZm9ybUFjdGlvbk9uQXhlcyhhbGxBeGVzLCBcInVwZGF0ZVNpemVcIiwgcGFuZXNDYW52YXNlcyk7XHJcbiAgICAgICAgICAgIHZhciBwYW5lU2l6ZXMgPSB0aGlzLnBhbmVzLnJlZHVjZSgoc2l6ZXMsIHBhbmUpID0+IHtcclxuICAgICAgICAgICAgICAgIHNpemVzW3BhbmUubmFtZV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwYW5lLmhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICB1bml0OiBwYW5lLnVuaXRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZXNcclxuICAgICAgICAgICAgfSwge30pO1xyXG4gICAgICAgICAgICBwYW5lc0NhbnZhc2VzID0gc2hyaW5rQ2FudmFzZXMocm90YXRlZCwgcGFuZXNDYW52YXNlcywgcGFuZVNpemVzLCBnZXRWZXJ0aWNhbEF4ZXNNYXJnaW5zKHZlcnRpY2FsQXhlcyksIGdldEhvcml6b250YWxBeGVzTWFyZ2lucyhob3Jpem9udGFsQXhlcywgZ2V0QXhpc01hcmdpbnMpKTtcclxuICAgICAgICAgICAgcGVyZm9ybUFjdGlvbk9uQXhlcyhhbGxBeGVzLCBcInVwZGF0ZVNpemVcIiwgcGFuZXNDYW52YXNlcyk7XHJcbiAgICAgICAgICAgIGhvcml6b250YWxBeGVzLmZvckVhY2goc2hpZnRBeGlzKFwidG9wXCIsIFwiYm90dG9tXCIpKTtcclxuICAgICAgICAgICAgdmVydGljYWxBeGVzLmZvckVhY2goc2hpZnRBeGlzKFwibGVmdFwiLCBcInJpZ2h0XCIpKTtcclxuICAgICAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKHBhbmUgPT4gX2V4dGVuZChwYW5lLmNhbnZhcywgcGFuZXNDYW52YXNlc1twYW5lLm5hbWVdKSlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2lzQXJndW1lbnRBeGlzQmVmb3JlU2Nyb2xsQmFyKCkge1xyXG4gICAgICAgIHZhciBhcmd1bWVudEF4aXMgPSB0aGlzLmdldEFyZ3VtZW50QXhpcygpO1xyXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxCYXIpIHtcclxuICAgICAgICAgICAgdmFyIF9hcmd1bWVudEF4aXMkZ2V0T3B0aTtcclxuICAgICAgICAgICAgdmFyIGFyZ0F4aXNQb3NpdGlvbiA9IGFyZ3VtZW50QXhpcy5nZXRSZXNvbHZlZEJvdW5kYXJ5UG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdmFyIGFyZ0F4aXNMYWJlbFBvc2l0aW9uID0gbnVsbCA9PT0gKF9hcmd1bWVudEF4aXMkZ2V0T3B0aSA9IGFyZ3VtZW50QXhpcy5nZXRPcHRpb25zKCkubGFiZWwpIHx8IHZvaWQgMCA9PT0gX2FyZ3VtZW50QXhpcyRnZXRPcHRpID8gdm9pZCAwIDogX2FyZ3VtZW50QXhpcyRnZXRPcHRpLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsQmFyUG9zaXRpb24gPSB0aGlzLl9zY3JvbGxCYXIuZ2V0T3B0aW9ucygpLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRBeGlzLmhhc05vbkJvdW5kYXJ5UG9zaXRpb24oKSB8fCBzY3JvbGxCYXJQb3NpdGlvbiA9PT0gYXJnQXhpc1Bvc2l0aW9uICYmIGFyZ0F4aXNMYWJlbFBvc2l0aW9uICE9PSBzY3JvbGxCYXJQb3NpdGlvblxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0sXHJcbiAgICBfZ2V0UGFuZXNQYXJhbWV0ZXJzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgcGFuZXMgPSB0aGlzLnBhbmVzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFuZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2dldFBhbmVCb3JkZXJWaXNpYmlsaXR5KGkpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzOiBwYW5lc1tpXS5ib3JkZXJDb29yZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpcFJlY3Q6IHRoaXMuX3BhbmVzQ2xpcFJlY3RzLmZpeGVkW2ldXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXNcclxuICAgIH0sXHJcbiAgICBfY3JlYXRlQ3Jvc3NoYWlyQ3Vyc29yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX3RoZW1lTWFuYWdlci5nZXRPcHRpb25zKFwiY3Jvc3NoYWlyXCIpIHx8IHt9O1xyXG4gICAgICAgIHZhciBhcmd1bWVudEF4aXMgPSB0aGlzLmdldEFyZ3VtZW50QXhpcygpO1xyXG4gICAgICAgIHZhciBheGVzID0gIXRoaXMuX2lzUm90YXRlZCgpID8gW1xyXG4gICAgICAgICAgICBbYXJndW1lbnRBeGlzXSwgdGhpcy5fdmFsdWVBeGVzXHJcbiAgICAgICAgXSA6IFt0aGlzLl92YWx1ZUF4ZXMsIFthcmd1bWVudEF4aXNdXTtcclxuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHtcclxuICAgICAgICAgICAgY2FudmFzOiB0aGlzLl9nZXRDb21tb25DYW52YXMoKSxcclxuICAgICAgICAgICAgcGFuZXM6IHRoaXMuX2dldFBhbmVzUGFyYW1ldGVycygpLFxyXG4gICAgICAgICAgICBheGVzOiBheGVzXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jcm9zc2hhaXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3Jvc3NoYWlyID0gbmV3IENyb3NzaGFpcih0aGlzLl9yZW5kZXJlciwgb3B0aW9ucywgcGFyYW1ldGVycywgdGhpcy5fY3Jvc3NoYWlyQ3Vyc29yR3JvdXApXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fY3Jvc3NoYWlyLnVwZGF0ZShvcHRpb25zLCBwYXJhbWV0ZXJzKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jcm9zc2hhaXIucmVuZGVyKClcclxuICAgIH0sXHJcbiAgICBfZ2V0Q29tbW9uQ2FudmFzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgY2FudmFzO1xyXG4gICAgICAgIHZhciBjb21tb25DYW52YXM7XHJcbiAgICAgICAgdmFyIHBhbmVzID0gdGhpcy5wYW5lcztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFuZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY2FudmFzID0gcGFuZXNbaV0uY2FudmFzO1xyXG4gICAgICAgICAgICBpZiAoIWNvbW1vbkNhbnZhcykge1xyXG4gICAgICAgICAgICAgICAgY29tbW9uQ2FudmFzID0gX2V4dGVuZCh7fSwgY2FudmFzKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29tbW9uQ2FudmFzLnJpZ2h0ID0gY2FudmFzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgY29tbW9uQ2FudmFzLmJvdHRvbSA9IGNhbnZhcy5ib3R0b21cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tbW9uQ2FudmFzXHJcbiAgICB9LFxyXG4gICAgX2NyZWF0ZVBhbmVzQmFja2dyb3VuZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl90aGVtZU1hbmFnZXIuZ2V0T3B0aW9ucyhcImNvbW1vblBhbmVTZXR0aW5nc1wiKS5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgdmFyIGJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcclxuICAgICAgICB2YXIgcmVjdDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgcmVjdHMgPSBbXTtcclxuICAgICAgICB0aGlzLl9wYW5lc0JhY2tncm91bmRHcm91cC5jbGVhcigpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBhbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IHRoaXMucGFuZXNbaV0uYmFja2dyb3VuZENvbG9yIHx8IGRlZmF1bHRCYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgICAgIGlmICghYmFja2dyb3VuZENvbG9yIHx8IFwibm9uZVwiID09PSBiYWNrZ3JvdW5kQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlY3RzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlY3QgPSByZW5kZXJlci5yZWN0KDAsIDAsIDAsIDApLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgZmlsbDogYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMFxyXG4gICAgICAgICAgICB9KS5hcHBlbmQodGhpcy5fcGFuZXNCYWNrZ3JvdW5kR3JvdXApO1xyXG4gICAgICAgICAgICByZWN0cy5wdXNoKHJlY3QpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFuZXNCYWNrZ3JvdW5kID0gcmVjdHNcclxuICAgIH0sXHJcbiAgICBfZmlsbFBhbmVzQmFja2dyb3VuZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBiYztcclxuICAgICAgICBfZWFjaCh0aGF0LnBhbmVzLCAoZnVuY3Rpb24oaSwgcGFuZSkge1xyXG4gICAgICAgICAgICBiYyA9IHBhbmUuYm9yZGVyQ29vcmRzO1xyXG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gdGhhdC5wYW5lc0JhY2tncm91bmRbaV0pIHtcclxuICAgICAgICAgICAgICAgIHRoYXQucGFuZXNCYWNrZ3JvdW5kW2ldLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IGJjLmxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogYmMudG9wLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBiYy53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJjLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSxcclxuICAgIF9jYWxjUGFuZUJvcmRlckNvb3JkczogZnVuY3Rpb24ocGFuZSkge1xyXG4gICAgICAgIHZhciBjYW52YXMgPSBwYW5lLmNhbnZhcztcclxuICAgICAgICB2YXIgYmMgPSBwYW5lLmJvcmRlckNvb3JkcyA9IHBhbmUuYm9yZGVyQ29vcmRzIHx8IHt9O1xyXG4gICAgICAgIGJjLmxlZnQgPSBjYW52YXMubGVmdDtcclxuICAgICAgICBiYy50b3AgPSBjYW52YXMudG9wO1xyXG4gICAgICAgIGJjLnJpZ2h0ID0gY2FudmFzLndpZHRoIC0gY2FudmFzLnJpZ2h0O1xyXG4gICAgICAgIGJjLmJvdHRvbSA9IGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuYm90dG9tO1xyXG4gICAgICAgIGJjLndpZHRoID0gTWF0aC5tYXgoYmMucmlnaHQgLSBiYy5sZWZ0LCAwKTtcclxuICAgICAgICBiYy5oZWlnaHQgPSBNYXRoLm1heChiYy5ib3R0b20gLSBiYy50b3AsIDApXHJcbiAgICB9LFxyXG4gICAgX2RyYXdQYW5lc0JvcmRlcnM6IGZ1bmN0aW9uKHBhbmVzQm9yZGVyT3B0aW9ucykge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgcm90YXRlZCA9IHRoYXQuX2lzUm90YXRlZCgpO1xyXG4gICAgICAgIHRoYXQuX3BhbmVzQm9yZGVyR3JvdXAubGlua1JlbW92ZSgpLmNsZWFyKCk7XHJcbiAgICAgICAgX2VhY2godGhhdC5wYW5lcywgKGZ1bmN0aW9uKGksIHBhbmUpIHtcclxuICAgICAgICAgICAgdmFyIGJvcmRlck9wdGlvbnMgPSBwYW5lc0JvcmRlck9wdGlvbnNbcGFuZS5uYW1lXTtcclxuICAgICAgICAgICAgdmFyIGF0dHIgPSB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogYm9yZGVyT3B0aW9ucy5jb2xvcixcclxuICAgICAgICAgICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogYm9yZGVyT3B0aW9ucy5vcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogYm9yZGVyT3B0aW9ucy53aWR0aCxcclxuICAgICAgICAgICAgICAgIGRhc2hTdHlsZTogYm9yZGVyT3B0aW9ucy5kYXNoU3R5bGUsXHJcbiAgICAgICAgICAgICAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwic3F1YXJlXCJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhhdC5fY2FsY1BhbmVCb3JkZXJDb29yZHMocGFuZSwgcm90YXRlZCk7XHJcbiAgICAgICAgICAgIGlmICghYm9yZGVyT3B0aW9ucy52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYmMgPSBwYW5lLmJvcmRlckNvb3JkcztcclxuICAgICAgICAgICAgdmFyIHNlZ21lbnRSZWN0UGFyYW1zID0gcHJlcGFyZVNlZ21lbnRSZWN0UG9pbnRzKGJjLmxlZnQsIGJjLnRvcCwgYmMud2lkdGgsIGJjLmhlaWdodCwgYm9yZGVyT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoYXQuX3JlbmRlcmVyLnBhdGgoc2VnbWVudFJlY3RQYXJhbXMucG9pbnRzLCBzZWdtZW50UmVjdFBhcmFtcy5wYXRoVHlwZSkuYXR0cihhdHRyKS5hcHBlbmQodGhhdC5fcGFuZXNCb3JkZXJHcm91cClcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhhdC5fcGFuZXNCb3JkZXJHcm91cC5saW5rQXBwZW5kKClcclxuICAgIH0sXHJcbiAgICBfY3JlYXRlQ2xpcFJlY3Q6IGZ1bmN0aW9uKGNsaXBBcnJheSwgaW5kZXgsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHZhciBjbGlwUmVjdCA9IGNsaXBBcnJheVtpbmRleF07XHJcbiAgICAgICAgaWYgKCFjbGlwUmVjdCkge1xyXG4gICAgICAgICAgICBjbGlwUmVjdCA9IHRoaXMuX3JlbmRlcmVyLmNsaXBSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIGNsaXBBcnJheVtpbmRleF0gPSBjbGlwUmVjdFxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNsaXBSZWN0LmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgeDogbGVmdCxcclxuICAgICAgICAgICAgICAgIHk6IHRvcCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9jcmVhdGVDbGlwUmVjdHNGb3JQYW5lczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGF0Ll9jYW52YXM7XHJcbiAgICAgICAgX2VhY2godGhhdC5wYW5lcywgKGZ1bmN0aW9uKGksIHBhbmUpIHtcclxuICAgICAgICAgICAgdmFyIG5lZWRXaWRlQ2xpcFJlY3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGJjID0gcGFuZS5ib3JkZXJDb29yZHM7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gYmMubGVmdDtcclxuICAgICAgICAgICAgdmFyIHRvcCA9IGJjLnRvcDtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gYmMud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBiYy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBwYW5lc0NsaXBSZWN0cyA9IHRoYXQuX3BhbmVzQ2xpcFJlY3RzO1xyXG4gICAgICAgICAgICB0aGF0Ll9jcmVhdGVDbGlwUmVjdChwYW5lc0NsaXBSZWN0cy5maXhlZCwgaSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhhdC5fY3JlYXRlQ2xpcFJlY3QocGFuZXNDbGlwUmVjdHMuYmFzZSwgaSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgX2VhY2godGhhdC5zZXJpZXMsIChmdW5jdGlvbihfLCBzZXJpZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZXJpZXMucGFuZSA9PT0gcGFuZS5uYW1lICYmIChzZXJpZXMuaXNGaW5hbmNpYWxTZXJpZXMoKSB8fCBzZXJpZXMuYXJlRXJyb3JCYXJzVmlzaWJsZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5lZWRXaWRlQ2xpcFJlY3QgPSB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgaWYgKG5lZWRXaWRlQ2xpcFJlY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9pc1JvdGF0ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gY2FudmFzLmhlaWdodFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGNhbnZhcy53aWR0aFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhhdC5fY3JlYXRlQ2xpcFJlY3QocGFuZXNDbGlwUmVjdHMud2lkZSwgaSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFuZXNDbGlwUmVjdHMud2lkZVtpXSA9IG51bGxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSxcclxuICAgIF9hcHBseUNsaXBSZWN0c0ZvckF4ZXMoKSB7XHJcbiAgICAgICAgdmFyIGF4ZXMgPSB0aGlzLl9nZXRBbGxBeGVzKCk7XHJcbiAgICAgICAgdmFyIGNoYXJ0Q2FudmFzQ2xpcFJlY3RJRCA9IHRoaXMuX2dldENhbnZhc0NsaXBSZWN0SUQoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRzQ2xpcFJlY3RJRCA9IHRoaXMuX2dldEVsZW1lbnRzQ2xpcFJlY3RJRChheGVzW2ldLnBhbmUpO1xyXG4gICAgICAgICAgICBheGVzW2ldLmFwcGx5Q2xpcFJlY3RzKGVsZW1lbnRzQ2xpcFJlY3RJRCwgY2hhcnRDYW52YXNDbGlwUmVjdElEKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0UGFuZUJvcmRlclZpc2liaWxpdHk6IGZ1bmN0aW9uKHBhbmVJbmRleCkge1xyXG4gICAgICAgIHZhciBjb21tb25QYW5lQm9yZGVyVmlzaWJsZSA9IHRoaXMuX3RoZW1lTWFuYWdlci5nZXRPcHRpb25zKFwiY29tbW9uUGFuZVNldHRpbmdzXCIpLmJvcmRlci52aXNpYmxlO1xyXG4gICAgICAgIHZhciBwYW5lID0gdGhpcy5wYW5lc1twYW5lSW5kZXhdIHx8IHt9O1xyXG4gICAgICAgIHZhciBwYW5lQm9yZGVyID0gcGFuZS5ib3JkZXIgfHwge307XHJcbiAgICAgICAgcmV0dXJuIFwidmlzaWJsZVwiIGluIHBhbmVCb3JkZXIgPyBwYW5lQm9yZGVyLnZpc2libGUgOiBjb21tb25QYW5lQm9yZGVyVmlzaWJsZVxyXG4gICAgfSxcclxuICAgIF9nZXRDYW52YXNGb3JQYW5lOiBmdW5jdGlvbihwYW5lTmFtZSkge1xyXG4gICAgICAgIHZhciBwYW5lcyA9IHRoaXMucGFuZXM7XHJcbiAgICAgICAgdmFyIHBhbmVzTnVtYmVyID0gcGFuZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYW5lc051bWJlcjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChwYW5lc1tpXS5uYW1lID09PSBwYW5lTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhbmVzW2ldLmNhbnZhc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9nZXRUcmFja2VyU2V0dGluZ3M6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGVtZU1hbmFnZXIgPSB0aGlzLl90aGVtZU1hbmFnZXI7XHJcbiAgICAgICAgcmV0dXJuIF9leHRlbmQodGhpcy5jYWxsQmFzZSgpLCB7XHJcbiAgICAgICAgICAgIGNoYXJ0OiB0aGlzLFxyXG4gICAgICAgICAgICByb3RhdGVkOiB0aGlzLl9pc1JvdGF0ZWQoKSxcclxuICAgICAgICAgICAgY3Jvc3NoYWlyOiB0aGlzLl9nZXRDcm9zc2hhaXJPcHRpb25zKCkuZW5hYmxlZCA/IHRoaXMuX2Nyb3NzaGFpciA6IG51bGwsXHJcbiAgICAgICAgICAgIHN0aWNreUhvdmVyaW5nOiB0aGVtZU1hbmFnZXIuZ2V0T3B0aW9ucyhcInN0aWNreUhvdmVyaW5nXCIpXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBfcmVzb2x2ZUxhYmVsT3ZlcmxhcHBpbmdTdGFjazogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBpc1JvdGF0ZWQgPSB0aGF0Ll9pc1JvdGF0ZWQoKTtcclxuICAgICAgICB2YXIgc2hpZnREaXJlY3Rpb24gPSBpc1JvdGF0ZWQgPyBmdW5jdGlvbihib3gsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogYm94LnggLSBsZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB5OiBib3gueVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGJveCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBib3gueCxcclxuICAgICAgICAgICAgICAgIHk6IGJveC55IC0gbGVuZ3RoXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIF9lYWNoKHRoYXQuX2dldFN0YWNrUG9pbnRzKCksIChmdW5jdGlvbihfLCBzdGFja3MpIHtcclxuICAgICAgICAgICAgX2VhY2goc3RhY2tzLCAoZnVuY3Rpb24oXywgcG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNJbnZlcnRlZCA9IHBvaW50c1swXS5zZXJpZXMuZ2V0VmFsdWVBeGlzKCkuZ2V0T3B0aW9ucygpLmludmVydGVkO1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmcucmVzb2x2ZUxhYmVsT3ZlcmxhcHBpbmdJbk9uZURpcmVjdGlvbihwb2ludHMsIHRoYXQuX2dldENvbW1vbkNhbnZhcygpLCBpc1JvdGF0ZWQsIGlzSW52ZXJ0ZWQsIHNoaWZ0RGlyZWN0aW9uLCAoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb29yZFBvc2l0aW9uID0gaXNSb3RhdGVkID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZ3VyZUNlbnRlcjEgPSBhLmxhYmVsc1swXS5nZXRGaWd1cmVDZW50ZXIoKVtjb29yZFBvc2l0aW9uXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlndXJlQ2VudGVyMTIgPSBiLmxhYmVsc1swXS5nZXRGaWd1cmVDZW50ZXIoKVtjb29yZFBvc2l0aW9uXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlndXJlQ2VudGVyMSAtIGZpZ3VyZUNlbnRlcjEyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYS52YWx1ZSgpIC0gYi52YWx1ZSgpKSAqIChhLmxhYmVsc1swXS5nZXRQb2ludCgpLnNlcmllcy5nZXRWYWx1ZUF4aXMoKS5nZXRUcmFuc2xhdG9yKCkuaXNJbnZlcnRlZCgpID8gLTEgOiAxKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfSkpXHJcbiAgICB9LFxyXG4gICAgX2dldFN0YWNrUG9pbnRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgc3RhY2tQb2ludHMgPSB7fTtcclxuICAgICAgICB2YXIgdmlzaWJsZVNlcmllcyA9IHRoaXMuX2dldFZpc2libGVTZXJpZXMoKTtcclxuICAgICAgICBfZWFjaCh2aXNpYmxlU2VyaWVzLCAoZnVuY3Rpb24oXywgc2luZ2xlU2VyaWVzKSB7XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBzaW5nbGVTZXJpZXMuZ2V0UG9pbnRzKCk7XHJcbiAgICAgICAgICAgIHZhciBzdGFja05hbWUgPSBzaW5nbGVTZXJpZXMuZ2V0U3RhY2tOYW1lKCkgfHwgbnVsbDtcclxuICAgICAgICAgICAgX2VhY2gocG9pbnRzLCAoZnVuY3Rpb24oXywgcG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmd1bWVudCA9IHBvaW50LmFyZ3VtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdGFja1BvaW50c1thcmd1bWVudF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1BvaW50c1thcmd1bWVudF0gPSB7fVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdGFja1BvaW50c1thcmd1bWVudF1bc3RhY2tOYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrUG9pbnRzW2FyZ3VtZW50XVtzdGFja05hbWVdID0gW11cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0YWNrUG9pbnRzW2FyZ3VtZW50XVtzdGFja05hbWVdLnB1c2gocG9pbnQpXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gc3RhY2tQb2ludHNcclxuICAgIH0sXHJcbiAgICBfZ2V0Q3Jvc3NoYWlyT3B0aW9uczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9wdGlvbihcImNyb3NzaGFpclwiKVxyXG4gICAgfSxcclxuICAgIHpvb21Bcmd1bWVudChtaW4sIG1heCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQgfHwgIV9pc0RlZmluZWQobWluKSAmJiAhX2lzRGVmaW5lZChtYXgpKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdldEFyZ3VtZW50QXhpcygpLnZpc3VhbFJhbmdlKFttaW4sIG1heF0pXHJcbiAgICB9LFxyXG4gICAgcmVzZXRWaXN1YWxSYW5nZSgpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGF4ZXMgPSB0aGF0Ll9hcmd1bWVudEF4ZXM7XHJcbiAgICAgICAgdmFyIG5vblZpcnR1YWxBcmd1bWVudEF4aXMgPSB0aGF0LmdldEFyZ3VtZW50QXhpcygpO1xyXG4gICAgICAgIGF4ZXMuZm9yRWFjaChheGlzID0+IHtcclxuICAgICAgICAgICAgYXhpcy5yZXNldFZpc3VhbFJhbmdlKG5vblZpcnR1YWxBcmd1bWVudEF4aXMgIT09IGF4aXMpO1xyXG4gICAgICAgICAgICB0aGF0Ll9hcHBseUN1c3RvbVZpc3VhbFJhbmdlT3B0aW9uKGF4aXMpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhhdC5jYWxsQmFzZSgpXHJcbiAgICB9LFxyXG4gICAgZ2V0VmlzaWJsZUFyZ3VtZW50Qm91bmRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdHJhbnNsYXRvciA9IHRoaXMuX2FyZ3VtZW50QXhlc1swXS5nZXRUcmFuc2xhdG9yKCk7XHJcbiAgICAgICAgdmFyIHJhbmdlID0gdHJhbnNsYXRvci5nZXRCdXNpbmVzc1JhbmdlKCk7XHJcbiAgICAgICAgdmFyIGlzRGlzY3JldGUgPSByYW5nZS5heGlzVHlwZSA9PT0gRElTQ1JFVEU7XHJcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSByYW5nZS5jYXRlZ29yaWVzO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1pblZpc2libGU6IGlzRGlzY3JldGUgPyByYW5nZS5taW5WaXNpYmxlIHx8IGNhdGVnb3JpZXNbMF0gOiByYW5nZS5taW5WaXNpYmxlLFxyXG4gICAgICAgICAgICBtYXhWaXNpYmxlOiBpc0Rpc2NyZXRlID8gcmFuZ2UubWF4VmlzaWJsZSB8fCBjYXRlZ29yaWVzW2NhdGVnb3JpZXMubGVuZ3RoIC0gMV0gOiByYW5nZS5tYXhWaXNpYmxlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9jaGFuZ2VfRlVMTF9SRU5ERVIoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jaGFuZ2VzLmhhcyhWSVNVQUxfUkFOR0UpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JhaXNlWm9vbUVuZEhhbmRsZXJzKClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2dldEF4ZXNGb3JTY2FsaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy5nZXRBcmd1bWVudEF4aXMoKV0uY29uY2F0KHRoaXMuX3ZhbHVlQXhlcylcclxuICAgIH0sXHJcbiAgICBfYXBwbHlWaXN1YWxSYW5nZUJ5VmlydHVhbEF4ZXMoYXhpcywgcmFuZ2UpIHtcclxuICAgICAgICBpZiAoYXhpcy5pc0FyZ3VtZW50QXhpcykge1xyXG4gICAgICAgICAgICBpZiAoYXhpcyAhPT0gdGhpcy5nZXRBcmd1bWVudEF4aXMoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hcmd1bWVudEF4ZXMuZmlsdGVyKGEgPT4gYSAhPT0gYXhpcykuZm9yRWFjaChhID0+IGEudmlzdWFsUmFuZ2UocmFuZ2UsIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZW5kOiB0cnVlXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0sXHJcbiAgICBfcmFpc2Vab29tRW5kSGFuZGxlcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fYXJndW1lbnRBeGVzLmZvckVhY2goYXhpcyA9PiBheGlzLmhhbmRsZVpvb21FbmQoKSk7XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZSgpXHJcbiAgICB9LFxyXG4gICAgX3NldE9wdGlvbnNCeVJlZmVyZW5jZSgpIHtcclxuICAgICAgICB0aGlzLmNhbGxCYXNlKCk7XHJcbiAgICAgICAgX2V4dGVuZCh0aGlzLl9vcHRpb25zQnlSZWZlcmVuY2UsIHtcclxuICAgICAgICAgICAgXCJhcmd1bWVudEF4aXMudmlzdWFsUmFuZ2VcIjogdHJ1ZVxyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgb3B0aW9uKCkge1xyXG4gICAgICAgIHZhciBvcHRpb24gPSB0aGlzLmNhbGxCYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdmFyIHZhbHVlQXhpcyA9IHRoaXMuX29wdGlvbnMuc2lsZW50KFwidmFsdWVBeGlzXCIpO1xyXG4gICAgICAgIGlmIChcImFycmF5XCIgPT09IHR5cGUodmFsdWVBeGlzKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlQXhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvblBhdGggPSBcInZhbHVlQXhpc1tcIi5jb25jYXQoaSwgXCJdLnZpc3VhbFJhbmdlXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9uc0J5UmVmZXJlbmNlW29wdGlvblBhdGhdID0gdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb25cclxuICAgIH0sXHJcbiAgICBfbm90aWZ5VmlzdWFsUmFuZ2UoKSB7XHJcbiAgICAgICAgdmFyIGFyZ0F4aXMgPSB0aGlzLl9hcmd1bWVudEF4ZXNbMF07XHJcbiAgICAgICAgdmFyIGFyZ3VtZW50VmlzdWFsUmFuZ2UgPSBjb252ZXJ0VmlzdWFsUmFuZ2VPYmplY3QoYXJnQXhpcy52aXN1YWxSYW5nZSgpLCAhX2lzQXJyYXkodGhpcy5vcHRpb24oXCJhcmd1bWVudEF4aXMudmlzdWFsUmFuZ2VcIikpKTtcclxuICAgICAgICBpZiAoIWFyZ0F4aXMuc2tpcEV2ZW50UmlzaW5nIHx8ICFyYW5nZXNBcmVFcXVhbChhcmd1bWVudFZpc3VhbFJhbmdlLCB0aGlzLm9wdGlvbihcImFyZ3VtZW50QXhpcy52aXN1YWxSYW5nZVwiKSkpIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb24oXCJhcmd1bWVudEF4aXMudmlzdWFsUmFuZ2VcIiwgYXJndW1lbnRWaXN1YWxSYW5nZSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhcmdBeGlzLnNraXBFdmVudFJpc2luZyA9IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZSgpXHJcbiAgICB9XHJcbn0pO1xyXG5pbXBvcnQgc2h1dHRlclpvb20gZnJvbSBcIi4vY2hhcnRfY29tcG9uZW50cy9zaHV0dGVyX3pvb21cIjtcclxuaW1wb3J0IHpvb21BbmRQYW4gZnJvbSBcIi4vY2hhcnRfY29tcG9uZW50cy96b29tX2FuZF9wYW5cIjtcclxuaW1wb3J0IHtcclxuICAgIHBsdWdpbnNcclxufSBmcm9tIFwiLi9jb3JlL2Fubm90YXRpb25zXCI7XHJcbmR4Q2hhcnQuYWRkUGx1Z2luKHNodXR0ZXJab29tKTtcclxuZHhDaGFydC5hZGRQbHVnaW4oem9vbUFuZFBhbik7XHJcbmR4Q2hhcnQuYWRkUGx1Z2luKHBsdWdpbnMuY29yZSk7XHJcbmR4Q2hhcnQuYWRkUGx1Z2luKHBsdWdpbnMuY2hhcnQpO1xyXG5yZWdpc3RlckNvbXBvbmVudChcImR4Q2hhcnRcIiwgZHhDaGFydCk7XHJcbmV4cG9ydCBkZWZhdWx0IGR4Q2hhcnQ7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/chart.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/chart_components/advanced_chart.js":
/*!****************************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/chart_components/advanced_chart.js ***!
  \****************************************************************************/
/*! exports provided: AdvancedChart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AdvancedChart\", function() { return AdvancedChart; });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _core_utils_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/utils/array */ \"./node_modules/devextreme/esm/core/utils/array.js\");\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/* harmony import */ var _translators_range__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../translators/range */ \"./node_modules/devextreme/esm/viz/translators/range.js\");\n/* harmony import */ var _axes_base_axis__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../axes/base_axis */ \"./node_modules/devextreme/esm/viz/axes/base_axis.js\");\n/* harmony import */ var _core_series_family__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/series_family */ \"./node_modules/devextreme/esm/viz/core/series_family.js\");\n/* harmony import */ var _base_chart__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base_chart */ \"./node_modules/devextreme/esm/viz/chart_components/base_chart.js\");\n/* harmony import */ var _series_helpers_range_data_calculator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../series/helpers/range_data_calculator */ \"./node_modules/devextreme/esm/viz/series/helpers/range_data_calculator.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/utils/common */ \"./node_modules/devextreme/esm/core/utils/common.js\");\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/**\r\n * DevExtreme (esm/viz/chart_components/advanced_chart.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar _isArray = Array.isArray;\r\nvar DEFAULT_AXIS_NAME = \"defaultAxisName\";\r\nvar FONT = \"font\";\r\nvar COMMON_AXIS_SETTINGS = \"commonAxisSettings\";\r\nvar DEFAULT_PANE_NAME = \"default\";\r\nvar VISUAL_RANGE = \"VISUAL_RANGE\";\r\n\r\nfunction prepareAxis(axisOptions) {\r\n    return _isArray(axisOptions) ? 0 === axisOptions.length ? [{}] : axisOptions : [axisOptions]\r\n}\r\n\r\nfunction processBubbleMargin(opt, bubbleSize) {\r\n    if (opt.processBubbleSize) {\r\n        opt.size = bubbleSize\r\n    }\r\n    return opt\r\n}\r\n\r\nfunction estimateBubbleSize(size, panesCount, maxSize, rotated) {\r\n    var width = rotated ? size.width / panesCount : size.width;\r\n    var height = rotated ? size.height : size.height / panesCount;\r\n    return Math.min(width, height) * maxSize\r\n}\r\n\r\nfunction setAxisVisualRangeByOption(arg, axis, isDirectOption, index) {\r\n    var options;\r\n    var visualRange;\r\n    if (isDirectOption) {\r\n        visualRange = arg.value;\r\n        options = {\r\n            skipEventRising: true\r\n        };\r\n        var wrappedVisualRange = wrapVisualRange(arg.fullName, visualRange);\r\n        if (wrappedVisualRange) {\r\n            options = {\r\n                allowPartialUpdate: true\r\n            };\r\n            visualRange = wrappedVisualRange\r\n        }\r\n    } else {\r\n        visualRange = (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(index) ? arg.value[index] : arg.value).visualRange\r\n    }\r\n    axis.visualRange(visualRange, options)\r\n}\r\n\r\nfunction getAxisTypes(groupsData, axis, isArgumentAxes) {\r\n    if (isArgumentAxes) {\r\n        return {\r\n            argumentAxisType: groupsData.argumentAxisType,\r\n            argumentType: groupsData.argumentType\r\n        }\r\n    }\r\n    var {\r\n        valueAxisType: valueAxisType,\r\n        valueType: valueType\r\n    } = groupsData.groups.filter(g => g.valueAxis === axis)[0];\r\n    return {\r\n        valueAxisType: valueAxisType,\r\n        valueType: valueType\r\n    }\r\n}\r\n\r\nfunction wrapVisualRange(fullName, value) {\r\n    var pathElements = fullName.split(\".\");\r\n    var destElem = pathElements[pathElements.length - 1];\r\n    if (\"endValue\" === destElem || \"startValue\" === destElem) {\r\n        return {\r\n            [destElem]: value\r\n        }\r\n    }\r\n}\r\nvar AdvancedChart = _base_chart__WEBPACK_IMPORTED_MODULE_7__[\"BaseChart\"].inherit({\r\n    _fontFields: [COMMON_AXIS_SETTINGS + \".label.\" + FONT, COMMON_AXIS_SETTINGS + \".title.\" + FONT],\r\n    _partialOptionChangesMap: {\r\n        visualRange: VISUAL_RANGE,\r\n        _customVisualRange: VISUAL_RANGE,\r\n        strips: \"REFRESH_AXES\",\r\n        constantLines: \"REFRESH_AXES\"\r\n    },\r\n    _partialOptionChangesPath: {\r\n        argumentAxis: [\"strips\", \"constantLines\", \"visualRange\", \"_customVisualRange\"],\r\n        valueAxis: [\"strips\", \"constantLines\", \"visualRange\", \"_customVisualRange\"]\r\n    },\r\n    _initCore() {\r\n        this._panesClipRects = {};\r\n        this.callBase()\r\n    },\r\n    _disposeCore() {\r\n        var disposeObjectsInArray = this._disposeObjectsInArray;\r\n        var panesClipRects = this._panesClipRects;\r\n        this.callBase();\r\n        disposeObjectsInArray.call(panesClipRects, \"fixed\");\r\n        disposeObjectsInArray.call(panesClipRects, \"base\");\r\n        disposeObjectsInArray.call(panesClipRects, \"wide\");\r\n        this._panesClipRects = null;\r\n        this._labelsAxesGroup.linkOff();\r\n        this._labelsAxesGroup.dispose();\r\n        this._labelsAxesGroup = null\r\n    },\r\n    _dispose: function() {\r\n        var disposeObjectsInArray = this._disposeObjectsInArray;\r\n        this.callBase();\r\n        this.panes = null;\r\n        if (this._legend) {\r\n            this._legend.dispose();\r\n            this._legend = null\r\n        }\r\n        disposeObjectsInArray.call(this, \"panesBackground\");\r\n        disposeObjectsInArray.call(this, \"seriesFamilies\");\r\n        this._disposeAxes()\r\n    },\r\n    _createPanes: function() {\r\n        this._cleanPanesClipRects(\"fixed\");\r\n        this._cleanPanesClipRects(\"base\");\r\n        this._cleanPanesClipRects(\"wide\")\r\n    },\r\n    _cleanPanesClipRects(clipArrayName) {\r\n        var clipArray = this._panesClipRects[clipArrayName];\r\n        (clipArray || []).forEach(clipRect => clipRect && clipRect.dispose());\r\n        this._panesClipRects[clipArrayName] = []\r\n    },\r\n    _getElementsClipRectID(paneName) {\r\n        var clipShape = this._panesClipRects.fixed[this._getPaneIndex(paneName)];\r\n        return clipShape && clipShape.id\r\n    },\r\n    _getPaneIndex(paneName) {\r\n        var paneIndex;\r\n        var name = paneName || DEFAULT_PANE_NAME;\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"each\"])(this.panes, (index, pane) => {\r\n            if (pane.name === name) {\r\n                paneIndex = index;\r\n                return false\r\n            }\r\n        });\r\n        return paneIndex\r\n    },\r\n    _updateSize() {\r\n        this.callBase();\r\n        Object(_core_utils__WEBPACK_IMPORTED_MODULE_11__[\"setCanvasValues\"])(this._canvas)\r\n    },\r\n    _reinitAxes: function() {\r\n        this.panes = this._createPanes();\r\n        this._populateAxes();\r\n        this._axesReinitialized = true\r\n    },\r\n    _populateAxes() {\r\n        var that = this;\r\n        var panes = that.panes;\r\n        var rotated = that._isRotated();\r\n        var argumentAxesOptions = prepareAxis(that.option(\"argumentAxis\") || {})[0];\r\n        var valueAxisOption = that.option(\"valueAxis\");\r\n        var valueAxesOptions = prepareAxis(valueAxisOption || {});\r\n        var argumentAxesPopulatedOptions;\r\n        var valueAxesPopulatedOptions = [];\r\n        var axisNames = [];\r\n        var valueAxesCounter = 0;\r\n        var paneWithNonVirtualAxis;\r\n        var crosshairMargins = that._getCrosshairMargins();\r\n        if (rotated) {\r\n            paneWithNonVirtualAxis = \"right\" === argumentAxesOptions.position ? panes[panes.length - 1].name : panes[0].name\r\n        } else {\r\n            paneWithNonVirtualAxis = \"top\" === argumentAxesOptions.position ? panes[0].name : panes[panes.length - 1].name\r\n        }\r\n        argumentAxesPopulatedOptions = Object(_core_utils__WEBPACK_IMPORTED_MODULE_11__[\"map\"])(panes, pane => {\r\n            var virtual = pane.name !== paneWithNonVirtualAxis;\r\n            return that._populateAxesOptions(\"argumentAxis\", argumentAxesOptions, {\r\n                pane: pane.name,\r\n                name: null,\r\n                optionPath: \"argumentAxis\",\r\n                crosshairMargin: rotated ? crosshairMargins.x : crosshairMargins.y\r\n            }, rotated, virtual)\r\n        });\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"each\"])(valueAxesOptions, (priority, axisOptions) => {\r\n            var _axisOptions$panes;\r\n            var axisPanes = [];\r\n            var name = axisOptions.name;\r\n            if (name && -1 !== Object(_core_utils_array__WEBPACK_IMPORTED_MODULE_2__[\"inArray\"])(name, axisNames)) {\r\n                that._incidentOccurred(\"E2102\");\r\n                return\r\n            }\r\n            name && axisNames.push(name);\r\n            if (axisOptions.pane) {\r\n                axisPanes.push(axisOptions.pane)\r\n            }\r\n            if (null !== (_axisOptions$panes = axisOptions.panes) && void 0 !== _axisOptions$panes && _axisOptions$panes.length) {\r\n                axisPanes = axisPanes.concat(axisOptions.panes.slice(0))\r\n            }\r\n            axisPanes = Object(_core_utils__WEBPACK_IMPORTED_MODULE_11__[\"unique\"])(axisPanes);\r\n            if (!axisPanes.length) {\r\n                axisPanes.push(void 0)\r\n            }\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"each\"])(axisPanes, (_, pane) => {\r\n                var optionPath = _isArray(valueAxisOption) ? \"valueAxis[\".concat(priority, \"]\") : \"valueAxis\";\r\n                valueAxesPopulatedOptions.push(that._populateAxesOptions(\"valueAxis\", axisOptions, {\r\n                    name: name || DEFAULT_AXIS_NAME + valueAxesCounter++,\r\n                    pane: pane,\r\n                    priority: priority,\r\n                    optionPath: optionPath,\r\n                    crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x\r\n                }, rotated))\r\n            })\r\n        });\r\n        that._redesignAxes(argumentAxesPopulatedOptions, true, paneWithNonVirtualAxis);\r\n        that._redesignAxes(valueAxesPopulatedOptions, false)\r\n    },\r\n    _redesignAxes(options, isArgumentAxes, paneWithNonVirtualAxis) {\r\n        var that = this;\r\n        var axesBasis = [];\r\n        var axes = isArgumentAxes ? that._argumentAxes : that._valueAxes;\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"each\"])(options, (_, opt) => {\r\n            var curAxes = axes && axes.filter(a => a.name === opt.name && (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(opt.pane) && that.panes.some(p => p.name === a.pane) || a.pane === opt.pane));\r\n            if (curAxes && curAxes.length > 0) {\r\n                Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"each\"])(curAxes, (_, axis) => {\r\n                    var axisTypes = getAxisTypes(that._groupsData, axis, isArgumentAxes);\r\n                    axis.updateOptions(opt);\r\n                    if (isArgumentAxes) {\r\n                        axis.setTypes(axisTypes.argumentAxisType, axisTypes.argumentType, \"argumentType\")\r\n                    } else {\r\n                        axis.setTypes(axisTypes.valueAxisType, axisTypes.valueType, \"valueType\")\r\n                    }\r\n                    axis.validate();\r\n                    axesBasis.push({\r\n                        axis: axis\r\n                    })\r\n                })\r\n            } else {\r\n                axesBasis.push({\r\n                    options: opt\r\n                })\r\n            }\r\n        });\r\n        if (axes) {\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"reverseEach\"])(axes, (index, axis) => {\r\n                if (!axesBasis.some(basis => basis.axis && basis.axis === axis)) {\r\n                    that._disposeAxis(index, isArgumentAxes)\r\n                }\r\n            })\r\n        } else if (isArgumentAxes) {\r\n            axes = that._argumentAxes = []\r\n        } else {\r\n            axes = that._valueAxes = []\r\n        }\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"each\"])(axesBasis, (_, basis) => {\r\n            var axis = basis.axis;\r\n            if (basis.axis && isArgumentAxes) {\r\n                basis.axis.isVirtual = basis.axis.pane !== paneWithNonVirtualAxis\r\n            } else if (basis.options) {\r\n                axis = that._createAxis(isArgumentAxes, basis.options, isArgumentAxes ? basis.options.pane !== paneWithNonVirtualAxis : void 0);\r\n                axes.push(axis)\r\n            }\r\n            axis.applyVisualRangeSetter(that._getVisualRangeSetter())\r\n        })\r\n    },\r\n    _disposeAxis(index, isArgumentAxis) {\r\n        var axes = isArgumentAxis ? this._argumentAxes : this._valueAxes;\r\n        var axis = axes[index];\r\n        if (!axis) {\r\n            return\r\n        }\r\n        axis.dispose();\r\n        axes.splice(index, 1)\r\n    },\r\n    _disposeAxes: function() {\r\n        var disposeObjectsInArray = this._disposeObjectsInArray;\r\n        disposeObjectsInArray.call(this, \"_argumentAxes\");\r\n        disposeObjectsInArray.call(this, \"_valueAxes\")\r\n    },\r\n    _appendAdditionalSeriesGroups: function() {\r\n        this._crosshairCursorGroup.linkAppend();\r\n        this._scrollBar && this._scrollBarGroup.linkAppend()\r\n    },\r\n    _getLegendTargets: function() {\r\n        return (this.series || []).map(s => {\r\n            var item = this._getLegendOptions(s);\r\n            item.legendData.series = s;\r\n            if (!s.getOptions().showInLegend) {\r\n                item.legendData.visible = false\r\n            }\r\n            return item\r\n        })\r\n    },\r\n    _legendItemTextField: \"name\",\r\n    _seriesPopulatedHandlerCore: function() {\r\n        this._processSeriesFamilies();\r\n        this._processValueAxisFormat()\r\n    },\r\n    _renderTrackers: function() {\r\n        var i;\r\n        for (i = 0; i < this.series.length; ++i) {\r\n            this.series[i].drawTrackers()\r\n        }\r\n    },\r\n    _specialProcessSeries: function() {\r\n        this._processSeriesFamilies()\r\n    },\r\n    _processSeriesFamilies: function() {\r\n        var _that$seriesFamilies;\r\n        var that = this;\r\n        var types = [];\r\n        var families = [];\r\n        var paneSeries;\r\n        var themeManager = that._themeManager;\r\n        var negativesAsZeroes = themeManager.getOptions(\"negativesAsZeroes\");\r\n        var negativesAsZeros = themeManager.getOptions(\"negativesAsZeros\");\r\n        var familyOptions = {\r\n            minBubbleSize: themeManager.getOptions(\"minBubbleSize\"),\r\n            maxBubbleSize: themeManager.getOptions(\"maxBubbleSize\"),\r\n            barGroupPadding: themeManager.getOptions(\"barGroupPadding\"),\r\n            barGroupWidth: themeManager.getOptions(\"barGroupWidth\"),\r\n            negativesAsZeroes: Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros\r\n        };\r\n        if (null !== (_that$seriesFamilies = that.seriesFamilies) && void 0 !== _that$seriesFamilies && _that$seriesFamilies.length) {\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"each\"])(that.seriesFamilies, (function(_, family) {\r\n                family.updateOptions(familyOptions);\r\n                family.adjustSeriesValues()\r\n            }));\r\n            return\r\n        }\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"each\"])(that.series, (function(_, item) {\r\n            if (-1 === Object(_core_utils_array__WEBPACK_IMPORTED_MODULE_2__[\"inArray\"])(item.type, types)) {\r\n                types.push(item.type)\r\n            }\r\n        }));\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"each\"])(that._getLayoutTargets(), (function(_, pane) {\r\n            paneSeries = that._getSeriesForPane(pane.name);\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"each\"])(types, (function(_, type) {\r\n                var family = new _core_series_family__WEBPACK_IMPORTED_MODULE_6__[\"SeriesFamily\"]({\r\n                    type: type,\r\n                    pane: pane.name,\r\n                    minBubbleSize: familyOptions.minBubbleSize,\r\n                    maxBubbleSize: familyOptions.maxBubbleSize,\r\n                    barGroupPadding: familyOptions.barGroupPadding,\r\n                    barGroupWidth: familyOptions.barGroupWidth,\r\n                    negativesAsZeroes: familyOptions.negativesAsZeroes,\r\n                    rotated: that._isRotated()\r\n                });\r\n                family.add(paneSeries);\r\n                family.adjustSeriesValues();\r\n                families.push(family)\r\n            }))\r\n        }));\r\n        that.seriesFamilies = families\r\n    },\r\n    _updateSeriesDimensions: function() {\r\n        var i;\r\n        var seriesFamilies = this.seriesFamilies || [];\r\n        for (i = 0; i < seriesFamilies.length; i++) {\r\n            var family = seriesFamilies[i];\r\n            family.updateSeriesValues();\r\n            family.adjustSeriesDimensions()\r\n        }\r\n    },\r\n    _getLegendCallBack: function(series) {\r\n        return this._legend && this._legend.getActionCallback(series)\r\n    },\r\n    _appendAxesGroups: function() {\r\n        this._stripsGroup.linkAppend();\r\n        this._gridGroup.linkAppend();\r\n        this._axesGroup.linkAppend();\r\n        this._labelsAxesGroup.linkAppend();\r\n        this._constantLinesGroup.linkAppend();\r\n        this._stripLabelAxesGroup.linkAppend();\r\n        this._scaleBreaksGroup.linkAppend()\r\n    },\r\n    _populateMarginOptions() {\r\n        var that = this;\r\n        var bubbleSize = estimateBubbleSize(that.getSize(), that.panes.length, that._themeManager.getOptions(\"maxBubbleSize\"), that._isRotated());\r\n        var argumentMarginOptions = {};\r\n        that._valueAxes.forEach(valueAxis => {\r\n            var groupSeries = that.series.filter((function(series) {\r\n                return series.getValueAxis() === valueAxis\r\n            }));\r\n            var marginOptions = {};\r\n            groupSeries.forEach(series => {\r\n                if (series.isVisible()) {\r\n                    var seriesMarginOptions = processBubbleMargin(series.getMarginOptions(), bubbleSize);\r\n                    marginOptions = Object(_core_utils__WEBPACK_IMPORTED_MODULE_11__[\"mergeMarginOptions\"])(marginOptions, seriesMarginOptions);\r\n                    argumentMarginOptions = Object(_core_utils__WEBPACK_IMPORTED_MODULE_11__[\"mergeMarginOptions\"])(argumentMarginOptions, seriesMarginOptions)\r\n                }\r\n            });\r\n            valueAxis.setMarginOptions(marginOptions)\r\n        });\r\n        that._argumentAxes.forEach(a => a.setMarginOptions(argumentMarginOptions))\r\n    },\r\n    _populateBusinessRange(updatedAxis, keepRange) {\r\n        var that = this;\r\n        var rotated = that._isRotated();\r\n        var series = that._getVisibleSeries();\r\n        var argRanges = {};\r\n        var commonArgRange = new _translators_range__WEBPACK_IMPORTED_MODULE_4__[\"Range\"]({\r\n            rotated: !!rotated\r\n        });\r\n        var getPaneName = axis => axis.pane || DEFAULT_PANE_NAME;\r\n        that.panes.forEach(p => argRanges[p.name] = new _translators_range__WEBPACK_IMPORTED_MODULE_4__[\"Range\"]({\r\n            rotated: !!rotated\r\n        }));\r\n        that._valueAxes.forEach(valueAxis => {\r\n            var groupRange = new _translators_range__WEBPACK_IMPORTED_MODULE_4__[\"Range\"]({\r\n                rotated: !!rotated,\r\n                pane: valueAxis.pane,\r\n                axis: valueAxis.name\r\n            });\r\n            var groupSeries = series.filter(series => series.getValueAxis() === valueAxis);\r\n            groupSeries.forEach(series => {\r\n                var seriesRange = series.getRangeData();\r\n                groupRange.addRange(seriesRange.val);\r\n                argRanges[getPaneName(valueAxis)].addRange(seriesRange.arg)\r\n            });\r\n            if (!updatedAxis || updatedAxis && groupSeries.length && valueAxis === updatedAxis) {\r\n                valueAxis.setGroupSeries(groupSeries);\r\n                valueAxis.setBusinessRange(groupRange, that._axesReinitialized || keepRange, that._argumentAxes[0]._lastVisualRangeUpdateMode)\r\n            }\r\n        });\r\n        if (!updatedAxis || updatedAxis && series.length) {\r\n            Object.keys(argRanges).forEach(p => commonArgRange.addRange(argRanges[p]));\r\n            var commonInterval = commonArgRange.interval;\r\n            that._argumentAxes.forEach(a => {\r\n                var _argRanges$getPaneNam;\r\n                var currentInterval = null !== (_argRanges$getPaneNam = argRanges[getPaneName(a)].interval) && void 0 !== _argRanges$getPaneNam ? _argRanges$getPaneNam : commonInterval;\r\n                a.setBusinessRange(new _translators_range__WEBPACK_IMPORTED_MODULE_4__[\"Range\"](Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, commonArgRange, {\r\n                    interval: currentInterval\r\n                })), that._axesReinitialized, void 0, that._groupsData.categories)\r\n            })\r\n        }\r\n        that._populateMarginOptions()\r\n    },\r\n    getArgumentAxis: function() {\r\n        return (this._argumentAxes || []).filter(a => !a.isVirtual)[0]\r\n    },\r\n    getValueAxis: function(name) {\r\n        return (this._valueAxes || []).filter(Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(name) ? a => a.name === name : a => a.pane === this.defaultPane)[0]\r\n    },\r\n    _getGroupsData: function() {\r\n        var that = this;\r\n        var groups = [];\r\n        that._valueAxes.forEach((function(axis) {\r\n            groups.push({\r\n                series: that.series.filter((function(series) {\r\n                    return series.getValueAxis() === axis\r\n                })),\r\n                valueAxis: axis,\r\n                valueOptions: axis.getOptions()\r\n            })\r\n        }));\r\n        return {\r\n            groups: groups,\r\n            argumentAxes: that._argumentAxes,\r\n            argumentOptions: that._argumentAxes[0].getOptions()\r\n        }\r\n    },\r\n    _groupSeries: function() {\r\n        this._correctValueAxes(false);\r\n        this._groupsData = this._getGroupsData()\r\n    },\r\n    _processValueAxisFormat: function() {\r\n        var axesWithFullStackedFormat = [];\r\n        this.series.forEach((function(series) {\r\n            var axis = series.getValueAxis();\r\n            if (series.isFullStackedSeries()) {\r\n                axis.setPercentLabelFormat();\r\n                axesWithFullStackedFormat.push(axis)\r\n            }\r\n        }));\r\n        this._valueAxes.forEach((function(axis) {\r\n            if (-1 === axesWithFullStackedFormat.indexOf(axis)) {\r\n                axis.resetAutoLabelFormat()\r\n            }\r\n        }))\r\n    },\r\n    _populateAxesOptions(typeSelector, userOptions, axisOptions, rotated, virtual) {\r\n        var preparedUserOptions = this._prepareStripsAndConstantLines(typeSelector, userOptions, rotated);\r\n        var options = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])(true, {}, preparedUserOptions, axisOptions, this._prepareAxisOptions(typeSelector, preparedUserOptions, rotated));\r\n        if (virtual) {\r\n            options.visible = options.tick.visible = options.minorTick.visible = options.label.visible = false;\r\n            options.title = {}\r\n        }\r\n        return options\r\n    },\r\n    _getValFilter: series => _series_helpers_range_data_calculator__WEBPACK_IMPORTED_MODULE_8__[\"default\"].getViewPortFilter(series.getValueAxis().visualRange() || {}),\r\n    _createAxis(isArgumentAxes, options, virtual) {\r\n        var that = this;\r\n        var typeSelector = isArgumentAxes ? \"argumentAxis\" : \"valueAxis\";\r\n        var renderingSettings = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])({\r\n            renderer: that._renderer,\r\n            incidentOccurred: that._incidentOccurred,\r\n            eventTrigger: that._eventTrigger,\r\n            axisClass: isArgumentAxes ? \"arg\" : \"val\",\r\n            widgetClass: \"dxc\",\r\n            stripsGroup: that._stripsGroup,\r\n            stripLabelAxesGroup: that._stripLabelAxesGroup,\r\n            constantLinesGroup: that._constantLinesGroup,\r\n            scaleBreaksGroup: that._scaleBreaksGroup,\r\n            axesContainerGroup: that._axesGroup,\r\n            labelsAxesGroup: that._labelsAxesGroup,\r\n            gridGroup: that._gridGroup,\r\n            isArgumentAxis: isArgumentAxes,\r\n            getTemplate: template => that._getTemplate(template)\r\n        }, that._getAxisRenderingOptions(typeSelector));\r\n        var axis = new _axes_base_axis__WEBPACK_IMPORTED_MODULE_5__[\"Axis\"](renderingSettings);\r\n        axis.updateOptions(options);\r\n        axis.isVirtual = virtual;\r\n        return axis\r\n    },\r\n    _applyVisualRangeByVirtualAxes: (axis, range) => false,\r\n    _applyCustomVisualRangeOption(axis, range) {\r\n        if (axis.getOptions().optionPath) {\r\n            this._parseVisualRangeOption(\"\".concat(axis.getOptions().optionPath, \".visualRange\"), range)\r\n        }\r\n    },\r\n    _getVisualRangeSetter() {\r\n        var chart = this;\r\n        return function(axis, _ref) {\r\n            var {\r\n                skipEventRising: skipEventRising,\r\n                range: range\r\n            } = _ref;\r\n            chart._applyCustomVisualRangeOption(axis, range);\r\n            axis.setCustomVisualRange(range);\r\n            axis.skipEventRising = skipEventRising;\r\n            if (!chart._applyVisualRangeByVirtualAxes(axis, range)) {\r\n                if (chart._applyingChanges) {\r\n                    chart._change_VISUAL_RANGE()\r\n                } else {\r\n                    chart._requestChange([VISUAL_RANGE])\r\n                }\r\n            }\r\n        }\r\n    },\r\n    _getTrackerSettings: function() {\r\n        return Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])(this.callBase(), {\r\n            argumentAxis: this.getArgumentAxis()\r\n        })\r\n    },\r\n    _prepareStripsAndConstantLines: function(typeSelector, userOptions, rotated) {\r\n        userOptions = this._themeManager.getOptions(typeSelector, userOptions, rotated);\r\n        if (userOptions.strips) {\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"each\"])(userOptions.strips, (function(i) {\r\n                userOptions.strips[i] = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])(true, {}, userOptions.stripStyle, userOptions.strips[i])\r\n            }))\r\n        }\r\n        if (userOptions.constantLines) {\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_3__[\"each\"])(userOptions.constantLines, (function(i, line) {\r\n                userOptions.constantLines[i] = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])(true, {}, userOptions.constantLineStyle, line)\r\n            }))\r\n        }\r\n        return userOptions\r\n    },\r\n    refresh: function() {\r\n        this._disposeAxes();\r\n        this.callBase()\r\n    },\r\n    _layoutAxes(drawAxes) {\r\n        drawAxes();\r\n        var needSpace = this.checkForMoreSpaceForPanesCanvas();\r\n        if (needSpace) {\r\n            var rect = this._rect.slice();\r\n            var size = this._layout.backward(rect, rect, [needSpace.width, needSpace.height]);\r\n            needSpace.width = Math.max(0, size[0]);\r\n            needSpace.height = Math.max(0, size[1]);\r\n            this._canvas = this._createCanvasFromRect(rect);\r\n            drawAxes(needSpace)\r\n        }\r\n    },\r\n    checkForMoreSpaceForPanesCanvas() {\r\n        return this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), this._isRotated())\r\n    },\r\n    _parseVisualRangeOption(fullName, value) {\r\n        var that = this;\r\n        var name = fullName.split(/[.[]/)[0];\r\n        var index = fullName.match(/\\d+/g);\r\n        index = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(index) ? parseInt(index[0]) : index;\r\n        if (fullName.indexOf(\"visualRange\") > 0) {\r\n            if (\"object\" !== Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"type\"])(value)) {\r\n                value = wrapVisualRange(fullName, value) || value\r\n            }\r\n            that._setCustomVisualRange(name, index, value)\r\n        } else if ((\"object\" === Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"type\"])(value) || _isArray(value)) && name.indexOf(\"Axis\") > 0 && JSON.stringify(value).indexOf(\"visualRange\") > 0) {\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(value.visualRange)) {\r\n                that._setCustomVisualRange(name, index, value.visualRange)\r\n            } else if (_isArray(value)) {\r\n                value.forEach((a, i) => Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(a.visualRange) && that._setCustomVisualRange(name, i, a.visualRange))\r\n            }\r\n        }\r\n    },\r\n    _setCustomVisualRange(axesName, index, value) {\r\n        var options = this._options.silent(axesName);\r\n        if (!options) {\r\n            return\r\n        }\r\n        if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(index)) {\r\n            options._customVisualRange = value\r\n        } else {\r\n            options[index]._customVisualRange = value\r\n        }\r\n        this._axesReinitialized = true\r\n    },\r\n    _raiseZoomEndHandlers() {\r\n        this._valueAxes.forEach(axis => axis.handleZoomEnd())\r\n    },\r\n    _setOptionsByReference() {\r\n        this.callBase();\r\n        Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])(this._optionsByReference, {\r\n            \"valueAxis.visualRange\": true\r\n        })\r\n    },\r\n    _notifyOptionChanged(option, value, previousValue) {\r\n        this.callBase.apply(this, arguments);\r\n        if (!this._optionChangedLocker) {\r\n            this._parseVisualRangeOption(option, value)\r\n        }\r\n    },\r\n    _notifyVisualRange() {\r\n        var that = this;\r\n        that._valueAxes.forEach(axis => {\r\n            var axisPath = axis.getOptions().optionPath;\r\n            if (axisPath) {\r\n                var path = \"\".concat(axisPath, \".visualRange\");\r\n                var visualRange = Object(_core_utils__WEBPACK_IMPORTED_MODULE_11__[\"convertVisualRangeObject\"])(axis.visualRange(), !_isArray(that.option(path)));\r\n                if (!axis.skipEventRising || !Object(_core_utils__WEBPACK_IMPORTED_MODULE_11__[\"rangesAreEqual\"])(visualRange, that.option(path))) {\r\n                    if (!that.option(axisPath) && \"valueAxis\" !== axisPath) {\r\n                        that.option(axisPath, {\r\n                            name: axis.name,\r\n                            visualRange: visualRange\r\n                        })\r\n                    } else {\r\n                        that.option(path, visualRange)\r\n                    }\r\n                } else {\r\n                    axis.skipEventRising = null\r\n                }\r\n            }\r\n        })\r\n    },\r\n    _notify() {\r\n        this.callBase();\r\n        this._axesReinitialized = false;\r\n        if (true !== this.option(\"disableTwoWayBinding\")) {\r\n            this.skipOptionsRollBack = true;\r\n            this._notifyVisualRange();\r\n            this.skipOptionsRollBack = false\r\n        }\r\n    },\r\n    _getAxesForScaling() {\r\n        return this._valueAxes\r\n    },\r\n    _getAxesByOptionPath(arg, isDirectOption, optionName) {\r\n        var sourceAxes = this._getAxesForScaling();\r\n        var axes = [];\r\n        if (isDirectOption) {\r\n            var axisPath;\r\n            if (arg.fullName) {\r\n                axisPath = arg.fullName.slice(0, arg.fullName.indexOf(\".\"))\r\n            }\r\n            axes = sourceAxes.filter(a => a.getOptions().optionPath === axisPath)\r\n        } else if (\"object\" === Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"type\"])(arg.value)) {\r\n            axes = sourceAxes.filter(a => a.getOptions().optionPath === arg.name)\r\n        } else if (_isArray(arg.value)) {\r\n            arg.value.forEach((v, index) => {\r\n                var axis = sourceAxes.filter(a => a.getOptions().optionPath === \"\".concat(arg.name, \"[\").concat(index, \"]\"))[0];\r\n                Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(v[optionName]) && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(axis) && (axes[index] = axis)\r\n            })\r\n        }\r\n        return axes\r\n    },\r\n    _optionChanged(arg) {\r\n        if (!this._optionChangedLocker) {\r\n            var axes;\r\n            var isDirectOption = arg.fullName.indexOf(\"visualRange\") > 0 ? true : this.getPartialChangeOptionsName(arg).indexOf(\"visualRange\") > -1 ? false : void 0;\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_9__[\"isDefined\"])(isDirectOption)) {\r\n                axes = this._getAxesByOptionPath(arg, isDirectOption, \"visualRange\");\r\n                if (axes) {\r\n                    if (axes.length > 1 || _isArray(arg.value)) {\r\n                        axes.forEach((a, index) => setAxisVisualRangeByOption(arg, a, isDirectOption, index))\r\n                    } else if (1 === axes.length) {\r\n                        setAxisVisualRangeByOption(arg, axes[0], isDirectOption)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.callBase(arg)\r\n    },\r\n    _change_VISUAL_RANGE: function() {\r\n        this._recreateSizeDependentObjects(false);\r\n        if (!this._changes.has(\"FULL_RENDER\")) {\r\n            var resizePanesOnZoom = this.option(\"resizePanesOnZoom\");\r\n            this._doRender({\r\n                force: true,\r\n                drawTitle: false,\r\n                drawLegend: false,\r\n                adjustAxes: null !== resizePanesOnZoom && void 0 !== resizePanesOnZoom ? resizePanesOnZoom : this.option(\"adjustAxesOnZoom\") || false,\r\n                animate: false\r\n            });\r\n            this._raiseZoomEndHandlers()\r\n        }\r\n    },\r\n    resetVisualRange() {\r\n        var that = this;\r\n        that._valueAxes.forEach(axis => {\r\n            axis.resetVisualRange(false);\r\n            that._applyCustomVisualRangeOption(axis)\r\n        });\r\n        that._requestChange([VISUAL_RANGE])\r\n    },\r\n    _getCrosshairMargins: () => ({\r\n        x: 0,\r\n        y: 0\r\n    }),\r\n    _legendDataField: \"series\",\r\n    _adjustSeriesLabels: _core_utils_common__WEBPACK_IMPORTED_MODULE_10__[\"noop\"],\r\n    _correctValueAxes: _core_utils_common__WEBPACK_IMPORTED_MODULE_10__[\"noop\"]\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2NoYXJ0X2NvbXBvbmVudHMvYWR2YW5jZWRfY2hhcnQuanM/ZTRlMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwRDtBQUd6QjtBQUdEO0FBSUc7QUFHTDtBQUdIO0FBR0k7QUFHVDtBQUNvRDtBQUkzQztBQUdFO0FBUVY7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsa0VBQVU7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sb0JBQW9CLHFEQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2RUFBd0I7QUFDMUQsOENBQThDLG1FQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdUJBQXVCLDZEQUFJO0FBQ3BDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQVUsbUJBQW1CLGtFQUFVO0FBQ3ZELGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCLHdEQUFLO0FBQzlCLHVCQUF1Qix3REFBSztBQUM1QixDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3Zpei9jaGFydF9jb21wb25lbnRzL2FkdmFuY2VkX2NoYXJ0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS92aXovY2hhcnRfY29tcG9uZW50cy9hZHZhbmNlZF9jaGFydC5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBleHRlbmQgYXMgX2V4dGVuZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2V4dGVuZFwiO1xyXG5pbXBvcnQge1xyXG4gICAgaW5BcnJheVxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2FycmF5XCI7XHJcbmltcG9ydCB7XHJcbiAgICBlYWNoIGFzIF9lYWNoLFxyXG4gICAgcmV2ZXJzZUVhY2ggYXMgX3JldmVyc2VFYWNoXHJcbn0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvaXRlcmF0b3JcIjtcclxuaW1wb3J0IHtcclxuICAgIFJhbmdlXHJcbn0gZnJvbSBcIi4uL3RyYW5zbGF0b3JzL3JhbmdlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBBeGlzXHJcbn0gZnJvbSBcIi4uL2F4ZXMvYmFzZV9heGlzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBTZXJpZXNGYW1pbHlcclxufSBmcm9tIFwiLi4vY29yZS9zZXJpZXNfZmFtaWx5XCI7XHJcbmltcG9ydCB7XHJcbiAgICBCYXNlQ2hhcnRcclxufSBmcm9tIFwiLi9iYXNlX2NoYXJ0XCI7XHJcbmltcG9ydCByYW5nZURhdGFDYWxjdWxhdG9yIGZyb20gXCIuLi9zZXJpZXMvaGVscGVycy9yYW5nZV9kYXRhX2NhbGN1bGF0b3JcIjtcclxuaW1wb3J0IHtcclxuICAgIGlzRGVmaW5lZCBhcyBfaXNEZWZpbmVkLFxyXG4gICAgdHlwZVxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL3R5cGVcIjtcclxuaW1wb3J0IHtcclxuICAgIG5vb3AgYXMgX25vb3BcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9jb21tb25cIjtcclxuaW1wb3J0IHtcclxuICAgIGNvbnZlcnRWaXN1YWxSYW5nZU9iamVjdCxcclxuICAgIHJhbmdlc0FyZUVxdWFsLFxyXG4gICAgbWFwIGFzIF9tYXAsXHJcbiAgICBtZXJnZU1hcmdpbk9wdGlvbnMsXHJcbiAgICBzZXRDYW52YXNWYWx1ZXMsXHJcbiAgICB1bmlxdWVcclxufSBmcm9tIFwiLi4vY29yZS91dGlsc1wiO1xyXG52YXIgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xyXG52YXIgREVGQVVMVF9BWElTX05BTUUgPSBcImRlZmF1bHRBeGlzTmFtZVwiO1xyXG52YXIgRk9OVCA9IFwiZm9udFwiO1xyXG52YXIgQ09NTU9OX0FYSVNfU0VUVElOR1MgPSBcImNvbW1vbkF4aXNTZXR0aW5nc1wiO1xyXG52YXIgREVGQVVMVF9QQU5FX05BTUUgPSBcImRlZmF1bHRcIjtcclxudmFyIFZJU1VBTF9SQU5HRSA9IFwiVklTVUFMX1JBTkdFXCI7XHJcblxyXG5mdW5jdGlvbiBwcmVwYXJlQXhpcyhheGlzT3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9pc0FycmF5KGF4aXNPcHRpb25zKSA/IDAgPT09IGF4aXNPcHRpb25zLmxlbmd0aCA/IFt7fV0gOiBheGlzT3B0aW9ucyA6IFtheGlzT3B0aW9uc11cclxufVxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc0J1YmJsZU1hcmdpbihvcHQsIGJ1YmJsZVNpemUpIHtcclxuICAgIGlmIChvcHQucHJvY2Vzc0J1YmJsZVNpemUpIHtcclxuICAgICAgICBvcHQuc2l6ZSA9IGJ1YmJsZVNpemVcclxuICAgIH1cclxuICAgIHJldHVybiBvcHRcclxufVxyXG5cclxuZnVuY3Rpb24gZXN0aW1hdGVCdWJibGVTaXplKHNpemUsIHBhbmVzQ291bnQsIG1heFNpemUsIHJvdGF0ZWQpIHtcclxuICAgIHZhciB3aWR0aCA9IHJvdGF0ZWQgPyBzaXplLndpZHRoIC8gcGFuZXNDb3VudCA6IHNpemUud2lkdGg7XHJcbiAgICB2YXIgaGVpZ2h0ID0gcm90YXRlZCA/IHNpemUuaGVpZ2h0IDogc2l6ZS5oZWlnaHQgLyBwYW5lc0NvdW50O1xyXG4gICAgcmV0dXJuIE1hdGgubWluKHdpZHRoLCBoZWlnaHQpICogbWF4U2l6ZVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRBeGlzVmlzdWFsUmFuZ2VCeU9wdGlvbihhcmcsIGF4aXMsIGlzRGlyZWN0T3B0aW9uLCBpbmRleCkge1xyXG4gICAgdmFyIG9wdGlvbnM7XHJcbiAgICB2YXIgdmlzdWFsUmFuZ2U7XHJcbiAgICBpZiAoaXNEaXJlY3RPcHRpb24pIHtcclxuICAgICAgICB2aXN1YWxSYW5nZSA9IGFyZy52YWx1ZTtcclxuICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBza2lwRXZlbnRSaXNpbmc6IHRydWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB3cmFwcGVkVmlzdWFsUmFuZ2UgPSB3cmFwVmlzdWFsUmFuZ2UoYXJnLmZ1bGxOYW1lLCB2aXN1YWxSYW5nZSk7XHJcbiAgICAgICAgaWYgKHdyYXBwZWRWaXN1YWxSYW5nZSkge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgYWxsb3dQYXJ0aWFsVXBkYXRlOiB0cnVlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZpc3VhbFJhbmdlID0gd3JhcHBlZFZpc3VhbFJhbmdlXHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2aXN1YWxSYW5nZSA9IChfaXNEZWZpbmVkKGluZGV4KSA/IGFyZy52YWx1ZVtpbmRleF0gOiBhcmcudmFsdWUpLnZpc3VhbFJhbmdlXHJcbiAgICB9XHJcbiAgICBheGlzLnZpc3VhbFJhbmdlKHZpc3VhbFJhbmdlLCBvcHRpb25zKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRBeGlzVHlwZXMoZ3JvdXBzRGF0YSwgYXhpcywgaXNBcmd1bWVudEF4ZXMpIHtcclxuICAgIGlmIChpc0FyZ3VtZW50QXhlcykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGFyZ3VtZW50QXhpc1R5cGU6IGdyb3Vwc0RhdGEuYXJndW1lbnRBeGlzVHlwZSxcclxuICAgICAgICAgICAgYXJndW1lbnRUeXBlOiBncm91cHNEYXRhLmFyZ3VtZW50VHlwZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciB7XHJcbiAgICAgICAgdmFsdWVBeGlzVHlwZTogdmFsdWVBeGlzVHlwZSxcclxuICAgICAgICB2YWx1ZVR5cGU6IHZhbHVlVHlwZVxyXG4gICAgfSA9IGdyb3Vwc0RhdGEuZ3JvdXBzLmZpbHRlcihnID0+IGcudmFsdWVBeGlzID09PSBheGlzKVswXTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsdWVBeGlzVHlwZTogdmFsdWVBeGlzVHlwZSxcclxuICAgICAgICB2YWx1ZVR5cGU6IHZhbHVlVHlwZVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB3cmFwVmlzdWFsUmFuZ2UoZnVsbE5hbWUsIHZhbHVlKSB7XHJcbiAgICB2YXIgcGF0aEVsZW1lbnRzID0gZnVsbE5hbWUuc3BsaXQoXCIuXCIpO1xyXG4gICAgdmFyIGRlc3RFbGVtID0gcGF0aEVsZW1lbnRzW3BhdGhFbGVtZW50cy5sZW5ndGggLSAxXTtcclxuICAgIGlmIChcImVuZFZhbHVlXCIgPT09IGRlc3RFbGVtIHx8IFwic3RhcnRWYWx1ZVwiID09PSBkZXN0RWxlbSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFtkZXN0RWxlbV06IHZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCB2YXIgQWR2YW5jZWRDaGFydCA9IEJhc2VDaGFydC5pbmhlcml0KHtcclxuICAgIF9mb250RmllbGRzOiBbQ09NTU9OX0FYSVNfU0VUVElOR1MgKyBcIi5sYWJlbC5cIiArIEZPTlQsIENPTU1PTl9BWElTX1NFVFRJTkdTICsgXCIudGl0bGUuXCIgKyBGT05UXSxcclxuICAgIF9wYXJ0aWFsT3B0aW9uQ2hhbmdlc01hcDoge1xyXG4gICAgICAgIHZpc3VhbFJhbmdlOiBWSVNVQUxfUkFOR0UsXHJcbiAgICAgICAgX2N1c3RvbVZpc3VhbFJhbmdlOiBWSVNVQUxfUkFOR0UsXHJcbiAgICAgICAgc3RyaXBzOiBcIlJFRlJFU0hfQVhFU1wiLFxyXG4gICAgICAgIGNvbnN0YW50TGluZXM6IFwiUkVGUkVTSF9BWEVTXCJcclxuICAgIH0sXHJcbiAgICBfcGFydGlhbE9wdGlvbkNoYW5nZXNQYXRoOiB7XHJcbiAgICAgICAgYXJndW1lbnRBeGlzOiBbXCJzdHJpcHNcIiwgXCJjb25zdGFudExpbmVzXCIsIFwidmlzdWFsUmFuZ2VcIiwgXCJfY3VzdG9tVmlzdWFsUmFuZ2VcIl0sXHJcbiAgICAgICAgdmFsdWVBeGlzOiBbXCJzdHJpcHNcIiwgXCJjb25zdGFudExpbmVzXCIsIFwidmlzdWFsUmFuZ2VcIiwgXCJfY3VzdG9tVmlzdWFsUmFuZ2VcIl1cclxuICAgIH0sXHJcbiAgICBfaW5pdENvcmUoKSB7XHJcbiAgICAgICAgdGhpcy5fcGFuZXNDbGlwUmVjdHMgPSB7fTtcclxuICAgICAgICB0aGlzLmNhbGxCYXNlKClcclxuICAgIH0sXHJcbiAgICBfZGlzcG9zZUNvcmUoKSB7XHJcbiAgICAgICAgdmFyIGRpc3Bvc2VPYmplY3RzSW5BcnJheSA9IHRoaXMuX2Rpc3Bvc2VPYmplY3RzSW5BcnJheTtcclxuICAgICAgICB2YXIgcGFuZXNDbGlwUmVjdHMgPSB0aGlzLl9wYW5lc0NsaXBSZWN0cztcclxuICAgICAgICB0aGlzLmNhbGxCYXNlKCk7XHJcbiAgICAgICAgZGlzcG9zZU9iamVjdHNJbkFycmF5LmNhbGwocGFuZXNDbGlwUmVjdHMsIFwiZml4ZWRcIik7XHJcbiAgICAgICAgZGlzcG9zZU9iamVjdHNJbkFycmF5LmNhbGwocGFuZXNDbGlwUmVjdHMsIFwiYmFzZVwiKTtcclxuICAgICAgICBkaXNwb3NlT2JqZWN0c0luQXJyYXkuY2FsbChwYW5lc0NsaXBSZWN0cywgXCJ3aWRlXCIpO1xyXG4gICAgICAgIHRoaXMuX3BhbmVzQ2xpcFJlY3RzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9sYWJlbHNBeGVzR3JvdXAubGlua09mZigpO1xyXG4gICAgICAgIHRoaXMuX2xhYmVsc0F4ZXNHcm91cC5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5fbGFiZWxzQXhlc0dyb3VwID0gbnVsbFxyXG4gICAgfSxcclxuICAgIF9kaXNwb3NlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZGlzcG9zZU9iamVjdHNJbkFycmF5ID0gdGhpcy5fZGlzcG9zZU9iamVjdHNJbkFycmF5O1xyXG4gICAgICAgIHRoaXMuY2FsbEJhc2UoKTtcclxuICAgICAgICB0aGlzLnBhbmVzID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5fbGVnZW5kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlZ2VuZC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlZ2VuZCA9IG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzcG9zZU9iamVjdHNJbkFycmF5LmNhbGwodGhpcywgXCJwYW5lc0JhY2tncm91bmRcIik7XHJcbiAgICAgICAgZGlzcG9zZU9iamVjdHNJbkFycmF5LmNhbGwodGhpcywgXCJzZXJpZXNGYW1pbGllc1wiKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlQXhlcygpXHJcbiAgICB9LFxyXG4gICAgX2NyZWF0ZVBhbmVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9jbGVhblBhbmVzQ2xpcFJlY3RzKFwiZml4ZWRcIik7XHJcbiAgICAgICAgdGhpcy5fY2xlYW5QYW5lc0NsaXBSZWN0cyhcImJhc2VcIik7XHJcbiAgICAgICAgdGhpcy5fY2xlYW5QYW5lc0NsaXBSZWN0cyhcIndpZGVcIilcclxuICAgIH0sXHJcbiAgICBfY2xlYW5QYW5lc0NsaXBSZWN0cyhjbGlwQXJyYXlOYW1lKSB7XHJcbiAgICAgICAgdmFyIGNsaXBBcnJheSA9IHRoaXMuX3BhbmVzQ2xpcFJlY3RzW2NsaXBBcnJheU5hbWVdO1xyXG4gICAgICAgIChjbGlwQXJyYXkgfHwgW10pLmZvckVhY2goY2xpcFJlY3QgPT4gY2xpcFJlY3QgJiYgY2xpcFJlY3QuZGlzcG9zZSgpKTtcclxuICAgICAgICB0aGlzLl9wYW5lc0NsaXBSZWN0c1tjbGlwQXJyYXlOYW1lXSA9IFtdXHJcbiAgICB9LFxyXG4gICAgX2dldEVsZW1lbnRzQ2xpcFJlY3RJRChwYW5lTmFtZSkge1xyXG4gICAgICAgIHZhciBjbGlwU2hhcGUgPSB0aGlzLl9wYW5lc0NsaXBSZWN0cy5maXhlZFt0aGlzLl9nZXRQYW5lSW5kZXgocGFuZU5hbWUpXTtcclxuICAgICAgICByZXR1cm4gY2xpcFNoYXBlICYmIGNsaXBTaGFwZS5pZFxyXG4gICAgfSxcclxuICAgIF9nZXRQYW5lSW5kZXgocGFuZU5hbWUpIHtcclxuICAgICAgICB2YXIgcGFuZUluZGV4O1xyXG4gICAgICAgIHZhciBuYW1lID0gcGFuZU5hbWUgfHwgREVGQVVMVF9QQU5FX05BTUU7XHJcbiAgICAgICAgX2VhY2godGhpcy5wYW5lcywgKGluZGV4LCBwYW5lKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwYW5lLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHBhbmVJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGFuZUluZGV4XHJcbiAgICB9LFxyXG4gICAgX3VwZGF0ZVNpemUoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZSgpO1xyXG4gICAgICAgIHNldENhbnZhc1ZhbHVlcyh0aGlzLl9jYW52YXMpXHJcbiAgICB9LFxyXG4gICAgX3JlaW5pdEF4ZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMucGFuZXMgPSB0aGlzLl9jcmVhdGVQYW5lcygpO1xyXG4gICAgICAgIHRoaXMuX3BvcHVsYXRlQXhlcygpO1xyXG4gICAgICAgIHRoaXMuX2F4ZXNSZWluaXRpYWxpemVkID0gdHJ1ZVxyXG4gICAgfSxcclxuICAgIF9wb3B1bGF0ZUF4ZXMoKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwYW5lcyA9IHRoYXQucGFuZXM7XHJcbiAgICAgICAgdmFyIHJvdGF0ZWQgPSB0aGF0Ll9pc1JvdGF0ZWQoKTtcclxuICAgICAgICB2YXIgYXJndW1lbnRBeGVzT3B0aW9ucyA9IHByZXBhcmVBeGlzKHRoYXQub3B0aW9uKFwiYXJndW1lbnRBeGlzXCIpIHx8IHt9KVswXTtcclxuICAgICAgICB2YXIgdmFsdWVBeGlzT3B0aW9uID0gdGhhdC5vcHRpb24oXCJ2YWx1ZUF4aXNcIik7XHJcbiAgICAgICAgdmFyIHZhbHVlQXhlc09wdGlvbnMgPSBwcmVwYXJlQXhpcyh2YWx1ZUF4aXNPcHRpb24gfHwge30pO1xyXG4gICAgICAgIHZhciBhcmd1bWVudEF4ZXNQb3B1bGF0ZWRPcHRpb25zO1xyXG4gICAgICAgIHZhciB2YWx1ZUF4ZXNQb3B1bGF0ZWRPcHRpb25zID0gW107XHJcbiAgICAgICAgdmFyIGF4aXNOYW1lcyA9IFtdO1xyXG4gICAgICAgIHZhciB2YWx1ZUF4ZXNDb3VudGVyID0gMDtcclxuICAgICAgICB2YXIgcGFuZVdpdGhOb25WaXJ0dWFsQXhpcztcclxuICAgICAgICB2YXIgY3Jvc3NoYWlyTWFyZ2lucyA9IHRoYXQuX2dldENyb3NzaGFpck1hcmdpbnMoKTtcclxuICAgICAgICBpZiAocm90YXRlZCkge1xyXG4gICAgICAgICAgICBwYW5lV2l0aE5vblZpcnR1YWxBeGlzID0gXCJyaWdodFwiID09PSBhcmd1bWVudEF4ZXNPcHRpb25zLnBvc2l0aW9uID8gcGFuZXNbcGFuZXMubGVuZ3RoIC0gMV0ubmFtZSA6IHBhbmVzWzBdLm5hbWVcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwYW5lV2l0aE5vblZpcnR1YWxBeGlzID0gXCJ0b3BcIiA9PT0gYXJndW1lbnRBeGVzT3B0aW9ucy5wb3NpdGlvbiA/IHBhbmVzWzBdLm5hbWUgOiBwYW5lc1twYW5lcy5sZW5ndGggLSAxXS5uYW1lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFyZ3VtZW50QXhlc1BvcHVsYXRlZE9wdGlvbnMgPSBfbWFwKHBhbmVzLCBwYW5lID0+IHtcclxuICAgICAgICAgICAgdmFyIHZpcnR1YWwgPSBwYW5lLm5hbWUgIT09IHBhbmVXaXRoTm9uVmlydHVhbEF4aXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGF0Ll9wb3B1bGF0ZUF4ZXNPcHRpb25zKFwiYXJndW1lbnRBeGlzXCIsIGFyZ3VtZW50QXhlc09wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgIHBhbmU6IHBhbmUubmFtZSxcclxuICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25QYXRoOiBcImFyZ3VtZW50QXhpc1wiLFxyXG4gICAgICAgICAgICAgICAgY3Jvc3NoYWlyTWFyZ2luOiByb3RhdGVkID8gY3Jvc3NoYWlyTWFyZ2lucy54IDogY3Jvc3NoYWlyTWFyZ2lucy55XHJcbiAgICAgICAgICAgIH0sIHJvdGF0ZWQsIHZpcnR1YWwpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgX2VhY2godmFsdWVBeGVzT3B0aW9ucywgKHByaW9yaXR5LCBheGlzT3B0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2F4aXNPcHRpb25zJHBhbmVzO1xyXG4gICAgICAgICAgICB2YXIgYXhpc1BhbmVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gYXhpc09wdGlvbnMubmFtZTtcclxuICAgICAgICAgICAgaWYgKG5hbWUgJiYgLTEgIT09IGluQXJyYXkobmFtZSwgYXhpc05hbWVzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5faW5jaWRlbnRPY2N1cnJlZChcIkUyMTAyXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmFtZSAmJiBheGlzTmFtZXMucHVzaChuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGF4aXNPcHRpb25zLnBhbmUpIHtcclxuICAgICAgICAgICAgICAgIGF4aXNQYW5lcy5wdXNoKGF4aXNPcHRpb25zLnBhbmUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG51bGwgIT09IChfYXhpc09wdGlvbnMkcGFuZXMgPSBheGlzT3B0aW9ucy5wYW5lcykgJiYgdm9pZCAwICE9PSBfYXhpc09wdGlvbnMkcGFuZXMgJiYgX2F4aXNPcHRpb25zJHBhbmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgYXhpc1BhbmVzID0gYXhpc1BhbmVzLmNvbmNhdChheGlzT3B0aW9ucy5wYW5lcy5zbGljZSgwKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBheGlzUGFuZXMgPSB1bmlxdWUoYXhpc1BhbmVzKTtcclxuICAgICAgICAgICAgaWYgKCFheGlzUGFuZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBheGlzUGFuZXMucHVzaCh2b2lkIDApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX2VhY2goYXhpc1BhbmVzLCAoXywgcGFuZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvblBhdGggPSBfaXNBcnJheSh2YWx1ZUF4aXNPcHRpb24pID8gXCJ2YWx1ZUF4aXNbXCIuY29uY2F0KHByaW9yaXR5LCBcIl1cIikgOiBcInZhbHVlQXhpc1wiO1xyXG4gICAgICAgICAgICAgICAgdmFsdWVBeGVzUG9wdWxhdGVkT3B0aW9ucy5wdXNoKHRoYXQuX3BvcHVsYXRlQXhlc09wdGlvbnMoXCJ2YWx1ZUF4aXNcIiwgYXhpc09wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lIHx8IERFRkFVTFRfQVhJU19OQU1FICsgdmFsdWVBeGVzQ291bnRlcisrLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhbmU6IHBhbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvblBhdGg6IG9wdGlvblBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgY3Jvc3NoYWlyTWFyZ2luOiByb3RhdGVkID8gY3Jvc3NoYWlyTWFyZ2lucy55IDogY3Jvc3NoYWlyTWFyZ2lucy54XHJcbiAgICAgICAgICAgICAgICB9LCByb3RhdGVkKSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGF0Ll9yZWRlc2lnbkF4ZXMoYXJndW1lbnRBeGVzUG9wdWxhdGVkT3B0aW9ucywgdHJ1ZSwgcGFuZVdpdGhOb25WaXJ0dWFsQXhpcyk7XHJcbiAgICAgICAgdGhhdC5fcmVkZXNpZ25BeGVzKHZhbHVlQXhlc1BvcHVsYXRlZE9wdGlvbnMsIGZhbHNlKVxyXG4gICAgfSxcclxuICAgIF9yZWRlc2lnbkF4ZXMob3B0aW9ucywgaXNBcmd1bWVudEF4ZXMsIHBhbmVXaXRoTm9uVmlydHVhbEF4aXMpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGF4ZXNCYXNpcyA9IFtdO1xyXG4gICAgICAgIHZhciBheGVzID0gaXNBcmd1bWVudEF4ZXMgPyB0aGF0Ll9hcmd1bWVudEF4ZXMgOiB0aGF0Ll92YWx1ZUF4ZXM7XHJcbiAgICAgICAgX2VhY2gob3B0aW9ucywgKF8sIG9wdCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgY3VyQXhlcyA9IGF4ZXMgJiYgYXhlcy5maWx0ZXIoYSA9PiBhLm5hbWUgPT09IG9wdC5uYW1lICYmICghX2lzRGVmaW5lZChvcHQucGFuZSkgJiYgdGhhdC5wYW5lcy5zb21lKHAgPT4gcC5uYW1lID09PSBhLnBhbmUpIHx8IGEucGFuZSA9PT0gb3B0LnBhbmUpKTtcclxuICAgICAgICAgICAgaWYgKGN1ckF4ZXMgJiYgY3VyQXhlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBfZWFjaChjdXJBeGVzLCAoXywgYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzVHlwZXMgPSBnZXRBeGlzVHlwZXModGhhdC5fZ3JvdXBzRGF0YSwgYXhpcywgaXNBcmd1bWVudEF4ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMudXBkYXRlT3B0aW9ucyhvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FyZ3VtZW50QXhlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzLnNldFR5cGVzKGF4aXNUeXBlcy5hcmd1bWVudEF4aXNUeXBlLCBheGlzVHlwZXMuYXJndW1lbnRUeXBlLCBcImFyZ3VtZW50VHlwZVwiKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMuc2V0VHlwZXMoYXhpc1R5cGVzLnZhbHVlQXhpc1R5cGUsIGF4aXNUeXBlcy52YWx1ZVR5cGUsIFwidmFsdWVUeXBlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMudmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBheGVzQmFzaXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXM6IGF4aXNcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGF4ZXNCYXNpcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoYXhlcykge1xyXG4gICAgICAgICAgICBfcmV2ZXJzZUVhY2goYXhlcywgKGluZGV4LCBheGlzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWF4ZXNCYXNpcy5zb21lKGJhc2lzID0+IGJhc2lzLmF4aXMgJiYgYmFzaXMuYXhpcyA9PT0gYXhpcykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9kaXNwb3NlQXhpcyhpbmRleCwgaXNBcmd1bWVudEF4ZXMpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0FyZ3VtZW50QXhlcykge1xyXG4gICAgICAgICAgICBheGVzID0gdGhhdC5fYXJndW1lbnRBeGVzID0gW11cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBheGVzID0gdGhhdC5fdmFsdWVBeGVzID0gW11cclxuICAgICAgICB9XHJcbiAgICAgICAgX2VhY2goYXhlc0Jhc2lzLCAoXywgYmFzaXMpID0+IHtcclxuICAgICAgICAgICAgdmFyIGF4aXMgPSBiYXNpcy5heGlzO1xyXG4gICAgICAgICAgICBpZiAoYmFzaXMuYXhpcyAmJiBpc0FyZ3VtZW50QXhlcykge1xyXG4gICAgICAgICAgICAgICAgYmFzaXMuYXhpcy5pc1ZpcnR1YWwgPSBiYXNpcy5heGlzLnBhbmUgIT09IHBhbmVXaXRoTm9uVmlydHVhbEF4aXNcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNpcy5vcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBheGlzID0gdGhhdC5fY3JlYXRlQXhpcyhpc0FyZ3VtZW50QXhlcywgYmFzaXMub3B0aW9ucywgaXNBcmd1bWVudEF4ZXMgPyBiYXNpcy5vcHRpb25zLnBhbmUgIT09IHBhbmVXaXRoTm9uVmlydHVhbEF4aXMgOiB2b2lkIDApO1xyXG4gICAgICAgICAgICAgICAgYXhlcy5wdXNoKGF4aXMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXhpcy5hcHBseVZpc3VhbFJhbmdlU2V0dGVyKHRoYXQuX2dldFZpc3VhbFJhbmdlU2V0dGVyKCkpXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBfZGlzcG9zZUF4aXMoaW5kZXgsIGlzQXJndW1lbnRBeGlzKSB7XHJcbiAgICAgICAgdmFyIGF4ZXMgPSBpc0FyZ3VtZW50QXhpcyA/IHRoaXMuX2FyZ3VtZW50QXhlcyA6IHRoaXMuX3ZhbHVlQXhlcztcclxuICAgICAgICB2YXIgYXhpcyA9IGF4ZXNbaW5kZXhdO1xyXG4gICAgICAgIGlmICghYXhpcykge1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgYXhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgYXhlcy5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICB9LFxyXG4gICAgX2Rpc3Bvc2VBeGVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZGlzcG9zZU9iamVjdHNJbkFycmF5ID0gdGhpcy5fZGlzcG9zZU9iamVjdHNJbkFycmF5O1xyXG4gICAgICAgIGRpc3Bvc2VPYmplY3RzSW5BcnJheS5jYWxsKHRoaXMsIFwiX2FyZ3VtZW50QXhlc1wiKTtcclxuICAgICAgICBkaXNwb3NlT2JqZWN0c0luQXJyYXkuY2FsbCh0aGlzLCBcIl92YWx1ZUF4ZXNcIilcclxuICAgIH0sXHJcbiAgICBfYXBwZW5kQWRkaXRpb25hbFNlcmllc0dyb3VwczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fY3Jvc3NoYWlyQ3Vyc29yR3JvdXAubGlua0FwcGVuZCgpO1xyXG4gICAgICAgIHRoaXMuX3Njcm9sbEJhciAmJiB0aGlzLl9zY3JvbGxCYXJHcm91cC5saW5rQXBwZW5kKClcclxuICAgIH0sXHJcbiAgICBfZ2V0TGVnZW5kVGFyZ2V0czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnNlcmllcyB8fCBbXSkubWFwKHMgPT4ge1xyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2dldExlZ2VuZE9wdGlvbnMocyk7XHJcbiAgICAgICAgICAgIGl0ZW0ubGVnZW5kRGF0YS5zZXJpZXMgPSBzO1xyXG4gICAgICAgICAgICBpZiAoIXMuZ2V0T3B0aW9ucygpLnNob3dJbkxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5sZWdlbmREYXRhLnZpc2libGUgPSBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBfbGVnZW5kSXRlbVRleHRGaWVsZDogXCJuYW1lXCIsXHJcbiAgICBfc2VyaWVzUG9wdWxhdGVkSGFuZGxlckNvcmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NTZXJpZXNGYW1pbGllcygpO1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NWYWx1ZUF4aXNGb3JtYXQoKVxyXG4gICAgfSxcclxuICAgIF9yZW5kZXJUcmFja2VyczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VyaWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzW2ldLmRyYXdUcmFja2VycygpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9zcGVjaWFsUHJvY2Vzc1NlcmllczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1Nlcmllc0ZhbWlsaWVzKClcclxuICAgIH0sXHJcbiAgICBfcHJvY2Vzc1Nlcmllc0ZhbWlsaWVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgX3RoYXQkc2VyaWVzRmFtaWxpZXM7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciB0eXBlcyA9IFtdO1xyXG4gICAgICAgIHZhciBmYW1pbGllcyA9IFtdO1xyXG4gICAgICAgIHZhciBwYW5lU2VyaWVzO1xyXG4gICAgICAgIHZhciB0aGVtZU1hbmFnZXIgPSB0aGF0Ll90aGVtZU1hbmFnZXI7XHJcbiAgICAgICAgdmFyIG5lZ2F0aXZlc0FzWmVyb2VzID0gdGhlbWVNYW5hZ2VyLmdldE9wdGlvbnMoXCJuZWdhdGl2ZXNBc1plcm9lc1wiKTtcclxuICAgICAgICB2YXIgbmVnYXRpdmVzQXNaZXJvcyA9IHRoZW1lTWFuYWdlci5nZXRPcHRpb25zKFwibmVnYXRpdmVzQXNaZXJvc1wiKTtcclxuICAgICAgICB2YXIgZmFtaWx5T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbWluQnViYmxlU2l6ZTogdGhlbWVNYW5hZ2VyLmdldE9wdGlvbnMoXCJtaW5CdWJibGVTaXplXCIpLFxyXG4gICAgICAgICAgICBtYXhCdWJibGVTaXplOiB0aGVtZU1hbmFnZXIuZ2V0T3B0aW9ucyhcIm1heEJ1YmJsZVNpemVcIiksXHJcbiAgICAgICAgICAgIGJhckdyb3VwUGFkZGluZzogdGhlbWVNYW5hZ2VyLmdldE9wdGlvbnMoXCJiYXJHcm91cFBhZGRpbmdcIiksXHJcbiAgICAgICAgICAgIGJhckdyb3VwV2lkdGg6IHRoZW1lTWFuYWdlci5nZXRPcHRpb25zKFwiYmFyR3JvdXBXaWR0aFwiKSxcclxuICAgICAgICAgICAgbmVnYXRpdmVzQXNaZXJvZXM6IF9pc0RlZmluZWQobmVnYXRpdmVzQXNaZXJvZXMpID8gbmVnYXRpdmVzQXNaZXJvZXMgOiBuZWdhdGl2ZXNBc1plcm9zXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAobnVsbCAhPT0gKF90aGF0JHNlcmllc0ZhbWlsaWVzID0gdGhhdC5zZXJpZXNGYW1pbGllcykgJiYgdm9pZCAwICE9PSBfdGhhdCRzZXJpZXNGYW1pbGllcyAmJiBfdGhhdCRzZXJpZXNGYW1pbGllcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgX2VhY2godGhhdC5zZXJpZXNGYW1pbGllcywgKGZ1bmN0aW9uKF8sIGZhbWlseSkge1xyXG4gICAgICAgICAgICAgICAgZmFtaWx5LnVwZGF0ZU9wdGlvbnMoZmFtaWx5T3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBmYW1pbHkuYWRqdXN0U2VyaWVzVmFsdWVzKClcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgX2VhY2godGhhdC5zZXJpZXMsIChmdW5jdGlvbihfLCBpdGVtKSB7XHJcbiAgICAgICAgICAgIGlmICgtMSA9PT0gaW5BcnJheShpdGVtLnR5cGUsIHR5cGVzKSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaChpdGVtLnR5cGUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgX2VhY2godGhhdC5fZ2V0TGF5b3V0VGFyZ2V0cygpLCAoZnVuY3Rpb24oXywgcGFuZSkge1xyXG4gICAgICAgICAgICBwYW5lU2VyaWVzID0gdGhhdC5fZ2V0U2VyaWVzRm9yUGFuZShwYW5lLm5hbWUpO1xyXG4gICAgICAgICAgICBfZWFjaCh0eXBlcywgKGZ1bmN0aW9uKF8sIHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmYW1pbHkgPSBuZXcgU2VyaWVzRmFtaWx5KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhbmU6IHBhbmUubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBtaW5CdWJibGVTaXplOiBmYW1pbHlPcHRpb25zLm1pbkJ1YmJsZVNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4QnViYmxlU2l6ZTogZmFtaWx5T3B0aW9ucy5tYXhCdWJibGVTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhckdyb3VwUGFkZGluZzogZmFtaWx5T3B0aW9ucy5iYXJHcm91cFBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFyR3JvdXBXaWR0aDogZmFtaWx5T3B0aW9ucy5iYXJHcm91cFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIG5lZ2F0aXZlc0FzWmVyb2VzOiBmYW1pbHlPcHRpb25zLm5lZ2F0aXZlc0FzWmVyb2VzLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZWQ6IHRoYXQuX2lzUm90YXRlZCgpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGZhbWlseS5hZGQocGFuZVNlcmllcyk7XHJcbiAgICAgICAgICAgICAgICBmYW1pbHkuYWRqdXN0U2VyaWVzVmFsdWVzKCk7XHJcbiAgICAgICAgICAgICAgICBmYW1pbGllcy5wdXNoKGZhbWlseSlcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoYXQuc2VyaWVzRmFtaWxpZXMgPSBmYW1pbGllc1xyXG4gICAgfSxcclxuICAgIF91cGRhdGVTZXJpZXNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VyaWVzRmFtaWxpZXMgPSB0aGlzLnNlcmllc0ZhbWlsaWVzIHx8IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZXJpZXNGYW1pbGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZmFtaWx5ID0gc2VyaWVzRmFtaWxpZXNbaV07XHJcbiAgICAgICAgICAgIGZhbWlseS51cGRhdGVTZXJpZXNWYWx1ZXMoKTtcclxuICAgICAgICAgICAgZmFtaWx5LmFkanVzdFNlcmllc0RpbWVuc2lvbnMoKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0TGVnZW5kQ2FsbEJhY2s6IGZ1bmN0aW9uKHNlcmllcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sZWdlbmQgJiYgdGhpcy5fbGVnZW5kLmdldEFjdGlvbkNhbGxiYWNrKHNlcmllcylcclxuICAgIH0sXHJcbiAgICBfYXBwZW5kQXhlc0dyb3VwczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fc3RyaXBzR3JvdXAubGlua0FwcGVuZCgpO1xyXG4gICAgICAgIHRoaXMuX2dyaWRHcm91cC5saW5rQXBwZW5kKCk7XHJcbiAgICAgICAgdGhpcy5fYXhlc0dyb3VwLmxpbmtBcHBlbmQoKTtcclxuICAgICAgICB0aGlzLl9sYWJlbHNBeGVzR3JvdXAubGlua0FwcGVuZCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbnN0YW50TGluZXNHcm91cC5saW5rQXBwZW5kKCk7XHJcbiAgICAgICAgdGhpcy5fc3RyaXBMYWJlbEF4ZXNHcm91cC5saW5rQXBwZW5kKCk7XHJcbiAgICAgICAgdGhpcy5fc2NhbGVCcmVha3NHcm91cC5saW5rQXBwZW5kKClcclxuICAgIH0sXHJcbiAgICBfcG9wdWxhdGVNYXJnaW5PcHRpb25zKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgYnViYmxlU2l6ZSA9IGVzdGltYXRlQnViYmxlU2l6ZSh0aGF0LmdldFNpemUoKSwgdGhhdC5wYW5lcy5sZW5ndGgsIHRoYXQuX3RoZW1lTWFuYWdlci5nZXRPcHRpb25zKFwibWF4QnViYmxlU2l6ZVwiKSwgdGhhdC5faXNSb3RhdGVkKCkpO1xyXG4gICAgICAgIHZhciBhcmd1bWVudE1hcmdpbk9wdGlvbnMgPSB7fTtcclxuICAgICAgICB0aGF0Ll92YWx1ZUF4ZXMuZm9yRWFjaCh2YWx1ZUF4aXMgPT4ge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBTZXJpZXMgPSB0aGF0LnNlcmllcy5maWx0ZXIoKGZ1bmN0aW9uKHNlcmllcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllcy5nZXRWYWx1ZUF4aXMoKSA9PT0gdmFsdWVBeGlzXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdmFyIG1hcmdpbk9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgZ3JvdXBTZXJpZXMuZm9yRWFjaChzZXJpZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlcmllcy5pc1Zpc2libGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXJpZXNNYXJnaW5PcHRpb25zID0gcHJvY2Vzc0J1YmJsZU1hcmdpbihzZXJpZXMuZ2V0TWFyZ2luT3B0aW9ucygpLCBidWJibGVTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5PcHRpb25zID0gbWVyZ2VNYXJnaW5PcHRpb25zKG1hcmdpbk9wdGlvbnMsIHNlcmllc01hcmdpbk9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50TWFyZ2luT3B0aW9ucyA9IG1lcmdlTWFyZ2luT3B0aW9ucyhhcmd1bWVudE1hcmdpbk9wdGlvbnMsIHNlcmllc01hcmdpbk9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YWx1ZUF4aXMuc2V0TWFyZ2luT3B0aW9ucyhtYXJnaW5PcHRpb25zKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoYXQuX2FyZ3VtZW50QXhlcy5mb3JFYWNoKGEgPT4gYS5zZXRNYXJnaW5PcHRpb25zKGFyZ3VtZW50TWFyZ2luT3B0aW9ucykpXHJcbiAgICB9LFxyXG4gICAgX3BvcHVsYXRlQnVzaW5lc3NSYW5nZSh1cGRhdGVkQXhpcywga2VlcFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciByb3RhdGVkID0gdGhhdC5faXNSb3RhdGVkKCk7XHJcbiAgICAgICAgdmFyIHNlcmllcyA9IHRoYXQuX2dldFZpc2libGVTZXJpZXMoKTtcclxuICAgICAgICB2YXIgYXJnUmFuZ2VzID0ge307XHJcbiAgICAgICAgdmFyIGNvbW1vbkFyZ1JhbmdlID0gbmV3IFJhbmdlKHtcclxuICAgICAgICAgICAgcm90YXRlZDogISFyb3RhdGVkXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGdldFBhbmVOYW1lID0gYXhpcyA9PiBheGlzLnBhbmUgfHwgREVGQVVMVF9QQU5FX05BTUU7XHJcbiAgICAgICAgdGhhdC5wYW5lcy5mb3JFYWNoKHAgPT4gYXJnUmFuZ2VzW3AubmFtZV0gPSBuZXcgUmFuZ2Uoe1xyXG4gICAgICAgICAgICByb3RhdGVkOiAhIXJvdGF0ZWRcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhhdC5fdmFsdWVBeGVzLmZvckVhY2godmFsdWVBeGlzID0+IHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwUmFuZ2UgPSBuZXcgUmFuZ2Uoe1xyXG4gICAgICAgICAgICAgICAgcm90YXRlZDogISFyb3RhdGVkLFxyXG4gICAgICAgICAgICAgICAgcGFuZTogdmFsdWVBeGlzLnBhbmUsXHJcbiAgICAgICAgICAgICAgICBheGlzOiB2YWx1ZUF4aXMubmFtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwU2VyaWVzID0gc2VyaWVzLmZpbHRlcihzZXJpZXMgPT4gc2VyaWVzLmdldFZhbHVlQXhpcygpID09PSB2YWx1ZUF4aXMpO1xyXG4gICAgICAgICAgICBncm91cFNlcmllcy5mb3JFYWNoKHNlcmllcyA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzUmFuZ2UgPSBzZXJpZXMuZ2V0UmFuZ2VEYXRhKCk7XHJcbiAgICAgICAgICAgICAgICBncm91cFJhbmdlLmFkZFJhbmdlKHNlcmllc1JhbmdlLnZhbCk7XHJcbiAgICAgICAgICAgICAgICBhcmdSYW5nZXNbZ2V0UGFuZU5hbWUodmFsdWVBeGlzKV0uYWRkUmFuZ2Uoc2VyaWVzUmFuZ2UuYXJnKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCF1cGRhdGVkQXhpcyB8fCB1cGRhdGVkQXhpcyAmJiBncm91cFNlcmllcy5sZW5ndGggJiYgdmFsdWVBeGlzID09PSB1cGRhdGVkQXhpcykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVBeGlzLnNldEdyb3VwU2VyaWVzKGdyb3VwU2VyaWVzKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlQXhpcy5zZXRCdXNpbmVzc1JhbmdlKGdyb3VwUmFuZ2UsIHRoYXQuX2F4ZXNSZWluaXRpYWxpemVkIHx8IGtlZXBSYW5nZSwgdGhhdC5fYXJndW1lbnRBeGVzWzBdLl9sYXN0VmlzdWFsUmFuZ2VVcGRhdGVNb2RlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCF1cGRhdGVkQXhpcyB8fCB1cGRhdGVkQXhpcyAmJiBzZXJpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFyZ1JhbmdlcykuZm9yRWFjaChwID0+IGNvbW1vbkFyZ1JhbmdlLmFkZFJhbmdlKGFyZ1Jhbmdlc1twXSkpO1xyXG4gICAgICAgICAgICB2YXIgY29tbW9uSW50ZXJ2YWwgPSBjb21tb25BcmdSYW5nZS5pbnRlcnZhbDtcclxuICAgICAgICAgICAgdGhhdC5fYXJndW1lbnRBeGVzLmZvckVhY2goYSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2FyZ1JhbmdlcyRnZXRQYW5lTmFtO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJbnRlcnZhbCA9IG51bGwgIT09IChfYXJnUmFuZ2VzJGdldFBhbmVOYW0gPSBhcmdSYW5nZXNbZ2V0UGFuZU5hbWUoYSldLmludGVydmFsKSAmJiB2b2lkIDAgIT09IF9hcmdSYW5nZXMkZ2V0UGFuZU5hbSA/IF9hcmdSYW5nZXMkZ2V0UGFuZU5hbSA6IGNvbW1vbkludGVydmFsO1xyXG4gICAgICAgICAgICAgICAgYS5zZXRCdXNpbmVzc1JhbmdlKG5ldyBSYW5nZShfZXh0ZW5kcyh7fSwgY29tbW9uQXJnUmFuZ2UsIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbDogY3VycmVudEludGVydmFsXHJcbiAgICAgICAgICAgICAgICB9KSksIHRoYXQuX2F4ZXNSZWluaXRpYWxpemVkLCB2b2lkIDAsIHRoYXQuX2dyb3Vwc0RhdGEuY2F0ZWdvcmllcylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhhdC5fcG9wdWxhdGVNYXJnaW5PcHRpb25zKClcclxuICAgIH0sXHJcbiAgICBnZXRBcmd1bWVudEF4aXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fYXJndW1lbnRBeGVzIHx8IFtdKS5maWx0ZXIoYSA9PiAhYS5pc1ZpcnR1YWwpWzBdXHJcbiAgICB9LFxyXG4gICAgZ2V0VmFsdWVBeGlzOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZUF4ZXMgfHwgW10pLmZpbHRlcihfaXNEZWZpbmVkKG5hbWUpID8gYSA9PiBhLm5hbWUgPT09IG5hbWUgOiBhID0+IGEucGFuZSA9PT0gdGhpcy5kZWZhdWx0UGFuZSlbMF1cclxuICAgIH0sXHJcbiAgICBfZ2V0R3JvdXBzRGF0YTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciBncm91cHMgPSBbXTtcclxuICAgICAgICB0aGF0Ll92YWx1ZUF4ZXMuZm9yRWFjaCgoZnVuY3Rpb24oYXhpcykge1xyXG4gICAgICAgICAgICBncm91cHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBzZXJpZXM6IHRoYXQuc2VyaWVzLmZpbHRlcigoZnVuY3Rpb24oc2VyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllcy5nZXRWYWx1ZUF4aXMoKSA9PT0gYXhpc1xyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVBeGlzOiBheGlzLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVPcHRpb25zOiBheGlzLmdldE9wdGlvbnMoKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBncm91cHM6IGdyb3VwcyxcclxuICAgICAgICAgICAgYXJndW1lbnRBeGVzOiB0aGF0Ll9hcmd1bWVudEF4ZXMsXHJcbiAgICAgICAgICAgIGFyZ3VtZW50T3B0aW9uczogdGhhdC5fYXJndW1lbnRBeGVzWzBdLmdldE9wdGlvbnMoKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ3JvdXBTZXJpZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2NvcnJlY3RWYWx1ZUF4ZXMoZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuX2dyb3Vwc0RhdGEgPSB0aGlzLl9nZXRHcm91cHNEYXRhKClcclxuICAgIH0sXHJcbiAgICBfcHJvY2Vzc1ZhbHVlQXhpc0Zvcm1hdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGF4ZXNXaXRoRnVsbFN0YWNrZWRGb3JtYXQgPSBbXTtcclxuICAgICAgICB0aGlzLnNlcmllcy5mb3JFYWNoKChmdW5jdGlvbihzZXJpZXMpIHtcclxuICAgICAgICAgICAgdmFyIGF4aXMgPSBzZXJpZXMuZ2V0VmFsdWVBeGlzKCk7XHJcbiAgICAgICAgICAgIGlmIChzZXJpZXMuaXNGdWxsU3RhY2tlZFNlcmllcygpKSB7XHJcbiAgICAgICAgICAgICAgICBheGlzLnNldFBlcmNlbnRMYWJlbEZvcm1hdCgpO1xyXG4gICAgICAgICAgICAgICAgYXhlc1dpdGhGdWxsU3RhY2tlZEZvcm1hdC5wdXNoKGF4aXMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWVBeGVzLmZvckVhY2goKGZ1bmN0aW9uKGF4aXMpIHtcclxuICAgICAgICAgICAgaWYgKC0xID09PSBheGVzV2l0aEZ1bGxTdGFja2VkRm9ybWF0LmluZGV4T2YoYXhpcykpIHtcclxuICAgICAgICAgICAgICAgIGF4aXMucmVzZXRBdXRvTGFiZWxGb3JtYXQoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpXHJcbiAgICB9LFxyXG4gICAgX3BvcHVsYXRlQXhlc09wdGlvbnModHlwZVNlbGVjdG9yLCB1c2VyT3B0aW9ucywgYXhpc09wdGlvbnMsIHJvdGF0ZWQsIHZpcnR1YWwpIHtcclxuICAgICAgICB2YXIgcHJlcGFyZWRVc2VyT3B0aW9ucyA9IHRoaXMuX3ByZXBhcmVTdHJpcHNBbmRDb25zdGFudExpbmVzKHR5cGVTZWxlY3RvciwgdXNlck9wdGlvbnMsIHJvdGF0ZWQpO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gX2V4dGVuZCh0cnVlLCB7fSwgcHJlcGFyZWRVc2VyT3B0aW9ucywgYXhpc09wdGlvbnMsIHRoaXMuX3ByZXBhcmVBeGlzT3B0aW9ucyh0eXBlU2VsZWN0b3IsIHByZXBhcmVkVXNlck9wdGlvbnMsIHJvdGF0ZWQpKTtcclxuICAgICAgICBpZiAodmlydHVhbCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLnZpc2libGUgPSBvcHRpb25zLnRpY2sudmlzaWJsZSA9IG9wdGlvbnMubWlub3JUaWNrLnZpc2libGUgPSBvcHRpb25zLmxhYmVsLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgb3B0aW9ucy50aXRsZSA9IHt9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb25zXHJcbiAgICB9LFxyXG4gICAgX2dldFZhbEZpbHRlcjogc2VyaWVzID0+IHJhbmdlRGF0YUNhbGN1bGF0b3IuZ2V0Vmlld1BvcnRGaWx0ZXIoc2VyaWVzLmdldFZhbHVlQXhpcygpLnZpc3VhbFJhbmdlKCkgfHwge30pLFxyXG4gICAgX2NyZWF0ZUF4aXMoaXNBcmd1bWVudEF4ZXMsIG9wdGlvbnMsIHZpcnR1YWwpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHR5cGVTZWxlY3RvciA9IGlzQXJndW1lbnRBeGVzID8gXCJhcmd1bWVudEF4aXNcIiA6IFwidmFsdWVBeGlzXCI7XHJcbiAgICAgICAgdmFyIHJlbmRlcmluZ1NldHRpbmdzID0gX2V4dGVuZCh7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyOiB0aGF0Ll9yZW5kZXJlcixcclxuICAgICAgICAgICAgaW5jaWRlbnRPY2N1cnJlZDogdGhhdC5faW5jaWRlbnRPY2N1cnJlZCxcclxuICAgICAgICAgICAgZXZlbnRUcmlnZ2VyOiB0aGF0Ll9ldmVudFRyaWdnZXIsXHJcbiAgICAgICAgICAgIGF4aXNDbGFzczogaXNBcmd1bWVudEF4ZXMgPyBcImFyZ1wiIDogXCJ2YWxcIixcclxuICAgICAgICAgICAgd2lkZ2V0Q2xhc3M6IFwiZHhjXCIsXHJcbiAgICAgICAgICAgIHN0cmlwc0dyb3VwOiB0aGF0Ll9zdHJpcHNHcm91cCxcclxuICAgICAgICAgICAgc3RyaXBMYWJlbEF4ZXNHcm91cDogdGhhdC5fc3RyaXBMYWJlbEF4ZXNHcm91cCxcclxuICAgICAgICAgICAgY29uc3RhbnRMaW5lc0dyb3VwOiB0aGF0Ll9jb25zdGFudExpbmVzR3JvdXAsXHJcbiAgICAgICAgICAgIHNjYWxlQnJlYWtzR3JvdXA6IHRoYXQuX3NjYWxlQnJlYWtzR3JvdXAsXHJcbiAgICAgICAgICAgIGF4ZXNDb250YWluZXJHcm91cDogdGhhdC5fYXhlc0dyb3VwLFxyXG4gICAgICAgICAgICBsYWJlbHNBeGVzR3JvdXA6IHRoYXQuX2xhYmVsc0F4ZXNHcm91cCxcclxuICAgICAgICAgICAgZ3JpZEdyb3VwOiB0aGF0Ll9ncmlkR3JvdXAsXHJcbiAgICAgICAgICAgIGlzQXJndW1lbnRBeGlzOiBpc0FyZ3VtZW50QXhlcyxcclxuICAgICAgICAgICAgZ2V0VGVtcGxhdGU6IHRlbXBsYXRlID0+IHRoYXQuX2dldFRlbXBsYXRlKHRlbXBsYXRlKVxyXG4gICAgICAgIH0sIHRoYXQuX2dldEF4aXNSZW5kZXJpbmdPcHRpb25zKHR5cGVTZWxlY3RvcikpO1xyXG4gICAgICAgIHZhciBheGlzID0gbmV3IEF4aXMocmVuZGVyaW5nU2V0dGluZ3MpO1xyXG4gICAgICAgIGF4aXMudXBkYXRlT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICBheGlzLmlzVmlydHVhbCA9IHZpcnR1YWw7XHJcbiAgICAgICAgcmV0dXJuIGF4aXNcclxuICAgIH0sXHJcbiAgICBfYXBwbHlWaXN1YWxSYW5nZUJ5VmlydHVhbEF4ZXM6IChheGlzLCByYW5nZSkgPT4gZmFsc2UsXHJcbiAgICBfYXBwbHlDdXN0b21WaXN1YWxSYW5nZU9wdGlvbihheGlzLCByYW5nZSkge1xyXG4gICAgICAgIGlmIChheGlzLmdldE9wdGlvbnMoKS5vcHRpb25QYXRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlVmlzdWFsUmFuZ2VPcHRpb24oXCJcIi5jb25jYXQoYXhpcy5nZXRPcHRpb25zKCkub3B0aW9uUGF0aCwgXCIudmlzdWFsUmFuZ2VcIiksIHJhbmdlKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0VmlzdWFsUmFuZ2VTZXR0ZXIoKSB7XHJcbiAgICAgICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXhpcywgX3JlZikge1xyXG4gICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgc2tpcEV2ZW50UmlzaW5nOiBza2lwRXZlbnRSaXNpbmcsXHJcbiAgICAgICAgICAgICAgICByYW5nZTogcmFuZ2VcclxuICAgICAgICAgICAgfSA9IF9yZWY7XHJcbiAgICAgICAgICAgIGNoYXJ0Ll9hcHBseUN1c3RvbVZpc3VhbFJhbmdlT3B0aW9uKGF4aXMsIHJhbmdlKTtcclxuICAgICAgICAgICAgYXhpcy5zZXRDdXN0b21WaXN1YWxSYW5nZShyYW5nZSk7XHJcbiAgICAgICAgICAgIGF4aXMuc2tpcEV2ZW50UmlzaW5nID0gc2tpcEV2ZW50UmlzaW5nO1xyXG4gICAgICAgICAgICBpZiAoIWNoYXJ0Ll9hcHBseVZpc3VhbFJhbmdlQnlWaXJ0dWFsQXhlcyhheGlzLCByYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fYXBwbHlpbmdDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQuX2NoYW5nZV9WSVNVQUxfUkFOR0UoKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC5fcmVxdWVzdENoYW5nZShbVklTVUFMX1JBTkdFXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0VHJhY2tlclNldHRpbmdzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX2V4dGVuZCh0aGlzLmNhbGxCYXNlKCksIHtcclxuICAgICAgICAgICAgYXJndW1lbnRBeGlzOiB0aGlzLmdldEFyZ3VtZW50QXhpcygpXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBfcHJlcGFyZVN0cmlwc0FuZENvbnN0YW50TGluZXM6IGZ1bmN0aW9uKHR5cGVTZWxlY3RvciwgdXNlck9wdGlvbnMsIHJvdGF0ZWQpIHtcclxuICAgICAgICB1c2VyT3B0aW9ucyA9IHRoaXMuX3RoZW1lTWFuYWdlci5nZXRPcHRpb25zKHR5cGVTZWxlY3RvciwgdXNlck9wdGlvbnMsIHJvdGF0ZWQpO1xyXG4gICAgICAgIGlmICh1c2VyT3B0aW9ucy5zdHJpcHMpIHtcclxuICAgICAgICAgICAgX2VhY2godXNlck9wdGlvbnMuc3RyaXBzLCAoZnVuY3Rpb24oaSkge1xyXG4gICAgICAgICAgICAgICAgdXNlck9wdGlvbnMuc3RyaXBzW2ldID0gX2V4dGVuZCh0cnVlLCB7fSwgdXNlck9wdGlvbnMuc3RyaXBTdHlsZSwgdXNlck9wdGlvbnMuc3RyaXBzW2ldKVxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZXJPcHRpb25zLmNvbnN0YW50TGluZXMpIHtcclxuICAgICAgICAgICAgX2VhY2godXNlck9wdGlvbnMuY29uc3RhbnRMaW5lcywgKGZ1bmN0aW9uKGksIGxpbmUpIHtcclxuICAgICAgICAgICAgICAgIHVzZXJPcHRpb25zLmNvbnN0YW50TGluZXNbaV0gPSBfZXh0ZW5kKHRydWUsIHt9LCB1c2VyT3B0aW9ucy5jb25zdGFudExpbmVTdHlsZSwgbGluZSlcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1c2VyT3B0aW9uc1xyXG4gICAgfSxcclxuICAgIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VBeGVzKCk7XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZSgpXHJcbiAgICB9LFxyXG4gICAgX2xheW91dEF4ZXMoZHJhd0F4ZXMpIHtcclxuICAgICAgICBkcmF3QXhlcygpO1xyXG4gICAgICAgIHZhciBuZWVkU3BhY2UgPSB0aGlzLmNoZWNrRm9yTW9yZVNwYWNlRm9yUGFuZXNDYW52YXMoKTtcclxuICAgICAgICBpZiAobmVlZFNwYWNlKSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdC5zbGljZSgpO1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX2xheW91dC5iYWNrd2FyZChyZWN0LCByZWN0LCBbbmVlZFNwYWNlLndpZHRoLCBuZWVkU3BhY2UuaGVpZ2h0XSk7XHJcbiAgICAgICAgICAgIG5lZWRTcGFjZS53aWR0aCA9IE1hdGgubWF4KDAsIHNpemVbMF0pO1xyXG4gICAgICAgICAgICBuZWVkU3BhY2UuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgc2l6ZVsxXSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IHRoaXMuX2NyZWF0ZUNhbnZhc0Zyb21SZWN0KHJlY3QpO1xyXG4gICAgICAgICAgICBkcmF3QXhlcyhuZWVkU3BhY2UpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNoZWNrRm9yTW9yZVNwYWNlRm9yUGFuZXNDYW52YXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0TWFuYWdlci5uZWVkTW9yZVNwYWNlRm9yUGFuZXNDYW52YXModGhpcy5fZ2V0TGF5b3V0VGFyZ2V0cygpLCB0aGlzLl9pc1JvdGF0ZWQoKSlcclxuICAgIH0sXHJcbiAgICBfcGFyc2VWaXN1YWxSYW5nZU9wdGlvbihmdWxsTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBmdWxsTmFtZS5zcGxpdCgvWy5bXS8pWzBdO1xyXG4gICAgICAgIHZhciBpbmRleCA9IGZ1bGxOYW1lLm1hdGNoKC9cXGQrL2cpO1xyXG4gICAgICAgIGluZGV4ID0gX2lzRGVmaW5lZChpbmRleCkgPyBwYXJzZUludChpbmRleFswXSkgOiBpbmRleDtcclxuICAgICAgICBpZiAoZnVsbE5hbWUuaW5kZXhPZihcInZpc3VhbFJhbmdlXCIpID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcFZpc3VhbFJhbmdlKGZ1bGxOYW1lLCB2YWx1ZSkgfHwgdmFsdWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0Ll9zZXRDdXN0b21WaXN1YWxSYW5nZShuYW1lLCBpbmRleCwgdmFsdWUpXHJcbiAgICAgICAgfSBlbHNlIGlmICgoXCJvYmplY3RcIiA9PT0gdHlwZSh2YWx1ZSkgfHwgX2lzQXJyYXkodmFsdWUpKSAmJiBuYW1lLmluZGV4T2YoXCJBeGlzXCIpID4gMCAmJiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkuaW5kZXhPZihcInZpc3VhbFJhbmdlXCIpID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoX2lzRGVmaW5lZCh2YWx1ZS52aXN1YWxSYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3NldEN1c3RvbVZpc3VhbFJhbmdlKG5hbWUsIGluZGV4LCB2YWx1ZS52aXN1YWxSYW5nZSlcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChfaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGEsIGkpID0+IF9pc0RlZmluZWQoYS52aXN1YWxSYW5nZSkgJiYgdGhhdC5fc2V0Q3VzdG9tVmlzdWFsUmFuZ2UobmFtZSwgaSwgYS52aXN1YWxSYW5nZSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3NldEN1c3RvbVZpc3VhbFJhbmdlKGF4ZXNOYW1lLCBpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMuc2lsZW50KGF4ZXNOYW1lKTtcclxuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghX2lzRGVmaW5lZChpbmRleCkpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5fY3VzdG9tVmlzdWFsUmFuZ2UgPSB2YWx1ZVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbaW5kZXhdLl9jdXN0b21WaXN1YWxSYW5nZSA9IHZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2F4ZXNSZWluaXRpYWxpemVkID0gdHJ1ZVxyXG4gICAgfSxcclxuICAgIF9yYWlzZVpvb21FbmRIYW5kbGVycygpIHtcclxuICAgICAgICB0aGlzLl92YWx1ZUF4ZXMuZm9yRWFjaChheGlzID0+IGF4aXMuaGFuZGxlWm9vbUVuZCgpKVxyXG4gICAgfSxcclxuICAgIF9zZXRPcHRpb25zQnlSZWZlcmVuY2UoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZSgpO1xyXG4gICAgICAgIF9leHRlbmQodGhpcy5fb3B0aW9uc0J5UmVmZXJlbmNlLCB7XHJcbiAgICAgICAgICAgIFwidmFsdWVBeGlzLnZpc3VhbFJhbmdlXCI6IHRydWVcclxuICAgICAgICB9KVxyXG4gICAgfSxcclxuICAgIF9ub3RpZnlPcHRpb25DaGFuZ2VkKG9wdGlvbiwgdmFsdWUsIHByZXZpb3VzVmFsdWUpIHtcclxuICAgICAgICB0aGlzLmNhbGxCYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25DaGFuZ2VkTG9ja2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlVmlzdWFsUmFuZ2VPcHRpb24ob3B0aW9uLCB2YWx1ZSlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX25vdGlmeVZpc3VhbFJhbmdlKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB0aGF0Ll92YWx1ZUF4ZXMuZm9yRWFjaChheGlzID0+IHtcclxuICAgICAgICAgICAgdmFyIGF4aXNQYXRoID0gYXhpcy5nZXRPcHRpb25zKCkub3B0aW9uUGF0aDtcclxuICAgICAgICAgICAgaWYgKGF4aXNQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IFwiXCIuY29uY2F0KGF4aXNQYXRoLCBcIi52aXN1YWxSYW5nZVwiKTtcclxuICAgICAgICAgICAgICAgIHZhciB2aXN1YWxSYW5nZSA9IGNvbnZlcnRWaXN1YWxSYW5nZU9iamVjdChheGlzLnZpc3VhbFJhbmdlKCksICFfaXNBcnJheSh0aGF0Lm9wdGlvbihwYXRoKSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFheGlzLnNraXBFdmVudFJpc2luZyB8fCAhcmFuZ2VzQXJlRXF1YWwodmlzdWFsUmFuZ2UsIHRoYXQub3B0aW9uKHBhdGgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhhdC5vcHRpb24oYXhpc1BhdGgpICYmIFwidmFsdWVBeGlzXCIgIT09IGF4aXNQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQub3B0aW9uKGF4aXNQYXRoLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBheGlzLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXN1YWxSYW5nZTogdmlzdWFsUmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm9wdGlvbihwYXRoLCB2aXN1YWxSYW5nZSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuc2tpcEV2ZW50UmlzaW5nID0gbnVsbFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBfbm90aWZ5KCkge1xyXG4gICAgICAgIHRoaXMuY2FsbEJhc2UoKTtcclxuICAgICAgICB0aGlzLl9heGVzUmVpbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0cnVlICE9PSB0aGlzLm9wdGlvbihcImRpc2FibGVUd29XYXlCaW5kaW5nXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2tpcE9wdGlvbnNSb2xsQmFjayA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeVZpc3VhbFJhbmdlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2tpcE9wdGlvbnNSb2xsQmFjayA9IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9nZXRBeGVzRm9yU2NhbGluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVBeGVzXHJcbiAgICB9LFxyXG4gICAgX2dldEF4ZXNCeU9wdGlvblBhdGgoYXJnLCBpc0RpcmVjdE9wdGlvbiwgb3B0aW9uTmFtZSkge1xyXG4gICAgICAgIHZhciBzb3VyY2VBeGVzID0gdGhpcy5fZ2V0QXhlc0ZvclNjYWxpbmcoKTtcclxuICAgICAgICB2YXIgYXhlcyA9IFtdO1xyXG4gICAgICAgIGlmIChpc0RpcmVjdE9wdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgYXhpc1BhdGg7XHJcbiAgICAgICAgICAgIGlmIChhcmcuZnVsbE5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGF4aXNQYXRoID0gYXJnLmZ1bGxOYW1lLnNsaWNlKDAsIGFyZy5mdWxsTmFtZS5pbmRleE9mKFwiLlwiKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBheGVzID0gc291cmNlQXhlcy5maWx0ZXIoYSA9PiBhLmdldE9wdGlvbnMoKS5vcHRpb25QYXRoID09PSBheGlzUGF0aClcclxuICAgICAgICB9IGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGUoYXJnLnZhbHVlKSkge1xyXG4gICAgICAgICAgICBheGVzID0gc291cmNlQXhlcy5maWx0ZXIoYSA9PiBhLmdldE9wdGlvbnMoKS5vcHRpb25QYXRoID09PSBhcmcubmFtZSlcclxuICAgICAgICB9IGVsc2UgaWYgKF9pc0FycmF5KGFyZy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgYXJnLnZhbHVlLmZvckVhY2goKHYsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IHNvdXJjZUF4ZXMuZmlsdGVyKGEgPT4gYS5nZXRPcHRpb25zKCkub3B0aW9uUGF0aCA9PT0gXCJcIi5jb25jYXQoYXJnLm5hbWUsIFwiW1wiKS5jb25jYXQoaW5kZXgsIFwiXVwiKSlbMF07XHJcbiAgICAgICAgICAgICAgICBfaXNEZWZpbmVkKHZbb3B0aW9uTmFtZV0pICYmIF9pc0RlZmluZWQoYXhpcykgJiYgKGF4ZXNbaW5kZXhdID0gYXhpcylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF4ZXNcclxuICAgIH0sXHJcbiAgICBfb3B0aW9uQ2hhbmdlZChhcmcpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbkNoYW5nZWRMb2NrZXIpIHtcclxuICAgICAgICAgICAgdmFyIGF4ZXM7XHJcbiAgICAgICAgICAgIHZhciBpc0RpcmVjdE9wdGlvbiA9IGFyZy5mdWxsTmFtZS5pbmRleE9mKFwidmlzdWFsUmFuZ2VcIikgPiAwID8gdHJ1ZSA6IHRoaXMuZ2V0UGFydGlhbENoYW5nZU9wdGlvbnNOYW1lKGFyZykuaW5kZXhPZihcInZpc3VhbFJhbmdlXCIpID4gLTEgPyBmYWxzZSA6IHZvaWQgMDtcclxuICAgICAgICAgICAgaWYgKF9pc0RlZmluZWQoaXNEaXJlY3RPcHRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBheGVzID0gdGhpcy5fZ2V0QXhlc0J5T3B0aW9uUGF0aChhcmcsIGlzRGlyZWN0T3B0aW9uLCBcInZpc3VhbFJhbmdlXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF4ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXhlcy5sZW5ndGggPiAxIHx8IF9pc0FycmF5KGFyZy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXhlcy5mb3JFYWNoKChhLCBpbmRleCkgPT4gc2V0QXhpc1Zpc3VhbFJhbmdlQnlPcHRpb24oYXJnLCBhLCBpc0RpcmVjdE9wdGlvbiwgaW5kZXgpKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoMSA9PT0gYXhlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXhpc1Zpc3VhbFJhbmdlQnlPcHRpb24oYXJnLCBheGVzWzBdLCBpc0RpcmVjdE9wdGlvbilcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQmFzZShhcmcpXHJcbiAgICB9LFxyXG4gICAgX2NoYW5nZV9WSVNVQUxfUkFOR0U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3JlY3JlYXRlU2l6ZURlcGVuZGVudE9iamVjdHMoZmFsc2UpO1xyXG4gICAgICAgIGlmICghdGhpcy5fY2hhbmdlcy5oYXMoXCJGVUxMX1JFTkRFUlwiKSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzaXplUGFuZXNPblpvb20gPSB0aGlzLm9wdGlvbihcInJlc2l6ZVBhbmVzT25ab29tXCIpO1xyXG4gICAgICAgICAgICB0aGlzLl9kb1JlbmRlcih7XHJcbiAgICAgICAgICAgICAgICBmb3JjZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGRyYXdUaXRsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBkcmF3TGVnZW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGFkanVzdEF4ZXM6IG51bGwgIT09IHJlc2l6ZVBhbmVzT25ab29tICYmIHZvaWQgMCAhPT0gcmVzaXplUGFuZXNPblpvb20gPyByZXNpemVQYW5lc09uWm9vbSA6IHRoaXMub3B0aW9uKFwiYWRqdXN0QXhlc09uWm9vbVwiKSB8fCBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGFuaW1hdGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9yYWlzZVpvb21FbmRIYW5kbGVycygpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlc2V0VmlzdWFsUmFuZ2UoKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHRoYXQuX3ZhbHVlQXhlcy5mb3JFYWNoKGF4aXMgPT4ge1xyXG4gICAgICAgICAgICBheGlzLnJlc2V0VmlzdWFsUmFuZ2UoZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGF0Ll9hcHBseUN1c3RvbVZpc3VhbFJhbmdlT3B0aW9uKGF4aXMpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhhdC5fcmVxdWVzdENoYW5nZShbVklTVUFMX1JBTkdFXSlcclxuICAgIH0sXHJcbiAgICBfZ2V0Q3Jvc3NoYWlyTWFyZ2luczogKCkgPT4gKHtcclxuICAgICAgICB4OiAwLFxyXG4gICAgICAgIHk6IDBcclxuICAgIH0pLFxyXG4gICAgX2xlZ2VuZERhdGFGaWVsZDogXCJzZXJpZXNcIixcclxuICAgIF9hZGp1c3RTZXJpZXNMYWJlbHM6IF9ub29wLFxyXG4gICAgX2NvcnJlY3RWYWx1ZUF4ZXM6IF9ub29wXHJcbn0pO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/chart_components/advanced_chart.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/chart_components/crosshair.js":
/*!***********************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/chart_components/crosshair.js ***!
  \***********************************************************************/
/*! exports provided: getMargins, Crosshair */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMargins\", function() { return getMargins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Crosshair\", function() { return Crosshair; });\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/**\r\n * DevExtreme (esm/viz/chart_components/crosshair.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\nvar math = Math;\r\nvar mathAbs = math.abs;\r\nvar mathMin = math.min;\r\nvar mathMax = math.max;\r\nvar mathFloor = math.floor;\r\nvar HORIZONTAL = \"horizontal\";\r\nvar VERTICAL = \"vertical\";\r\nvar LABEL_BACKGROUND_PADDING_X = 8;\r\nvar LABEL_BACKGROUND_PADDING_Y = 4;\r\nvar CENTER = \"center\";\r\nvar RIGHT = \"right\";\r\nvar LEFT = \"left\";\r\nvar TOP = \"top\";\r\nvar BOTTOM = \"bottom\";\r\nfunction getMargins() {\r\n    return {\r\n        x: LABEL_BACKGROUND_PADDING_X,\r\n        y: LABEL_BACKGROUND_PADDING_Y\r\n    }\r\n}\r\n\r\nfunction getRectangleBBox(bBox) {\r\n    return {\r\n        x: bBox.x - LABEL_BACKGROUND_PADDING_X,\r\n        y: bBox.y - LABEL_BACKGROUND_PADDING_Y,\r\n        width: bBox.width + 2 * LABEL_BACKGROUND_PADDING_X,\r\n        height: bBox.height + 2 * LABEL_BACKGROUND_PADDING_Y\r\n    }\r\n}\r\n\r\nfunction getLabelCheckerPosition(x, y, isHorizontal, canvas) {\r\n    var params = isHorizontal ? [\"x\", \"width\", \"y\", \"height\", y, 0] : [\"y\", \"height\", \"x\", \"width\", x, 1];\r\n    return function(bBox, position, coord) {\r\n        var labelCoord = {\r\n            x: coord.x,\r\n            y: coord.y\r\n        };\r\n        var rectangleBBox = getRectangleBBox(bBox);\r\n        var delta = isHorizontal ? coord.y - bBox.y - bBox.height / 2 : coord.y - bBox.y;\r\n        labelCoord.y = isHorizontal || !isHorizontal && position === BOTTOM ? coord.y + delta : coord.y;\r\n        if (rectangleBBox[params[0]] < 0) {\r\n            labelCoord[params[0]] -= rectangleBBox[params[0]]\r\n        } else if (rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] > canvas[params[1]]) {\r\n            labelCoord[params[0]] -= rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] - canvas[params[1]]\r\n        }\r\n        if (params[4] - rectangleBBox[params[3]] / 2 < 0) {\r\n            labelCoord[params[2]] -= params[4] - rectangleBBox[params[3]] / 2\r\n        } else if (params[4] + rectangleBBox[params[3]] / 2 > canvas[params[3]]) {\r\n            labelCoord[params[2]] -= params[4] + rectangleBBox[params[3]] / 2 - canvas[params[3]]\r\n        }\r\n        return labelCoord\r\n    }\r\n}\r\nfunction Crosshair(renderer, options, params, group) {\r\n    this._renderer = renderer;\r\n    this._crosshairGroup = group;\r\n    this._options = {};\r\n    this.update(options, params)\r\n}\r\nCrosshair.prototype = {\r\n    constructor: Crosshair,\r\n    update: function(options, params) {\r\n        var canvas = params.canvas;\r\n        this._canvas = {\r\n            top: canvas.top,\r\n            bottom: canvas.height - canvas.bottom,\r\n            left: canvas.left,\r\n            right: canvas.width - canvas.right,\r\n            width: canvas.width,\r\n            height: canvas.height\r\n        };\r\n        this._axes = params.axes;\r\n        this._panes = params.panes;\r\n        this._prepareOptions(options, HORIZONTAL);\r\n        this._prepareOptions(options, VERTICAL)\r\n    },\r\n    dispose: function() {\r\n        this._renderer = this._crosshairGroup = this._options = this._axes = this._canvas = this._horizontalGroup = this._verticalGroup = this._horizontal = this._vertical = this._circle = this._panes = null\r\n    },\r\n    _prepareOptions: function(options, direction) {\r\n        var lineOptions = options[direction + \"Line\"];\r\n        this._options[direction] = {\r\n            visible: lineOptions.visible,\r\n            line: {\r\n                stroke: lineOptions.color || options.color,\r\n                \"stroke-width\": lineOptions.width || options.width,\r\n                dashStyle: lineOptions.dashStyle || options.dashStyle,\r\n                opacity: lineOptions.opacity || options.opacity,\r\n                \"stroke-linecap\": \"butt\"\r\n            },\r\n            label: Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])(true, {}, options.label, lineOptions.label)\r\n        }\r\n    },\r\n    _createLines: function(options, sharpParam, group) {\r\n        var lines = [];\r\n        var canvas = this._canvas;\r\n        var points = [canvas.left, canvas.top, canvas.left, canvas.top];\r\n        for (var i = 0; i < 2; i++) {\r\n            lines.push(this._renderer.path(points, \"line\").attr(options).sharp(sharpParam).append(group))\r\n        }\r\n        return lines\r\n    },\r\n    render: function() {\r\n        var renderer = this._renderer;\r\n        var options = this._options;\r\n        var verticalOptions = options.vertical;\r\n        var horizontalOptions = options.horizontal;\r\n        var extraOptions = horizontalOptions.visible ? horizontalOptions.line : verticalOptions.line;\r\n        var circleOptions = {\r\n            stroke: extraOptions.stroke,\r\n            \"stroke-width\": extraOptions[\"stroke-width\"],\r\n            dashStyle: extraOptions.dashStyle,\r\n            opacity: extraOptions.opacity\r\n        };\r\n        var canvas = this._canvas;\r\n        this._horizontal = {};\r\n        this._vertical = {};\r\n        this._circle = renderer.circle(canvas.left, canvas.top, 0).attr(circleOptions).append(this._crosshairGroup);\r\n        this._horizontalGroup = renderer.g().append(this._crosshairGroup);\r\n        this._verticalGroup = renderer.g().append(this._crosshairGroup);\r\n        if (verticalOptions.visible) {\r\n            this._vertical.lines = this._createLines(verticalOptions.line, \"h\", this._verticalGroup);\r\n            this._vertical.labels = this._createLabels(this._axes[0], verticalOptions, false, this._verticalGroup)\r\n        }\r\n        if (horizontalOptions.visible) {\r\n            this._horizontal.lines = this._createLines(horizontalOptions.line, \"v\", this._horizontalGroup);\r\n            this._horizontal.labels = this._createLabels(this._axes[1], horizontalOptions, true, this._horizontalGroup)\r\n        }\r\n        this.hide()\r\n    },\r\n    _createLabels: function(axes, options, isHorizontal, group) {\r\n        var canvas = this._canvas;\r\n        var renderer = this._renderer;\r\n        var x;\r\n        var y;\r\n        var text;\r\n        var labels = [];\r\n        var background;\r\n        var currentLabelPos;\r\n        var labelOptions = options.label;\r\n        if (labelOptions.visible) {\r\n            axes.forEach((function(axis) {\r\n                var position = axis.getOptions().position;\r\n                if (axis.getTranslator().getBusinessRange().isEmpty()) {\r\n                    return\r\n                }\r\n                currentLabelPos = axis.getLabelsPosition();\r\n                if (isHorizontal) {\r\n                    y = canvas.top;\r\n                    x = currentLabelPos\r\n                } else {\r\n                    x = canvas.left;\r\n                    y = currentLabelPos\r\n                }\r\n                var align = position === TOP || position === BOTTOM ? CENTER : position === RIGHT ? LEFT : RIGHT;\r\n                background = renderer.rect(0, 0, 0, 0).attr({\r\n                    fill: labelOptions.backgroundColor || options.line.stroke\r\n                }).append(group);\r\n                text = renderer.text(\"0\", 0, 0).css(Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"patchFontOptions\"])(options.label.font)).attr({\r\n                    align: align,\r\n                    class: labelOptions.cssClass\r\n                }).append(group);\r\n                labels.push({\r\n                    text: text,\r\n                    background: background,\r\n                    axis: axis,\r\n                    options: labelOptions,\r\n                    pos: {\r\n                        coord: currentLabelPos,\r\n                        side: position\r\n                    },\r\n                    startXY: {\r\n                        x: x,\r\n                        y: y\r\n                    }\r\n                })\r\n            }))\r\n        }\r\n        return labels\r\n    },\r\n    _updateText: function(value, axisName, labels, point, func) {\r\n        var that = this;\r\n        labels.forEach((function(label) {\r\n            var axis = label.axis;\r\n            var coord = label.startXY;\r\n            var textElement = label.text;\r\n            var backgroundElement = label.background;\r\n            var text = \"\";\r\n            if (!axis.name || axis.name === axisName) {\r\n                text = axis.getFormattedValue(value, label.options, point)\r\n            }\r\n            if (text) {\r\n                textElement.attr({\r\n                    text: text,\r\n                    x: coord.x,\r\n                    y: coord.y\r\n                });\r\n                textElement.attr(func(textElement.getBBox(), label.pos.side, coord));\r\n                that._updateLinesCanvas(label);\r\n                backgroundElement.attr(getRectangleBBox(textElement.getBBox()))\r\n            } else {\r\n                textElement.attr({\r\n                    text: \"\"\r\n                });\r\n                backgroundElement.attr({\r\n                    x: 0,\r\n                    y: 0,\r\n                    width: 0,\r\n                    height: 0\r\n                })\r\n            }\r\n        }))\r\n    },\r\n    hide: function() {\r\n        this._crosshairGroup.attr({\r\n            visibility: \"hidden\"\r\n        })\r\n    },\r\n    _updateLinesCanvas: function(label) {\r\n        var position = label.pos.side;\r\n        var labelCoord = label.pos.coord;\r\n        var coords = this._linesCanvas;\r\n        var canvas = this._canvas;\r\n        coords[position] = coords[position] !== canvas[position] && mathAbs(coords[position] - canvas[position]) < mathAbs(labelCoord - canvas[position]) ? coords[position] : labelCoord\r\n    },\r\n    _updateLines: function(lines, x, y, r, isHorizontal) {\r\n        var coords = this._linesCanvas;\r\n        var canvas = this._canvas;\r\n        var points = isHorizontal ? [\r\n            [mathMin(x - r, coords.left), canvas.top, x - r, canvas.top],\r\n            [x + r, canvas.top, mathMax(coords.right, x + r), canvas.top]\r\n        ] : [\r\n            [canvas.left, mathMin(coords.top, y - r), canvas.left, y - r],\r\n            [canvas.left, y + r, canvas.left, mathMax(coords.bottom, y + r)]\r\n        ];\r\n        for (var i = 0; i < 2; i++) {\r\n            lines[i].attr({\r\n                points: points[i]\r\n            }).sharp(isHorizontal ? \"v\" : \"h\", isHorizontal ? y === canvas.bottom ? -1 : 1 : x === canvas.right ? -1 : 1)\r\n        }\r\n    },\r\n    _resetLinesCanvas: function() {\r\n        var canvas = this._canvas;\r\n        this._linesCanvas = {\r\n            left: canvas.left,\r\n            right: canvas.right,\r\n            top: canvas.top,\r\n            bottom: canvas.bottom\r\n        }\r\n    },\r\n    _getClipRectForPane: function(x, y) {\r\n        var panes = this._panes;\r\n        var i;\r\n        var coords;\r\n        for (i = 0; i < panes.length; i++) {\r\n            coords = panes[i].coords;\r\n            if (coords.left <= x && coords.right >= x && coords.top <= y && coords.bottom >= y) {\r\n                return panes[i].clipRect\r\n            }\r\n        }\r\n        return {\r\n            id: null\r\n        }\r\n    },\r\n    show: function(data) {\r\n        var point = data.point;\r\n        var pointData = point.getCrosshairData(data.x, data.y);\r\n        var r = point.getPointRadius();\r\n        var horizontal = this._horizontal;\r\n        var vertical = this._vertical;\r\n        var rad = !r ? 0 : r + 3;\r\n        var canvas = this._canvas;\r\n        var x = mathFloor(pointData.x);\r\n        var y = mathFloor(pointData.y);\r\n        if (x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom) {\r\n            this._crosshairGroup.attr({\r\n                visibility: \"visible\"\r\n            });\r\n            this._resetLinesCanvas();\r\n            this._circle.attr({\r\n                cx: x,\r\n                cy: y,\r\n                r: rad,\r\n                \"clip-path\": this._getClipRectForPane(x, y).id\r\n            });\r\n            if (horizontal.lines) {\r\n                this._updateText(pointData.yValue, pointData.axis, horizontal.labels, point, getLabelCheckerPosition(x, y, true, canvas));\r\n                this._updateLines(horizontal.lines, x, y, rad, true);\r\n                this._horizontalGroup.attr({\r\n                    translateY: y - canvas.top\r\n                })\r\n            }\r\n            if (vertical.lines) {\r\n                this._updateText(pointData.xValue, pointData.axis, vertical.labels, point, getLabelCheckerPosition(x, y, false, canvas));\r\n                this._updateLines(vertical.lines, x, y, rad, false);\r\n                this._verticalGroup.attr({\r\n                    translateX: x - canvas.left\r\n                })\r\n            }\r\n        } else {\r\n            this.hide()\r\n        }\r\n    }\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2NoYXJ0X2NvbXBvbmVudHMvY3Jvc3NoYWlyLmpzP2ZiYTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHdUI7QUFHVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG1CQUFtQixpRUFBTSxTQUFTO0FBQ2xDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixvREFBb0Qsb0VBQWdCO0FBQ3BFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2NoYXJ0X2NvbXBvbmVudHMvY3Jvc3NoYWlyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS92aXovY2hhcnRfY29tcG9uZW50cy9jcm9zc2hhaXIuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCB7XHJcbiAgICBwYXRjaEZvbnRPcHRpb25zXHJcbn0gZnJvbSBcIi4uL2NvcmUvdXRpbHNcIjtcclxuaW1wb3J0IHtcclxuICAgIGV4dGVuZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2V4dGVuZFwiO1xyXG52YXIgbWF0aCA9IE1hdGg7XHJcbnZhciBtYXRoQWJzID0gbWF0aC5hYnM7XHJcbnZhciBtYXRoTWluID0gbWF0aC5taW47XHJcbnZhciBtYXRoTWF4ID0gbWF0aC5tYXg7XHJcbnZhciBtYXRoRmxvb3IgPSBtYXRoLmZsb29yO1xyXG52YXIgSE9SSVpPTlRBTCA9IFwiaG9yaXpvbnRhbFwiO1xyXG52YXIgVkVSVElDQUwgPSBcInZlcnRpY2FsXCI7XHJcbnZhciBMQUJFTF9CQUNLR1JPVU5EX1BBRERJTkdfWCA9IDg7XHJcbnZhciBMQUJFTF9CQUNLR1JPVU5EX1BBRERJTkdfWSA9IDQ7XHJcbnZhciBDRU5URVIgPSBcImNlbnRlclwiO1xyXG52YXIgUklHSFQgPSBcInJpZ2h0XCI7XHJcbnZhciBMRUZUID0gXCJsZWZ0XCI7XHJcbnZhciBUT1AgPSBcInRvcFwiO1xyXG52YXIgQk9UVE9NID0gXCJib3R0b21cIjtcclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmdpbnMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IExBQkVMX0JBQ0tHUk9VTkRfUEFERElOR19YLFxyXG4gICAgICAgIHk6IExBQkVMX0JBQ0tHUk9VTkRfUEFERElOR19ZXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFJlY3RhbmdsZUJCb3goYkJveCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBiQm94LnggLSBMQUJFTF9CQUNLR1JPVU5EX1BBRERJTkdfWCxcclxuICAgICAgICB5OiBiQm94LnkgLSBMQUJFTF9CQUNLR1JPVU5EX1BBRERJTkdfWSxcclxuICAgICAgICB3aWR0aDogYkJveC53aWR0aCArIDIgKiBMQUJFTF9CQUNLR1JPVU5EX1BBRERJTkdfWCxcclxuICAgICAgICBoZWlnaHQ6IGJCb3guaGVpZ2h0ICsgMiAqIExBQkVMX0JBQ0tHUk9VTkRfUEFERElOR19ZXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldExhYmVsQ2hlY2tlclBvc2l0aW9uKHgsIHksIGlzSG9yaXpvbnRhbCwgY2FudmFzKSB7XHJcbiAgICB2YXIgcGFyYW1zID0gaXNIb3Jpem9udGFsID8gW1wieFwiLCBcIndpZHRoXCIsIFwieVwiLCBcImhlaWdodFwiLCB5LCAwXSA6IFtcInlcIiwgXCJoZWlnaHRcIiwgXCJ4XCIsIFwid2lkdGhcIiwgeCwgMV07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oYkJveCwgcG9zaXRpb24sIGNvb3JkKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsQ29vcmQgPSB7XHJcbiAgICAgICAgICAgIHg6IGNvb3JkLngsXHJcbiAgICAgICAgICAgIHk6IGNvb3JkLnlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByZWN0YW5nbGVCQm94ID0gZ2V0UmVjdGFuZ2xlQkJveChiQm94KTtcclxuICAgICAgICB2YXIgZGVsdGEgPSBpc0hvcml6b250YWwgPyBjb29yZC55IC0gYkJveC55IC0gYkJveC5oZWlnaHQgLyAyIDogY29vcmQueSAtIGJCb3gueTtcclxuICAgICAgICBsYWJlbENvb3JkLnkgPSBpc0hvcml6b250YWwgfHwgIWlzSG9yaXpvbnRhbCAmJiBwb3NpdGlvbiA9PT0gQk9UVE9NID8gY29vcmQueSArIGRlbHRhIDogY29vcmQueTtcclxuICAgICAgICBpZiAocmVjdGFuZ2xlQkJveFtwYXJhbXNbMF1dIDwgMCkge1xyXG4gICAgICAgICAgICBsYWJlbENvb3JkW3BhcmFtc1swXV0gLT0gcmVjdGFuZ2xlQkJveFtwYXJhbXNbMF1dXHJcbiAgICAgICAgfSBlbHNlIGlmIChyZWN0YW5nbGVCQm94W3BhcmFtc1swXV0gKyByZWN0YW5nbGVCQm94W3BhcmFtc1sxXV0gKyBkZWx0YSAqIHBhcmFtc1s1XSA+IGNhbnZhc1twYXJhbXNbMV1dKSB7XHJcbiAgICAgICAgICAgIGxhYmVsQ29vcmRbcGFyYW1zWzBdXSAtPSByZWN0YW5nbGVCQm94W3BhcmFtc1swXV0gKyByZWN0YW5nbGVCQm94W3BhcmFtc1sxXV0gKyBkZWx0YSAqIHBhcmFtc1s1XSAtIGNhbnZhc1twYXJhbXNbMV1dXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJhbXNbNF0gLSByZWN0YW5nbGVCQm94W3BhcmFtc1szXV0gLyAyIDwgMCkge1xyXG4gICAgICAgICAgICBsYWJlbENvb3JkW3BhcmFtc1syXV0gLT0gcGFyYW1zWzRdIC0gcmVjdGFuZ2xlQkJveFtwYXJhbXNbM11dIC8gMlxyXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zWzRdICsgcmVjdGFuZ2xlQkJveFtwYXJhbXNbM11dIC8gMiA+IGNhbnZhc1twYXJhbXNbM11dKSB7XHJcbiAgICAgICAgICAgIGxhYmVsQ29vcmRbcGFyYW1zWzJdXSAtPSBwYXJhbXNbNF0gKyByZWN0YW5nbGVCQm94W3BhcmFtc1szXV0gLyAyIC0gY2FudmFzW3BhcmFtc1szXV1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsQ29vcmRcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gQ3Jvc3NoYWlyKHJlbmRlcmVyLCBvcHRpb25zLCBwYXJhbXMsIGdyb3VwKSB7XHJcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG4gICAgdGhpcy5fY3Jvc3NoYWlyR3JvdXAgPSBncm91cDtcclxuICAgIHRoaXMuX29wdGlvbnMgPSB7fTtcclxuICAgIHRoaXMudXBkYXRlKG9wdGlvbnMsIHBhcmFtcylcclxufVxyXG5Dcm9zc2hhaXIucHJvdG90eXBlID0ge1xyXG4gICAgY29uc3RydWN0b3I6IENyb3NzaGFpcixcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24ob3B0aW9ucywgcGFyYW1zKSB7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IHBhcmFtcy5jYW52YXM7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzID0ge1xyXG4gICAgICAgICAgICB0b3A6IGNhbnZhcy50b3AsXHJcbiAgICAgICAgICAgIGJvdHRvbTogY2FudmFzLmhlaWdodCAtIGNhbnZhcy5ib3R0b20sXHJcbiAgICAgICAgICAgIGxlZnQ6IGNhbnZhcy5sZWZ0LFxyXG4gICAgICAgICAgICByaWdodDogY2FudmFzLndpZHRoIC0gY2FudmFzLnJpZ2h0LFxyXG4gICAgICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2F4ZXMgPSBwYXJhbXMuYXhlcztcclxuICAgICAgICB0aGlzLl9wYW5lcyA9IHBhcmFtcy5wYW5lcztcclxuICAgICAgICB0aGlzLl9wcmVwYXJlT3B0aW9ucyhvcHRpb25zLCBIT1JJWk9OVEFMKTtcclxuICAgICAgICB0aGlzLl9wcmVwYXJlT3B0aW9ucyhvcHRpb25zLCBWRVJUSUNBTClcclxuICAgIH0sXHJcbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IHRoaXMuX2Nyb3NzaGFpckdyb3VwID0gdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2F4ZXMgPSB0aGlzLl9jYW52YXMgPSB0aGlzLl9ob3Jpem9udGFsR3JvdXAgPSB0aGlzLl92ZXJ0aWNhbEdyb3VwID0gdGhpcy5faG9yaXpvbnRhbCA9IHRoaXMuX3ZlcnRpY2FsID0gdGhpcy5fY2lyY2xlID0gdGhpcy5fcGFuZXMgPSBudWxsXHJcbiAgICB9LFxyXG4gICAgX3ByZXBhcmVPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICB2YXIgbGluZU9wdGlvbnMgPSBvcHRpb25zW2RpcmVjdGlvbiArIFwiTGluZVwiXTtcclxuICAgICAgICB0aGlzLl9vcHRpb25zW2RpcmVjdGlvbl0gPSB7XHJcbiAgICAgICAgICAgIHZpc2libGU6IGxpbmVPcHRpb25zLnZpc2libGUsXHJcbiAgICAgICAgICAgIGxpbmU6IHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogbGluZU9wdGlvbnMuY29sb3IgfHwgb3B0aW9ucy5jb2xvcixcclxuICAgICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IGxpbmVPcHRpb25zLndpZHRoIHx8IG9wdGlvbnMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBkYXNoU3R5bGU6IGxpbmVPcHRpb25zLmRhc2hTdHlsZSB8fCBvcHRpb25zLmRhc2hTdHlsZSxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IGxpbmVPcHRpb25zLm9wYWNpdHkgfHwgb3B0aW9ucy5vcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiBcImJ1dHRcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsYWJlbDogZXh0ZW5kKHRydWUsIHt9LCBvcHRpb25zLmxhYmVsLCBsaW5lT3B0aW9ucy5sYWJlbClcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX2NyZWF0ZUxpbmVzOiBmdW5jdGlvbihvcHRpb25zLCBzaGFycFBhcmFtLCBncm91cCkge1xyXG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xyXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtjYW52YXMubGVmdCwgY2FudmFzLnRvcCwgY2FudmFzLmxlZnQsIGNhbnZhcy50b3BdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2godGhpcy5fcmVuZGVyZXIucGF0aChwb2ludHMsIFwibGluZVwiKS5hdHRyKG9wdGlvbnMpLnNoYXJwKHNoYXJwUGFyYW0pLmFwcGVuZChncm91cCkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaW5lc1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNhbE9wdGlvbnMgPSBvcHRpb25zLnZlcnRpY2FsO1xyXG4gICAgICAgIHZhciBob3Jpem9udGFsT3B0aW9ucyA9IG9wdGlvbnMuaG9yaXpvbnRhbDtcclxuICAgICAgICB2YXIgZXh0cmFPcHRpb25zID0gaG9yaXpvbnRhbE9wdGlvbnMudmlzaWJsZSA/IGhvcml6b250YWxPcHRpb25zLmxpbmUgOiB2ZXJ0aWNhbE9wdGlvbnMubGluZTtcclxuICAgICAgICB2YXIgY2lyY2xlT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgc3Ryb2tlOiBleHRyYU9wdGlvbnMuc3Ryb2tlLFxyXG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBleHRyYU9wdGlvbnNbXCJzdHJva2Utd2lkdGhcIl0sXHJcbiAgICAgICAgICAgIGRhc2hTdHlsZTogZXh0cmFPcHRpb25zLmRhc2hTdHlsZSxcclxuICAgICAgICAgICAgb3BhY2l0eTogZXh0cmFPcHRpb25zLm9wYWNpdHlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XHJcbiAgICAgICAgdGhpcy5faG9yaXpvbnRhbCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3ZlcnRpY2FsID0ge307XHJcbiAgICAgICAgdGhpcy5fY2lyY2xlID0gcmVuZGVyZXIuY2lyY2xlKGNhbnZhcy5sZWZ0LCBjYW52YXMudG9wLCAwKS5hdHRyKGNpcmNsZU9wdGlvbnMpLmFwcGVuZCh0aGlzLl9jcm9zc2hhaXJHcm91cCk7XHJcbiAgICAgICAgdGhpcy5faG9yaXpvbnRhbEdyb3VwID0gcmVuZGVyZXIuZygpLmFwcGVuZCh0aGlzLl9jcm9zc2hhaXJHcm91cCk7XHJcbiAgICAgICAgdGhpcy5fdmVydGljYWxHcm91cCA9IHJlbmRlcmVyLmcoKS5hcHBlbmQodGhpcy5fY3Jvc3NoYWlyR3JvdXApO1xyXG4gICAgICAgIGlmICh2ZXJ0aWNhbE9wdGlvbnMudmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl92ZXJ0aWNhbC5saW5lcyA9IHRoaXMuX2NyZWF0ZUxpbmVzKHZlcnRpY2FsT3B0aW9ucy5saW5lLCBcImhcIiwgdGhpcy5fdmVydGljYWxHcm91cCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRpY2FsLmxhYmVscyA9IHRoaXMuX2NyZWF0ZUxhYmVscyh0aGlzLl9heGVzWzBdLCB2ZXJ0aWNhbE9wdGlvbnMsIGZhbHNlLCB0aGlzLl92ZXJ0aWNhbEdyb3VwKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaG9yaXpvbnRhbE9wdGlvbnMudmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ob3Jpem9udGFsLmxpbmVzID0gdGhpcy5fY3JlYXRlTGluZXMoaG9yaXpvbnRhbE9wdGlvbnMubGluZSwgXCJ2XCIsIHRoaXMuX2hvcml6b250YWxHcm91cCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hvcml6b250YWwubGFiZWxzID0gdGhpcy5fY3JlYXRlTGFiZWxzKHRoaXMuX2F4ZXNbMV0sIGhvcml6b250YWxPcHRpb25zLCB0cnVlLCB0aGlzLl9ob3Jpem9udGFsR3JvdXApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGlkZSgpXHJcbiAgICB9LFxyXG4gICAgX2NyZWF0ZUxhYmVsczogZnVuY3Rpb24oYXhlcywgb3B0aW9ucywgaXNIb3Jpem9udGFsLCBncm91cCkge1xyXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XHJcbiAgICAgICAgdmFyIHg7XHJcbiAgICAgICAgdmFyIHk7XHJcbiAgICAgICAgdmFyIHRleHQ7XHJcbiAgICAgICAgdmFyIGxhYmVscyA9IFtdO1xyXG4gICAgICAgIHZhciBiYWNrZ3JvdW5kO1xyXG4gICAgICAgIHZhciBjdXJyZW50TGFiZWxQb3M7XHJcbiAgICAgICAgdmFyIGxhYmVsT3B0aW9ucyA9IG9wdGlvbnMubGFiZWw7XHJcbiAgICAgICAgaWYgKGxhYmVsT3B0aW9ucy52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIGF4ZXMuZm9yRWFjaCgoZnVuY3Rpb24oYXhpcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gYXhpcy5nZXRPcHRpb25zKCkucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoYXhpcy5nZXRUcmFuc2xhdG9yKCkuZ2V0QnVzaW5lc3NSYW5nZSgpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudExhYmVsUG9zID0gYXhpcy5nZXRMYWJlbHNQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBjYW52YXMudG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBjdXJyZW50TGFiZWxQb3NcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IGNhbnZhcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBjdXJyZW50TGFiZWxQb3NcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBhbGlnbiA9IHBvc2l0aW9uID09PSBUT1AgfHwgcG9zaXRpb24gPT09IEJPVFRPTSA/IENFTlRFUiA6IHBvc2l0aW9uID09PSBSSUdIVCA/IExFRlQgOiBSSUdIVDtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQgPSByZW5kZXJlci5yZWN0KDAsIDAsIDAsIDApLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IGxhYmVsT3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgfHwgb3B0aW9ucy5saW5lLnN0cm9rZVxyXG4gICAgICAgICAgICAgICAgfSkuYXBwZW5kKGdyb3VwKTtcclxuICAgICAgICAgICAgICAgIHRleHQgPSByZW5kZXJlci50ZXh0KFwiMFwiLCAwLCAwKS5jc3MocGF0Y2hGb250T3B0aW9ucyhvcHRpb25zLmxhYmVsLmZvbnQpKS5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbjogYWxpZ24sXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGxhYmVsT3B0aW9ucy5jc3NDbGFzc1xyXG4gICAgICAgICAgICAgICAgfSkuYXBwZW5kKGdyb3VwKTtcclxuICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGJhY2tncm91bmQsXHJcbiAgICAgICAgICAgICAgICAgICAgYXhpczogYXhpcyxcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBsYWJlbE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkOiBjdXJyZW50TGFiZWxQb3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGU6IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFhZOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsc1xyXG4gICAgfSxcclxuICAgIF91cGRhdGVUZXh0OiBmdW5jdGlvbih2YWx1ZSwgYXhpc05hbWUsIGxhYmVscywgcG9pbnQsIGZ1bmMpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgbGFiZWxzLmZvckVhY2goKGZ1bmN0aW9uKGxhYmVsKSB7XHJcbiAgICAgICAgICAgIHZhciBheGlzID0gbGFiZWwuYXhpcztcclxuICAgICAgICAgICAgdmFyIGNvb3JkID0gbGFiZWwuc3RhcnRYWTtcclxuICAgICAgICAgICAgdmFyIHRleHRFbGVtZW50ID0gbGFiZWwudGV4dDtcclxuICAgICAgICAgICAgdmFyIGJhY2tncm91bmRFbGVtZW50ID0gbGFiZWwuYmFja2dyb3VuZDtcclxuICAgICAgICAgICAgdmFyIHRleHQgPSBcIlwiO1xyXG4gICAgICAgICAgICBpZiAoIWF4aXMubmFtZSB8fCBheGlzLm5hbWUgPT09IGF4aXNOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gYXhpcy5nZXRGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSwgbGFiZWwub3B0aW9ucywgcG9pbnQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRleHQpIHtcclxuICAgICAgICAgICAgICAgIHRleHRFbGVtZW50LmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgeDogY29vcmQueCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBjb29yZC55XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRleHRFbGVtZW50LmF0dHIoZnVuYyh0ZXh0RWxlbWVudC5nZXRCQm94KCksIGxhYmVsLnBvcy5zaWRlLCBjb29yZCkpO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fdXBkYXRlTGluZXNDYW52YXMobGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEVsZW1lbnQuYXR0cihnZXRSZWN0YW5nbGVCQm94KHRleHRFbGVtZW50LmdldEJCb3goKSkpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0RWxlbWVudC5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRFbGVtZW50LmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSlcclxuICAgIH0sXHJcbiAgICBoaWRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLl9jcm9zc2hhaXJHcm91cC5hdHRyKHtcclxuICAgICAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIlxyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgX3VwZGF0ZUxpbmVzQ2FudmFzOiBmdW5jdGlvbihsYWJlbCkge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGxhYmVsLnBvcy5zaWRlO1xyXG4gICAgICAgIHZhciBsYWJlbENvb3JkID0gbGFiZWwucG9zLmNvb3JkO1xyXG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9saW5lc0NhbnZhcztcclxuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xyXG4gICAgICAgIGNvb3Jkc1twb3NpdGlvbl0gPSBjb29yZHNbcG9zaXRpb25dICE9PSBjYW52YXNbcG9zaXRpb25dICYmIG1hdGhBYnMoY29vcmRzW3Bvc2l0aW9uXSAtIGNhbnZhc1twb3NpdGlvbl0pIDwgbWF0aEFicyhsYWJlbENvb3JkIC0gY2FudmFzW3Bvc2l0aW9uXSkgPyBjb29yZHNbcG9zaXRpb25dIDogbGFiZWxDb29yZFxyXG4gICAgfSxcclxuICAgIF91cGRhdGVMaW5lczogZnVuY3Rpb24obGluZXMsIHgsIHksIHIsIGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9saW5lc0NhbnZhcztcclxuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBpc0hvcml6b250YWwgPyBbXHJcbiAgICAgICAgICAgIFttYXRoTWluKHggLSByLCBjb29yZHMubGVmdCksIGNhbnZhcy50b3AsIHggLSByLCBjYW52YXMudG9wXSxcclxuICAgICAgICAgICAgW3ggKyByLCBjYW52YXMudG9wLCBtYXRoTWF4KGNvb3Jkcy5yaWdodCwgeCArIHIpLCBjYW52YXMudG9wXVxyXG4gICAgICAgIF0gOiBbXHJcbiAgICAgICAgICAgIFtjYW52YXMubGVmdCwgbWF0aE1pbihjb29yZHMudG9wLCB5IC0gciksIGNhbnZhcy5sZWZ0LCB5IC0gcl0sXHJcbiAgICAgICAgICAgIFtjYW52YXMubGVmdCwgeSArIHIsIGNhbnZhcy5sZWZ0LCBtYXRoTWF4KGNvb3Jkcy5ib3R0b20sIHkgKyByKV1cclxuICAgICAgICBdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxpbmVzW2ldLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNbaV1cclxuICAgICAgICAgICAgfSkuc2hhcnAoaXNIb3Jpem9udGFsID8gXCJ2XCIgOiBcImhcIiwgaXNIb3Jpem9udGFsID8geSA9PT0gY2FudmFzLmJvdHRvbSA/IC0xIDogMSA6IHggPT09IGNhbnZhcy5yaWdodCA/IC0xIDogMSlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgX3Jlc2V0TGluZXNDYW52YXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XHJcbiAgICAgICAgdGhpcy5fbGluZXNDYW52YXMgPSB7XHJcbiAgICAgICAgICAgIGxlZnQ6IGNhbnZhcy5sZWZ0LFxyXG4gICAgICAgICAgICByaWdodDogY2FudmFzLnJpZ2h0LFxyXG4gICAgICAgICAgICB0b3A6IGNhbnZhcy50b3AsXHJcbiAgICAgICAgICAgIGJvdHRvbTogY2FudmFzLmJvdHRvbVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfZ2V0Q2xpcFJlY3RGb3JQYW5lOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgICAgdmFyIHBhbmVzID0gdGhpcy5fcGFuZXM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGNvb3JkcztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFuZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29vcmRzID0gcGFuZXNbaV0uY29vcmRzO1xyXG4gICAgICAgICAgICBpZiAoY29vcmRzLmxlZnQgPD0geCAmJiBjb29yZHMucmlnaHQgPj0geCAmJiBjb29yZHMudG9wIDw9IHkgJiYgY29vcmRzLmJvdHRvbSA+PSB5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFuZXNbaV0uY2xpcFJlY3RcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogbnVsbFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzaG93OiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgdmFyIHBvaW50ID0gZGF0YS5wb2ludDtcclxuICAgICAgICB2YXIgcG9pbnREYXRhID0gcG9pbnQuZ2V0Q3Jvc3NoYWlyRGF0YShkYXRhLngsIGRhdGEueSk7XHJcbiAgICAgICAgdmFyIHIgPSBwb2ludC5nZXRQb2ludFJhZGl1cygpO1xyXG4gICAgICAgIHZhciBob3Jpem9udGFsID0gdGhpcy5faG9yaXpvbnRhbDtcclxuICAgICAgICB2YXIgdmVydGljYWwgPSB0aGlzLl92ZXJ0aWNhbDtcclxuICAgICAgICB2YXIgcmFkID0gIXIgPyAwIDogciArIDM7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcclxuICAgICAgICB2YXIgeCA9IG1hdGhGbG9vcihwb2ludERhdGEueCk7XHJcbiAgICAgICAgdmFyIHkgPSBtYXRoRmxvb3IocG9pbnREYXRhLnkpO1xyXG4gICAgICAgIGlmICh4ID49IGNhbnZhcy5sZWZ0ICYmIHggPD0gY2FudmFzLnJpZ2h0ICYmIHkgPj0gY2FudmFzLnRvcCAmJiB5IDw9IGNhbnZhcy5ib3R0b20pIHtcclxuICAgICAgICAgICAgdGhpcy5fY3Jvc3NoYWlyR3JvdXAuYXR0cih7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBcInZpc2libGVcIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fcmVzZXRMaW5lc0NhbnZhcygpO1xyXG4gICAgICAgICAgICB0aGlzLl9jaXJjbGUuYXR0cih7XHJcbiAgICAgICAgICAgICAgICBjeDogeCxcclxuICAgICAgICAgICAgICAgIGN5OiB5LFxyXG4gICAgICAgICAgICAgICAgcjogcmFkLFxyXG4gICAgICAgICAgICAgICAgXCJjbGlwLXBhdGhcIjogdGhpcy5fZ2V0Q2xpcFJlY3RGb3JQYW5lKHgsIHkpLmlkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbC5saW5lcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGV4dChwb2ludERhdGEueVZhbHVlLCBwb2ludERhdGEuYXhpcywgaG9yaXpvbnRhbC5sYWJlbHMsIHBvaW50LCBnZXRMYWJlbENoZWNrZXJQb3NpdGlvbih4LCB5LCB0cnVlLCBjYW52YXMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxpbmVzKGhvcml6b250YWwubGluZXMsIHgsIHksIHJhZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ob3Jpem9udGFsR3JvdXAuYXR0cih7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogeSAtIGNhbnZhcy50b3BcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZlcnRpY2FsLmxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVUZXh0KHBvaW50RGF0YS54VmFsdWUsIHBvaW50RGF0YS5heGlzLCB2ZXJ0aWNhbC5sYWJlbHMsIHBvaW50LCBnZXRMYWJlbENoZWNrZXJQb3NpdGlvbih4LCB5LCBmYWxzZSwgY2FudmFzKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMaW5lcyh2ZXJ0aWNhbC5saW5lcywgeCwgeSwgcmFkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92ZXJ0aWNhbEdyb3VwLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg6IHggLSBjYW52YXMubGVmdFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/chart_components/crosshair.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/chart_components/multi_axes_synchronizer.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/chart_components/multi_axes_synchronizer.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_utils_console__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/utils/console */ \"./node_modules/devextreme/esm/core/utils/console.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/utils/math */ \"./node_modules/devextreme/esm/core/utils/math.js\");\n/**\r\n * DevExtreme (esm/viz/chart_components/multi_axes_synchronizer.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\nvar _math = Math;\r\nvar _floor = _math.floor;\r\nvar _max = _math.max;\r\nvar _abs = _math.abs;\r\n\r\nfunction getValueAxesPerPanes(valueAxes) {\r\n    var result = {};\r\n    valueAxes.forEach(axis => {\r\n        var pane = axis.pane;\r\n        if (!result[pane]) {\r\n            result[pane] = []\r\n        }\r\n        result[pane].push(axis)\r\n    });\r\n    return result\r\n}\r\nvar linearConverter = br => ({\r\n    transform: function(v, b) {\r\n        return Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_4__[\"adjust\"])(Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"getLogExt\"])(v, b, br.allowNegatives, br.linearThreshold))\r\n    },\r\n    getTicks: function(interval, tickValues, base) {\r\n        var ticks = [];\r\n        var tick = this.transform(tickValues[0], base);\r\n        while (ticks.length < tickValues.length) {\r\n            ticks.push(tick);\r\n            tick = Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_4__[\"adjust\"])(tick + interval)\r\n        }\r\n        return ticks\r\n    }\r\n});\r\nvar logConverter = br => ({\r\n    transform: function(v, b) {\r\n        return Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_4__[\"adjust\"])(Object(_core_utils__WEBPACK_IMPORTED_MODULE_3__[\"raiseToExt\"])(v, b, br.allowNegatives, br.linearThreshold))\r\n    },\r\n    getTicks: function(interval, tickValues, base) {\r\n        var ticks = [];\r\n        var tick;\r\n        for (var i = 0; i < tickValues.length; i += 1) {\r\n            tick = this.transform(tickValues[i], base);\r\n            ticks.push(tick)\r\n        }\r\n        return ticks\r\n    }\r\n});\r\n\r\nfunction convertAxisInfo(axisInfo, converter) {\r\n    if (!axisInfo.isLogarithmic) {\r\n        return\r\n    }\r\n    var base = axisInfo.logarithmicBase;\r\n    var tickValues = axisInfo.tickValues;\r\n    axisInfo.minValue = converter.transform(axisInfo.minValue, base);\r\n    axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);\r\n    axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);\r\n    axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);\r\n    axisInfo.tickInterval = _math.round(axisInfo.tickInterval);\r\n    if (axisInfo.tickInterval < 1) {\r\n        axisInfo.tickInterval = 1\r\n    }\r\n    var ticks = converter.getTicks(axisInfo.tickInterval, tickValues, base);\r\n    ticks.tickInterval = axisInfo.tickInterval;\r\n    axisInfo.tickValues = ticks\r\n}\r\n\r\nfunction populateAxesInfo(axes) {\r\n    return axes.reduce((function(result, axis) {\r\n        var ticksValues = axis.getTicksValues();\r\n        var majorTicks = ticksValues.majorTicksValues;\r\n        var options = axis.getOptions();\r\n        var businessRange = axis.getTranslator().getBusinessRange();\r\n        var visibleArea = axis.getVisibleArea();\r\n        var axisInfo;\r\n        var tickInterval = axis._tickInterval;\r\n        var synchronizedValue = options.synchronizedValue;\r\n        var action = axis.getViewport().action;\r\n        if (majorTicks && majorTicks.length > 0 && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isNumeric\"])(majorTicks[0]) && \"discrete\" !== options.type && !businessRange.isEmpty() && !(businessRange.breaks && businessRange.breaks.length) && \"zoom\" !== action && \"pan\" !== action) {\r\n            axis.applyMargins();\r\n            var startValue = axis.getTranslator().from(visibleArea[0]);\r\n            var endValue = axis.getTranslator().from(visibleArea[1]);\r\n            var minValue = startValue < endValue ? startValue : endValue;\r\n            var maxValue = startValue < endValue ? endValue : startValue;\r\n            if (minValue === maxValue && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(synchronizedValue)) {\r\n                tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;\r\n                minValue = majorTicks[0] - tickInterval;\r\n                maxValue = majorTicks[0] + tickInterval\r\n            }\r\n            axisInfo = {\r\n                axis: axis,\r\n                isLogarithmic: \"logarithmic\" === options.type,\r\n                logarithmicBase: businessRange.base,\r\n                tickValues: majorTicks,\r\n                minorValues: ticksValues.minorTicksValues,\r\n                minorTickInterval: axis._minorTickInterval,\r\n                minValue: minValue,\r\n                oldMinValue: minValue,\r\n                maxValue: maxValue,\r\n                oldMaxValue: maxValue,\r\n                inverted: businessRange.invert,\r\n                tickInterval: tickInterval,\r\n                synchronizedValue: synchronizedValue\r\n            };\r\n            convertAxisInfo(axisInfo, linearConverter(axis.getTranslator().getBusinessRange()));\r\n            result.push(axisInfo)\r\n        }\r\n        return result\r\n    }), [])\r\n}\r\n\r\nfunction updateTickValues(axesInfo) {\r\n    var maxTicksCount = axesInfo.reduce((max, axisInfo) => _max(max, axisInfo.tickValues.length), 0);\r\n    axesInfo.forEach(axisInfo => {\r\n        var ticksMultiplier;\r\n        var ticksCount;\r\n        var additionalStartTicksCount = 0;\r\n        var synchronizedValue = axisInfo.synchronizedValue;\r\n        var tickValues = axisInfo.tickValues;\r\n        var tickInterval = axisInfo.tickInterval;\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(synchronizedValue)) {\r\n            axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;\r\n            axisInfo.tickValues = [axisInfo.baseTickValue]\r\n        } else {\r\n            if (tickValues.length > 1 && tickInterval) {\r\n                ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);\r\n                ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;\r\n                additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);\r\n                while (additionalStartTicksCount > 0 && 0 !== tickValues[0]) {\r\n                    tickValues.unshift(Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_4__[\"adjust\"])(tickValues[0] - tickInterval));\r\n                    additionalStartTicksCount--\r\n                }\r\n                while (tickValues.length < ticksCount) {\r\n                    tickValues.push(Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_4__[\"adjust\"])(tickValues[tickValues.length - 1] + tickInterval))\r\n                }\r\n                axisInfo.tickInterval = tickInterval / ticksMultiplier\r\n            }\r\n            axisInfo.baseTickValue = tickValues[0];\r\n            axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1]\r\n        }\r\n    })\r\n}\r\n\r\nfunction getAxisRange(axisInfo) {\r\n    return axisInfo.maxValue - axisInfo.minValue || 1\r\n}\r\n\r\nfunction getMainAxisInfo(axesInfo) {\r\n    for (var i = 0; i < axesInfo.length; i++) {\r\n        if (!axesInfo[i].stubData) {\r\n            return axesInfo[i]\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nfunction correctMinMaxValues(axesInfo) {\r\n    var mainAxisInfo = getMainAxisInfo(axesInfo);\r\n    var mainAxisInfoTickInterval = mainAxisInfo.tickInterval;\r\n    axesInfo.forEach(axisInfo => {\r\n        var scale;\r\n        var move;\r\n        var mainAxisBaseValueOffset;\r\n        var valueFromAxisInfo;\r\n        if (axisInfo !== mainAxisInfo) {\r\n            if (mainAxisInfoTickInterval && axisInfo.tickInterval) {\r\n                if (axisInfo.stubData && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(axisInfo.synchronizedValue)) {\r\n                    axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;\r\n                    axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval\r\n                }\r\n                scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);\r\n                axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale\r\n            }\r\n            if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {\r\n                mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue\r\n            } else {\r\n                mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue\r\n            }\r\n            valueFromAxisInfo = getAxisRange(axisInfo);\r\n            move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;\r\n            axisInfo.minValue -= move;\r\n            axisInfo.maxValue -= move\r\n        }\r\n    })\r\n}\r\n\r\nfunction calculatePaddings(axesInfo) {\r\n    var minPadding;\r\n    var maxPadding;\r\n    var startPadding = 0;\r\n    var endPadding = 0;\r\n    axesInfo.forEach(axisInfo => {\r\n        var inverted = axisInfo.inverted;\r\n        minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;\r\n        maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;\r\n        startPadding = _max(startPadding, inverted ? maxPadding : minPadding);\r\n        endPadding = _max(endPadding, inverted ? minPadding : maxPadding)\r\n    });\r\n    return {\r\n        start: startPadding,\r\n        end: endPadding\r\n    }\r\n}\r\n\r\nfunction correctMinMaxValuesByPaddings(axesInfo, paddings) {\r\n    axesInfo.forEach(info => {\r\n        var range = getAxisRange(info);\r\n        var inverted = info.inverted;\r\n        info.minValue = Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_4__[\"adjust\"])(info.minValue - paddings[inverted ? \"end\" : \"start\"] * range);\r\n        info.maxValue = Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_4__[\"adjust\"])(info.maxValue + paddings[inverted ? \"start\" : \"end\"] * range)\r\n    })\r\n}\r\n\r\nfunction updateTickValuesIfSynchronizedValueUsed(axesInfo) {\r\n    var hasSynchronizedValue = false;\r\n    axesInfo.forEach(info => {\r\n        hasSynchronizedValue = hasSynchronizedValue || Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(info.synchronizedValue)\r\n    });\r\n    axesInfo.forEach(info => {\r\n        var tickInterval = info.tickInterval;\r\n        var tickValues = info.tickValues;\r\n        var maxValue = info.maxValue;\r\n        var minValue = info.minValue;\r\n        var tick;\r\n        if (hasSynchronizedValue && tickInterval) {\r\n            while ((tick = Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_4__[\"adjust\"])(tickValues[0] - tickInterval)) >= minValue) {\r\n                tickValues.unshift(tick)\r\n            }\r\n            tick = tickValues[tickValues.length - 1];\r\n            while ((tick = Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_4__[\"adjust\"])(tick + tickInterval)) <= maxValue) {\r\n                tickValues.push(tick)\r\n            }\r\n        }\r\n        while (tickValues[0] + tickInterval / 10 < minValue) {\r\n            tickValues.shift()\r\n        }\r\n        while (tickValues[tickValues.length - 1] - tickInterval / 10 > maxValue) {\r\n            tickValues.pop()\r\n        }\r\n    })\r\n}\r\n\r\nfunction applyMinMaxValues(axesInfo) {\r\n    axesInfo.forEach(info => {\r\n        var axis = info.axis;\r\n        var range = axis.getTranslator().getBusinessRange();\r\n        if (range.min === range.minVisible) {\r\n            range.min = info.minValue\r\n        }\r\n        if (range.max === range.maxVisible) {\r\n            range.max = info.maxValue\r\n        }\r\n        range.minVisible = info.minValue;\r\n        range.maxVisible = info.maxValue;\r\n        if (range.min > range.minVisible) {\r\n            range.min = range.minVisible\r\n        }\r\n        if (range.max < range.maxVisible) {\r\n            range.max = range.maxVisible\r\n        }\r\n        axis.getTranslator().updateBusinessRange(range);\r\n        axis.setTicks({\r\n            majorTicks: info.tickValues,\r\n            minorTicks: info.minorValues\r\n        })\r\n    })\r\n}\r\n\r\nfunction correctAfterSynchronize(axesInfo) {\r\n    var invalidAxisInfo = [];\r\n    var correctValue;\r\n    axesInfo.forEach(info => {\r\n        if (info.oldMaxValue - info.oldMinValue === 0) {\r\n            invalidAxisInfo.push(info)\r\n        } else if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(correctValue) && !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(info.synchronizedValue)) {\r\n            correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] - info.minValue || info.maxValue))\r\n        }\r\n    });\r\n    if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(correctValue)) {\r\n        return\r\n    }\r\n    invalidAxisInfo.forEach(info => {\r\n        var firstTick = info.tickValues[0];\r\n        var correctedTick = firstTick * correctValue;\r\n        if (firstTick > 0) {\r\n            info.maxValue = correctedTick;\r\n            info.minValue = 0\r\n        } else if (firstTick < 0) {\r\n            info.minValue = correctedTick;\r\n            info.maxValue = 0\r\n        }\r\n    })\r\n}\r\n\r\nfunction updateMinorTicks(axesInfo) {\r\n    axesInfo.forEach((function(axisInfo) {\r\n        if (!axisInfo.minorTickInterval) {\r\n            return\r\n        }\r\n        var ticks = [];\r\n        var interval = axisInfo.minorTickInterval;\r\n        var tickCount = axisInfo.tickInterval / interval - 1;\r\n        for (var i = 1; i < axisInfo.tickValues.length; i++) {\r\n            var tick = axisInfo.tickValues[i - 1];\r\n            for (var j = 0; j < tickCount; j++) {\r\n                tick += interval;\r\n                ticks.push(tick)\r\n            }\r\n        }\r\n        axisInfo.minorValues = ticks\r\n    }))\r\n}\r\n\r\nfunction correctPaddings(axesInfo, paddings) {\r\n    return axesInfo.reduce((prev, info) => {\r\n        var inverted = info.inverted;\r\n        var {\r\n            start: start,\r\n            end: end\r\n        } = info.axis.getCorrectedValuesToZero(info.minValue, info.maxValue);\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(start) || Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(end)) {\r\n            return inverted ? {\r\n                start: prev.start,\r\n                end: Math.min(prev.end, end)\r\n            } : {\r\n                start: Math.min(prev.start, start),\r\n                end: prev.end\r\n            }\r\n        }\r\n        return prev\r\n    }, paddings)\r\n}\r\nvar multiAxesSynchronizer = {\r\n    synchronize: function(valueAxes) {\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__[\"each\"])(getValueAxesPerPanes(valueAxes), (function(_, axes) {\r\n            var axesInfo;\r\n            var paddings;\r\n            if (axes.length > 1) {\r\n                axesInfo = populateAxesInfo(axes);\r\n                if (axesInfo.length < 2 || !getMainAxisInfo(axesInfo)) {\r\n                    return\r\n                }\r\n                updateTickValues(axesInfo);\r\n                correctMinMaxValues(axesInfo);\r\n                paddings = calculatePaddings(axesInfo);\r\n                paddings = correctPaddings(axesInfo, paddings);\r\n                correctMinMaxValuesByPaddings(axesInfo, paddings);\r\n                correctAfterSynchronize(axesInfo);\r\n                updateTickValuesIfSynchronizedValueUsed(axesInfo);\r\n                updateMinorTicks(axesInfo);\r\n                axesInfo.forEach(info => {\r\n                    convertAxisInfo(info, logConverter(info.axis.getTranslator().getBusinessRange()))\r\n                });\r\n                applyMinMaxValues(axesInfo)\r\n            }\r\n        }))\r\n    }\r\n};\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (multiAxesSynchronizer);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2NoYXJ0X2NvbXBvbmVudHMvbXVsdGlfYXhlc19zeW5jaHJvbml6ZXIuanM/YTJiMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR2tDO0FBSUg7QUFHSTtBQUlaO0FBR1E7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQU0sQ0FBQyw2REFBUztBQUMvQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGVBQWUsK0RBQU0sQ0FBQyw4REFBVTtBQUNoQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxrRUFBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtFQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBUztBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0RBQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtEQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrRUFBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrREFBTTtBQUM5Qix3QkFBd0IsK0RBQU07QUFDOUIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrRUFBUztBQUNoRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtEQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXLGtFQUFTLG1CQUFtQixrRUFBUztBQUN6RDtBQUNBO0FBQ0EsS0FBSztBQUNMLFNBQVMsa0VBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxZQUFZLGtFQUFTLFdBQVcsa0VBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ2Usb0ZBQXFCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2NoYXJ0X2NvbXBvbmVudHMvbXVsdGlfYXhlc19zeW5jaHJvbml6ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3Zpei9jaGFydF9jb21wb25lbnRzL211bHRpX2F4ZXNfc3luY2hyb25pemVyLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQge1xyXG4gICAgZGVidWdcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9jb25zb2xlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBpc0RlZmluZWQsXHJcbiAgICBpc051bWVyaWNcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy90eXBlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBlYWNoXHJcbn0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvaXRlcmF0b3JcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldExvZ0V4dCxcclxuICAgIHJhaXNlVG9FeHRcclxufSBmcm9tIFwiLi4vY29yZS91dGlsc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgYWRqdXN0XHJcbn0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvbWF0aFwiO1xyXG52YXIgX21hdGggPSBNYXRoO1xyXG52YXIgX2Zsb29yID0gX21hdGguZmxvb3I7XHJcbnZhciBfbWF4ID0gX21hdGgubWF4O1xyXG52YXIgX2FicyA9IF9tYXRoLmFicztcclxuXHJcbmZ1bmN0aW9uIGdldFZhbHVlQXhlc1BlclBhbmVzKHZhbHVlQXhlcykge1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgdmFsdWVBeGVzLmZvckVhY2goYXhpcyA9PiB7XHJcbiAgICAgICAgdmFyIHBhbmUgPSBheGlzLnBhbmU7XHJcbiAgICAgICAgaWYgKCFyZXN1bHRbcGFuZV0pIHtcclxuICAgICAgICAgICAgcmVzdWx0W3BhbmVdID0gW11cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0W3BhbmVdLnB1c2goYXhpcylcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG59XHJcbnZhciBsaW5lYXJDb252ZXJ0ZXIgPSBiciA9PiAoe1xyXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbih2LCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGFkanVzdChnZXRMb2dFeHQodiwgYiwgYnIuYWxsb3dOZWdhdGl2ZXMsIGJyLmxpbmVhclRocmVzaG9sZCkpXHJcbiAgICB9LFxyXG4gICAgZ2V0VGlja3M6IGZ1bmN0aW9uKGludGVydmFsLCB0aWNrVmFsdWVzLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIHRpY2tzID0gW107XHJcbiAgICAgICAgdmFyIHRpY2sgPSB0aGlzLnRyYW5zZm9ybSh0aWNrVmFsdWVzWzBdLCBiYXNlKTtcclxuICAgICAgICB3aGlsZSAodGlja3MubGVuZ3RoIDwgdGlja1ZhbHVlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGlja3MucHVzaCh0aWNrKTtcclxuICAgICAgICAgICAgdGljayA9IGFkanVzdCh0aWNrICsgaW50ZXJ2YWwpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aWNrc1xyXG4gICAgfVxyXG59KTtcclxudmFyIGxvZ0NvbnZlcnRlciA9IGJyID0+ICh7XHJcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHYsIGIpIHtcclxuICAgICAgICByZXR1cm4gYWRqdXN0KHJhaXNlVG9FeHQodiwgYiwgYnIuYWxsb3dOZWdhdGl2ZXMsIGJyLmxpbmVhclRocmVzaG9sZCkpXHJcbiAgICB9LFxyXG4gICAgZ2V0VGlja3M6IGZ1bmN0aW9uKGludGVydmFsLCB0aWNrVmFsdWVzLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIHRpY2tzID0gW107XHJcbiAgICAgICAgdmFyIHRpY2s7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrVmFsdWVzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIHRpY2sgPSB0aGlzLnRyYW5zZm9ybSh0aWNrVmFsdWVzW2ldLCBiYXNlKTtcclxuICAgICAgICAgICAgdGlja3MucHVzaCh0aWNrKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGlja3NcclxuICAgIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBjb252ZXJ0QXhpc0luZm8oYXhpc0luZm8sIGNvbnZlcnRlcikge1xyXG4gICAgaWYgKCFheGlzSW5mby5pc0xvZ2FyaXRobWljKSB7XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICB2YXIgYmFzZSA9IGF4aXNJbmZvLmxvZ2FyaXRobWljQmFzZTtcclxuICAgIHZhciB0aWNrVmFsdWVzID0gYXhpc0luZm8udGlja1ZhbHVlcztcclxuICAgIGF4aXNJbmZvLm1pblZhbHVlID0gY29udmVydGVyLnRyYW5zZm9ybShheGlzSW5mby5taW5WYWx1ZSwgYmFzZSk7XHJcbiAgICBheGlzSW5mby5vbGRNaW5WYWx1ZSA9IGNvbnZlcnRlci50cmFuc2Zvcm0oYXhpc0luZm8ub2xkTWluVmFsdWUsIGJhc2UpO1xyXG4gICAgYXhpc0luZm8ubWF4VmFsdWUgPSBjb252ZXJ0ZXIudHJhbnNmb3JtKGF4aXNJbmZvLm1heFZhbHVlLCBiYXNlKTtcclxuICAgIGF4aXNJbmZvLm9sZE1heFZhbHVlID0gY29udmVydGVyLnRyYW5zZm9ybShheGlzSW5mby5vbGRNYXhWYWx1ZSwgYmFzZSk7XHJcbiAgICBheGlzSW5mby50aWNrSW50ZXJ2YWwgPSBfbWF0aC5yb3VuZChheGlzSW5mby50aWNrSW50ZXJ2YWwpO1xyXG4gICAgaWYgKGF4aXNJbmZvLnRpY2tJbnRlcnZhbCA8IDEpIHtcclxuICAgICAgICBheGlzSW5mby50aWNrSW50ZXJ2YWwgPSAxXHJcbiAgICB9XHJcbiAgICB2YXIgdGlja3MgPSBjb252ZXJ0ZXIuZ2V0VGlja3MoYXhpc0luZm8udGlja0ludGVydmFsLCB0aWNrVmFsdWVzLCBiYXNlKTtcclxuICAgIHRpY2tzLnRpY2tJbnRlcnZhbCA9IGF4aXNJbmZvLnRpY2tJbnRlcnZhbDtcclxuICAgIGF4aXNJbmZvLnRpY2tWYWx1ZXMgPSB0aWNrc1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb3B1bGF0ZUF4ZXNJbmZvKGF4ZXMpIHtcclxuICAgIHJldHVybiBheGVzLnJlZHVjZSgoZnVuY3Rpb24ocmVzdWx0LCBheGlzKSB7XHJcbiAgICAgICAgdmFyIHRpY2tzVmFsdWVzID0gYXhpcy5nZXRUaWNrc1ZhbHVlcygpO1xyXG4gICAgICAgIHZhciBtYWpvclRpY2tzID0gdGlja3NWYWx1ZXMubWFqb3JUaWNrc1ZhbHVlcztcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGF4aXMuZ2V0T3B0aW9ucygpO1xyXG4gICAgICAgIHZhciBidXNpbmVzc1JhbmdlID0gYXhpcy5nZXRUcmFuc2xhdG9yKCkuZ2V0QnVzaW5lc3NSYW5nZSgpO1xyXG4gICAgICAgIHZhciB2aXNpYmxlQXJlYSA9IGF4aXMuZ2V0VmlzaWJsZUFyZWEoKTtcclxuICAgICAgICB2YXIgYXhpc0luZm87XHJcbiAgICAgICAgdmFyIHRpY2tJbnRlcnZhbCA9IGF4aXMuX3RpY2tJbnRlcnZhbDtcclxuICAgICAgICB2YXIgc3luY2hyb25pemVkVmFsdWUgPSBvcHRpb25zLnN5bmNocm9uaXplZFZhbHVlO1xyXG4gICAgICAgIHZhciBhY3Rpb24gPSBheGlzLmdldFZpZXdwb3J0KCkuYWN0aW9uO1xyXG4gICAgICAgIGlmIChtYWpvclRpY2tzICYmIG1ham9yVGlja3MubGVuZ3RoID4gMCAmJiBpc051bWVyaWMobWFqb3JUaWNrc1swXSkgJiYgXCJkaXNjcmV0ZVwiICE9PSBvcHRpb25zLnR5cGUgJiYgIWJ1c2luZXNzUmFuZ2UuaXNFbXB0eSgpICYmICEoYnVzaW5lc3NSYW5nZS5icmVha3MgJiYgYnVzaW5lc3NSYW5nZS5icmVha3MubGVuZ3RoKSAmJiBcInpvb21cIiAhPT0gYWN0aW9uICYmIFwicGFuXCIgIT09IGFjdGlvbikge1xyXG4gICAgICAgICAgICBheGlzLmFwcGx5TWFyZ2lucygpO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRWYWx1ZSA9IGF4aXMuZ2V0VHJhbnNsYXRvcigpLmZyb20odmlzaWJsZUFyZWFbMF0pO1xyXG4gICAgICAgICAgICB2YXIgZW5kVmFsdWUgPSBheGlzLmdldFRyYW5zbGF0b3IoKS5mcm9tKHZpc2libGVBcmVhWzFdKTtcclxuICAgICAgICAgICAgdmFyIG1pblZhbHVlID0gc3RhcnRWYWx1ZSA8IGVuZFZhbHVlID8gc3RhcnRWYWx1ZSA6IGVuZFZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgbWF4VmFsdWUgPSBzdGFydFZhbHVlIDwgZW5kVmFsdWUgPyBlbmRWYWx1ZSA6IHN0YXJ0VmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChtaW5WYWx1ZSA9PT0gbWF4VmFsdWUgJiYgaXNEZWZpbmVkKHN5bmNocm9uaXplZFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGlja0ludGVydmFsID0gX2FicyhtYWpvclRpY2tzWzBdIC0gc3luY2hyb25pemVkVmFsdWUpIHx8IDE7XHJcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IG1ham9yVGlja3NbMF0gLSB0aWNrSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IG1ham9yVGlja3NbMF0gKyB0aWNrSW50ZXJ2YWxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBheGlzSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIGF4aXM6IGF4aXMsXHJcbiAgICAgICAgICAgICAgICBpc0xvZ2FyaXRobWljOiBcImxvZ2FyaXRobWljXCIgPT09IG9wdGlvbnMudHlwZSxcclxuICAgICAgICAgICAgICAgIGxvZ2FyaXRobWljQmFzZTogYnVzaW5lc3NSYW5nZS5iYXNlLFxyXG4gICAgICAgICAgICAgICAgdGlja1ZhbHVlczogbWFqb3JUaWNrcyxcclxuICAgICAgICAgICAgICAgIG1pbm9yVmFsdWVzOiB0aWNrc1ZhbHVlcy5taW5vclRpY2tzVmFsdWVzLFxyXG4gICAgICAgICAgICAgICAgbWlub3JUaWNrSW50ZXJ2YWw6IGF4aXMuX21pbm9yVGlja0ludGVydmFsLFxyXG4gICAgICAgICAgICAgICAgbWluVmFsdWU6IG1pblZhbHVlLFxyXG4gICAgICAgICAgICAgICAgb2xkTWluVmFsdWU6IG1pblZhbHVlLFxyXG4gICAgICAgICAgICAgICAgbWF4VmFsdWU6IG1heFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgb2xkTWF4VmFsdWU6IG1heFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWQ6IGJ1c2luZXNzUmFuZ2UuaW52ZXJ0LFxyXG4gICAgICAgICAgICAgICAgdGlja0ludGVydmFsOiB0aWNrSW50ZXJ2YWwsXHJcbiAgICAgICAgICAgICAgICBzeW5jaHJvbml6ZWRWYWx1ZTogc3luY2hyb25pemVkVmFsdWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29udmVydEF4aXNJbmZvKGF4aXNJbmZvLCBsaW5lYXJDb252ZXJ0ZXIoYXhpcy5nZXRUcmFuc2xhdG9yKCkuZ2V0QnVzaW5lc3NSYW5nZSgpKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGF4aXNJbmZvKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICB9KSwgW10pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVRpY2tWYWx1ZXMoYXhlc0luZm8pIHtcclxuICAgIHZhciBtYXhUaWNrc0NvdW50ID0gYXhlc0luZm8ucmVkdWNlKChtYXgsIGF4aXNJbmZvKSA9PiBfbWF4KG1heCwgYXhpc0luZm8udGlja1ZhbHVlcy5sZW5ndGgpLCAwKTtcclxuICAgIGF4ZXNJbmZvLmZvckVhY2goYXhpc0luZm8gPT4ge1xyXG4gICAgICAgIHZhciB0aWNrc011bHRpcGxpZXI7XHJcbiAgICAgICAgdmFyIHRpY2tzQ291bnQ7XHJcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxTdGFydFRpY2tzQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciBzeW5jaHJvbml6ZWRWYWx1ZSA9IGF4aXNJbmZvLnN5bmNocm9uaXplZFZhbHVlO1xyXG4gICAgICAgIHZhciB0aWNrVmFsdWVzID0gYXhpc0luZm8udGlja1ZhbHVlcztcclxuICAgICAgICB2YXIgdGlja0ludGVydmFsID0gYXhpc0luZm8udGlja0ludGVydmFsO1xyXG4gICAgICAgIGlmIChpc0RlZmluZWQoc3luY2hyb25pemVkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGF4aXNJbmZvLmJhc2VUaWNrVmFsdWUgPSBheGlzSW5mby5pbnZlcnRlZEJhc2VUaWNrVmFsdWUgPSBzeW5jaHJvbml6ZWRWYWx1ZTtcclxuICAgICAgICAgICAgYXhpc0luZm8udGlja1ZhbHVlcyA9IFtheGlzSW5mby5iYXNlVGlja1ZhbHVlXVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aWNrVmFsdWVzLmxlbmd0aCA+IDEgJiYgdGlja0ludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICB0aWNrc011bHRpcGxpZXIgPSBfZmxvb3IoKG1heFRpY2tzQ291bnQgKyAxKSAvIHRpY2tWYWx1ZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHRpY2tzQ291bnQgPSB0aWNrc011bHRpcGxpZXIgPiAxID8gX2Zsb29yKChtYXhUaWNrc0NvdW50ICsgMSkgLyB0aWNrc011bHRpcGxpZXIpIDogbWF4VGlja3NDb3VudDtcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxTdGFydFRpY2tzQ291bnQgPSBfZmxvb3IoKHRpY2tzQ291bnQgLSB0aWNrVmFsdWVzLmxlbmd0aCkgLyAyKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChhZGRpdGlvbmFsU3RhcnRUaWNrc0NvdW50ID4gMCAmJiAwICE9PSB0aWNrVmFsdWVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlja1ZhbHVlcy51bnNoaWZ0KGFkanVzdCh0aWNrVmFsdWVzWzBdIC0gdGlja0ludGVydmFsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFN0YXJ0VGlja3NDb3VudC0tXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodGlja1ZhbHVlcy5sZW5ndGggPCB0aWNrc0NvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlja1ZhbHVlcy5wdXNoKGFkanVzdCh0aWNrVmFsdWVzW3RpY2tWYWx1ZXMubGVuZ3RoIC0gMV0gKyB0aWNrSW50ZXJ2YWwpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXhpc0luZm8udGlja0ludGVydmFsID0gdGlja0ludGVydmFsIC8gdGlja3NNdWx0aXBsaWVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXhpc0luZm8uYmFzZVRpY2tWYWx1ZSA9IHRpY2tWYWx1ZXNbMF07XHJcbiAgICAgICAgICAgIGF4aXNJbmZvLmludmVydGVkQmFzZVRpY2tWYWx1ZSA9IHRpY2tWYWx1ZXNbdGlja1ZhbHVlcy5sZW5ndGggLSAxXVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEF4aXNSYW5nZShheGlzSW5mbykge1xyXG4gICAgcmV0dXJuIGF4aXNJbmZvLm1heFZhbHVlIC0gYXhpc0luZm8ubWluVmFsdWUgfHwgMVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNYWluQXhpc0luZm8oYXhlc0luZm8pIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlc0luZm8ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoIWF4ZXNJbmZvW2ldLnN0dWJEYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBheGVzSW5mb1tpXVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcnJlY3RNaW5NYXhWYWx1ZXMoYXhlc0luZm8pIHtcclxuICAgIHZhciBtYWluQXhpc0luZm8gPSBnZXRNYWluQXhpc0luZm8oYXhlc0luZm8pO1xyXG4gICAgdmFyIG1haW5BeGlzSW5mb1RpY2tJbnRlcnZhbCA9IG1haW5BeGlzSW5mby50aWNrSW50ZXJ2YWw7XHJcbiAgICBheGVzSW5mby5mb3JFYWNoKGF4aXNJbmZvID0+IHtcclxuICAgICAgICB2YXIgc2NhbGU7XHJcbiAgICAgICAgdmFyIG1vdmU7XHJcbiAgICAgICAgdmFyIG1haW5BeGlzQmFzZVZhbHVlT2Zmc2V0O1xyXG4gICAgICAgIHZhciB2YWx1ZUZyb21BeGlzSW5mbztcclxuICAgICAgICBpZiAoYXhpc0luZm8gIT09IG1haW5BeGlzSW5mbykge1xyXG4gICAgICAgICAgICBpZiAobWFpbkF4aXNJbmZvVGlja0ludGVydmFsICYmIGF4aXNJbmZvLnRpY2tJbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGF4aXNJbmZvLnN0dWJEYXRhICYmIGlzRGVmaW5lZChheGlzSW5mby5zeW5jaHJvbml6ZWRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBheGlzSW5mby5vbGRNaW5WYWx1ZSA9IGF4aXNJbmZvLm1pblZhbHVlID0gYXhpc0luZm8uYmFzZVRpY2tWYWx1ZSAtIChtYWluQXhpc0luZm8uYmFzZVRpY2tWYWx1ZSAtIG1haW5BeGlzSW5mby5taW5WYWx1ZSkgLyBtYWluQXhpc0luZm9UaWNrSW50ZXJ2YWwgKiBheGlzSW5mby50aWNrSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc0luZm8ub2xkTWF4VmFsdWUgPSBheGlzSW5mby5tYXhWYWx1ZSA9IGF4aXNJbmZvLmJhc2VUaWNrVmFsdWUgLSAobWFpbkF4aXNJbmZvLmJhc2VUaWNrVmFsdWUgLSBtYWluQXhpc0luZm8ubWF4VmFsdWUpIC8gbWFpbkF4aXNJbmZvVGlja0ludGVydmFsICogYXhpc0luZm8udGlja0ludGVydmFsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzY2FsZSA9IG1haW5BeGlzSW5mb1RpY2tJbnRlcnZhbCAvIGdldEF4aXNSYW5nZShtYWluQXhpc0luZm8pIC8gYXhpc0luZm8udGlja0ludGVydmFsICogZ2V0QXhpc1JhbmdlKGF4aXNJbmZvKTtcclxuICAgICAgICAgICAgICAgIGF4aXNJbmZvLm1heFZhbHVlID0gYXhpc0luZm8ubWluVmFsdWUgKyBnZXRBeGlzUmFuZ2UoYXhpc0luZm8pIC8gc2NhbGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWFpbkF4aXNJbmZvLmludmVydGVkICYmICFheGlzSW5mby5pbnZlcnRlZCB8fCAhbWFpbkF4aXNJbmZvLmludmVydGVkICYmIGF4aXNJbmZvLmludmVydGVkKSB7XHJcbiAgICAgICAgICAgICAgICBtYWluQXhpc0Jhc2VWYWx1ZU9mZnNldCA9IG1haW5BeGlzSW5mby5tYXhWYWx1ZSAtIG1haW5BeGlzSW5mby5pbnZlcnRlZEJhc2VUaWNrVmFsdWVcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1haW5BeGlzQmFzZVZhbHVlT2Zmc2V0ID0gbWFpbkF4aXNJbmZvLmJhc2VUaWNrVmFsdWUgLSBtYWluQXhpc0luZm8ubWluVmFsdWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWx1ZUZyb21BeGlzSW5mbyA9IGdldEF4aXNSYW5nZShheGlzSW5mbyk7XHJcbiAgICAgICAgICAgIG1vdmUgPSAobWFpbkF4aXNCYXNlVmFsdWVPZmZzZXQgLyBnZXRBeGlzUmFuZ2UobWFpbkF4aXNJbmZvKSAtIChheGlzSW5mby5iYXNlVGlja1ZhbHVlIC0gYXhpc0luZm8ubWluVmFsdWUpIC8gdmFsdWVGcm9tQXhpc0luZm8pICogdmFsdWVGcm9tQXhpc0luZm87XHJcbiAgICAgICAgICAgIGF4aXNJbmZvLm1pblZhbHVlIC09IG1vdmU7XHJcbiAgICAgICAgICAgIGF4aXNJbmZvLm1heFZhbHVlIC09IG1vdmVcclxuICAgICAgICB9XHJcbiAgICB9KVxyXG59XHJcblxyXG5mdW5jdGlvbiBjYWxjdWxhdGVQYWRkaW5ncyhheGVzSW5mbykge1xyXG4gICAgdmFyIG1pblBhZGRpbmc7XHJcbiAgICB2YXIgbWF4UGFkZGluZztcclxuICAgIHZhciBzdGFydFBhZGRpbmcgPSAwO1xyXG4gICAgdmFyIGVuZFBhZGRpbmcgPSAwO1xyXG4gICAgYXhlc0luZm8uZm9yRWFjaChheGlzSW5mbyA9PiB7XHJcbiAgICAgICAgdmFyIGludmVydGVkID0gYXhpc0luZm8uaW52ZXJ0ZWQ7XHJcbiAgICAgICAgbWluUGFkZGluZyA9IGF4aXNJbmZvLm1pblZhbHVlID4gYXhpc0luZm8ub2xkTWluVmFsdWUgPyAoYXhpc0luZm8ubWluVmFsdWUgLSBheGlzSW5mby5vbGRNaW5WYWx1ZSkgLyBnZXRBeGlzUmFuZ2UoYXhpc0luZm8pIDogMDtcclxuICAgICAgICBtYXhQYWRkaW5nID0gYXhpc0luZm8ubWF4VmFsdWUgPCBheGlzSW5mby5vbGRNYXhWYWx1ZSA/IChheGlzSW5mby5vbGRNYXhWYWx1ZSAtIGF4aXNJbmZvLm1heFZhbHVlKSAvIGdldEF4aXNSYW5nZShheGlzSW5mbykgOiAwO1xyXG4gICAgICAgIHN0YXJ0UGFkZGluZyA9IF9tYXgoc3RhcnRQYWRkaW5nLCBpbnZlcnRlZCA/IG1heFBhZGRpbmcgOiBtaW5QYWRkaW5nKTtcclxuICAgICAgICBlbmRQYWRkaW5nID0gX21heChlbmRQYWRkaW5nLCBpbnZlcnRlZCA/IG1pblBhZGRpbmcgOiBtYXhQYWRkaW5nKVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXJ0OiBzdGFydFBhZGRpbmcsXHJcbiAgICAgICAgZW5kOiBlbmRQYWRkaW5nXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcnJlY3RNaW5NYXhWYWx1ZXNCeVBhZGRpbmdzKGF4ZXNJbmZvLCBwYWRkaW5ncykge1xyXG4gICAgYXhlc0luZm8uZm9yRWFjaChpbmZvID0+IHtcclxuICAgICAgICB2YXIgcmFuZ2UgPSBnZXRBeGlzUmFuZ2UoaW5mbyk7XHJcbiAgICAgICAgdmFyIGludmVydGVkID0gaW5mby5pbnZlcnRlZDtcclxuICAgICAgICBpbmZvLm1pblZhbHVlID0gYWRqdXN0KGluZm8ubWluVmFsdWUgLSBwYWRkaW5nc1tpbnZlcnRlZCA/IFwiZW5kXCIgOiBcInN0YXJ0XCJdICogcmFuZ2UpO1xyXG4gICAgICAgIGluZm8ubWF4VmFsdWUgPSBhZGp1c3QoaW5mby5tYXhWYWx1ZSArIHBhZGRpbmdzW2ludmVydGVkID8gXCJzdGFydFwiIDogXCJlbmRcIl0gKiByYW5nZSlcclxuICAgIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVRpY2tWYWx1ZXNJZlN5bmNocm9uaXplZFZhbHVlVXNlZChheGVzSW5mbykge1xyXG4gICAgdmFyIGhhc1N5bmNocm9uaXplZFZhbHVlID0gZmFsc2U7XHJcbiAgICBheGVzSW5mby5mb3JFYWNoKGluZm8gPT4ge1xyXG4gICAgICAgIGhhc1N5bmNocm9uaXplZFZhbHVlID0gaGFzU3luY2hyb25pemVkVmFsdWUgfHwgaXNEZWZpbmVkKGluZm8uc3luY2hyb25pemVkVmFsdWUpXHJcbiAgICB9KTtcclxuICAgIGF4ZXNJbmZvLmZvckVhY2goaW5mbyA9PiB7XHJcbiAgICAgICAgdmFyIHRpY2tJbnRlcnZhbCA9IGluZm8udGlja0ludGVydmFsO1xyXG4gICAgICAgIHZhciB0aWNrVmFsdWVzID0gaW5mby50aWNrVmFsdWVzO1xyXG4gICAgICAgIHZhciBtYXhWYWx1ZSA9IGluZm8ubWF4VmFsdWU7XHJcbiAgICAgICAgdmFyIG1pblZhbHVlID0gaW5mby5taW5WYWx1ZTtcclxuICAgICAgICB2YXIgdGljaztcclxuICAgICAgICBpZiAoaGFzU3luY2hyb25pemVkVmFsdWUgJiYgdGlja0ludGVydmFsKSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgodGljayA9IGFkanVzdCh0aWNrVmFsdWVzWzBdIC0gdGlja0ludGVydmFsKSkgPj0gbWluVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRpY2tWYWx1ZXMudW5zaGlmdCh0aWNrKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpY2sgPSB0aWNrVmFsdWVzW3RpY2tWYWx1ZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIHdoaWxlICgodGljayA9IGFkanVzdCh0aWNrICsgdGlja0ludGVydmFsKSkgPD0gbWF4VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRpY2tWYWx1ZXMucHVzaCh0aWNrKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlICh0aWNrVmFsdWVzWzBdICsgdGlja0ludGVydmFsIC8gMTAgPCBtaW5WYWx1ZSkge1xyXG4gICAgICAgICAgICB0aWNrVmFsdWVzLnNoaWZ0KClcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRpY2tWYWx1ZXNbdGlja1ZhbHVlcy5sZW5ndGggLSAxXSAtIHRpY2tJbnRlcnZhbCAvIDEwID4gbWF4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGlja1ZhbHVlcy5wb3AoKVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5TWluTWF4VmFsdWVzKGF4ZXNJbmZvKSB7XHJcbiAgICBheGVzSW5mby5mb3JFYWNoKGluZm8gPT4ge1xyXG4gICAgICAgIHZhciBheGlzID0gaW5mby5heGlzO1xyXG4gICAgICAgIHZhciByYW5nZSA9IGF4aXMuZ2V0VHJhbnNsYXRvcigpLmdldEJ1c2luZXNzUmFuZ2UoKTtcclxuICAgICAgICBpZiAocmFuZ2UubWluID09PSByYW5nZS5taW5WaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHJhbmdlLm1pbiA9IGluZm8ubWluVmFsdWVcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhbmdlLm1heCA9PT0gcmFuZ2UubWF4VmlzaWJsZSkge1xyXG4gICAgICAgICAgICByYW5nZS5tYXggPSBpbmZvLm1heFZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJhbmdlLm1pblZpc2libGUgPSBpbmZvLm1pblZhbHVlO1xyXG4gICAgICAgIHJhbmdlLm1heFZpc2libGUgPSBpbmZvLm1heFZhbHVlO1xyXG4gICAgICAgIGlmIChyYW5nZS5taW4gPiByYW5nZS5taW5WaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHJhbmdlLm1pbiA9IHJhbmdlLm1pblZpc2libGVcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhbmdlLm1heCA8IHJhbmdlLm1heFZpc2libGUpIHtcclxuICAgICAgICAgICAgcmFuZ2UubWF4ID0gcmFuZ2UubWF4VmlzaWJsZVxyXG4gICAgICAgIH1cclxuICAgICAgICBheGlzLmdldFRyYW5zbGF0b3IoKS51cGRhdGVCdXNpbmVzc1JhbmdlKHJhbmdlKTtcclxuICAgICAgICBheGlzLnNldFRpY2tzKHtcclxuICAgICAgICAgICAgbWFqb3JUaWNrczogaW5mby50aWNrVmFsdWVzLFxyXG4gICAgICAgICAgICBtaW5vclRpY2tzOiBpbmZvLm1pbm9yVmFsdWVzXHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcnJlY3RBZnRlclN5bmNocm9uaXplKGF4ZXNJbmZvKSB7XHJcbiAgICB2YXIgaW52YWxpZEF4aXNJbmZvID0gW107XHJcbiAgICB2YXIgY29ycmVjdFZhbHVlO1xyXG4gICAgYXhlc0luZm8uZm9yRWFjaChpbmZvID0+IHtcclxuICAgICAgICBpZiAoaW5mby5vbGRNYXhWYWx1ZSAtIGluZm8ub2xkTWluVmFsdWUgPT09IDApIHtcclxuICAgICAgICAgICAgaW52YWxpZEF4aXNJbmZvLnB1c2goaW5mbylcclxuICAgICAgICB9IGVsc2UgaWYgKCFpc0RlZmluZWQoY29ycmVjdFZhbHVlKSAmJiAhaXNEZWZpbmVkKGluZm8uc3luY2hyb25pemVkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGNvcnJlY3RWYWx1ZSA9IF9hYnMoKGluZm8ubWF4VmFsdWUgLSBpbmZvLm1pblZhbHVlKSAvIChpbmZvLnRpY2tWYWx1ZXNbX2Zsb29yKGluZm8udGlja1ZhbHVlcy5sZW5ndGggLyAyKV0gLSBpbmZvLm1pblZhbHVlIHx8IGluZm8ubWF4VmFsdWUpKVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaWYgKCFpc0RlZmluZWQoY29ycmVjdFZhbHVlKSkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgaW52YWxpZEF4aXNJbmZvLmZvckVhY2goaW5mbyA9PiB7XHJcbiAgICAgICAgdmFyIGZpcnN0VGljayA9IGluZm8udGlja1ZhbHVlc1swXTtcclxuICAgICAgICB2YXIgY29ycmVjdGVkVGljayA9IGZpcnN0VGljayAqIGNvcnJlY3RWYWx1ZTtcclxuICAgICAgICBpZiAoZmlyc3RUaWNrID4gMCkge1xyXG4gICAgICAgICAgICBpbmZvLm1heFZhbHVlID0gY29ycmVjdGVkVGljaztcclxuICAgICAgICAgICAgaW5mby5taW5WYWx1ZSA9IDBcclxuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0VGljayA8IDApIHtcclxuICAgICAgICAgICAgaW5mby5taW5WYWx1ZSA9IGNvcnJlY3RlZFRpY2s7XHJcbiAgICAgICAgICAgIGluZm8ubWF4VmFsdWUgPSAwXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTWlub3JUaWNrcyhheGVzSW5mbykge1xyXG4gICAgYXhlc0luZm8uZm9yRWFjaCgoZnVuY3Rpb24oYXhpc0luZm8pIHtcclxuICAgICAgICBpZiAoIWF4aXNJbmZvLm1pbm9yVGlja0ludGVydmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGlja3MgPSBbXTtcclxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBheGlzSW5mby5taW5vclRpY2tJbnRlcnZhbDtcclxuICAgICAgICB2YXIgdGlja0NvdW50ID0gYXhpc0luZm8udGlja0ludGVydmFsIC8gaW50ZXJ2YWwgLSAxO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXhpc0luZm8udGlja1ZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdGljayA9IGF4aXNJbmZvLnRpY2tWYWx1ZXNbaSAtIDFdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRpY2tDb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB0aWNrICs9IGludGVydmFsO1xyXG4gICAgICAgICAgICAgICAgdGlja3MucHVzaCh0aWNrKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF4aXNJbmZvLm1pbm9yVmFsdWVzID0gdGlja3NcclxuICAgIH0pKVxyXG59XHJcblxyXG5mdW5jdGlvbiBjb3JyZWN0UGFkZGluZ3MoYXhlc0luZm8sIHBhZGRpbmdzKSB7XHJcbiAgICByZXR1cm4gYXhlc0luZm8ucmVkdWNlKChwcmV2LCBpbmZvKSA9PiB7XHJcbiAgICAgICAgdmFyIGludmVydGVkID0gaW5mby5pbnZlcnRlZDtcclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogZW5kXHJcbiAgICAgICAgfSA9IGluZm8uYXhpcy5nZXRDb3JyZWN0ZWRWYWx1ZXNUb1plcm8oaW5mby5taW5WYWx1ZSwgaW5mby5tYXhWYWx1ZSk7XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZChzdGFydCkgfHwgaXNEZWZpbmVkKGVuZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludmVydGVkID8ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHByZXYuc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBlbmQ6IE1hdGgubWluKHByZXYuZW5kLCBlbmQpXHJcbiAgICAgICAgICAgIH0gOiB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogTWF0aC5taW4ocHJldi5zdGFydCwgc3RhcnQpLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBwcmV2LmVuZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcmV2XHJcbiAgICB9LCBwYWRkaW5ncylcclxufVxyXG52YXIgbXVsdGlBeGVzU3luY2hyb25pemVyID0ge1xyXG4gICAgc3luY2hyb25pemU6IGZ1bmN0aW9uKHZhbHVlQXhlcykge1xyXG4gICAgICAgIGVhY2goZ2V0VmFsdWVBeGVzUGVyUGFuZXModmFsdWVBeGVzKSwgKGZ1bmN0aW9uKF8sIGF4ZXMpIHtcclxuICAgICAgICAgICAgdmFyIGF4ZXNJbmZvO1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZ3M7XHJcbiAgICAgICAgICAgIGlmIChheGVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGF4ZXNJbmZvID0gcG9wdWxhdGVBeGVzSW5mbyhheGVzKTtcclxuICAgICAgICAgICAgICAgIGlmIChheGVzSW5mby5sZW5ndGggPCAyIHx8ICFnZXRNYWluQXhpc0luZm8oYXhlc0luZm8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVUaWNrVmFsdWVzKGF4ZXNJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvcnJlY3RNaW5NYXhWYWx1ZXMoYXhlc0luZm8pO1xyXG4gICAgICAgICAgICAgICAgcGFkZGluZ3MgPSBjYWxjdWxhdGVQYWRkaW5ncyhheGVzSW5mbyk7XHJcbiAgICAgICAgICAgICAgICBwYWRkaW5ncyA9IGNvcnJlY3RQYWRkaW5ncyhheGVzSW5mbywgcGFkZGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgY29ycmVjdE1pbk1heFZhbHVlc0J5UGFkZGluZ3MoYXhlc0luZm8sIHBhZGRpbmdzKTtcclxuICAgICAgICAgICAgICAgIGNvcnJlY3RBZnRlclN5bmNocm9uaXplKGF4ZXNJbmZvKTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVRpY2tWYWx1ZXNJZlN5bmNocm9uaXplZFZhbHVlVXNlZChheGVzSW5mbyk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVNaW5vclRpY2tzKGF4ZXNJbmZvKTtcclxuICAgICAgICAgICAgICAgIGF4ZXNJbmZvLmZvckVhY2goaW5mbyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udmVydEF4aXNJbmZvKGluZm8sIGxvZ0NvbnZlcnRlcihpbmZvLmF4aXMuZ2V0VHJhbnNsYXRvcigpLmdldEJ1c2luZXNzUmFuZ2UoKSkpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGFwcGx5TWluTWF4VmFsdWVzKGF4ZXNJbmZvKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpXHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydCBkZWZhdWx0IG11bHRpQXhlc1N5bmNocm9uaXplcjtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/chart_components/multi_axes_synchronizer.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/chart_components/scroll_bar.js":
/*!************************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/chart_components/scroll_bar.js ***!
  \************************************************************************/
/*! exports provided: ScrollBar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollBar\", function() { return ScrollBar; });\n/* harmony import */ var _events_core_events_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../events/core/events_engine */ \"./node_modules/devextreme/esm/events/core/events_engine.js\");\n/* harmony import */ var _events_utils_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../events/utils/index */ \"./node_modules/devextreme/esm/events/utils/index.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _translators_translator2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../translators/translator2d */ \"./node_modules/devextreme/esm/viz/translators/translator2d.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/utils/common */ \"./node_modules/devextreme/esm/core/utils/common.js\");\n/* harmony import */ var _events_drag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../events/drag */ \"./node_modules/devextreme/esm/events/drag.js\");\n/**\r\n * DevExtreme (esm/viz/chart_components/scroll_bar.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar _min = Math.min;\r\nvar _max = Math.max;\r\nvar MIN_SCROLL_BAR_SIZE = 2;\r\nvar ScrollBar = function(renderer, group) {\r\n    this._translator = new _translators_translator2d__WEBPACK_IMPORTED_MODULE_3__[\"Translator2D\"]({}, {}, {});\r\n    this._scroll = renderer.rect().append(group);\r\n    this._addEvents()\r\n};\r\n\r\nfunction _getXCoord(canvas, pos, offset, width) {\r\n    var x = 0;\r\n    if (\"right\" === pos) {\r\n        x = canvas.width - canvas.right + offset\r\n    } else if (\"left\" === pos) {\r\n        x = canvas.left - offset - width\r\n    }\r\n    return x\r\n}\r\n\r\nfunction _getYCoord(canvas, pos, offset, width) {\r\n    var y = 0;\r\n    if (\"top\" === pos) {\r\n        y = canvas.top - offset\r\n    } else if (\"bottom\" === pos) {\r\n        y = canvas.height - canvas.bottom + width + offset\r\n    }\r\n    return y\r\n}\r\nScrollBar.prototype = {\r\n    _addEvents: function() {\r\n        var scrollElement = this._scroll.element;\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_0__[\"default\"].on(scrollElement, _events_drag__WEBPACK_IMPORTED_MODULE_6__[\"start\"], e => {\r\n            Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_1__[\"fireEvent\"])({\r\n                type: \"dxc-scroll-start\",\r\n                originalEvent: e,\r\n                target: scrollElement\r\n            })\r\n        });\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_0__[\"default\"].on(scrollElement, _events_drag__WEBPACK_IMPORTED_MODULE_6__[\"move\"], e => {\r\n            var dX = -e.offset.x * this._scale;\r\n            var dY = -e.offset.y * this._scale;\r\n            var lx = this._offset - (this._layoutOptions.vertical ? dY : dX) / this._scale;\r\n            this._applyPosition(lx, lx + this._translator.canvasLength / this._scale);\r\n            Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_1__[\"fireEvent\"])({\r\n                type: \"dxc-scroll-move\",\r\n                originalEvent: e,\r\n                target: scrollElement,\r\n                offset: {\r\n                    x: dX,\r\n                    y: dY\r\n                }\r\n            })\r\n        });\r\n        _events_core_events_engine__WEBPACK_IMPORTED_MODULE_0__[\"default\"].on(scrollElement, _events_drag__WEBPACK_IMPORTED_MODULE_6__[\"end\"], e => {\r\n            Object(_events_utils_index__WEBPACK_IMPORTED_MODULE_1__[\"fireEvent\"])({\r\n                type: \"dxc-scroll-end\",\r\n                originalEvent: e,\r\n                target: scrollElement,\r\n                offset: {\r\n                    x: -e.offset.x * this._scale,\r\n                    y: -e.offset.y * this._scale\r\n                }\r\n            })\r\n        })\r\n    },\r\n    update: function(options) {\r\n        var position = options.position;\r\n        var isVertical = options.rotated;\r\n        var defaultPosition = isVertical ? \"right\" : \"top\";\r\n        var secondaryPosition = isVertical ? \"left\" : \"bottom\";\r\n        if (position !== defaultPosition && position !== secondaryPosition) {\r\n            position = defaultPosition\r\n        }\r\n        this._scroll.attr({\r\n            rotate: !options.rotated ? -90 : 0,\r\n            rotateX: 0,\r\n            rotateY: 0,\r\n            fill: options.color,\r\n            width: options.width,\r\n            opacity: options.opacity\r\n        });\r\n        this._layoutOptions = {\r\n            width: options.width,\r\n            offset: options.offset,\r\n            vertical: isVertical,\r\n            position: position\r\n        };\r\n        return this\r\n    },\r\n    init: function(range, stick) {\r\n        var isDiscrete = \"discrete\" === range.axisType;\r\n        this._translateWithOffset = isDiscrete && !stick ? 1 : 0;\r\n        this._translator.update(Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])({}, range, {\r\n            minVisible: null,\r\n            maxVisible: null,\r\n            visibleCategories: null\r\n        }, isDiscrete && {\r\n            min: null,\r\n            max: null\r\n        } || {}), this._canvas, {\r\n            isHorizontal: !this._layoutOptions.vertical,\r\n            stick: stick\r\n        });\r\n        return this\r\n    },\r\n    getOptions: function() {\r\n        return this._layoutOptions\r\n    },\r\n    setPane: function(panes) {\r\n        var position = this._layoutOptions.position;\r\n        var pane;\r\n        if (\"left\" === position || \"top\" === position) {\r\n            pane = panes[0]\r\n        } else {\r\n            pane = panes[panes.length - 1]\r\n        }\r\n        this.pane = pane.name;\r\n        return this\r\n    },\r\n    updateSize: function(canvas) {\r\n        this._canvas = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_2__[\"extend\"])({}, canvas);\r\n        var options = this._layoutOptions;\r\n        var pos = options.position;\r\n        var offset = options.offset;\r\n        var width = options.width;\r\n        this._scroll.attr({\r\n            translateX: _getXCoord(canvas, pos, offset, width),\r\n            translateY: _getYCoord(canvas, pos, offset, width)\r\n        })\r\n    },\r\n    getMultipleAxesSpacing: function() {\r\n        return 0\r\n    },\r\n    estimateMargins: function() {\r\n        return this.getMargins()\r\n    },\r\n    getMargins: function() {\r\n        var options = this._layoutOptions;\r\n        var margins = {\r\n            left: 0,\r\n            top: 0,\r\n            right: 0,\r\n            bottom: 0\r\n        };\r\n        margins[options.position] = options.width + options.offset;\r\n        return margins\r\n    },\r\n    shift: function(margins) {\r\n        var _that$_scroll$attr, _that$_scroll$attr2;\r\n        var options = this._layoutOptions;\r\n        var side = options.position;\r\n        var isVertical = options.vertical;\r\n        var attr = {\r\n            translateX: null !== (_that$_scroll$attr = this._scroll.attr(\"translateX\")) && void 0 !== _that$_scroll$attr ? _that$_scroll$attr : 0,\r\n            translateY: null !== (_that$_scroll$attr2 = this._scroll.attr(\"translateY\")) && void 0 !== _that$_scroll$attr2 ? _that$_scroll$attr2 : 0\r\n        };\r\n        var shift = margins[side];\r\n        attr[isVertical ? \"translateX\" : \"translateY\"] += (\"left\" === side || \"top\" === side ? -1 : 1) * shift;\r\n        this._scroll.attr(attr)\r\n    },\r\n    hideTitle: _core_utils_common__WEBPACK_IMPORTED_MODULE_5__[\"noop\"],\r\n    hideOuterElements: _core_utils_common__WEBPACK_IMPORTED_MODULE_5__[\"noop\"],\r\n    setPosition: function(min, max) {\r\n        var translator = this._translator;\r\n        var minPoint = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_4__[\"isDefined\"])(min) ? translator.translate(min, -this._translateWithOffset) : translator.translate(\"canvas_position_start\");\r\n        var maxPoint = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_4__[\"isDefined\"])(max) ? translator.translate(max, this._translateWithOffset) : translator.translate(\"canvas_position_end\");\r\n        this._offset = _min(minPoint, maxPoint);\r\n        this._scale = translator.getScale(min, max);\r\n        this._applyPosition(_min(minPoint, maxPoint), _max(minPoint, maxPoint))\r\n    },\r\n    customPositionIsAvailable: () => false,\r\n    dispose: function() {\r\n        this._scroll.dispose();\r\n        this._scroll = this._translator = null\r\n    },\r\n    _applyPosition: function(x1, x2) {\r\n        var visibleArea = this._translator.getCanvasVisibleArea();\r\n        x1 = _max(x1, visibleArea.min);\r\n        x1 = _min(x1, visibleArea.max);\r\n        x2 = _min(x2, visibleArea.max);\r\n        x2 = _max(x2, visibleArea.min);\r\n        var height = Math.abs(x2 - x1);\r\n        this._scroll.attr({\r\n            y: x1,\r\n            height: height < MIN_SCROLL_BAR_SIZE ? MIN_SCROLL_BAR_SIZE : height\r\n        })\r\n    }\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2NoYXJ0X2NvbXBvbmVudHMvc2Nyb2xsX2Jhci5qcz85ZWNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkQ7QUFHekI7QUFHRDtBQUdJO0FBR047QUFHRTtBQUtOO0FBQzNCO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMkJBQTJCLHNFQUFZLEdBQUcsSUFBSSxJQUFJO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0VBQVksbUJBQW1CLGtEQUFjO0FBQ3JELFlBQVkscUVBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxRQUFRLGtFQUFZLG1CQUFtQixpREFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUVBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULFFBQVEsa0VBQVksbUJBQW1CLGdEQUFZO0FBQ25ELFlBQVkscUVBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlFQUFNLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QixpRUFBTSxHQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsdURBQUk7QUFDbkIsdUJBQXVCLHVEQUFJO0FBQzNCO0FBQ0E7QUFDQSx1QkFBdUIsa0VBQVM7QUFDaEMsdUJBQXVCLGtFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3Zpei9jaGFydF9jb21wb25lbnRzL3Njcm9sbF9iYXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3Zpei9jaGFydF9jb21wb25lbnRzL3Njcm9sbF9iYXIuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCBldmVudHNFbmdpbmUgZnJvbSBcIi4uLy4uL2V2ZW50cy9jb3JlL2V2ZW50c19lbmdpbmVcIjtcclxuaW1wb3J0IHtcclxuICAgIGZpcmVFdmVudFxyXG59IGZyb20gXCIuLi8uLi9ldmVudHMvdXRpbHMvaW5kZXhcIjtcclxuaW1wb3J0IHtcclxuICAgIGV4dGVuZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2V4dGVuZFwiO1xyXG5pbXBvcnQge1xyXG4gICAgVHJhbnNsYXRvcjJEXHJcbn0gZnJvbSBcIi4uL3RyYW5zbGF0b3JzL3RyYW5zbGF0b3IyZFwiO1xyXG5pbXBvcnQge1xyXG4gICAgaXNEZWZpbmVkXHJcbn0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvdHlwZVwiO1xyXG5pbXBvcnQge1xyXG4gICAgbm9vcFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2NvbW1vblwiO1xyXG5pbXBvcnQge1xyXG4gICAgc3RhcnQgYXMgZHJhZ0V2ZW50U3RhcnQsXHJcbiAgICBtb3ZlIGFzIGRyYWdFdmVudE1vdmUsXHJcbiAgICBlbmQgYXMgZHJhZ0V2ZW50RW5kXHJcbn0gZnJvbSBcIi4uLy4uL2V2ZW50cy9kcmFnXCI7XHJcbnZhciBfbWluID0gTWF0aC5taW47XHJcbnZhciBfbWF4ID0gTWF0aC5tYXg7XHJcbnZhciBNSU5fU0NST0xMX0JBUl9TSVpFID0gMjtcclxuZXhwb3J0IHZhciBTY3JvbGxCYXIgPSBmdW5jdGlvbihyZW5kZXJlciwgZ3JvdXApIHtcclxuICAgIHRoaXMuX3RyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcjJEKHt9LCB7fSwge30pO1xyXG4gICAgdGhpcy5fc2Nyb2xsID0gcmVuZGVyZXIucmVjdCgpLmFwcGVuZChncm91cCk7XHJcbiAgICB0aGlzLl9hZGRFdmVudHMoKVxyXG59O1xyXG5cclxuZnVuY3Rpb24gX2dldFhDb29yZChjYW52YXMsIHBvcywgb2Zmc2V0LCB3aWR0aCkge1xyXG4gICAgdmFyIHggPSAwO1xyXG4gICAgaWYgKFwicmlnaHRcIiA9PT0gcG9zKSB7XHJcbiAgICAgICAgeCA9IGNhbnZhcy53aWR0aCAtIGNhbnZhcy5yaWdodCArIG9mZnNldFxyXG4gICAgfSBlbHNlIGlmIChcImxlZnRcIiA9PT0gcG9zKSB7XHJcbiAgICAgICAgeCA9IGNhbnZhcy5sZWZ0IC0gb2Zmc2V0IC0gd2lkdGhcclxuICAgIH1cclxuICAgIHJldHVybiB4XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9nZXRZQ29vcmQoY2FudmFzLCBwb3MsIG9mZnNldCwgd2lkdGgpIHtcclxuICAgIHZhciB5ID0gMDtcclxuICAgIGlmIChcInRvcFwiID09PSBwb3MpIHtcclxuICAgICAgICB5ID0gY2FudmFzLnRvcCAtIG9mZnNldFxyXG4gICAgfSBlbHNlIGlmIChcImJvdHRvbVwiID09PSBwb3MpIHtcclxuICAgICAgICB5ID0gY2FudmFzLmhlaWdodCAtIGNhbnZhcy5ib3R0b20gKyB3aWR0aCArIG9mZnNldFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHlcclxufVxyXG5TY3JvbGxCYXIucHJvdG90eXBlID0ge1xyXG4gICAgX2FkZEV2ZW50czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbEVsZW1lbnQgPSB0aGlzLl9zY3JvbGwuZWxlbWVudDtcclxuICAgICAgICBldmVudHNFbmdpbmUub24oc2Nyb2xsRWxlbWVudCwgZHJhZ0V2ZW50U3RhcnQsIGUgPT4ge1xyXG4gICAgICAgICAgICBmaXJlRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJkeGMtc2Nyb2xsLXN0YXJ0XCIsXHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBzY3JvbGxFbGVtZW50XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZXZlbnRzRW5naW5lLm9uKHNjcm9sbEVsZW1lbnQsIGRyYWdFdmVudE1vdmUsIGUgPT4ge1xyXG4gICAgICAgICAgICB2YXIgZFggPSAtZS5vZmZzZXQueCAqIHRoaXMuX3NjYWxlO1xyXG4gICAgICAgICAgICB2YXIgZFkgPSAtZS5vZmZzZXQueSAqIHRoaXMuX3NjYWxlO1xyXG4gICAgICAgICAgICB2YXIgbHggPSB0aGlzLl9vZmZzZXQgLSAodGhpcy5fbGF5b3V0T3B0aW9ucy52ZXJ0aWNhbCA/IGRZIDogZFgpIC8gdGhpcy5fc2NhbGU7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5UG9zaXRpb24obHgsIGx4ICsgdGhpcy5fdHJhbnNsYXRvci5jYW52YXNMZW5ndGggLyB0aGlzLl9zY2FsZSk7XHJcbiAgICAgICAgICAgIGZpcmVFdmVudCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImR4Yy1zY3JvbGwtbW92ZVwiLFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogc2Nyb2xsRWxlbWVudCxcclxuICAgICAgICAgICAgICAgIG9mZnNldDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IGRYLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGRZXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZXZlbnRzRW5naW5lLm9uKHNjcm9sbEVsZW1lbnQsIGRyYWdFdmVudEVuZCwgZSA9PiB7XHJcbiAgICAgICAgICAgIGZpcmVFdmVudCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImR4Yy1zY3JvbGwtZW5kXCIsXHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBzY3JvbGxFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogLWUub2Zmc2V0LnggKiB0aGlzLl9zY2FsZSxcclxuICAgICAgICAgICAgICAgICAgICB5OiAtZS5vZmZzZXQueSAqIHRoaXMuX3NjYWxlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBpc1ZlcnRpY2FsID0gb3B0aW9ucy5yb3RhdGVkO1xyXG4gICAgICAgIHZhciBkZWZhdWx0UG9zaXRpb24gPSBpc1ZlcnRpY2FsID8gXCJyaWdodFwiIDogXCJ0b3BcIjtcclxuICAgICAgICB2YXIgc2Vjb25kYXJ5UG9zaXRpb24gPSBpc1ZlcnRpY2FsID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiO1xyXG4gICAgICAgIGlmIChwb3NpdGlvbiAhPT0gZGVmYXVsdFBvc2l0aW9uICYmIHBvc2l0aW9uICE9PSBzZWNvbmRhcnlQb3NpdGlvbikge1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IGRlZmF1bHRQb3NpdGlvblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zY3JvbGwuYXR0cih7XHJcbiAgICAgICAgICAgIHJvdGF0ZTogIW9wdGlvbnMucm90YXRlZCA/IC05MCA6IDAsXHJcbiAgICAgICAgICAgIHJvdGF0ZVg6IDAsXHJcbiAgICAgICAgICAgIHJvdGF0ZVk6IDAsXHJcbiAgICAgICAgICAgIGZpbGw6IG9wdGlvbnMuY29sb3IsXHJcbiAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiBvcHRpb25zLm9wYWNpdHlcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9sYXlvdXRPcHRpb25zID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogb3B0aW9ucy53aWR0aCxcclxuICAgICAgICAgICAgb2Zmc2V0OiBvcHRpb25zLm9mZnNldCxcclxuICAgICAgICAgICAgdmVydGljYWw6IGlzVmVydGljYWwsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH0sXHJcbiAgICBpbml0OiBmdW5jdGlvbihyYW5nZSwgc3RpY2spIHtcclxuICAgICAgICB2YXIgaXNEaXNjcmV0ZSA9IFwiZGlzY3JldGVcIiA9PT0gcmFuZ2UuYXhpc1R5cGU7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRlV2l0aE9mZnNldCA9IGlzRGlzY3JldGUgJiYgIXN0aWNrID8gMSA6IDA7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRvci51cGRhdGUoZXh0ZW5kKHt9LCByYW5nZSwge1xyXG4gICAgICAgICAgICBtaW5WaXNpYmxlOiBudWxsLFxyXG4gICAgICAgICAgICBtYXhWaXNpYmxlOiBudWxsLFxyXG4gICAgICAgICAgICB2aXNpYmxlQ2F0ZWdvcmllczogbnVsbFxyXG4gICAgICAgIH0sIGlzRGlzY3JldGUgJiYge1xyXG4gICAgICAgICAgICBtaW46IG51bGwsXHJcbiAgICAgICAgICAgIG1heDogbnVsbFxyXG4gICAgICAgIH0gfHwge30pLCB0aGlzLl9jYW52YXMsIHtcclxuICAgICAgICAgICAgaXNIb3Jpem9udGFsOiAhdGhpcy5fbGF5b3V0T3B0aW9ucy52ZXJ0aWNhbCxcclxuICAgICAgICAgICAgc3RpY2s6IHN0aWNrXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH0sXHJcbiAgICBnZXRPcHRpb25zOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0T3B0aW9uc1xyXG4gICAgfSxcclxuICAgIHNldFBhbmU6IGZ1bmN0aW9uKHBhbmVzKSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fbGF5b3V0T3B0aW9ucy5wb3NpdGlvbjtcclxuICAgICAgICB2YXIgcGFuZTtcclxuICAgICAgICBpZiAoXCJsZWZ0XCIgPT09IHBvc2l0aW9uIHx8IFwidG9wXCIgPT09IHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHBhbmUgPSBwYW5lc1swXVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhbmUgPSBwYW5lc1twYW5lcy5sZW5ndGggLSAxXVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhbmUgPSBwYW5lLm5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH0sXHJcbiAgICB1cGRhdGVTaXplOiBmdW5jdGlvbihjYW52YXMpIHtcclxuICAgICAgICB0aGlzLl9jYW52YXMgPSBleHRlbmQoe30sIGNhbnZhcyk7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9sYXlvdXRPcHRpb25zO1xyXG4gICAgICAgIHZhciBwb3MgPSBvcHRpb25zLnBvc2l0aW9uO1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSBvcHRpb25zLm9mZnNldDtcclxuICAgICAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoO1xyXG4gICAgICAgIHRoaXMuX3Njcm9sbC5hdHRyKHtcclxuICAgICAgICAgICAgdHJhbnNsYXRlWDogX2dldFhDb29yZChjYW52YXMsIHBvcywgb2Zmc2V0LCB3aWR0aCksXHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IF9nZXRZQ29vcmQoY2FudmFzLCBwb3MsIG9mZnNldCwgd2lkdGgpXHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBnZXRNdWx0aXBsZUF4ZXNTcGFjaW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gMFxyXG4gICAgfSxcclxuICAgIGVzdGltYXRlTWFyZ2luczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFyZ2lucygpXHJcbiAgICB9LFxyXG4gICAgZ2V0TWFyZ2luczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9sYXlvdXRPcHRpb25zO1xyXG4gICAgICAgIHZhciBtYXJnaW5zID0ge1xyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgICAgICBib3R0b206IDBcclxuICAgICAgICB9O1xyXG4gICAgICAgIG1hcmdpbnNbb3B0aW9ucy5wb3NpdGlvbl0gPSBvcHRpb25zLndpZHRoICsgb3B0aW9ucy5vZmZzZXQ7XHJcbiAgICAgICAgcmV0dXJuIG1hcmdpbnNcclxuICAgIH0sXHJcbiAgICBzaGlmdDogZnVuY3Rpb24obWFyZ2lucykge1xyXG4gICAgICAgIHZhciBfdGhhdCRfc2Nyb2xsJGF0dHIsIF90aGF0JF9zY3JvbGwkYXR0cjI7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9sYXlvdXRPcHRpb25zO1xyXG4gICAgICAgIHZhciBzaWRlID0gb3B0aW9ucy5wb3NpdGlvbjtcclxuICAgICAgICB2YXIgaXNWZXJ0aWNhbCA9IG9wdGlvbnMudmVydGljYWw7XHJcbiAgICAgICAgdmFyIGF0dHIgPSB7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6IG51bGwgIT09IChfdGhhdCRfc2Nyb2xsJGF0dHIgPSB0aGlzLl9zY3JvbGwuYXR0cihcInRyYW5zbGF0ZVhcIikpICYmIHZvaWQgMCAhPT0gX3RoYXQkX3Njcm9sbCRhdHRyID8gX3RoYXQkX3Njcm9sbCRhdHRyIDogMCxcclxuICAgICAgICAgICAgdHJhbnNsYXRlWTogbnVsbCAhPT0gKF90aGF0JF9zY3JvbGwkYXR0cjIgPSB0aGlzLl9zY3JvbGwuYXR0cihcInRyYW5zbGF0ZVlcIikpICYmIHZvaWQgMCAhPT0gX3RoYXQkX3Njcm9sbCRhdHRyMiA/IF90aGF0JF9zY3JvbGwkYXR0cjIgOiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc2hpZnQgPSBtYXJnaW5zW3NpZGVdO1xyXG4gICAgICAgIGF0dHJbaXNWZXJ0aWNhbCA/IFwidHJhbnNsYXRlWFwiIDogXCJ0cmFuc2xhdGVZXCJdICs9IChcImxlZnRcIiA9PT0gc2lkZSB8fCBcInRvcFwiID09PSBzaWRlID8gLTEgOiAxKSAqIHNoaWZ0O1xyXG4gICAgICAgIHRoaXMuX3Njcm9sbC5hdHRyKGF0dHIpXHJcbiAgICB9LFxyXG4gICAgaGlkZVRpdGxlOiBub29wLFxyXG4gICAgaGlkZU91dGVyRWxlbWVudHM6IG5vb3AsXHJcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24obWluLCBtYXgpIHtcclxuICAgICAgICB2YXIgdHJhbnNsYXRvciA9IHRoaXMuX3RyYW5zbGF0b3I7XHJcbiAgICAgICAgdmFyIG1pblBvaW50ID0gaXNEZWZpbmVkKG1pbikgPyB0cmFuc2xhdG9yLnRyYW5zbGF0ZShtaW4sIC10aGlzLl90cmFuc2xhdGVXaXRoT2Zmc2V0KSA6IHRyYW5zbGF0b3IudHJhbnNsYXRlKFwiY2FudmFzX3Bvc2l0aW9uX3N0YXJ0XCIpO1xyXG4gICAgICAgIHZhciBtYXhQb2ludCA9IGlzRGVmaW5lZChtYXgpID8gdHJhbnNsYXRvci50cmFuc2xhdGUobWF4LCB0aGlzLl90cmFuc2xhdGVXaXRoT2Zmc2V0KSA6IHRyYW5zbGF0b3IudHJhbnNsYXRlKFwiY2FudmFzX3Bvc2l0aW9uX2VuZFwiKTtcclxuICAgICAgICB0aGlzLl9vZmZzZXQgPSBfbWluKG1pblBvaW50LCBtYXhQb2ludCk7XHJcbiAgICAgICAgdGhpcy5fc2NhbGUgPSB0cmFuc2xhdG9yLmdldFNjYWxlKG1pbiwgbWF4KTtcclxuICAgICAgICB0aGlzLl9hcHBseVBvc2l0aW9uKF9taW4obWluUG9pbnQsIG1heFBvaW50KSwgX21heChtaW5Qb2ludCwgbWF4UG9pbnQpKVxyXG4gICAgfSxcclxuICAgIGN1c3RvbVBvc2l0aW9uSXNBdmFpbGFibGU6ICgpID0+IGZhbHNlLFxyXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLl9zY3JvbGwgPSB0aGlzLl90cmFuc2xhdG9yID0gbnVsbFxyXG4gICAgfSxcclxuICAgIF9hcHBseVBvc2l0aW9uOiBmdW5jdGlvbih4MSwgeDIpIHtcclxuICAgICAgICB2YXIgdmlzaWJsZUFyZWEgPSB0aGlzLl90cmFuc2xhdG9yLmdldENhbnZhc1Zpc2libGVBcmVhKCk7XHJcbiAgICAgICAgeDEgPSBfbWF4KHgxLCB2aXNpYmxlQXJlYS5taW4pO1xyXG4gICAgICAgIHgxID0gX21pbih4MSwgdmlzaWJsZUFyZWEubWF4KTtcclxuICAgICAgICB4MiA9IF9taW4oeDIsIHZpc2libGVBcmVhLm1heCk7XHJcbiAgICAgICAgeDIgPSBfbWF4KHgyLCB2aXNpYmxlQXJlYS5taW4pO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLmFicyh4MiAtIHgxKTtcclxuICAgICAgICB0aGlzLl9zY3JvbGwuYXR0cih7XHJcbiAgICAgICAgICAgIHk6IHgxLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCA8IE1JTl9TQ1JPTExfQkFSX1NJWkUgPyBNSU5fU0NST0xMX0JBUl9TSVpFIDogaGVpZ2h0XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/chart_components/scroll_bar.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/chart_components/shutter_zoom.js":
/*!**************************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/chart_components/shutter_zoom.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _events_drag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../events/drag */ \"./node_modules/devextreme/esm/events/drag.js\");\n/**\r\n * DevExtreme (esm/viz/chart_components/shutter_zoom.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\nvar SHUTTER_EVENTS_NS = \".shutter-zoom\";\r\nvar DRAG_START_EVENT_NAME = _events_drag__WEBPACK_IMPORTED_MODULE_0__[\"start\"] + SHUTTER_EVENTS_NS;\r\nvar DRAG_UPDATE_EVENT_NAME = _events_drag__WEBPACK_IMPORTED_MODULE_0__[\"move\"] + SHUTTER_EVENTS_NS;\r\nvar DRAG_END_EVENT_NAME = _events_drag__WEBPACK_IMPORTED_MODULE_0__[\"end\"] + SHUTTER_EVENTS_NS;\r\n\r\nfunction getPointerCoord(rootOffset, canvas, rotated, e) {\r\n    var coord = Math.floor(rotated ? e.pageY - rootOffset.top : e.pageX - rootOffset.left);\r\n    var min = rotated ? canvas.y1 : canvas.x1;\r\n    var max = rotated ? canvas.y2 : canvas.x2;\r\n    if (coord < min) {\r\n        coord = min\r\n    } else if (coord > max) {\r\n        coord = max\r\n    }\r\n    return coord\r\n}\r\n\r\nfunction checkCoords(rootOffset, canvas, e) {\r\n    var x = e.pageX - rootOffset.left;\r\n    var y = e.pageY - rootOffset.top;\r\n    return x >= canvas.x1 && x <= canvas.x2 && y >= canvas.y1 && y <= canvas.y2\r\n}\r\n\r\nfunction dragStartHandler(ctx) {\r\n    return function(e) {\r\n        var offset = ctx.getRootOffset();\r\n        var canvas = ctx.getCanvas();\r\n        if (!checkCoords(offset, canvas, e)) {\r\n            e.cancel = true;\r\n            return\r\n        }\r\n        ctx.rootOffset = offset;\r\n        ctx.canvas = canvas;\r\n        ctx.startCoord = getPointerCoord(offset, canvas, ctx.rotated, e);\r\n        ctx.triggerStart();\r\n        ctx.rect.attr({\r\n            x: canvas.x1,\r\n            y: canvas.y1,\r\n            width: canvas.width,\r\n            height: canvas.height\r\n        }).append(ctx.root)\r\n    }\r\n}\r\n\r\nfunction dragHandler(ctx) {\r\n    return function(e) {\r\n        var curCoord = getPointerCoord(ctx.rootOffset, ctx.canvas, ctx.rotated, e);\r\n        var attr = {};\r\n        ctx.curCoord = curCoord;\r\n        attr[ctx.rotated ? \"y\" : \"x\"] = Math.min(ctx.startCoord, curCoord);\r\n        attr[ctx.rotated ? \"height\" : \"width\"] = Math.abs(ctx.startCoord - curCoord);\r\n        ctx.rect.attr(attr)\r\n    }\r\n}\r\n\r\nfunction dragEndHandler(ctx) {\r\n    return function(e) {\r\n        ctx.triggerEnd();\r\n        ctx.rect.remove()\r\n    }\r\n}\r\n\r\nfunction shutterZoom(options) {\r\n    var chart = options.chart;\r\n    var renderer = options.renderer;\r\n    var rotated = options.rotated;\r\n    var rect = renderer.rect(0, 0, 0, 0).attr(options.shutterOptions);\r\n    var shutter = {\r\n        rect: rect,\r\n        root: renderer.root,\r\n        rotated: rotated,\r\n        triggerStart: function() {\r\n            chart._eventTrigger(\"zoomStart\")\r\n        },\r\n        triggerEnd: function() {\r\n            var tr = chart._argumentAxes[0].getTranslator();\r\n            var rangeStart = Math.min(this.startCoord, this.curCoord);\r\n            var rangeEnd = Math.max(this.startCoord, this.curCoord);\r\n            chart._eventTrigger(\"zoomEnd\", {\r\n                rangeStart: tr.from(rangeStart),\r\n                rangeEnd: tr.from(rangeEnd)\r\n            })\r\n        },\r\n        dispose: function() {\r\n            renderer.root.off(SHUTTER_EVENTS_NS);\r\n            rect.dispose()\r\n        },\r\n        getRootOffset: function() {\r\n            return renderer.getRootOffset()\r\n        },\r\n        getCanvas: function() {\r\n            var canvas = chart._canvas;\r\n            var panes = chart.panes;\r\n            var firstPane = panes[0].canvas;\r\n            var lastPane = panes[panes.length - 1].canvas;\r\n            return {\r\n                x1: firstPane.left,\r\n                y1: firstPane.top,\r\n                x2: canvas.width - lastPane.right,\r\n                y2: canvas.height - lastPane.bottom,\r\n                width: canvas.width - firstPane.left - lastPane.right,\r\n                height: canvas.height - firstPane.top - lastPane.bottom\r\n            }\r\n        }\r\n    };\r\n    renderer.root.off(SHUTTER_EVENTS_NS).on(DRAG_START_EVENT_NAME, {\r\n        direction: rotated ? \"vertical\" : \"horizontal\",\r\n        immediate: true\r\n    }, dragStartHandler(shutter)).on(DRAG_UPDATE_EVENT_NAME, dragHandler(shutter)).on(DRAG_END_EVENT_NAME, dragEndHandler(shutter));\r\n    return shutter\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    name: \"shutter_zoom\",\r\n    init: function() {\r\n        var options = this.option(\"shutterZoom\") || {};\r\n        if (!options.enabled) {\r\n            return\r\n        }\r\n        this._shutterZoom = shutterZoom({\r\n            chart: this,\r\n            renderer: this._renderer,\r\n            rotated: this.option(\"rotated\"),\r\n            shutterOptions: options\r\n        })\r\n    },\r\n    dispose: function() {\r\n        this._shutterZoom && this._shutterZoom.dispose()\r\n    }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2NoYXJ0X2NvbXBvbmVudHMvc2h1dHRlcl96b29tLmpzP2RhMjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLMkI7QUFDM0I7QUFDQSw0QkFBNEIsa0RBQWM7QUFDMUMsNkJBQTZCLGlEQUFhO0FBQzFDLDBCQUEwQixnREFBWTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3Zpei9jaGFydF9jb21wb25lbnRzL3NodXR0ZXJfem9vbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdml6L2NoYXJ0X2NvbXBvbmVudHMvc2h1dHRlcl96b29tLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQge1xyXG4gICAgc3RhcnQgYXMgZHJhZ0V2ZW50U3RhcnQsXHJcbiAgICBtb3ZlIGFzIGRyYWdFdmVudE1vdmUsXHJcbiAgICBlbmQgYXMgZHJhZ0V2ZW50RW5kXHJcbn0gZnJvbSBcIi4uLy4uL2V2ZW50cy9kcmFnXCI7XHJcbnZhciBTSFVUVEVSX0VWRU5UU19OUyA9IFwiLnNodXR0ZXItem9vbVwiO1xyXG52YXIgRFJBR19TVEFSVF9FVkVOVF9OQU1FID0gZHJhZ0V2ZW50U3RhcnQgKyBTSFVUVEVSX0VWRU5UU19OUztcclxudmFyIERSQUdfVVBEQVRFX0VWRU5UX05BTUUgPSBkcmFnRXZlbnRNb3ZlICsgU0hVVFRFUl9FVkVOVFNfTlM7XHJcbnZhciBEUkFHX0VORF9FVkVOVF9OQU1FID0gZHJhZ0V2ZW50RW5kICsgU0hVVFRFUl9FVkVOVFNfTlM7XHJcblxyXG5mdW5jdGlvbiBnZXRQb2ludGVyQ29vcmQocm9vdE9mZnNldCwgY2FudmFzLCByb3RhdGVkLCBlKSB7XHJcbiAgICB2YXIgY29vcmQgPSBNYXRoLmZsb29yKHJvdGF0ZWQgPyBlLnBhZ2VZIC0gcm9vdE9mZnNldC50b3AgOiBlLnBhZ2VYIC0gcm9vdE9mZnNldC5sZWZ0KTtcclxuICAgIHZhciBtaW4gPSByb3RhdGVkID8gY2FudmFzLnkxIDogY2FudmFzLngxO1xyXG4gICAgdmFyIG1heCA9IHJvdGF0ZWQgPyBjYW52YXMueTIgOiBjYW52YXMueDI7XHJcbiAgICBpZiAoY29vcmQgPCBtaW4pIHtcclxuICAgICAgICBjb29yZCA9IG1pblxyXG4gICAgfSBlbHNlIGlmIChjb29yZCA+IG1heCkge1xyXG4gICAgICAgIGNvb3JkID0gbWF4XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29vcmRcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tDb29yZHMocm9vdE9mZnNldCwgY2FudmFzLCBlKSB7XHJcbiAgICB2YXIgeCA9IGUucGFnZVggLSByb290T2Zmc2V0LmxlZnQ7XHJcbiAgICB2YXIgeSA9IGUucGFnZVkgLSByb290T2Zmc2V0LnRvcDtcclxuICAgIHJldHVybiB4ID49IGNhbnZhcy54MSAmJiB4IDw9IGNhbnZhcy54MiAmJiB5ID49IGNhbnZhcy55MSAmJiB5IDw9IGNhbnZhcy55MlxyXG59XHJcblxyXG5mdW5jdGlvbiBkcmFnU3RhcnRIYW5kbGVyKGN0eCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gY3R4LmdldFJvb3RPZmZzZXQoKTtcclxuICAgICAgICB2YXIgY2FudmFzID0gY3R4LmdldENhbnZhcygpO1xyXG4gICAgICAgIGlmICghY2hlY2tDb29yZHMob2Zmc2V0LCBjYW52YXMsIGUpKSB7XHJcbiAgICAgICAgICAgIGUuY2FuY2VsID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5yb290T2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIGN0eC5jYW52YXMgPSBjYW52YXM7XHJcbiAgICAgICAgY3R4LnN0YXJ0Q29vcmQgPSBnZXRQb2ludGVyQ29vcmQob2Zmc2V0LCBjYW52YXMsIGN0eC5yb3RhdGVkLCBlKTtcclxuICAgICAgICBjdHgudHJpZ2dlclN0YXJ0KCk7XHJcbiAgICAgICAgY3R4LnJlY3QuYXR0cih7XHJcbiAgICAgICAgICAgIHg6IGNhbnZhcy54MSxcclxuICAgICAgICAgICAgeTogY2FudmFzLnkxLFxyXG4gICAgICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcclxuICAgICAgICB9KS5hcHBlbmQoY3R4LnJvb3QpXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYWdIYW5kbGVyKGN0eCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICB2YXIgY3VyQ29vcmQgPSBnZXRQb2ludGVyQ29vcmQoY3R4LnJvb3RPZmZzZXQsIGN0eC5jYW52YXMsIGN0eC5yb3RhdGVkLCBlKTtcclxuICAgICAgICB2YXIgYXR0ciA9IHt9O1xyXG4gICAgICAgIGN0eC5jdXJDb29yZCA9IGN1ckNvb3JkO1xyXG4gICAgICAgIGF0dHJbY3R4LnJvdGF0ZWQgPyBcInlcIiA6IFwieFwiXSA9IE1hdGgubWluKGN0eC5zdGFydENvb3JkLCBjdXJDb29yZCk7XHJcbiAgICAgICAgYXR0cltjdHgucm90YXRlZCA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCJdID0gTWF0aC5hYnMoY3R4LnN0YXJ0Q29vcmQgLSBjdXJDb29yZCk7XHJcbiAgICAgICAgY3R4LnJlY3QuYXR0cihhdHRyKVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkcmFnRW5kSGFuZGxlcihjdHgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgY3R4LnRyaWdnZXJFbmQoKTtcclxuICAgICAgICBjdHgucmVjdC5yZW1vdmUoKVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzaHV0dGVyWm9vbShvcHRpb25zKSB7XHJcbiAgICB2YXIgY2hhcnQgPSBvcHRpb25zLmNoYXJ0O1xyXG4gICAgdmFyIHJlbmRlcmVyID0gb3B0aW9ucy5yZW5kZXJlcjtcclxuICAgIHZhciByb3RhdGVkID0gb3B0aW9ucy5yb3RhdGVkO1xyXG4gICAgdmFyIHJlY3QgPSByZW5kZXJlci5yZWN0KDAsIDAsIDAsIDApLmF0dHIob3B0aW9ucy5zaHV0dGVyT3B0aW9ucyk7XHJcbiAgICB2YXIgc2h1dHRlciA9IHtcclxuICAgICAgICByZWN0OiByZWN0LFxyXG4gICAgICAgIHJvb3Q6IHJlbmRlcmVyLnJvb3QsXHJcbiAgICAgICAgcm90YXRlZDogcm90YXRlZCxcclxuICAgICAgICB0cmlnZ2VyU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBjaGFydC5fZXZlbnRUcmlnZ2VyKFwiem9vbVN0YXJ0XCIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmlnZ2VyRW5kOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHRyID0gY2hhcnQuX2FyZ3VtZW50QXhlc1swXS5nZXRUcmFuc2xhdG9yKCk7XHJcbiAgICAgICAgICAgIHZhciByYW5nZVN0YXJ0ID0gTWF0aC5taW4odGhpcy5zdGFydENvb3JkLCB0aGlzLmN1ckNvb3JkKTtcclxuICAgICAgICAgICAgdmFyIHJhbmdlRW5kID0gTWF0aC5tYXgodGhpcy5zdGFydENvb3JkLCB0aGlzLmN1ckNvb3JkKTtcclxuICAgICAgICAgICAgY2hhcnQuX2V2ZW50VHJpZ2dlcihcInpvb21FbmRcIiwge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2VTdGFydDogdHIuZnJvbShyYW5nZVN0YXJ0KSxcclxuICAgICAgICAgICAgICAgIHJhbmdlRW5kOiB0ci5mcm9tKHJhbmdlRW5kKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJvb3Qub2ZmKFNIVVRURVJfRVZFTlRTX05TKTtcclxuICAgICAgICAgICAgcmVjdC5kaXNwb3NlKClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFJvb3RPZmZzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0Um9vdE9mZnNldCgpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gY2hhcnQuX2NhbnZhcztcclxuICAgICAgICAgICAgdmFyIHBhbmVzID0gY2hhcnQucGFuZXM7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdFBhbmUgPSBwYW5lc1swXS5jYW52YXM7XHJcbiAgICAgICAgICAgIHZhciBsYXN0UGFuZSA9IHBhbmVzW3BhbmVzLmxlbmd0aCAtIDFdLmNhbnZhcztcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHgxOiBmaXJzdFBhbmUubGVmdCxcclxuICAgICAgICAgICAgICAgIHkxOiBmaXJzdFBhbmUudG9wLFxyXG4gICAgICAgICAgICAgICAgeDI6IGNhbnZhcy53aWR0aCAtIGxhc3RQYW5lLnJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgeTI6IGNhbnZhcy5oZWlnaHQgLSBsYXN0UGFuZS5ib3R0b20sXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoIC0gZmlyc3RQYW5lLmxlZnQgLSBsYXN0UGFuZS5yaWdodCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodCAtIGZpcnN0UGFuZS50b3AgLSBsYXN0UGFuZS5ib3R0b21cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZW5kZXJlci5yb290Lm9mZihTSFVUVEVSX0VWRU5UU19OUykub24oRFJBR19TVEFSVF9FVkVOVF9OQU1FLCB7XHJcbiAgICAgICAgZGlyZWN0aW9uOiByb3RhdGVkID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIsXHJcbiAgICAgICAgaW1tZWRpYXRlOiB0cnVlXHJcbiAgICB9LCBkcmFnU3RhcnRIYW5kbGVyKHNodXR0ZXIpKS5vbihEUkFHX1VQREFURV9FVkVOVF9OQU1FLCBkcmFnSGFuZGxlcihzaHV0dGVyKSkub24oRFJBR19FTkRfRVZFTlRfTkFNRSwgZHJhZ0VuZEhhbmRsZXIoc2h1dHRlcikpO1xyXG4gICAgcmV0dXJuIHNodXR0ZXJcclxufVxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBuYW1lOiBcInNodXR0ZXJfem9vbVwiLFxyXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbihcInNodXR0ZXJab29tXCIpIHx8IHt9O1xyXG4gICAgICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zaHV0dGVyWm9vbSA9IHNodXR0ZXJab29tKHtcclxuICAgICAgICAgICAgY2hhcnQ6IHRoaXMsXHJcbiAgICAgICAgICAgIHJlbmRlcmVyOiB0aGlzLl9yZW5kZXJlcixcclxuICAgICAgICAgICAgcm90YXRlZDogdGhpcy5vcHRpb24oXCJyb3RhdGVkXCIpLFxyXG4gICAgICAgICAgICBzaHV0dGVyT3B0aW9uczogb3B0aW9uc1xyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fc2h1dHRlclpvb20gJiYgdGhpcy5fc2h1dHRlclpvb20uZGlzcG9zZSgpXHJcbiAgICB9XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/chart_components/shutter_zoom.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/chart_components/zoom_and_pan.js":
/*!**************************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/chart_components/zoom_and_pan.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/* harmony import */ var _events_core_wheel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../events/core/wheel */ \"./node_modules/devextreme/esm/events/core/wheel.js\");\n/* harmony import */ var _events_transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../events/transform */ \"./node_modules/devextreme/esm/events/transform.js\");\n/* harmony import */ var _events_drag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../events/drag */ \"./node_modules/devextreme/esm/events/drag.js\");\n/**\r\n * DevExtreme (esm/viz/chart_components/zoom_and_pan.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar EVENTS_NS = \".zoomAndPanNS\";\r\nvar DRAG_START_EVENT_NAME = _events_drag__WEBPACK_IMPORTED_MODULE_5__[\"start\"] + EVENTS_NS;\r\nvar DRAG_EVENT_NAME = _events_drag__WEBPACK_IMPORTED_MODULE_5__[\"move\"] + EVENTS_NS;\r\nvar DRAG_END_EVENT_NAME = _events_drag__WEBPACK_IMPORTED_MODULE_5__[\"end\"] + EVENTS_NS;\r\nvar PINCH_START_EVENT_NAME = _events_transform__WEBPACK_IMPORTED_MODULE_4__[\"pinchstart\"] + EVENTS_NS;\r\nvar PINCH_EVENT_NAME = _events_transform__WEBPACK_IMPORTED_MODULE_4__[\"pinch\"] + EVENTS_NS;\r\nvar PINCH_END_EVENT_NAME = _events_transform__WEBPACK_IMPORTED_MODULE_4__[\"pinchend\"] + EVENTS_NS;\r\nvar SCROLL_BAR_START_EVENT_NAME = \"dxc-scroll-start\" + EVENTS_NS;\r\nvar SCROLL_BAR_MOVE_EVENT_NAME = \"dxc-scroll-move\" + EVENTS_NS;\r\nvar SCROLL_BAR_END_EVENT_NAME = \"dxc-scroll-end\" + EVENTS_NS;\r\nvar GESTURE_TIMEOUT = 300;\r\nvar MIN_DRAG_DELTA = 5;\r\nvar _min = Math.min;\r\nvar _max = Math.max;\r\nvar _abs = Math.abs;\r\n\r\nfunction canvasToRect(canvas) {\r\n    return {\r\n        x: canvas.left,\r\n        y: canvas.top,\r\n        width: canvas.width - canvas.left - canvas.right,\r\n        height: canvas.height - canvas.top - canvas.bottom\r\n    }\r\n}\r\n\r\nfunction checkCoords(rect, coords) {\r\n    var x = coords.x;\r\n    var y = coords.y;\r\n    return x >= rect.x && x <= rect.width + rect.x && y >= rect.y && y <= rect.height + rect.y\r\n}\r\n\r\nfunction sortAxes(axes, onlyAxisToNotify) {\r\n    if (onlyAxisToNotify) {\r\n        axes = axes.sort((a, b) => {\r\n            if (a === onlyAxisToNotify) {\r\n                return -1\r\n            }\r\n            if (b === onlyAxisToNotify) {\r\n                return 1\r\n            }\r\n            return 0\r\n        })\r\n    }\r\n    return axes\r\n}\r\n\r\nfunction isNotEmptyAxisBusinessRange(axis) {\r\n    return !axis.getTranslator().getBusinessRange().isEmpty()\r\n}\r\n\r\nfunction axisZoom(axis, onlyAxisToNotify, getRange, getParameters, actionField, scale, e) {\r\n    var silent = onlyAxisToNotify && axis !== onlyAxisToNotify;\r\n    var range = getRange(axis);\r\n    var {\r\n        stopInteraction: stopInteraction,\r\n        correctedRange: correctedRange\r\n    } = axis.checkZoomingLowerLimitOvercome(actionField, scale, range);\r\n    var result = axis.handleZooming(stopInteraction ? null : correctedRange, getParameters(silent), e, actionField);\r\n    stopInteraction && axis.handleZoomEnd();\r\n    return {\r\n        stopInteraction: stopInteraction,\r\n        result: result\r\n    }\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    name: \"zoom_and_pan\",\r\n    init: function() {\r\n        var chart = this;\r\n        var renderer = this._renderer;\r\n\r\n        function cancelEvent(e) {\r\n            if (e.originalEvent) {\r\n                cancelEvent(e.originalEvent)\r\n            }\r\n            if (false !== e.cancelable) {\r\n                e.cancel = true\r\n            }\r\n        }\r\n\r\n        function startAxesViewportChanging(zoomAndPan, actionField, e) {\r\n            var options = zoomAndPan.options;\r\n            var actionData = zoomAndPan.actionData;\r\n            var axes = [];\r\n            if (options.argumentAxis[actionField]) {\r\n                axes.push(chart.getArgumentAxis())\r\n            }\r\n            if (options.valueAxis[actionField]) {\r\n                axes = axes.concat(actionData.valueAxes)\r\n            }\r\n            axes.reduce((isPrevented, axis) => {\r\n                if (isPrevented) {\r\n                    return isPrevented\r\n                }\r\n                if (isNotEmptyAxisBusinessRange(axis)) {\r\n                    return axis.handleZooming(null, {\r\n                        end: true\r\n                    }, e, actionField).isPrevented\r\n                }\r\n                return isPrevented\r\n            }, false) && cancelEvent(e)\r\n        }\r\n\r\n        function axesViewportChanging(zoomAndPan, actionField, e, offsetCalc, centerCalc) {\r\n            function zoomAxes(axes, criteria, coordField, e, actionData) {\r\n                var zoom = {\r\n                    zoomed: false\r\n                };\r\n                criteria && axes.filter(isNotEmptyAxisBusinessRange).forEach(axis => {\r\n                    var options = axis.getOptions();\r\n                    var viewport = axis.visualRange();\r\n                    var scale = axis.getTranslator().getEventScale(e);\r\n                    var translate = -offsetCalc(e, actionData, coordField, scale);\r\n                    zoom = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])(true, zoom, axis.getTranslator().zoom(translate, scale, axis.getZoomBounds()));\r\n                    var range = axis.adjustRange(Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"getVizRangeObject\"])([zoom.min, zoom.max]));\r\n                    var {\r\n                        stopInteraction: stopInteraction,\r\n                        correctedRange: correctedRange\r\n                    } = axis.checkZoomingLowerLimitOvercome(actionField, scale, range);\r\n                    if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(viewport) || viewport.startValue.valueOf() !== correctedRange.startValue.valueOf() || viewport.endValue.valueOf() !== correctedRange.endValue.valueOf()) {\r\n                        axis.handleZooming(stopInteraction ? null : correctedRange, {\r\n                            start: true,\r\n                            end: true\r\n                        }, e, actionField);\r\n                        if (!stopInteraction) {\r\n                            zoom.zoomed = true;\r\n                            zoom.deltaTranslate = translate - zoom.translate\r\n                        }\r\n                    } else if (\"touch\" === e.pointerType && \"discrete\" === options.type) {\r\n                        var isMinPosition = axis.isExtremePosition(false);\r\n                        var isMaxPosition = axis.isExtremePosition(true);\r\n                        var zoomInEnabled = scale > 1 && !stopInteraction;\r\n                        var zoomOutEnabled = scale < 1 && (!isMinPosition || !isMaxPosition);\r\n                        var panningEnabled = 1 === scale && !(isMinPosition && (translate < 0 && !options.inverted || translate > 0 && options.inverted) || isMaxPosition && (translate > 0 && !options.inverted || translate < 0 && options.inverted));\r\n                        zoom.enabled = zoomInEnabled || zoomOutEnabled || panningEnabled\r\n                    }\r\n                });\r\n                return zoom\r\n            }\r\n\r\n            function storeOffset(e, actionData, zoom, coordField) {\r\n                if (zoom.zoomed) {\r\n                    actionData.offset[coordField] = (e.offset ? e.offset[coordField] : actionData.offset[coordField]) + zoom.deltaTranslate\r\n                }\r\n            }\r\n\r\n            function storeCenter(center, actionData, zoom, coordField) {\r\n                if (zoom.zoomed) {\r\n                    actionData.center[coordField] = center[coordField] + zoom.deltaTranslate\r\n                }\r\n            }\r\n            var rotated = chart.option(\"rotated\");\r\n            var actionData = zoomAndPan.actionData;\r\n            var options = zoomAndPan.options;\r\n            var argZoom = {};\r\n            var valZoom = {};\r\n            if (!actionData.fallback) {\r\n                argZoom = zoomAxes(chart._argumentAxes, options.argumentAxis[actionField], rotated ? \"y\" : \"x\", e, actionData);\r\n                valZoom = zoomAxes(actionData.valueAxes, options.valueAxis[actionField], rotated ? \"x\" : \"y\", e, actionData);\r\n                chart._requestChange([\"VISUAL_RANGE\"]);\r\n                storeOffset(e, actionData, argZoom, rotated ? \"y\" : \"x\");\r\n                storeOffset(e, actionData, valZoom, rotated ? \"x\" : \"y\")\r\n            }\r\n            var center = centerCalc(e);\r\n            storeCenter(center, actionData, argZoom, rotated ? \"y\" : \"x\");\r\n            storeCenter(center, actionData, valZoom, rotated ? \"x\" : \"y\");\r\n            if (!argZoom.zoomed && !valZoom.zoomed) {\r\n                actionData.center = center\r\n            }\r\n            return argZoom.zoomed || valZoom.zoomed || actionData.fallback || argZoom.enabled || valZoom.enabled\r\n        }\r\n\r\n        function finishAxesViewportChanging(zoomAndPan, actionField, e, offsetCalc) {\r\n            function zoomAxes(axes, criteria, coordField, actionData, onlyAxisToNotify) {\r\n                var zoomStarted = false;\r\n                var scale = e.scale || 1;\r\n                var getRange = axis => {\r\n                    var zoom = axis.getTranslator().zoom(-offsetCalc(e, actionData, coordField, scale), scale, axis.getZoomBounds());\r\n                    return {\r\n                        startValue: zoom.min,\r\n                        endValue: zoom.max\r\n                    }\r\n                };\r\n                var getParameters = silent => ({\r\n                    start: true,\r\n                    end: silent\r\n                });\r\n                criteria && axes.forEach(axis => {\r\n                    zoomStarted = !axisZoom(axis, onlyAxisToNotify, getRange, getParameters, actionField, scale, e).stopInteraction\r\n                });\r\n                return zoomStarted\r\n            }\r\n            var rotated = chart.option(\"rotated\");\r\n            var actionData = zoomAndPan.actionData;\r\n            var options = zoomAndPan.options;\r\n            var zoomStarted = true;\r\n            if (actionData.fallback) {\r\n                zoomStarted &= zoomAxes(chart._argumentAxes, options.argumentAxis[actionField], rotated ? \"y\" : \"x\", actionData, chart.getArgumentAxis());\r\n                zoomStarted |= zoomAxes(actionData.valueAxes, options.valueAxis[actionField], rotated ? \"x\" : \"y\", actionData)\r\n            } else {\r\n                var axes = [];\r\n                if (options.argumentAxis[actionField]) {\r\n                    axes.push(chart.getArgumentAxis())\r\n                }\r\n                if (options.valueAxis[actionField]) {\r\n                    axes = axes.concat(actionData.valueAxes)\r\n                }\r\n                axes.filter(isNotEmptyAxisBusinessRange).forEach(axis => {\r\n                    axis.handleZooming(null, {\r\n                        start: true\r\n                    }, e, actionField)\r\n                });\r\n                zoomStarted = axes.length\r\n            }\r\n            zoomStarted && chart._requestChange([\"VISUAL_RANGE\"])\r\n        }\r\n\r\n        function prepareActionData(coords, action) {\r\n            var axes = chart._argumentAxes.filter(axis => checkCoords(canvasToRect(axis.getCanvas()), coords));\r\n            return {\r\n                fallback: chart._lastRenderingTime > GESTURE_TIMEOUT,\r\n                cancel: !axes.length || !Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(action),\r\n                action: action,\r\n                curAxisRect: axes.length && canvasToRect(axes[0].getCanvas()),\r\n                valueAxes: axes.length && chart._valueAxes.filter(axis => checkCoords(canvasToRect(axis.getCanvas()), coords)),\r\n                offset: {\r\n                    x: 0,\r\n                    y: 0\r\n                },\r\n                center: coords,\r\n                startCenter: coords\r\n            }\r\n        }\r\n\r\n        function getPointerCoord(rect, e) {\r\n            var rootOffset = renderer.getRootOffset();\r\n            return {\r\n                x: _min(_max(e.pageX - rootOffset.left, rect.x), rect.width + rect.x),\r\n                y: _min(_max(e.pageY - rootOffset.top, rect.y), rect.height + rect.y)\r\n            }\r\n        }\r\n\r\n        function calcCenterForPinch(e) {\r\n            var rootOffset = renderer.getRootOffset();\r\n            var x1 = e.pointers[0].pageX;\r\n            var x2 = e.pointers[1].pageX;\r\n            var y1 = e.pointers[0].pageY;\r\n            var y2 = e.pointers[1].pageY;\r\n            return {\r\n                x: _min(x1, x2) + _abs(x2 - x1) / 2 - rootOffset.left,\r\n                y: _min(y1, y2) + _abs(y2 - y1) / 2 - rootOffset.top\r\n            }\r\n        }\r\n\r\n        function calcCenterForDrag(e) {\r\n            var rootOffset = renderer.getRootOffset();\r\n            return {\r\n                x: e.pageX - rootOffset.left,\r\n                y: e.pageY - rootOffset.top\r\n            }\r\n        }\r\n\r\n        function calcOffsetForDrag(e, actionData, coordField) {\r\n            return e.offset[coordField] - actionData.offset[coordField]\r\n        }\r\n\r\n        function preventDefaults(e) {\r\n            if (false !== e.cancelable) {\r\n                e.preventDefault();\r\n                e.stopPropagation()\r\n            }\r\n            chart._stopCurrentHandling()\r\n        }\r\n        var zoomAndPan = {\r\n            dragStartHandler: function(e) {\r\n                var options = zoomAndPan.options;\r\n                var isTouch = \"touch\" === e.pointerType;\r\n                var wantPan = options.argumentAxis.pan || options.valueAxis.pan;\r\n                var wantZoom = options.argumentAxis.zoom || options.valueAxis.zoom;\r\n                var panKeyPressed = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(options.panKey) && e[Object(_core_utils__WEBPACK_IMPORTED_MODULE_2__[\"normalizeEnum\"])(options.panKey) + \"Key\"];\r\n                var dragToZoom = options.dragToZoom;\r\n                var action;\r\n                e._cancelPreventDefault = true;\r\n                if (isTouch) {\r\n                    if (options.allowTouchGestures && wantPan) {\r\n                        var cancelPanning = !zoomAndPan.panningVisualRangeEnabled() || zoomAndPan.skipEvent;\r\n                        action = cancelPanning ? null : \"pan\"\r\n                    }\r\n                } else if (dragToZoom && wantPan && panKeyPressed) {\r\n                    action = \"pan\"\r\n                } else if (!dragToZoom && wantPan) {\r\n                    action = \"pan\"\r\n                } else if (dragToZoom && wantZoom) {\r\n                    action = \"zoom\"\r\n                }\r\n                var actionData = prepareActionData(calcCenterForDrag(e), action);\r\n                if (actionData.cancel) {\r\n                    zoomAndPan.skipEvent = false;\r\n                    if (false !== e.cancelable) {\r\n                        e.cancel = true\r\n                    }\r\n                    return\r\n                }\r\n                zoomAndPan.actionData = actionData;\r\n                if (\"zoom\" === action) {\r\n                    actionData.startCoords = getPointerCoord(actionData.curAxisRect, e);\r\n                    actionData.rect = renderer.rect(0, 0, 0, 0).attr(options.dragBoxStyle).append(renderer.root)\r\n                } else {\r\n                    startAxesViewportChanging(zoomAndPan, \"pan\", e)\r\n                }\r\n            },\r\n            dragHandler: function(e) {\r\n                var rotated = chart.option(\"rotated\");\r\n                var options = zoomAndPan.options;\r\n                var actionData = zoomAndPan.actionData;\r\n                var isTouch = \"touch\" === e.pointerType;\r\n                e._cancelPreventDefault = true;\r\n                if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled()) {\r\n                    return\r\n                }\r\n                if (\"zoom\" === actionData.action) {\r\n                    preventDefaults(e);\r\n                    var curCanvas = actionData.curAxisRect;\r\n                    var startCoords = actionData.startCoords;\r\n                    var curCoords = getPointerCoord(curCanvas, e);\r\n                    var zoomArg = options.argumentAxis.zoom;\r\n                    var zoomVal = options.valueAxis.zoom;\r\n                    var rect = {\r\n                        x: _min(startCoords.x, curCoords.x),\r\n                        y: _min(startCoords.y, curCoords.y),\r\n                        width: _abs(startCoords.x - curCoords.x),\r\n                        height: _abs(startCoords.y - curCoords.y)\r\n                    };\r\n                    if (!zoomArg || !zoomVal) {\r\n                        if (!zoomArg && !rotated || !zoomVal && rotated) {\r\n                            rect.x = curCanvas.x;\r\n                            rect.width = curCanvas.width\r\n                        } else {\r\n                            rect.y = curCanvas.y;\r\n                            rect.height = curCanvas.height\r\n                        }\r\n                    }\r\n                    actionData.rect.attr(rect)\r\n                } else if (\"pan\" === actionData.action) {\r\n                    axesViewportChanging(zoomAndPan, \"pan\", e, calcOffsetForDrag, e => e.offset);\r\n                    var deltaOffsetY = Math.abs(e.offset.y - actionData.offset.y);\r\n                    var deltaOffsetX = Math.abs(e.offset.x - actionData.offset.x);\r\n                    if (isTouch && (deltaOffsetY > MIN_DRAG_DELTA && deltaOffsetY > Math.abs(actionData.offset.x) || deltaOffsetX > MIN_DRAG_DELTA && deltaOffsetX > Math.abs(actionData.offset.y))) {\r\n                        return\r\n                    }\r\n                    preventDefaults(e)\r\n                }\r\n            },\r\n            dragEndHandler: function(e) {\r\n                var rotated = chart.option(\"rotated\");\r\n                var options = zoomAndPan.options;\r\n                var actionData = zoomAndPan.actionData;\r\n                var isTouch = \"touch\" === e.pointerType;\r\n                var panIsEmpty = actionData && \"pan\" === actionData.action && !actionData.fallback && 0 === actionData.offset.x && 0 === actionData.offset.y;\r\n                if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled() || panIsEmpty) {\r\n                    return\r\n                }(!isTouch || !zoomAndPan.actionData.isNative) && preventDefaults(e);\r\n                if (\"zoom\" === actionData.action) {\r\n                    var zoomAxes = (axes, criteria, coordField, startCoords, curCoords, onlyAxisToNotify) => {\r\n                        axes = sortAxes(axes, onlyAxisToNotify);\r\n                        var curCoord = curCoords[coordField];\r\n                        var startCoord = startCoords[coordField];\r\n                        var zoomStarted = false;\r\n                        var getParameters = silent => ({\r\n                            start: !!silent,\r\n                            end: !!silent\r\n                        });\r\n                        if (criteria && _abs(curCoord - startCoord) > MIN_DRAG_DELTA) {\r\n                            axes.some(axis => {\r\n                                var tr = axis.getTranslator();\r\n                                if (tr.getBusinessRange().isEmpty()) {\r\n                                    return\r\n                                }\r\n                                var {\r\n                                    stopInteraction: stopInteraction,\r\n                                    result: result\r\n                                } = axisZoom(axis, onlyAxisToNotify, () => [tr.from(startCoord), tr.from(curCoord)], getParameters, actionData.action, tr.getMinScale(true), e);\r\n                                zoomStarted = !stopInteraction;\r\n                                return onlyAxisToNotify && result.isPrevented\r\n                            })\r\n                        }\r\n                        return zoomStarted\r\n                    };\r\n                    var curCoords = getPointerCoord(actionData.curAxisRect, e);\r\n                    var argumentAxesZoomed = zoomAxes(chart._argumentAxes, options.argumentAxis.zoom, rotated ? \"y\" : \"x\", actionData.startCoords, curCoords, chart.getArgumentAxis());\r\n                    var valueAxesZoomed = zoomAxes(actionData.valueAxes, options.valueAxis.zoom, rotated ? \"x\" : \"y\", actionData.startCoords, curCoords);\r\n                    if (valueAxesZoomed || argumentAxesZoomed) {\r\n                        chart._requestChange([\"VISUAL_RANGE\"])\r\n                    }\r\n                    actionData.rect.dispose()\r\n                } else if (\"pan\" === actionData.action) {\r\n                    finishAxesViewportChanging(zoomAndPan, \"pan\", e, calcOffsetForDrag)\r\n                }\r\n                zoomAndPan.actionData = null\r\n            },\r\n            pinchStartHandler: function(e) {\r\n                var actionData = prepareActionData(calcCenterForPinch(e), \"zoom\");\r\n                actionData.isNative = !zoomAndPan.panningVisualRangeEnabled();\r\n                if (actionData.cancel) {\r\n                    cancelEvent(e);\r\n                    return\r\n                }\r\n                zoomAndPan.actionData = actionData;\r\n                startAxesViewportChanging(zoomAndPan, \"zoom\", e)\r\n            },\r\n            pinchHandler: function(e) {\r\n                if (!zoomAndPan.actionData) {\r\n                    return\r\n                }\r\n                var viewportChanged = axesViewportChanging(zoomAndPan, \"zoom\", e, (e, actionData, coordField, scale) => calcCenterForPinch(e)[coordField] - actionData.center[coordField] + (actionData.center[coordField] - actionData.center[coordField] * scale), calcCenterForPinch);\r\n                zoomAndPan.defineTouchBehavior(!viewportChanged, e);\r\n                !viewportChanged && (zoomAndPan.actionData = null)\r\n            },\r\n            pinchEndHandler: function(e) {\r\n                if (!zoomAndPan.actionData) {\r\n                    return\r\n                }\r\n                finishAxesViewportChanging(zoomAndPan, \"zoom\", e, (e, actionData, coordField, scale) => actionData.center[coordField] - actionData.startCenter[coordField] + (actionData.startCenter[coordField] - actionData.startCenter[coordField] * scale));\r\n                zoomAndPan.actionData = null\r\n            },\r\n            cleanup: function() {\r\n                renderer.root.off(EVENTS_NS);\r\n                zoomAndPan.actionData && zoomAndPan.actionData.rect && zoomAndPan.actionData.rect.dispose();\r\n                zoomAndPan.actionData = null;\r\n                renderer.root.css({\r\n                    \"touch-action\": \"\",\r\n                    \"-ms-touch-action\": \"\"\r\n                })\r\n            },\r\n            setup: function(options) {\r\n                zoomAndPan.cleanup();\r\n                if (!options.argumentAxis.pan) {\r\n                    renderer.root.on(SCROLL_BAR_START_EVENT_NAME, cancelEvent)\r\n                }\r\n                if (options.argumentAxis.none && options.valueAxis.none) {\r\n                    return\r\n                }\r\n                zoomAndPan.options = options;\r\n                var rotated = chart.option(\"rotated\");\r\n                if ((options.argumentAxis.zoom || options.valueAxis.zoom) && options.allowMouseWheel) {\r\n                    renderer.root.on(_events_core_wheel__WEBPACK_IMPORTED_MODULE_3__[\"name\"] + EVENTS_NS, (function(e) {\r\n                        function zoomAxes(axes, coord, delta, onlyAxisToNotify) {\r\n                            axes = sortAxes(axes, onlyAxisToNotify);\r\n                            var zoomStarted = false;\r\n                            var getParameters = silent => ({\r\n                                start: !!silent,\r\n                                end: !!silent\r\n                            });\r\n                            axes.some(axis => {\r\n                                var translator = axis.getTranslator();\r\n                                if (translator.getBusinessRange().isEmpty()) {\r\n                                    return\r\n                                }\r\n                                var scale = translator.getMinScale(delta > 0);\r\n                                var {\r\n                                    stopInteraction: stopInteraction,\r\n                                    result: result\r\n                                } = axisZoom(axis, onlyAxisToNotify, () => {\r\n                                    var zoom = translator.zoom(-(coord - coord * scale), scale, axis.getZoomBounds());\r\n                                    return {\r\n                                        startValue: zoom.min,\r\n                                        endValue: zoom.max\r\n                                    }\r\n                                }, getParameters, \"zoom\", scale, e);\r\n                                zoomStarted = !stopInteraction;\r\n                                return onlyAxisToNotify && result.isPrevented\r\n                            });\r\n                            return zoomStarted\r\n                        }\r\n                        var coords = calcCenterForDrag(e);\r\n                        var axesZoomed = false;\r\n                        var targetAxes;\r\n                        if (options.valueAxis.zoom) {\r\n                            targetAxes = chart._valueAxes.filter(axis => checkCoords(canvasToRect(axis.getCanvas()), coords));\r\n                            if (0 === targetAxes.length) {\r\n                                var targetCanvas = chart._valueAxes.reduce((r, axis) => {\r\n                                    if (!r && axis.coordsIn(coords.x, coords.y)) {\r\n                                        r = axis.getCanvas()\r\n                                    }\r\n                                    return r\r\n                                }, null);\r\n                                if (targetCanvas) {\r\n                                    targetAxes = chart._valueAxes.filter(axis => checkCoords(canvasToRect(axis.getCanvas()), {\r\n                                        x: targetCanvas.left,\r\n                                        y: targetCanvas.top\r\n                                    }))\r\n                                }\r\n                            }\r\n                            axesZoomed |= zoomAxes(targetAxes, rotated ? coords.x : coords.y, e.delta)\r\n                        }\r\n                        if (options.argumentAxis.zoom) {\r\n                            var canZoom = chart._argumentAxes.some(axis => {\r\n                                if (checkCoords(canvasToRect(axis.getCanvas()), coords) || axis.coordsIn(coords.x, coords.y)) {\r\n                                    return true\r\n                                }\r\n                                return false\r\n                            });\r\n                            axesZoomed |= canZoom && zoomAxes(chart._argumentAxes, rotated ? coords.y : coords.x, e.delta, chart.getArgumentAxis())\r\n                        }\r\n                        if (axesZoomed) {\r\n                            chart._requestChange([\"VISUAL_RANGE\"]);\r\n                            zoomAndPan.panningVisualRangeEnabled(targetAxes) && preventDefaults(e)\r\n                        }\r\n                    }))\r\n                }\r\n                if (options.allowTouchGestures) {\r\n                    if (options.argumentAxis.zoom || options.valueAxis.zoom) {\r\n                        renderer.root.on(PINCH_START_EVENT_NAME, {\r\n                            passive: false\r\n                        }, zoomAndPan.pinchStartHandler).on(PINCH_EVENT_NAME, {\r\n                            passive: false\r\n                        }, zoomAndPan.pinchHandler).on(PINCH_END_EVENT_NAME, zoomAndPan.pinchEndHandler)\r\n                    }\r\n                }\r\n                renderer.root.on(DRAG_START_EVENT_NAME, {\r\n                    immediate: true,\r\n                    passive: false\r\n                }, zoomAndPan.dragStartHandler).on(DRAG_EVENT_NAME, {\r\n                    immediate: true,\r\n                    passive: false\r\n                }, zoomAndPan.dragHandler).on(DRAG_END_EVENT_NAME, zoomAndPan.dragEndHandler);\r\n                if (options.argumentAxis.pan) {\r\n                    renderer.root.on(SCROLL_BAR_START_EVENT_NAME, (function(e) {\r\n                        zoomAndPan.actionData = {\r\n                            valueAxes: [],\r\n                            offset: {\r\n                                x: 0,\r\n                                y: 0\r\n                            },\r\n                            center: {\r\n                                x: 0,\r\n                                y: 0\r\n                            }\r\n                        };\r\n                        preventDefaults(e);\r\n                        startAxesViewportChanging(zoomAndPan, \"pan\", e)\r\n                    })).on(SCROLL_BAR_MOVE_EVENT_NAME, (function(e) {\r\n                        preventDefaults(e);\r\n                        axesViewportChanging(zoomAndPan, \"pan\", e, calcOffsetForDrag, e => e.offset)\r\n                    })).on(SCROLL_BAR_END_EVENT_NAME, (function(e) {\r\n                        preventDefaults(e);\r\n                        finishAxesViewportChanging(zoomAndPan, \"pan\", e, calcOffsetForDrag);\r\n                        zoomAndPan.actionData = null\r\n                    }))\r\n                }\r\n            },\r\n            defineTouchBehavior: function(isDefault, e) {\r\n                zoomAndPan.actionData && (zoomAndPan.actionData.isNative = isDefault);\r\n                if (!isDefault) {\r\n                    preventDefaults(e)\r\n                }\r\n            },\r\n            panningVisualRangeEnabled: function(targetAxes) {\r\n                if (null !== targetAxes && void 0 !== targetAxes && targetAxes.length) {\r\n                    return targetAxes.some(axis => !axis.isExtremePosition(false) || !axis.isExtremePosition(true))\r\n                }\r\n                var enablePanByValueAxis = chart._valueAxes.some(axis => !axis.isExtremePosition(false) || !axis.isExtremePosition(true));\r\n                var enablePanByArgumentAxis = chart._argumentAxes.some(axis => !axis.isExtremePosition(false) || !axis.isExtremePosition(true));\r\n                return enablePanByValueAxis || enablePanByArgumentAxis\r\n            }\r\n        };\r\n        this._zoomAndPan = zoomAndPan\r\n    },\r\n    members: {\r\n        _setupZoomAndPan: function() {\r\n            this._zoomAndPan.setup(this._themeManager.getOptions(\"zoomAndPan\"))\r\n        }\r\n    },\r\n    dispose: function() {\r\n        this._zoomAndPan.cleanup()\r\n    },\r\n    customize: function(constructor) {\r\n        constructor.addChange({\r\n            code: \"ZOOM_AND_PAN\",\r\n            handler: function() {\r\n                this._setupZoomAndPan()\r\n            },\r\n            isThemeDependent: true,\r\n            isOptionChange: true,\r\n            option: \"zoomAndPan\"\r\n        })\r\n    }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2NoYXJ0X2NvbXBvbmVudHMvem9vbV9hbmRfcGFuLmpzPzY0ZWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRytCO0FBR0U7QUFJVjtBQUdVO0FBQ3lCO0FBSy9CO0FBQzNCO0FBQ0EsNEJBQTRCLGtEQUFjO0FBQzFDLHNCQUFzQixpREFBYTtBQUNuQywwQkFBMEIsZ0RBQVk7QUFDdEMsNkJBQTZCLDREQUEwQjtBQUN2RCx1QkFBdUIsdURBQXFCO0FBQzVDLDJCQUEyQiwwREFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFNO0FB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Q0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUMsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS92aXovY2hhcnRfY29tcG9uZW50cy96b29tX2FuZF9wYW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3Zpei9jaGFydF9jb21wb25lbnRzL3pvb21fYW5kX3Bhbi5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IHtcclxuICAgIGlzRGVmaW5lZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL3R5cGVcIjtcclxuaW1wb3J0IHtcclxuICAgIGV4dGVuZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2V4dGVuZFwiO1xyXG5pbXBvcnQge1xyXG4gICAgbm9ybWFsaXplRW51bSxcclxuICAgIGdldFZpelJhbmdlT2JqZWN0XHJcbn0gZnJvbSBcIi4uL2NvcmUvdXRpbHNcIjtcclxuaW1wb3J0IHtcclxuICAgIG5hbWUgYXMgd2hlZWxFdmVudFxyXG59IGZyb20gXCIuLi8uLi9ldmVudHMvY29yZS93aGVlbFwiO1xyXG5pbXBvcnQgKiBhcyB0cmFuc2Zvcm1FdmVudHMgZnJvbSBcIi4uLy4uL2V2ZW50cy90cmFuc2Zvcm1cIjtcclxuaW1wb3J0IHtcclxuICAgIHN0YXJ0IGFzIGRyYWdFdmVudFN0YXJ0LFxyXG4gICAgbW92ZSBhcyBkcmFnRXZlbnRNb3ZlLFxyXG4gICAgZW5kIGFzIGRyYWdFdmVudEVuZFxyXG59IGZyb20gXCIuLi8uLi9ldmVudHMvZHJhZ1wiO1xyXG52YXIgRVZFTlRTX05TID0gXCIuem9vbUFuZFBhbk5TXCI7XHJcbnZhciBEUkFHX1NUQVJUX0VWRU5UX05BTUUgPSBkcmFnRXZlbnRTdGFydCArIEVWRU5UU19OUztcclxudmFyIERSQUdfRVZFTlRfTkFNRSA9IGRyYWdFdmVudE1vdmUgKyBFVkVOVFNfTlM7XHJcbnZhciBEUkFHX0VORF9FVkVOVF9OQU1FID0gZHJhZ0V2ZW50RW5kICsgRVZFTlRTX05TO1xyXG52YXIgUElOQ0hfU1RBUlRfRVZFTlRfTkFNRSA9IHRyYW5zZm9ybUV2ZW50cy5waW5jaHN0YXJ0ICsgRVZFTlRTX05TO1xyXG52YXIgUElOQ0hfRVZFTlRfTkFNRSA9IHRyYW5zZm9ybUV2ZW50cy5waW5jaCArIEVWRU5UU19OUztcclxudmFyIFBJTkNIX0VORF9FVkVOVF9OQU1FID0gdHJhbnNmb3JtRXZlbnRzLnBpbmNoZW5kICsgRVZFTlRTX05TO1xyXG52YXIgU0NST0xMX0JBUl9TVEFSVF9FVkVOVF9OQU1FID0gXCJkeGMtc2Nyb2xsLXN0YXJ0XCIgKyBFVkVOVFNfTlM7XHJcbnZhciBTQ1JPTExfQkFSX01PVkVfRVZFTlRfTkFNRSA9IFwiZHhjLXNjcm9sbC1tb3ZlXCIgKyBFVkVOVFNfTlM7XHJcbnZhciBTQ1JPTExfQkFSX0VORF9FVkVOVF9OQU1FID0gXCJkeGMtc2Nyb2xsLWVuZFwiICsgRVZFTlRTX05TO1xyXG52YXIgR0VTVFVSRV9USU1FT1VUID0gMzAwO1xyXG52YXIgTUlOX0RSQUdfREVMVEEgPSA1O1xyXG52YXIgX21pbiA9IE1hdGgubWluO1xyXG52YXIgX21heCA9IE1hdGgubWF4O1xyXG52YXIgX2FicyA9IE1hdGguYWJzO1xyXG5cclxuZnVuY3Rpb24gY2FudmFzVG9SZWN0KGNhbnZhcykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBjYW52YXMubGVmdCxcclxuICAgICAgICB5OiBjYW52YXMudG9wLFxyXG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGggLSBjYW52YXMubGVmdCAtIGNhbnZhcy5yaWdodCxcclxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQgLSBjYW52YXMudG9wIC0gY2FudmFzLmJvdHRvbVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0Nvb3JkcyhyZWN0LCBjb29yZHMpIHtcclxuICAgIHZhciB4ID0gY29vcmRzLng7XHJcbiAgICB2YXIgeSA9IGNvb3Jkcy55O1xyXG4gICAgcmV0dXJuIHggPj0gcmVjdC54ICYmIHggPD0gcmVjdC53aWR0aCArIHJlY3QueCAmJiB5ID49IHJlY3QueSAmJiB5IDw9IHJlY3QuaGVpZ2h0ICsgcmVjdC55XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNvcnRBeGVzKGF4ZXMsIG9ubHlBeGlzVG9Ob3RpZnkpIHtcclxuICAgIGlmIChvbmx5QXhpc1RvTm90aWZ5KSB7XHJcbiAgICAgICAgYXhlcyA9IGF4ZXMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYSA9PT0gb25seUF4aXNUb05vdGlmeSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGIgPT09IG9ubHlBeGlzVG9Ob3RpZnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDBcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGF4ZXNcclxufVxyXG5cclxuZnVuY3Rpb24gaXNOb3RFbXB0eUF4aXNCdXNpbmVzc1JhbmdlKGF4aXMpIHtcclxuICAgIHJldHVybiAhYXhpcy5nZXRUcmFuc2xhdG9yKCkuZ2V0QnVzaW5lc3NSYW5nZSgpLmlzRW1wdHkoKVxyXG59XHJcblxyXG5mdW5jdGlvbiBheGlzWm9vbShheGlzLCBvbmx5QXhpc1RvTm90aWZ5LCBnZXRSYW5nZSwgZ2V0UGFyYW1ldGVycywgYWN0aW9uRmllbGQsIHNjYWxlLCBlKSB7XHJcbiAgICB2YXIgc2lsZW50ID0gb25seUF4aXNUb05vdGlmeSAmJiBheGlzICE9PSBvbmx5QXhpc1RvTm90aWZ5O1xyXG4gICAgdmFyIHJhbmdlID0gZ2V0UmFuZ2UoYXhpcyk7XHJcbiAgICB2YXIge1xyXG4gICAgICAgIHN0b3BJbnRlcmFjdGlvbjogc3RvcEludGVyYWN0aW9uLFxyXG4gICAgICAgIGNvcnJlY3RlZFJhbmdlOiBjb3JyZWN0ZWRSYW5nZVxyXG4gICAgfSA9IGF4aXMuY2hlY2tab29taW5nTG93ZXJMaW1pdE92ZXJjb21lKGFjdGlvbkZpZWxkLCBzY2FsZSwgcmFuZ2UpO1xyXG4gICAgdmFyIHJlc3VsdCA9IGF4aXMuaGFuZGxlWm9vbWluZyhzdG9wSW50ZXJhY3Rpb24gPyBudWxsIDogY29ycmVjdGVkUmFuZ2UsIGdldFBhcmFtZXRlcnMoc2lsZW50KSwgZSwgYWN0aW9uRmllbGQpO1xyXG4gICAgc3RvcEludGVyYWN0aW9uICYmIGF4aXMuaGFuZGxlWm9vbUVuZCgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdG9wSW50ZXJhY3Rpb246IHN0b3BJbnRlcmFjdGlvbixcclxuICAgICAgICByZXN1bHQ6IHJlc3VsdFxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIG5hbWU6IFwiem9vbV9hbmRfcGFuXCIsXHJcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjYW5jZWxFdmVudChlKSB7XHJcbiAgICAgICAgICAgIGlmIChlLm9yaWdpbmFsRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhbmNlbEV2ZW50KGUub3JpZ2luYWxFdmVudClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmFsc2UgIT09IGUuY2FuY2VsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgZS5jYW5jZWwgPSB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0QXhlc1ZpZXdwb3J0Q2hhbmdpbmcoem9vbUFuZFBhbiwgYWN0aW9uRmllbGQsIGUpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB6b29tQW5kUGFuLm9wdGlvbnM7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25EYXRhID0gem9vbUFuZFBhbi5hY3Rpb25EYXRhO1xyXG4gICAgICAgICAgICB2YXIgYXhlcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcmd1bWVudEF4aXNbYWN0aW9uRmllbGRdKSB7XHJcbiAgICAgICAgICAgICAgICBheGVzLnB1c2goY2hhcnQuZ2V0QXJndW1lbnRBeGlzKCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudmFsdWVBeGlzW2FjdGlvbkZpZWxkXSkge1xyXG4gICAgICAgICAgICAgICAgYXhlcyA9IGF4ZXMuY29uY2F0KGFjdGlvbkRhdGEudmFsdWVBeGVzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF4ZXMucmVkdWNlKChpc1ByZXZlbnRlZCwgYXhpcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUHJldmVudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJldmVudGVkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOb3RFbXB0eUF4aXNCdXNpbmVzc1JhbmdlKGF4aXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF4aXMuaGFuZGxlWm9vbWluZyhudWxsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIGUsIGFjdGlvbkZpZWxkKS5pc1ByZXZlbnRlZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJldmVudGVkXHJcbiAgICAgICAgICAgIH0sIGZhbHNlKSAmJiBjYW5jZWxFdmVudChlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYXhlc1ZpZXdwb3J0Q2hhbmdpbmcoem9vbUFuZFBhbiwgYWN0aW9uRmllbGQsIGUsIG9mZnNldENhbGMsIGNlbnRlckNhbGMpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gem9vbUF4ZXMoYXhlcywgY3JpdGVyaWEsIGNvb3JkRmllbGQsIGUsIGFjdGlvbkRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciB6b29tID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHpvb21lZDogZmFsc2VcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjcml0ZXJpYSAmJiBheGVzLmZpbHRlcihpc05vdEVtcHR5QXhpc0J1c2luZXNzUmFuZ2UpLmZvckVhY2goYXhpcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBheGlzLmdldE9wdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnQgPSBheGlzLnZpc3VhbFJhbmdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gYXhpcy5nZXRUcmFuc2xhdG9yKCkuZ2V0RXZlbnRTY2FsZShlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRlID0gLW9mZnNldENhbGMoZSwgYWN0aW9uRGF0YSwgY29vcmRGaWVsZCwgc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHpvb20gPSBleHRlbmQodHJ1ZSwgem9vbSwgYXhpcy5nZXRUcmFuc2xhdG9yKCkuem9vbSh0cmFuc2xhdGUsIHNjYWxlLCBheGlzLmdldFpvb21Cb3VuZHMoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGF4aXMuYWRqdXN0UmFuZ2UoZ2V0Vml6UmFuZ2VPYmplY3QoW3pvb20ubWluLCB6b29tLm1heF0pKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wSW50ZXJhY3Rpb246IHN0b3BJbnRlcmFjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVjdGVkUmFuZ2U6IGNvcnJlY3RlZFJhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgfSA9IGF4aXMuY2hlY2tab29taW5nTG93ZXJMaW1pdE92ZXJjb21lKGFjdGlvbkZpZWxkLCBzY2FsZSwgcmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKHZpZXdwb3J0KSB8fCB2aWV3cG9ydC5zdGFydFZhbHVlLnZhbHVlT2YoKSAhPT0gY29ycmVjdGVkUmFuZ2Uuc3RhcnRWYWx1ZS52YWx1ZU9mKCkgfHwgdmlld3BvcnQuZW5kVmFsdWUudmFsdWVPZigpICE9PSBjb3JyZWN0ZWRSYW5nZS5lbmRWYWx1ZS52YWx1ZU9mKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpcy5oYW5kbGVab29taW5nKHN0b3BJbnRlcmFjdGlvbiA/IG51bGwgOiBjb3JyZWN0ZWRSYW5nZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZSwgYWN0aW9uRmllbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3BJbnRlcmFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbS56b29tZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbS5kZWx0YVRyYW5zbGF0ZSA9IHRyYW5zbGF0ZSAtIHpvb20udHJhbnNsYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwidG91Y2hcIiA9PT0gZS5wb2ludGVyVHlwZSAmJiBcImRpc2NyZXRlXCIgPT09IG9wdGlvbnMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNNaW5Qb3NpdGlvbiA9IGF4aXMuaXNFeHRyZW1lUG9zaXRpb24oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNNYXhQb3NpdGlvbiA9IGF4aXMuaXNFeHRyZW1lUG9zaXRpb24odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6b29tSW5FbmFibGVkID0gc2NhbGUgPiAxICYmICFzdG9wSW50ZXJhY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6b29tT3V0RW5hYmxlZCA9IHNjYWxlIDwgMSAmJiAoIWlzTWluUG9zaXRpb24gfHwgIWlzTWF4UG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFubmluZ0VuYWJsZWQgPSAxID09PSBzY2FsZSAmJiAhKGlzTWluUG9zaXRpb24gJiYgKHRyYW5zbGF0ZSA8IDAgJiYgIW9wdGlvbnMuaW52ZXJ0ZWQgfHwgdHJhbnNsYXRlID4gMCAmJiBvcHRpb25zLmludmVydGVkKSB8fCBpc01heFBvc2l0aW9uICYmICh0cmFuc2xhdGUgPiAwICYmICFvcHRpb25zLmludmVydGVkIHx8IHRyYW5zbGF0ZSA8IDAgJiYgb3B0aW9ucy5pbnZlcnRlZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6b29tLmVuYWJsZWQgPSB6b29tSW5FbmFibGVkIHx8IHpvb21PdXRFbmFibGVkIHx8IHBhbm5pbmdFbmFibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gem9vbVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdG9yZU9mZnNldChlLCBhY3Rpb25EYXRhLCB6b29tLCBjb29yZEZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoem9vbS56b29tZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25EYXRhLm9mZnNldFtjb29yZEZpZWxkXSA9IChlLm9mZnNldCA/IGUub2Zmc2V0W2Nvb3JkRmllbGRdIDogYWN0aW9uRGF0YS5vZmZzZXRbY29vcmRGaWVsZF0pICsgem9vbS5kZWx0YVRyYW5zbGF0ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdG9yZUNlbnRlcihjZW50ZXIsIGFjdGlvbkRhdGEsIHpvb20sIGNvb3JkRmllbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh6b29tLnpvb21lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkRhdGEuY2VudGVyW2Nvb3JkRmllbGRdID0gY2VudGVyW2Nvb3JkRmllbGRdICsgem9vbS5kZWx0YVRyYW5zbGF0ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByb3RhdGVkID0gY2hhcnQub3B0aW9uKFwicm90YXRlZFwiKTtcclxuICAgICAgICAgICAgdmFyIGFjdGlvbkRhdGEgPSB6b29tQW5kUGFuLmFjdGlvbkRhdGE7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gem9vbUFuZFBhbi5vcHRpb25zO1xyXG4gICAgICAgICAgICB2YXIgYXJnWm9vbSA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgdmFsWm9vbSA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWFjdGlvbkRhdGEuZmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGFyZ1pvb20gPSB6b29tQXhlcyhjaGFydC5fYXJndW1lbnRBeGVzLCBvcHRpb25zLmFyZ3VtZW50QXhpc1thY3Rpb25GaWVsZF0sIHJvdGF0ZWQgPyBcInlcIiA6IFwieFwiLCBlLCBhY3Rpb25EYXRhKTtcclxuICAgICAgICAgICAgICAgIHZhbFpvb20gPSB6b29tQXhlcyhhY3Rpb25EYXRhLnZhbHVlQXhlcywgb3B0aW9ucy52YWx1ZUF4aXNbYWN0aW9uRmllbGRdLCByb3RhdGVkID8gXCJ4XCIgOiBcInlcIiwgZSwgYWN0aW9uRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5fcmVxdWVzdENoYW5nZShbXCJWSVNVQUxfUkFOR0VcIl0pO1xyXG4gICAgICAgICAgICAgICAgc3RvcmVPZmZzZXQoZSwgYWN0aW9uRGF0YSwgYXJnWm9vbSwgcm90YXRlZCA/IFwieVwiIDogXCJ4XCIpO1xyXG4gICAgICAgICAgICAgICAgc3RvcmVPZmZzZXQoZSwgYWN0aW9uRGF0YSwgdmFsWm9vbSwgcm90YXRlZCA/IFwieFwiIDogXCJ5XCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IGNlbnRlckNhbGMoZSk7XHJcbiAgICAgICAgICAgIHN0b3JlQ2VudGVyKGNlbnRlciwgYWN0aW9uRGF0YSwgYXJnWm9vbSwgcm90YXRlZCA/IFwieVwiIDogXCJ4XCIpO1xyXG4gICAgICAgICAgICBzdG9yZUNlbnRlcihjZW50ZXIsIGFjdGlvbkRhdGEsIHZhbFpvb20sIHJvdGF0ZWQgPyBcInhcIiA6IFwieVwiKTtcclxuICAgICAgICAgICAgaWYgKCFhcmdab29tLnpvb21lZCAmJiAhdmFsWm9vbS56b29tZWQpIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbkRhdGEuY2VudGVyID0gY2VudGVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFyZ1pvb20uem9vbWVkIHx8IHZhbFpvb20uem9vbWVkIHx8IGFjdGlvbkRhdGEuZmFsbGJhY2sgfHwgYXJnWm9vbS5lbmFibGVkIHx8IHZhbFpvb20uZW5hYmxlZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZmluaXNoQXhlc1ZpZXdwb3J0Q2hhbmdpbmcoem9vbUFuZFBhbiwgYWN0aW9uRmllbGQsIGUsIG9mZnNldENhbGMpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gem9vbUF4ZXMoYXhlcywgY3JpdGVyaWEsIGNvb3JkRmllbGQsIGFjdGlvbkRhdGEsIG9ubHlBeGlzVG9Ob3RpZnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB6b29tU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gZS5zY2FsZSB8fCAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdldFJhbmdlID0gYXhpcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHpvb20gPSBheGlzLmdldFRyYW5zbGF0b3IoKS56b29tKC1vZmZzZXRDYWxjKGUsIGFjdGlvbkRhdGEsIGNvb3JkRmllbGQsIHNjYWxlKSwgc2NhbGUsIGF4aXMuZ2V0Wm9vbUJvdW5kcygpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB6b29tLm1pbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kVmFsdWU6IHpvb20ubWF4XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciBnZXRQYXJhbWV0ZXJzID0gc2lsZW50ID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBzaWxlbnRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY3JpdGVyaWEgJiYgYXhlcy5mb3JFYWNoKGF4aXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHpvb21TdGFydGVkID0gIWF4aXNab29tKGF4aXMsIG9ubHlBeGlzVG9Ob3RpZnksIGdldFJhbmdlLCBnZXRQYXJhbWV0ZXJzLCBhY3Rpb25GaWVsZCwgc2NhbGUsIGUpLnN0b3BJbnRlcmFjdGlvblxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gem9vbVN0YXJ0ZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcm90YXRlZCA9IGNoYXJ0Lm9wdGlvbihcInJvdGF0ZWRcIik7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25EYXRhID0gem9vbUFuZFBhbi5hY3Rpb25EYXRhO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHpvb21BbmRQYW4ub3B0aW9ucztcclxuICAgICAgICAgICAgdmFyIHpvb21TdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGFjdGlvbkRhdGEuZmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHpvb21TdGFydGVkICY9IHpvb21BeGVzKGNoYXJ0Ll9hcmd1bWVudEF4ZXMsIG9wdGlvbnMuYXJndW1lbnRBeGlzW2FjdGlvbkZpZWxkXSwgcm90YXRlZCA/IFwieVwiIDogXCJ4XCIsIGFjdGlvbkRhdGEsIGNoYXJ0LmdldEFyZ3VtZW50QXhpcygpKTtcclxuICAgICAgICAgICAgICAgIHpvb21TdGFydGVkIHw9IHpvb21BeGVzKGFjdGlvbkRhdGEudmFsdWVBeGVzLCBvcHRpb25zLnZhbHVlQXhpc1thY3Rpb25GaWVsZF0sIHJvdGF0ZWQgPyBcInhcIiA6IFwieVwiLCBhY3Rpb25EYXRhKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGF4ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFyZ3VtZW50QXhpc1thY3Rpb25GaWVsZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBheGVzLnB1c2goY2hhcnQuZ2V0QXJndW1lbnRBeGlzKCkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy52YWx1ZUF4aXNbYWN0aW9uRmllbGRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhlcyA9IGF4ZXMuY29uY2F0KGFjdGlvbkRhdGEudmFsdWVBeGVzKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXhlcy5maWx0ZXIoaXNOb3RFbXB0eUF4aXNCdXNpbmVzc1JhbmdlKS5mb3JFYWNoKGF4aXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuaGFuZGxlWm9vbWluZyhudWxsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZSwgYWN0aW9uRmllbGQpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHpvb21TdGFydGVkID0gYXhlcy5sZW5ndGhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB6b29tU3RhcnRlZCAmJiBjaGFydC5fcmVxdWVzdENoYW5nZShbXCJWSVNVQUxfUkFOR0VcIl0pXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwcmVwYXJlQWN0aW9uRGF0YShjb29yZHMsIGFjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgYXhlcyA9IGNoYXJ0Ll9hcmd1bWVudEF4ZXMuZmlsdGVyKGF4aXMgPT4gY2hlY2tDb29yZHMoY2FudmFzVG9SZWN0KGF4aXMuZ2V0Q2FudmFzKCkpLCBjb29yZHMpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGZhbGxiYWNrOiBjaGFydC5fbGFzdFJlbmRlcmluZ1RpbWUgPiBHRVNUVVJFX1RJTUVPVVQsXHJcbiAgICAgICAgICAgICAgICBjYW5jZWw6ICFheGVzLmxlbmd0aCB8fCAhaXNEZWZpbmVkKGFjdGlvbiksXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcclxuICAgICAgICAgICAgICAgIGN1ckF4aXNSZWN0OiBheGVzLmxlbmd0aCAmJiBjYW52YXNUb1JlY3QoYXhlc1swXS5nZXRDYW52YXMoKSksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZUF4ZXM6IGF4ZXMubGVuZ3RoICYmIGNoYXJ0Ll92YWx1ZUF4ZXMuZmlsdGVyKGF4aXMgPT4gY2hlY2tDb29yZHMoY2FudmFzVG9SZWN0KGF4aXMuZ2V0Q2FudmFzKCkpLCBjb29yZHMpKSxcclxuICAgICAgICAgICAgICAgIG9mZnNldDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNlbnRlcjogY29vcmRzLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRDZW50ZXI6IGNvb3Jkc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRQb2ludGVyQ29vcmQocmVjdCwgZSkge1xyXG4gICAgICAgICAgICB2YXIgcm9vdE9mZnNldCA9IHJlbmRlcmVyLmdldFJvb3RPZmZzZXQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IF9taW4oX21heChlLnBhZ2VYIC0gcm9vdE9mZnNldC5sZWZ0LCByZWN0LngpLCByZWN0LndpZHRoICsgcmVjdC54KSxcclxuICAgICAgICAgICAgICAgIHk6IF9taW4oX21heChlLnBhZ2VZIC0gcm9vdE9mZnNldC50b3AsIHJlY3QueSksIHJlY3QuaGVpZ2h0ICsgcmVjdC55KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjYWxjQ2VudGVyRm9yUGluY2goZSkge1xyXG4gICAgICAgICAgICB2YXIgcm9vdE9mZnNldCA9IHJlbmRlcmVyLmdldFJvb3RPZmZzZXQoKTtcclxuICAgICAgICAgICAgdmFyIHgxID0gZS5wb2ludGVyc1swXS5wYWdlWDtcclxuICAgICAgICAgICAgdmFyIHgyID0gZS5wb2ludGVyc1sxXS5wYWdlWDtcclxuICAgICAgICAgICAgdmFyIHkxID0gZS5wb2ludGVyc1swXS5wYWdlWTtcclxuICAgICAgICAgICAgdmFyIHkyID0gZS5wb2ludGVyc1sxXS5wYWdlWTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IF9taW4oeDEsIHgyKSArIF9hYnMoeDIgLSB4MSkgLyAyIC0gcm9vdE9mZnNldC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgeTogX21pbih5MSwgeTIpICsgX2Ficyh5MiAtIHkxKSAvIDIgLSByb290T2Zmc2V0LnRvcFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjYWxjQ2VudGVyRm9yRHJhZyhlKSB7XHJcbiAgICAgICAgICAgIHZhciByb290T2Zmc2V0ID0gcmVuZGVyZXIuZ2V0Um9vdE9mZnNldCgpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogZS5wYWdlWCAtIHJvb3RPZmZzZXQubGVmdCxcclxuICAgICAgICAgICAgICAgIHk6IGUucGFnZVkgLSByb290T2Zmc2V0LnRvcFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjYWxjT2Zmc2V0Rm9yRHJhZyhlLCBhY3Rpb25EYXRhLCBjb29yZEZpZWxkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlLm9mZnNldFtjb29yZEZpZWxkXSAtIGFjdGlvbkRhdGEub2Zmc2V0W2Nvb3JkRmllbGRdXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdHMoZSkge1xyXG4gICAgICAgICAgICBpZiAoZmFsc2UgIT09IGUuY2FuY2VsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoYXJ0Ll9zdG9wQ3VycmVudEhhbmRsaW5nKClcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHpvb21BbmRQYW4gPSB7XHJcbiAgICAgICAgICAgIGRyYWdTdGFydEhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gem9vbUFuZFBhbi5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzVG91Y2ggPSBcInRvdWNoXCIgPT09IGUucG9pbnRlclR5cGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2FudFBhbiA9IG9wdGlvbnMuYXJndW1lbnRBeGlzLnBhbiB8fCBvcHRpb25zLnZhbHVlQXhpcy5wYW47XHJcbiAgICAgICAgICAgICAgICB2YXIgd2FudFpvb20gPSBvcHRpb25zLmFyZ3VtZW50QXhpcy56b29tIHx8IG9wdGlvbnMudmFsdWVBeGlzLnpvb207XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFuS2V5UHJlc3NlZCA9IGlzRGVmaW5lZChvcHRpb25zLnBhbktleSkgJiYgZVtub3JtYWxpemVFbnVtKG9wdGlvbnMucGFuS2V5KSArIFwiS2V5XCJdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyYWdUb1pvb20gPSBvcHRpb25zLmRyYWdUb1pvb207XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgZS5fY2FuY2VsUHJldmVudERlZmF1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVG91Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd1RvdWNoR2VzdHVyZXMgJiYgd2FudFBhbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuY2VsUGFubmluZyA9ICF6b29tQW5kUGFuLnBhbm5pbmdWaXN1YWxSYW5nZUVuYWJsZWQoKSB8fCB6b29tQW5kUGFuLnNraXBFdmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gY2FuY2VsUGFubmluZyA/IG51bGwgOiBcInBhblwiXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkcmFnVG9ab29tICYmIHdhbnRQYW4gJiYgcGFuS2V5UHJlc3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IFwicGFuXCJcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRyYWdUb1pvb20gJiYgd2FudFBhbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IFwicGFuXCJcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZHJhZ1RvWm9vbSAmJiB3YW50Wm9vbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IFwiem9vbVwiXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uRGF0YSA9IHByZXBhcmVBY3Rpb25EYXRhKGNhbGNDZW50ZXJGb3JEcmFnKGUpLCBhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbkRhdGEuY2FuY2VsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgem9vbUFuZFBhbi5za2lwRXZlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmFsc2UgIT09IGUuY2FuY2VsYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmNhbmNlbCA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB6b29tQW5kUGFuLmFjdGlvbkRhdGEgPSBhY3Rpb25EYXRhO1xyXG4gICAgICAgICAgICAgICAgaWYgKFwiem9vbVwiID09PSBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25EYXRhLnN0YXJ0Q29vcmRzID0gZ2V0UG9pbnRlckNvb3JkKGFjdGlvbkRhdGEuY3VyQXhpc1JlY3QsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkRhdGEucmVjdCA9IHJlbmRlcmVyLnJlY3QoMCwgMCwgMCwgMCkuYXR0cihvcHRpb25zLmRyYWdCb3hTdHlsZSkuYXBwZW5kKHJlbmRlcmVyLnJvb3QpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0QXhlc1ZpZXdwb3J0Q2hhbmdpbmcoem9vbUFuZFBhbiwgXCJwYW5cIiwgZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ0hhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb3RhdGVkID0gY2hhcnQub3B0aW9uKFwicm90YXRlZFwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gem9vbUFuZFBhbi5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbkRhdGEgPSB6b29tQW5kUGFuLmFjdGlvbkRhdGE7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNUb3VjaCA9IFwidG91Y2hcIiA9PT0gZS5wb2ludGVyVHlwZTtcclxuICAgICAgICAgICAgICAgIGUuX2NhbmNlbFByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghYWN0aW9uRGF0YSB8fCBpc1RvdWNoICYmICF6b29tQW5kUGFuLnBhbm5pbmdWaXN1YWxSYW5nZUVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKFwiem9vbVwiID09PSBhY3Rpb25EYXRhLmFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0cyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyQ2FudmFzID0gYWN0aW9uRGF0YS5jdXJBeGlzUmVjdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb29yZHMgPSBhY3Rpb25EYXRhLnN0YXJ0Q29vcmRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJDb29yZHMgPSBnZXRQb2ludGVyQ29vcmQoY3VyQ2FudmFzLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgem9vbUFyZyA9IG9wdGlvbnMuYXJndW1lbnRBeGlzLnpvb207XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHpvb21WYWwgPSBvcHRpb25zLnZhbHVlQXhpcy56b29tO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBfbWluKHN0YXJ0Q29vcmRzLngsIGN1ckNvb3Jkcy54KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogX21pbihzdGFydENvb3Jkcy55LCBjdXJDb29yZHMueSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBfYWJzKHN0YXJ0Q29vcmRzLnggLSBjdXJDb29yZHMueCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogX2FicyhzdGFydENvb3Jkcy55IC0gY3VyQ29vcmRzLnkpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXpvb21BcmcgfHwgIXpvb21WYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF6b29tQXJnICYmICFyb3RhdGVkIHx8ICF6b29tVmFsICYmIHJvdGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QueCA9IGN1ckNhbnZhcy54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC53aWR0aCA9IGN1ckNhbnZhcy53aWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC55ID0gY3VyQ2FudmFzLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0LmhlaWdodCA9IGN1ckNhbnZhcy5oZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25EYXRhLnJlY3QuYXR0cihyZWN0KVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcInBhblwiID09PSBhY3Rpb25EYXRhLmFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGF4ZXNWaWV3cG9ydENoYW5naW5nKHpvb21BbmRQYW4sIFwicGFuXCIsIGUsIGNhbGNPZmZzZXRGb3JEcmFnLCBlID0+IGUub2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFPZmZzZXRZID0gTWF0aC5hYnMoZS5vZmZzZXQueSAtIGFjdGlvbkRhdGEub2Zmc2V0LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YU9mZnNldFggPSBNYXRoLmFicyhlLm9mZnNldC54IC0gYWN0aW9uRGF0YS5vZmZzZXQueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVG91Y2ggJiYgKGRlbHRhT2Zmc2V0WSA+IE1JTl9EUkFHX0RFTFRBICYmIGRlbHRhT2Zmc2V0WSA+IE1hdGguYWJzKGFjdGlvbkRhdGEub2Zmc2V0LngpIHx8IGRlbHRhT2Zmc2V0WCA+IE1JTl9EUkFHX0RFTFRBICYmIGRlbHRhT2Zmc2V0WCA+IE1hdGguYWJzKGFjdGlvbkRhdGEub2Zmc2V0LnkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRzKGUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdFbmRIYW5kbGVyOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRlZCA9IGNoYXJ0Lm9wdGlvbihcInJvdGF0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHpvb21BbmRQYW4ub3B0aW9ucztcclxuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25EYXRhID0gem9vbUFuZFBhbi5hY3Rpb25EYXRhO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzVG91Y2ggPSBcInRvdWNoXCIgPT09IGUucG9pbnRlclR5cGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFuSXNFbXB0eSA9IGFjdGlvbkRhdGEgJiYgXCJwYW5cIiA9PT0gYWN0aW9uRGF0YS5hY3Rpb24gJiYgIWFjdGlvbkRhdGEuZmFsbGJhY2sgJiYgMCA9PT0gYWN0aW9uRGF0YS5vZmZzZXQueCAmJiAwID09PSBhY3Rpb25EYXRhLm9mZnNldC55O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhY3Rpb25EYXRhIHx8IGlzVG91Y2ggJiYgIXpvb21BbmRQYW4ucGFubmluZ1Zpc3VhbFJhbmdlRW5hYmxlZCgpIHx8IHBhbklzRW1wdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH0oIWlzVG91Y2ggfHwgIXpvb21BbmRQYW4uYWN0aW9uRGF0YS5pc05hdGl2ZSkgJiYgcHJldmVudERlZmF1bHRzKGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFwiem9vbVwiID09PSBhY3Rpb25EYXRhLmFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB6b29tQXhlcyA9IChheGVzLCBjcml0ZXJpYSwgY29vcmRGaWVsZCwgc3RhcnRDb29yZHMsIGN1ckNvb3Jkcywgb25seUF4aXNUb05vdGlmeSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBheGVzID0gc29ydEF4ZXMoYXhlcywgb25seUF4aXNUb05vdGlmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJDb29yZCA9IGN1ckNvb3Jkc1tjb29yZEZpZWxkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q29vcmQgPSBzdGFydENvb3Jkc1tjb29yZEZpZWxkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHpvb21TdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRQYXJhbWV0ZXJzID0gc2lsZW50ID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogISFzaWxlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6ICEhc2lsZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3JpdGVyaWEgJiYgX2FicyhjdXJDb29yZCAtIHN0YXJ0Q29vcmQpID4gTUlOX0RSQUdfREVMVEEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4ZXMuc29tZShheGlzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHIgPSBheGlzLmdldFRyYW5zbGF0b3IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHIuZ2V0QnVzaW5lc3NSYW5nZSgpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcEludGVyYWN0aW9uOiBzdG9wSW50ZXJhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA9IGF4aXNab29tKGF4aXMsIG9ubHlBeGlzVG9Ob3RpZnksICgpID0+IFt0ci5mcm9tKHN0YXJ0Q29vcmQpLCB0ci5mcm9tKGN1ckNvb3JkKV0sIGdldFBhcmFtZXRlcnMsIGFjdGlvbkRhdGEuYWN0aW9uLCB0ci5nZXRNaW5TY2FsZSh0cnVlKSwgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbVN0YXJ0ZWQgPSAhc3RvcEludGVyYWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvbmx5QXhpc1RvTm90aWZ5ICYmIHJlc3VsdC5pc1ByZXZlbnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gem9vbVN0YXJ0ZWRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJDb29yZHMgPSBnZXRQb2ludGVyQ29vcmQoYWN0aW9uRGF0YS5jdXJBeGlzUmVjdCwgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3VtZW50QXhlc1pvb21lZCA9IHpvb21BeGVzKGNoYXJ0Ll9hcmd1bWVudEF4ZXMsIG9wdGlvbnMuYXJndW1lbnRBeGlzLnpvb20sIHJvdGF0ZWQgPyBcInlcIiA6IFwieFwiLCBhY3Rpb25EYXRhLnN0YXJ0Q29vcmRzLCBjdXJDb29yZHMsIGNoYXJ0LmdldEFyZ3VtZW50QXhpcygpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVBeGVzWm9vbWVkID0gem9vbUF4ZXMoYWN0aW9uRGF0YS52YWx1ZUF4ZXMsIG9wdGlvbnMudmFsdWVBeGlzLnpvb20sIHJvdGF0ZWQgPyBcInhcIiA6IFwieVwiLCBhY3Rpb25EYXRhLnN0YXJ0Q29vcmRzLCBjdXJDb29yZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUF4ZXNab29tZWQgfHwgYXJndW1lbnRBeGVzWm9vbWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0Ll9yZXF1ZXN0Q2hhbmdlKFtcIlZJU1VBTF9SQU5HRVwiXSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uRGF0YS5yZWN0LmRpc3Bvc2UoKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcInBhblwiID09PSBhY3Rpb25EYXRhLmFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaEF4ZXNWaWV3cG9ydENoYW5naW5nKHpvb21BbmRQYW4sIFwicGFuXCIsIGUsIGNhbGNPZmZzZXRGb3JEcmFnKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgem9vbUFuZFBhbi5hY3Rpb25EYXRhID0gbnVsbFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwaW5jaFN0YXJ0SGFuZGxlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbkRhdGEgPSBwcmVwYXJlQWN0aW9uRGF0YShjYWxjQ2VudGVyRm9yUGluY2goZSksIFwiem9vbVwiKTtcclxuICAgICAgICAgICAgICAgIGFjdGlvbkRhdGEuaXNOYXRpdmUgPSAhem9vbUFuZFBhbi5wYW5uaW5nVmlzdWFsUmFuZ2VFbmFibGVkKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uRGF0YS5jYW5jZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxFdmVudChlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHpvb21BbmRQYW4uYWN0aW9uRGF0YSA9IGFjdGlvbkRhdGE7XHJcbiAgICAgICAgICAgICAgICBzdGFydEF4ZXNWaWV3cG9ydENoYW5naW5nKHpvb21BbmRQYW4sIFwiem9vbVwiLCBlKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwaW5jaEhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghem9vbUFuZFBhbi5hY3Rpb25EYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRDaGFuZ2VkID0gYXhlc1ZpZXdwb3J0Q2hhbmdpbmcoem9vbUFuZFBhbiwgXCJ6b29tXCIsIGUsIChlLCBhY3Rpb25EYXRhLCBjb29yZEZpZWxkLCBzY2FsZSkgPT4gY2FsY0NlbnRlckZvclBpbmNoKGUpW2Nvb3JkRmllbGRdIC0gYWN0aW9uRGF0YS5jZW50ZXJbY29vcmRGaWVsZF0gKyAoYWN0aW9uRGF0YS5jZW50ZXJbY29vcmRGaWVsZF0gLSBhY3Rpb25EYXRhLmNlbnRlcltjb29yZEZpZWxkXSAqIHNjYWxlKSwgY2FsY0NlbnRlckZvclBpbmNoKTtcclxuICAgICAgICAgICAgICAgIHpvb21BbmRQYW4uZGVmaW5lVG91Y2hCZWhhdmlvcighdmlld3BvcnRDaGFuZ2VkLCBlKTtcclxuICAgICAgICAgICAgICAgICF2aWV3cG9ydENoYW5nZWQgJiYgKHpvb21BbmRQYW4uYWN0aW9uRGF0YSA9IG51bGwpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBpbmNoRW5kSGFuZGxlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF6b29tQW5kUGFuLmFjdGlvbkRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmlzaEF4ZXNWaWV3cG9ydENoYW5naW5nKHpvb21BbmRQYW4sIFwiem9vbVwiLCBlLCAoZSwgYWN0aW9uRGF0YSwgY29vcmRGaWVsZCwgc2NhbGUpID0+IGFjdGlvbkRhdGEuY2VudGVyW2Nvb3JkRmllbGRdIC0gYWN0aW9uRGF0YS5zdGFydENlbnRlcltjb29yZEZpZWxkXSArIChhY3Rpb25EYXRhLnN0YXJ0Q2VudGVyW2Nvb3JkRmllbGRdIC0gYWN0aW9uRGF0YS5zdGFydENlbnRlcltjb29yZEZpZWxkXSAqIHNjYWxlKSk7XHJcbiAgICAgICAgICAgICAgICB6b29tQW5kUGFuLmFjdGlvbkRhdGEgPSBudWxsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsZWFudXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIucm9vdC5vZmYoRVZFTlRTX05TKTtcclxuICAgICAgICAgICAgICAgIHpvb21BbmRQYW4uYWN0aW9uRGF0YSAmJiB6b29tQW5kUGFuLmFjdGlvbkRhdGEucmVjdCAmJiB6b29tQW5kUGFuLmFjdGlvbkRhdGEucmVjdC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB6b29tQW5kUGFuLmFjdGlvbkRhdGEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIucm9vdC5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgIFwidG91Y2gtYWN0aW9uXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCItbXMtdG91Y2gtYWN0aW9uXCI6IFwiXCJcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldHVwOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB6b29tQW5kUGFuLmNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5hcmd1bWVudEF4aXMucGFuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIucm9vdC5vbihTQ1JPTExfQkFSX1NUQVJUX0VWRU5UX05BTUUsIGNhbmNlbEV2ZW50KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJndW1lbnRBeGlzLm5vbmUgJiYgb3B0aW9ucy52YWx1ZUF4aXMubm9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgem9vbUFuZFBhbi5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICAgICAgICAgIHZhciByb3RhdGVkID0gY2hhcnQub3B0aW9uKFwicm90YXRlZFwiKTtcclxuICAgICAgICAgICAgICAgIGlmICgob3B0aW9ucy5hcmd1bWVudEF4aXMuem9vbSB8fCBvcHRpb25zLnZhbHVlQXhpcy56b29tKSAmJiBvcHRpb25zLmFsbG93TW91c2VXaGVlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJvb3Qub24od2hlZWxFdmVudCArIEVWRU5UU19OUywgKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gem9vbUF4ZXMoYXhlcywgY29vcmQsIGRlbHRhLCBvbmx5QXhpc1RvTm90aWZ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGVzID0gc29ydEF4ZXMoYXhlcywgb25seUF4aXNUb05vdGlmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgem9vbVN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRQYXJhbWV0ZXJzID0gc2lsZW50ID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6ICEhc2lsZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogISFzaWxlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhlcy5zb21lKGF4aXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2xhdG9yID0gYXhpcy5nZXRUcmFuc2xhdG9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zbGF0b3IuZ2V0QnVzaW5lc3NSYW5nZSgpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gdHJhbnNsYXRvci5nZXRNaW5TY2FsZShkZWx0YSA+IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BJbnRlcmFjdGlvbjogc3RvcEludGVyYWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gPSBheGlzWm9vbShheGlzLCBvbmx5QXhpc1RvTm90aWZ5LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6b29tID0gdHJhbnNsYXRvci56b29tKC0oY29vcmQgLSBjb29yZCAqIHNjYWxlKSwgc2NhbGUsIGF4aXMuZ2V0Wm9vbUJvdW5kcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWU6IHpvb20ubWluLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kVmFsdWU6IHpvb20ubWF4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBnZXRQYXJhbWV0ZXJzLCBcInpvb21cIiwgc2NhbGUsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpvb21TdGFydGVkID0gIXN0b3BJbnRlcmFjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25seUF4aXNUb05vdGlmeSAmJiByZXN1bHQuaXNQcmV2ZW50ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHpvb21TdGFydGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IGNhbGNDZW50ZXJGb3JEcmFnKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhlc1pvb21lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0QXhlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudmFsdWVBeGlzLnpvb20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEF4ZXMgPSBjaGFydC5fdmFsdWVBeGVzLmZpbHRlcihheGlzID0+IGNoZWNrQ29vcmRzKGNhbnZhc1RvUmVjdChheGlzLmdldENhbnZhcygpKSwgY29vcmRzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gdGFyZ2V0QXhlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Q2FudmFzID0gY2hhcnQuX3ZhbHVlQXhlcy5yZWR1Y2UoKHIsIGF4aXMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyICYmIGF4aXMuY29vcmRzSW4oY29vcmRzLngsIGNvb3Jkcy55KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IGF4aXMuZ2V0Q2FudmFzKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRDYW52YXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QXhlcyA9IGNoYXJ0Ll92YWx1ZUF4ZXMuZmlsdGVyKGF4aXMgPT4gY2hlY2tDb29yZHMoY2FudmFzVG9SZWN0KGF4aXMuZ2V0Q2FudmFzKCkpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB0YXJnZXRDYW52YXMubGVmdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRhcmdldENhbnZhcy50b3BcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhlc1pvb21lZCB8PSB6b29tQXhlcyh0YXJnZXRBeGVzLCByb3RhdGVkID8gY29vcmRzLnggOiBjb29yZHMueSwgZS5kZWx0YSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hcmd1bWVudEF4aXMuem9vbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhblpvb20gPSBjaGFydC5fYXJndW1lbnRBeGVzLnNvbWUoYXhpcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrQ29vcmRzKGNhbnZhc1RvUmVjdChheGlzLmdldENhbnZhcygpKSwgY29vcmRzKSB8fCBheGlzLmNvb3Jkc0luKGNvb3Jkcy54LCBjb29yZHMueSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4ZXNab29tZWQgfD0gY2FuWm9vbSAmJiB6b29tQXhlcyhjaGFydC5fYXJndW1lbnRBeGVzLCByb3RhdGVkID8gY29vcmRzLnkgOiBjb29yZHMueCwgZS5kZWx0YSwgY2hhcnQuZ2V0QXJndW1lbnRBeGlzKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF4ZXNab29tZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0Ll9yZXF1ZXN0Q2hhbmdlKFtcIlZJU1VBTF9SQU5HRVwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tQW5kUGFuLnBhbm5pbmdWaXN1YWxSYW5nZUVuYWJsZWQodGFyZ2V0QXhlcykgJiYgcHJldmVudERlZmF1bHRzKGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbG93VG91Y2hHZXN0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFyZ3VtZW50QXhpcy56b29tIHx8IG9wdGlvbnMudmFsdWVBeGlzLnpvb20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIucm9vdC5vbihQSU5DSF9TVEFSVF9FVkVOVF9OQU1FLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB6b29tQW5kUGFuLnBpbmNoU3RhcnRIYW5kbGVyKS5vbihQSU5DSF9FVkVOVF9OQU1FLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB6b29tQW5kUGFuLnBpbmNoSGFuZGxlcikub24oUElOQ0hfRU5EX0VWRU5UX05BTUUsIHpvb21BbmRQYW4ucGluY2hFbmRIYW5kbGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJvb3Qub24oRFJBR19TVEFSVF9FVkVOVF9OQU1FLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1tZWRpYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9LCB6b29tQW5kUGFuLmRyYWdTdGFydEhhbmRsZXIpLm9uKERSQUdfRVZFTlRfTkFNRSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfSwgem9vbUFuZFBhbi5kcmFnSGFuZGxlcikub24oRFJBR19FTkRfRVZFTlRfTkFNRSwgem9vbUFuZFBhbi5kcmFnRW5kSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hcmd1bWVudEF4aXMucGFuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIucm9vdC5vbihTQ1JPTExfQkFSX1NUQVJUX0VWRU5UX05BTUUsIChmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb21BbmRQYW4uYWN0aW9uRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlQXhlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRzKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEF4ZXNWaWV3cG9ydENoYW5naW5nKHpvb21BbmRQYW4sIFwicGFuXCIsIGUpXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLm9uKFNDUk9MTF9CQVJfTU9WRV9FVkVOVF9OQU1FLCAoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdHMoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4ZXNWaWV3cG9ydENoYW5naW5nKHpvb21BbmRQYW4sIFwicGFuXCIsIGUsIGNhbGNPZmZzZXRGb3JEcmFnLCBlID0+IGUub2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKS5vbihTQ1JPTExfQkFSX0VORF9FVkVOVF9OQU1FLCAoZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdHMoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaEF4ZXNWaWV3cG9ydENoYW5naW5nKHpvb21BbmRQYW4sIFwicGFuXCIsIGUsIGNhbGNPZmZzZXRGb3JEcmFnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgem9vbUFuZFBhbi5hY3Rpb25EYXRhID0gbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkZWZpbmVUb3VjaEJlaGF2aW9yOiBmdW5jdGlvbihpc0RlZmF1bHQsIGUpIHtcclxuICAgICAgICAgICAgICAgIHpvb21BbmRQYW4uYWN0aW9uRGF0YSAmJiAoem9vbUFuZFBhbi5hY3Rpb25EYXRhLmlzTmF0aXZlID0gaXNEZWZhdWx0KTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNEZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRzKGUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBhbm5pbmdWaXN1YWxSYW5nZUVuYWJsZWQ6IGZ1bmN0aW9uKHRhcmdldEF4ZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSB0YXJnZXRBeGVzICYmIHZvaWQgMCAhPT0gdGFyZ2V0QXhlcyAmJiB0YXJnZXRBeGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRBeGVzLnNvbWUoYXhpcyA9PiAhYXhpcy5pc0V4dHJlbWVQb3NpdGlvbihmYWxzZSkgfHwgIWF4aXMuaXNFeHRyZW1lUG9zaXRpb24odHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5hYmxlUGFuQnlWYWx1ZUF4aXMgPSBjaGFydC5fdmFsdWVBeGVzLnNvbWUoYXhpcyA9PiAhYXhpcy5pc0V4dHJlbWVQb3NpdGlvbihmYWxzZSkgfHwgIWF4aXMuaXNFeHRyZW1lUG9zaXRpb24odHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuYWJsZVBhbkJ5QXJndW1lbnRBeGlzID0gY2hhcnQuX2FyZ3VtZW50QXhlcy5zb21lKGF4aXMgPT4gIWF4aXMuaXNFeHRyZW1lUG9zaXRpb24oZmFsc2UpIHx8ICFheGlzLmlzRXh0cmVtZVBvc2l0aW9uKHRydWUpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbmFibGVQYW5CeVZhbHVlQXhpcyB8fCBlbmFibGVQYW5CeUFyZ3VtZW50QXhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl96b29tQW5kUGFuID0gem9vbUFuZFBhblxyXG4gICAgfSxcclxuICAgIG1lbWJlcnM6IHtcclxuICAgICAgICBfc2V0dXBab29tQW5kUGFuOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5fem9vbUFuZFBhbi5zZXR1cCh0aGlzLl90aGVtZU1hbmFnZXIuZ2V0T3B0aW9ucyhcInpvb21BbmRQYW5cIikpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuX3pvb21BbmRQYW4uY2xlYW51cCgpXHJcbiAgICB9LFxyXG4gICAgY3VzdG9taXplOiBmdW5jdGlvbihjb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yLmFkZENoYW5nZSh7XHJcbiAgICAgICAgICAgIGNvZGU6IFwiWk9PTV9BTkRfUEFOXCIsXHJcbiAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0dXBab29tQW5kUGFuKClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaXNUaGVtZURlcGVuZGVudDogdHJ1ZSxcclxuICAgICAgICAgICAgaXNPcHRpb25DaGFuZ2U6IHRydWUsXHJcbiAgICAgICAgICAgIG9wdGlvbjogXCJ6b29tQW5kUGFuXCJcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/chart_components/zoom_and_pan.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/core/series_family.js":
/*!***************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/core/series_family.js ***!
  \***************************************************************/
/*! exports provided: SeriesFamily */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SeriesFamily\", function() { return SeriesFamily; });\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/utils/math */ \"./node_modules/devextreme/esm/core/utils/math.js\");\n/* harmony import */ var _core_utils_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/utils/common */ \"./node_modules/devextreme/esm/core/utils/common.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/* harmony import */ var _core_utils_date__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/utils/date */ \"./node_modules/devextreme/esm/core/utils/date.js\");\n/**\r\n * DevExtreme (esm/viz/core/series_family.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar {\r\n    round: round,\r\n    abs: abs,\r\n    pow: pow,\r\n    sqrt: sqrt\r\n} = Math;\r\nvar _min = Math.min;\r\nvar DEFAULT_BAR_GROUP_PADDING = .3;\r\n\r\nfunction validateBarPadding(barPadding) {\r\n    return barPadding < 0 || barPadding > 1 ? void 0 : barPadding\r\n}\r\n\r\nfunction validateBarGroupPadding(barGroupPadding) {\r\n    return barGroupPadding < 0 || barGroupPadding > 1 ? DEFAULT_BAR_GROUP_PADDING : barGroupPadding\r\n}\r\n\r\nfunction isStackExist(series, arg) {\r\n    return series.some((function(s) {\r\n        return !s.getOptions().ignoreEmptyPoints || s.getPointsByArg(arg, true).some((function(point) {\r\n            return point.hasValue()\r\n        }))\r\n    }))\r\n}\r\n\r\nfunction correctStackCoordinates(series, currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback) {\r\n    series.forEach((function(series) {\r\n        var stackIndex = seriesStackIndexCallback(currentStacks.indexOf(stack), currentStacks.length);\r\n        var points = series.getPointsByArg(arg, true);\r\n        var barPadding = validateBarPadding(series.getOptions().barPadding);\r\n        var barWidth = series.getOptions().barWidth;\r\n        var offset = getOffset(stackIndex, parameters);\r\n        var width = parameters.width;\r\n        var extraParameters;\r\n        if (-1 === stackIndex) {\r\n            return\r\n        }\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(barPadding) || Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(barWidth)) {\r\n            extraParameters = calculateParams(barsArea, currentStacks.length, 1 - barPadding, barWidth);\r\n            width = extraParameters.width;\r\n            if (!series.getBarOverlapGroup()) {\r\n                offset = getOffset(stackIndex, extraParameters)\r\n            }\r\n        }\r\n        correctPointCoordinates(points, width, offset)\r\n    }))\r\n}\r\n\r\nfunction getStackName(series) {\r\n    return series.getStackName() || series.getBarOverlapGroup()\r\n}\r\n\r\nfunction adjustBarSeriesDimensionsCore(series, options, seriesStackIndexCallback) {\r\n    var _series$, _series$2;\r\n    var commonStacks = [];\r\n    var allArguments = [];\r\n    var seriesInStacks = {};\r\n    var barGroupWidth = options.barGroupWidth;\r\n    var argumentAxis = null === (_series$ = series[0]) || void 0 === _series$ ? void 0 : _series$.getArgumentAxis();\r\n    var interval;\r\n    if (null !== (_series$2 = series[0]) && void 0 !== _series$2 && _series$2.useAggregation()) {\r\n        var _series$3;\r\n        var isDateArgAxis = \"datetime\" === (null === (_series$3 = series[0]) || void 0 === _series$3 ? void 0 : _series$3.argumentType);\r\n        var tickInterval = argumentAxis.getTickInterval();\r\n        var aggregationInterval = argumentAxis.getAggregationInterval();\r\n        tickInterval = isDateArgAxis ? _core_utils_date__WEBPACK_IMPORTED_MODULE_6__[\"default\"].dateToMilliseconds(tickInterval) : tickInterval;\r\n        aggregationInterval = isDateArgAxis ? _core_utils_date__WEBPACK_IMPORTED_MODULE_6__[\"default\"].dateToMilliseconds(aggregationInterval) : aggregationInterval;\r\n        interval = aggregationInterval < tickInterval ? aggregationInterval : tickInterval\r\n    }\r\n    interval = null === argumentAxis || void 0 === argumentAxis ? void 0 : argumentAxis.getTranslator().getInterval(interval);\r\n    var barsArea = barGroupWidth ? interval > barGroupWidth ? barGroupWidth : interval : interval * (1 - validateBarGroupPadding(options.barGroupPadding));\r\n    series.forEach((function(s, i) {\r\n        var stackName = getStackName(s) || i.toString();\r\n        var argument;\r\n        for (argument in s.pointsByArgument) {\r\n            if (-1 === allArguments.indexOf(argument.valueOf())) {\r\n                allArguments.push(argument.valueOf())\r\n            }\r\n        }\r\n        if (-1 === commonStacks.indexOf(stackName)) {\r\n            commonStacks.push(stackName);\r\n            seriesInStacks[stackName] = []\r\n        }\r\n        seriesInStacks[stackName].push(s)\r\n    }));\r\n    allArguments.forEach((function(arg) {\r\n        var currentStacks = commonStacks.reduce((stacks, stack) => {\r\n            if (isStackExist(seriesInStacks[stack], arg)) {\r\n                stacks.push(stack)\r\n            }\r\n            return stacks\r\n        }, []);\r\n        var parameters = calculateParams(barsArea, currentStacks.length);\r\n        commonStacks.forEach(stack => {\r\n            correctStackCoordinates(seriesInStacks[stack], currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback)\r\n        })\r\n    }))\r\n}\r\n\r\nfunction calculateParams(barsArea, count, percentWidth, fixedBarWidth) {\r\n    var spacing;\r\n    var width;\r\n    if (fixedBarWidth) {\r\n        width = _min(fixedBarWidth, barsArea / count);\r\n        spacing = count > 1 ? round((barsArea - round(width) * count) / (count - 1)) : 0\r\n    } else if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(percentWidth)) {\r\n        width = barsArea * percentWidth / count;\r\n        spacing = count > 1 ? round((barsArea - barsArea * percentWidth) / (count - 1)) : 0\r\n    } else {\r\n        spacing = round(barsArea / count * .2);\r\n        width = (barsArea - spacing * (count - 1)) / count\r\n    }\r\n    return {\r\n        width: width > 1 ? round(width) : 1,\r\n        spacing: spacing,\r\n        middleIndex: count / 2,\r\n        rawWidth: width\r\n    }\r\n}\r\n\r\nfunction getOffset(stackIndex, parameters) {\r\n    var width = parameters.rawWidth < 1 ? parameters.rawWidth : parameters.width;\r\n    return (stackIndex - parameters.middleIndex + .5) * width - (parameters.middleIndex - stackIndex - .5) * parameters.spacing\r\n}\r\n\r\nfunction correctPointCoordinates(points, width, offset) {\r\n    Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__[\"each\"])(points, (function(_, point) {\r\n        point.correctCoordinates({\r\n            width: width,\r\n            offset: offset\r\n        })\r\n    }))\r\n}\r\n\r\nfunction getValueType(value) {\r\n    return value >= 0 ? \"positive\" : \"negative\"\r\n}\r\n\r\nfunction getVisibleSeries(that) {\r\n    return that.series.filter((function(s) {\r\n        return s.isVisible()\r\n    }))\r\n}\r\n\r\nfunction getAbsStackSumByArg(stackKeepers, stackName, argument) {\r\n    var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;\r\n    var negativeStackValue = -(stackKeepers.negative[stackName] || {})[argument] || 0;\r\n    return positiveStackValue + negativeStackValue\r\n}\r\n\r\nfunction getStackSumByArg(stackKeepers, stackName, argument) {\r\n    var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;\r\n    var negativeStackValue = (stackKeepers.negative[stackName] || {})[argument] || 0;\r\n    return positiveStackValue + negativeStackValue\r\n}\r\n\r\nfunction getSeriesStackIndexCallback(inverted) {\r\n    if (!inverted) {\r\n        return function(index) {\r\n            return index\r\n        }\r\n    } else {\r\n        return function(index, stackCount) {\r\n            return stackCount - index - 1\r\n        }\r\n    }\r\n}\r\n\r\nfunction isInverted(series) {\r\n    return series[0] && series[0].getArgumentAxis().getTranslator().isInverted()\r\n}\r\n\r\nfunction adjustBarSeriesDimensions() {\r\n    var series = getVisibleSeries(this);\r\n    adjustBarSeriesDimensionsCore(series, this._options, getSeriesStackIndexCallback(isInverted(series)))\r\n}\r\n\r\nfunction getFirstValueSign(series) {\r\n    var points = series.getPoints();\r\n    var value;\r\n    for (var i = 0; i < points.length; i++) {\r\n        var point = points[i];\r\n        value = point.initialValue && point.initialValue.valueOf();\r\n        if (abs(value) > 0) {\r\n            break\r\n        }\r\n    }\r\n    return Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_3__[\"sign\"])(value)\r\n}\r\n\r\nfunction adjustStackedSeriesValues() {\r\n    var negativesAsZeroes = this._options.negativesAsZeroes;\r\n    var series = getVisibleSeries(this);\r\n    var stackKeepers = {\r\n        positive: {},\r\n        negative: {}\r\n    };\r\n    var holesStack = {\r\n        left: {},\r\n        right: {}\r\n    };\r\n    var lastSeriesInPositiveStack = {};\r\n    var lastSeriesInNegativeStack = {};\r\n    series.forEach((function(singleSeries) {\r\n        var stackName = getStackName(singleSeries);\r\n        var hole = false;\r\n        var stack = getFirstValueSign(singleSeries) < 0 ? lastSeriesInNegativeStack : lastSeriesInPositiveStack;\r\n        singleSeries._prevSeries = stack[stackName];\r\n        stack[stackName] = singleSeries;\r\n        singleSeries.holes = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_1__[\"extend\"])(true, {}, holesStack);\r\n        singleSeries.getPoints().forEach((function(point, index, points) {\r\n            var value = point.initialValue && point.initialValue.valueOf();\r\n            var argument = point.argument.valueOf();\r\n            var stacks = value >= 0 ? stackKeepers.positive : stackKeepers.negative;\r\n            var isNotBarSeries = \"bar\" !== singleSeries.type;\r\n            if (negativesAsZeroes && value < 0) {\r\n                stacks = stackKeepers.positive;\r\n                value = 0;\r\n                point.resetValue()\r\n            }\r\n            stacks[stackName] = stacks[stackName] || {};\r\n            var currentStack = stacks[stackName];\r\n            if (currentStack[argument]) {\r\n                if (isNotBarSeries) {\r\n                    point.correctValue(currentStack[argument])\r\n                }\r\n                currentStack[argument] += value\r\n            } else {\r\n                currentStack[argument] = value;\r\n                if (isNotBarSeries) {\r\n                    point.resetCorrection()\r\n                }\r\n            }\r\n            if (!point.hasValue()) {\r\n                var prevPoint = points[index - 1];\r\n                if (!hole && prevPoint && prevPoint.hasValue()) {\r\n                    argument = prevPoint.argument.valueOf();\r\n                    prevPoint._skipSetRightHole = true;\r\n                    holesStack.right[argument] = (holesStack.right[argument] || 0) + (prevPoint.value.valueOf() - (isFinite(prevPoint.minValue) ? prevPoint.minValue.valueOf() : 0))\r\n                }\r\n                hole = true\r\n            } else if (hole) {\r\n                hole = false;\r\n                holesStack.left[argument] = (holesStack.left[argument] || 0) + (point.value.valueOf() - (isFinite(point.minValue) ? point.minValue.valueOf() : 0));\r\n                point._skipSetLeftHole = true\r\n            }\r\n        }))\r\n    }));\r\n    series.forEach((function(singleSeries) {\r\n        var holes = singleSeries.holes;\r\n        singleSeries.getPoints().forEach((function(point) {\r\n            var argument = point.argument.valueOf();\r\n            point.resetHoles();\r\n            !point._skipSetLeftHole && point.setHole(holes.left[argument] || holesStack.left[argument] && 0, \"left\");\r\n            !point._skipSetRightHole && point.setHole(holes.right[argument] || holesStack.right[argument] && 0, \"right\");\r\n            point._skipSetLeftHole = null;\r\n            point._skipSetRightHole = null\r\n        }))\r\n    }));\r\n    this._stackKeepers = stackKeepers;\r\n    series.forEach((function(singleSeries) {\r\n        singleSeries.getPoints().forEach((function(point) {\r\n            var argument = point.argument.valueOf();\r\n            var stackName = getStackName(singleSeries);\r\n            var absTotal = getAbsStackSumByArg(stackKeepers, stackName, argument);\r\n            var total = getStackSumByArg(stackKeepers, stackName, argument);\r\n            point.setPercentValue(absTotal, total, holesStack.left[argument], holesStack.right[argument])\r\n        }))\r\n    }))\r\n}\r\n\r\nfunction updateStackedSeriesValues() {\r\n    var that = this;\r\n    var series = getVisibleSeries(that);\r\n    var stack = that._stackKeepers;\r\n    var stackKeepers = {\r\n        positive: {},\r\n        negative: {}\r\n    };\r\n    Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__[\"each\"])(series, (function(_, singleSeries) {\r\n        var minBarSize = singleSeries.getOptions().minBarSize;\r\n        var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();\r\n        var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);\r\n        var stackName = singleSeries.getStackName();\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__[\"each\"])(singleSeries.getPoints(), (function(index, point) {\r\n            if (!point.hasValue()) {\r\n                return\r\n            }\r\n            var value = point.initialValue && point.initialValue.valueOf();\r\n            var argument = point.argument.valueOf();\r\n            if (that.fullStacked) {\r\n                value = value / getAbsStackSumByArg(stack, stackName, argument) || 0\r\n            }\r\n            var updateValue = valueAxisTranslator.checkMinBarSize(value, minShownBusinessValue, point.value);\r\n            var valueType = getValueType(updateValue);\r\n            var currentStack = stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};\r\n            if (currentStack[argument]) {\r\n                point.minValue = currentStack[argument];\r\n                currentStack[argument] += updateValue\r\n            } else {\r\n                currentStack[argument] = updateValue\r\n            }\r\n            point.value = currentStack[argument]\r\n        }))\r\n    }));\r\n    if (that.fullStacked) {\r\n        updateFullStackedSeriesValues(series, stackKeepers)\r\n    }\r\n}\r\n\r\nfunction updateFullStackedSeriesValues(series, stackKeepers) {\r\n    Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__[\"each\"])(series, (function(_, singleSeries) {\r\n        var stackName = singleSeries.getStackName ? singleSeries.getStackName() : \"default\";\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__[\"each\"])(singleSeries.getPoints(), (function(index, point) {\r\n            var stackSum = getAbsStackSumByArg(stackKeepers, stackName, point.argument.valueOf());\r\n            if (0 !== stackSum) {\r\n                point.value = point.value / stackSum;\r\n                if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isNumeric\"])(point.minValue)) {\r\n                    point.minValue = point.minValue / stackSum\r\n                }\r\n            }\r\n        }))\r\n    }))\r\n}\r\n\r\nfunction updateBarSeriesValues() {\r\n    Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__[\"each\"])(this.series, (function(_, singleSeries) {\r\n        var minBarSize = singleSeries.getOptions().minBarSize;\r\n        var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();\r\n        var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);\r\n        if (minShownBusinessValue) {\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__[\"each\"])(singleSeries.getPoints(), (function(index, point) {\r\n                if (point.hasValue()) {\r\n                    point.value = valueAxisTranslator.checkMinBarSize(point.initialValue, minShownBusinessValue)\r\n                }\r\n            }))\r\n        }\r\n    }))\r\n}\r\n\r\nfunction adjustCandlestickSeriesDimensions() {\r\n    var series = getVisibleSeries(this);\r\n    adjustBarSeriesDimensionsCore(series, {\r\n        barGroupPadding: .3\r\n    }, getSeriesStackIndexCallback(isInverted(series)))\r\n}\r\n\r\nfunction adjustBubbleSeriesDimensions() {\r\n    var series = getVisibleSeries(this);\r\n    if (!series.length) {\r\n        return\r\n    }\r\n    var options = this._options;\r\n    var visibleAreaX = series[0].getArgumentAxis().getVisibleArea();\r\n    var visibleAreaY = series[0].getValueAxis().getVisibleArea();\r\n    var min = _min(visibleAreaX[1] - visibleAreaX[0], visibleAreaY[1] - visibleAreaY[0]);\r\n    var minBubbleArea = pow(options.minBubbleSize, 2);\r\n    var maxBubbleArea = pow(min * options.maxBubbleSize, 2);\r\n    var equalBubbleSize = (min * options.maxBubbleSize + options.minBubbleSize) / 2;\r\n    var minPointSize = 1 / 0;\r\n    var maxPointSize = -1 / 0;\r\n    var pointSize;\r\n    var bubbleArea;\r\n    var sizeProportion;\r\n    Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__[\"each\"])(series, (function(_, seriesItem) {\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__[\"each\"])(seriesItem.getPoints(), (function(_, point) {\r\n            maxPointSize = maxPointSize > point.size ? maxPointSize : point.size;\r\n            minPointSize = minPointSize < point.size ? minPointSize : point.size\r\n        }))\r\n    }));\r\n    var sizeDispersion = maxPointSize - minPointSize;\r\n    var areaDispersion = abs(maxBubbleArea - minBubbleArea);\r\n    Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__[\"each\"])(series, (function(_, seriesItem) {\r\n        Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_2__[\"each\"])(seriesItem.getPoints(), (function(_, point) {\r\n            if (maxPointSize === minPointSize) {\r\n                pointSize = round(equalBubbleSize)\r\n            } else {\r\n                sizeProportion = abs(point.size - minPointSize) / sizeDispersion;\r\n                bubbleArea = areaDispersion * sizeProportion + minBubbleArea;\r\n                pointSize = round(sqrt(bubbleArea))\r\n            }\r\n            point.correctCoordinates(pointSize)\r\n        }))\r\n    }))\r\n}\r\nfunction SeriesFamily(options) {\r\n    this.type = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"normalizeEnum\"])(options.type);\r\n    this.pane = options.pane;\r\n    this.series = [];\r\n    this.updateOptions(options);\r\n    switch (this.type) {\r\n        case \"bar\":\r\n            this.adjustSeriesDimensions = adjustBarSeriesDimensions;\r\n            this.updateSeriesValues = updateBarSeriesValues;\r\n            this.adjustSeriesValues = adjustStackedSeriesValues;\r\n            break;\r\n        case \"rangebar\":\r\n            this.adjustSeriesDimensions = adjustBarSeriesDimensions;\r\n            break;\r\n        case \"fullstackedbar\":\r\n            this.fullStacked = true;\r\n            this.adjustSeriesDimensions = adjustBarSeriesDimensions;\r\n            this.adjustSeriesValues = adjustStackedSeriesValues;\r\n            this.updateSeriesValues = updateStackedSeriesValues;\r\n            break;\r\n        case \"stackedbar\":\r\n            this.adjustSeriesDimensions = adjustBarSeriesDimensions;\r\n            this.adjustSeriesValues = adjustStackedSeriesValues;\r\n            this.updateSeriesValues = updateStackedSeriesValues;\r\n            break;\r\n        case \"fullstackedarea\":\r\n        case \"fullstackedline\":\r\n        case \"fullstackedspline\":\r\n        case \"fullstackedsplinearea\":\r\n            this.fullStacked = true;\r\n            this.adjustSeriesValues = adjustStackedSeriesValues;\r\n            break;\r\n        case \"stackedarea\":\r\n        case \"stackedsplinearea\":\r\n        case \"stackedline\":\r\n        case \"stackedspline\":\r\n            this.adjustSeriesValues = adjustStackedSeriesValues;\r\n            break;\r\n        case \"candlestick\":\r\n        case \"stock\":\r\n            this.adjustSeriesDimensions = adjustCandlestickSeriesDimensions;\r\n            break;\r\n        case \"bubble\":\r\n            this.adjustSeriesDimensions = adjustBubbleSeriesDimensions\r\n    }\r\n}\r\nSeriesFamily.prototype = {\r\n    constructor: SeriesFamily,\r\n    adjustSeriesDimensions: _core_utils_common__WEBPACK_IMPORTED_MODULE_4__[\"noop\"],\r\n    adjustSeriesValues: _core_utils_common__WEBPACK_IMPORTED_MODULE_4__[\"noop\"],\r\n    updateSeriesValues: _core_utils_common__WEBPACK_IMPORTED_MODULE_4__[\"noop\"],\r\n    updateOptions: function(options) {\r\n        this._options = options\r\n    },\r\n    dispose: function() {\r\n        this.series = null\r\n    },\r\n    add: function(series) {\r\n        var type = this.type;\r\n        this.series = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"map\"])(series, singleSeries => singleSeries.type === type ? singleSeries : null)\r\n    }\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2NvcmUvc2VyaWVzX2ZhbWlseS5qcz9lN2UzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJK0I7QUFHRTtBQUdFO0FBR0o7QUFHRTtBQUloQjtBQUM2QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBUyxnQkFBZ0Isa0VBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdEQUFTO0FBQ2hELDhDQUE4Qyx3REFBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssVUFBVSxrRUFBUztBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1REFBSztBQUNqQyx3QkFBd0IsdURBQUs7QUFDN0Isd0JBQXdCLHVEQUFLO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCLGtEQUFJO0FBQzFCO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L2NvcmUvc2VyaWVzX2ZhbWlseS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdml6L2NvcmUvc2VyaWVzX2ZhbWlseS5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IHtcclxuICAgIGlzTnVtZXJpYyxcclxuICAgIGlzRGVmaW5lZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL3R5cGVcIjtcclxuaW1wb3J0IHtcclxuICAgIGV4dGVuZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2V4dGVuZFwiO1xyXG5pbXBvcnQge1xyXG4gICAgZWFjaCBhcyBfZWFjaFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2l0ZXJhdG9yXCI7XHJcbmltcG9ydCB7XHJcbiAgICBzaWduXHJcbn0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvbWF0aFwiO1xyXG5pbXBvcnQge1xyXG4gICAgbm9vcCBhcyBfbm9vcFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2NvbW1vblwiO1xyXG5pbXBvcnQge1xyXG4gICAgbWFwIGFzIF9tYXAsXHJcbiAgICBub3JtYWxpemVFbnVtIGFzIF9ub3JtYWxpemVFbnVtXHJcbn0gZnJvbSBcIi4vdXRpbHNcIjtcclxuaW1wb3J0IGRhdGVVdGlscyBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9kYXRlXCI7XHJcbnZhciB7XHJcbiAgICByb3VuZDogcm91bmQsXHJcbiAgICBhYnM6IGFicyxcclxuICAgIHBvdzogcG93LFxyXG4gICAgc3FydDogc3FydFxyXG59ID0gTWF0aDtcclxudmFyIF9taW4gPSBNYXRoLm1pbjtcclxudmFyIERFRkFVTFRfQkFSX0dST1VQX1BBRERJTkcgPSAuMztcclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlQmFyUGFkZGluZyhiYXJQYWRkaW5nKSB7XHJcbiAgICByZXR1cm4gYmFyUGFkZGluZyA8IDAgfHwgYmFyUGFkZGluZyA+IDEgPyB2b2lkIDAgOiBiYXJQYWRkaW5nXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlQmFyR3JvdXBQYWRkaW5nKGJhckdyb3VwUGFkZGluZykge1xyXG4gICAgcmV0dXJuIGJhckdyb3VwUGFkZGluZyA8IDAgfHwgYmFyR3JvdXBQYWRkaW5nID4gMSA/IERFRkFVTFRfQkFSX0dST1VQX1BBRERJTkcgOiBiYXJHcm91cFBhZGRpbmdcclxufVxyXG5cclxuZnVuY3Rpb24gaXNTdGFja0V4aXN0KHNlcmllcywgYXJnKSB7XHJcbiAgICByZXR1cm4gc2VyaWVzLnNvbWUoKGZ1bmN0aW9uKHMpIHtcclxuICAgICAgICByZXR1cm4gIXMuZ2V0T3B0aW9ucygpLmlnbm9yZUVtcHR5UG9pbnRzIHx8IHMuZ2V0UG9pbnRzQnlBcmcoYXJnLCB0cnVlKS5zb21lKChmdW5jdGlvbihwb2ludCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQuaGFzVmFsdWUoKVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcnJlY3RTdGFja0Nvb3JkaW5hdGVzKHNlcmllcywgY3VycmVudFN0YWNrcywgYXJnLCBzdGFjaywgcGFyYW1ldGVycywgYmFyc0FyZWEsIHNlcmllc1N0YWNrSW5kZXhDYWxsYmFjaykge1xyXG4gICAgc2VyaWVzLmZvckVhY2goKGZ1bmN0aW9uKHNlcmllcykge1xyXG4gICAgICAgIHZhciBzdGFja0luZGV4ID0gc2VyaWVzU3RhY2tJbmRleENhbGxiYWNrKGN1cnJlbnRTdGFja3MuaW5kZXhPZihzdGFjayksIGN1cnJlbnRTdGFja3MubGVuZ3RoKTtcclxuICAgICAgICB2YXIgcG9pbnRzID0gc2VyaWVzLmdldFBvaW50c0J5QXJnKGFyZywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGJhclBhZGRpbmcgPSB2YWxpZGF0ZUJhclBhZGRpbmcoc2VyaWVzLmdldE9wdGlvbnMoKS5iYXJQYWRkaW5nKTtcclxuICAgICAgICB2YXIgYmFyV2lkdGggPSBzZXJpZXMuZ2V0T3B0aW9ucygpLmJhcldpZHRoO1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSBnZXRPZmZzZXQoc3RhY2tJbmRleCwgcGFyYW1ldGVycyk7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gcGFyYW1ldGVycy53aWR0aDtcclxuICAgICAgICB2YXIgZXh0cmFQYXJhbWV0ZXJzO1xyXG4gICAgICAgIGlmICgtMSA9PT0gc3RhY2tJbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZChiYXJQYWRkaW5nKSB8fCBpc0RlZmluZWQoYmFyV2lkdGgpKSB7XHJcbiAgICAgICAgICAgIGV4dHJhUGFyYW1ldGVycyA9IGNhbGN1bGF0ZVBhcmFtcyhiYXJzQXJlYSwgY3VycmVudFN0YWNrcy5sZW5ndGgsIDEgLSBiYXJQYWRkaW5nLCBiYXJXaWR0aCk7XHJcbiAgICAgICAgICAgIHdpZHRoID0gZXh0cmFQYXJhbWV0ZXJzLndpZHRoO1xyXG4gICAgICAgICAgICBpZiAoIXNlcmllcy5nZXRCYXJPdmVybGFwR3JvdXAoKSkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZ2V0T2Zmc2V0KHN0YWNrSW5kZXgsIGV4dHJhUGFyYW1ldGVycylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb3JyZWN0UG9pbnRDb29yZGluYXRlcyhwb2ludHMsIHdpZHRoLCBvZmZzZXQpXHJcbiAgICB9KSlcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U3RhY2tOYW1lKHNlcmllcykge1xyXG4gICAgcmV0dXJuIHNlcmllcy5nZXRTdGFja05hbWUoKSB8fCBzZXJpZXMuZ2V0QmFyT3ZlcmxhcEdyb3VwKClcclxufVxyXG5cclxuZnVuY3Rpb24gYWRqdXN0QmFyU2VyaWVzRGltZW5zaW9uc0NvcmUoc2VyaWVzLCBvcHRpb25zLCBzZXJpZXNTdGFja0luZGV4Q2FsbGJhY2spIHtcclxuICAgIHZhciBfc2VyaWVzJCwgX3NlcmllcyQyO1xyXG4gICAgdmFyIGNvbW1vblN0YWNrcyA9IFtdO1xyXG4gICAgdmFyIGFsbEFyZ3VtZW50cyA9IFtdO1xyXG4gICAgdmFyIHNlcmllc0luU3RhY2tzID0ge307XHJcbiAgICB2YXIgYmFyR3JvdXBXaWR0aCA9IG9wdGlvbnMuYmFyR3JvdXBXaWR0aDtcclxuICAgIHZhciBhcmd1bWVudEF4aXMgPSBudWxsID09PSAoX3NlcmllcyQgPSBzZXJpZXNbMF0pIHx8IHZvaWQgMCA9PT0gX3NlcmllcyQgPyB2b2lkIDAgOiBfc2VyaWVzJC5nZXRBcmd1bWVudEF4aXMoKTtcclxuICAgIHZhciBpbnRlcnZhbDtcclxuICAgIGlmIChudWxsICE9PSAoX3NlcmllcyQyID0gc2VyaWVzWzBdKSAmJiB2b2lkIDAgIT09IF9zZXJpZXMkMiAmJiBfc2VyaWVzJDIudXNlQWdncmVnYXRpb24oKSkge1xyXG4gICAgICAgIHZhciBfc2VyaWVzJDM7XHJcbiAgICAgICAgdmFyIGlzRGF0ZUFyZ0F4aXMgPSBcImRhdGV0aW1lXCIgPT09IChudWxsID09PSAoX3NlcmllcyQzID0gc2VyaWVzWzBdKSB8fCB2b2lkIDAgPT09IF9zZXJpZXMkMyA/IHZvaWQgMCA6IF9zZXJpZXMkMy5hcmd1bWVudFR5cGUpO1xyXG4gICAgICAgIHZhciB0aWNrSW50ZXJ2YWwgPSBhcmd1bWVudEF4aXMuZ2V0VGlja0ludGVydmFsKCk7XHJcbiAgICAgICAgdmFyIGFnZ3JlZ2F0aW9uSW50ZXJ2YWwgPSBhcmd1bWVudEF4aXMuZ2V0QWdncmVnYXRpb25JbnRlcnZhbCgpO1xyXG4gICAgICAgIHRpY2tJbnRlcnZhbCA9IGlzRGF0ZUFyZ0F4aXMgPyBkYXRlVXRpbHMuZGF0ZVRvTWlsbGlzZWNvbmRzKHRpY2tJbnRlcnZhbCkgOiB0aWNrSW50ZXJ2YWw7XHJcbiAgICAgICAgYWdncmVnYXRpb25JbnRlcnZhbCA9IGlzRGF0ZUFyZ0F4aXMgPyBkYXRlVXRpbHMuZGF0ZVRvTWlsbGlzZWNvbmRzKGFnZ3JlZ2F0aW9uSW50ZXJ2YWwpIDogYWdncmVnYXRpb25JbnRlcnZhbDtcclxuICAgICAgICBpbnRlcnZhbCA9IGFnZ3JlZ2F0aW9uSW50ZXJ2YWwgPCB0aWNrSW50ZXJ2YWwgPyBhZ2dyZWdhdGlvbkludGVydmFsIDogdGlja0ludGVydmFsXHJcbiAgICB9XHJcbiAgICBpbnRlcnZhbCA9IG51bGwgPT09IGFyZ3VtZW50QXhpcyB8fCB2b2lkIDAgPT09IGFyZ3VtZW50QXhpcyA/IHZvaWQgMCA6IGFyZ3VtZW50QXhpcy5nZXRUcmFuc2xhdG9yKCkuZ2V0SW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgdmFyIGJhcnNBcmVhID0gYmFyR3JvdXBXaWR0aCA/IGludGVydmFsID4gYmFyR3JvdXBXaWR0aCA/IGJhckdyb3VwV2lkdGggOiBpbnRlcnZhbCA6IGludGVydmFsICogKDEgLSB2YWxpZGF0ZUJhckdyb3VwUGFkZGluZyhvcHRpb25zLmJhckdyb3VwUGFkZGluZykpO1xyXG4gICAgc2VyaWVzLmZvckVhY2goKGZ1bmN0aW9uKHMsIGkpIHtcclxuICAgICAgICB2YXIgc3RhY2tOYW1lID0gZ2V0U3RhY2tOYW1lKHMpIHx8IGkudG9TdHJpbmcoKTtcclxuICAgICAgICB2YXIgYXJndW1lbnQ7XHJcbiAgICAgICAgZm9yIChhcmd1bWVudCBpbiBzLnBvaW50c0J5QXJndW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKC0xID09PSBhbGxBcmd1bWVudHMuaW5kZXhPZihhcmd1bWVudC52YWx1ZU9mKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBhbGxBcmd1bWVudHMucHVzaChhcmd1bWVudC52YWx1ZU9mKCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKC0xID09PSBjb21tb25TdGFja3MuaW5kZXhPZihzdGFja05hbWUpKSB7XHJcbiAgICAgICAgICAgIGNvbW1vblN0YWNrcy5wdXNoKHN0YWNrTmFtZSk7XHJcbiAgICAgICAgICAgIHNlcmllc0luU3RhY2tzW3N0YWNrTmFtZV0gPSBbXVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXJpZXNJblN0YWNrc1tzdGFja05hbWVdLnB1c2gocylcclxuICAgIH0pKTtcclxuICAgIGFsbEFyZ3VtZW50cy5mb3JFYWNoKChmdW5jdGlvbihhcmcpIHtcclxuICAgICAgICB2YXIgY3VycmVudFN0YWNrcyA9IGNvbW1vblN0YWNrcy5yZWR1Y2UoKHN0YWNrcywgc3RhY2spID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzU3RhY2tFeGlzdChzZXJpZXNJblN0YWNrc1tzdGFja10sIGFyZykpIHtcclxuICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKHN0YWNrKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFja3NcclxuICAgICAgICB9LCBbXSk7XHJcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBjYWxjdWxhdGVQYXJhbXMoYmFyc0FyZWEsIGN1cnJlbnRTdGFja3MubGVuZ3RoKTtcclxuICAgICAgICBjb21tb25TdGFja3MuZm9yRWFjaChzdGFjayA9PiB7XHJcbiAgICAgICAgICAgIGNvcnJlY3RTdGFja0Nvb3JkaW5hdGVzKHNlcmllc0luU3RhY2tzW3N0YWNrXSwgY3VycmVudFN0YWNrcywgYXJnLCBzdGFjaywgcGFyYW1ldGVycywgYmFyc0FyZWEsIHNlcmllc1N0YWNrSW5kZXhDYWxsYmFjaylcclxuICAgICAgICB9KVxyXG4gICAgfSkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVBhcmFtcyhiYXJzQXJlYSwgY291bnQsIHBlcmNlbnRXaWR0aCwgZml4ZWRCYXJXaWR0aCkge1xyXG4gICAgdmFyIHNwYWNpbmc7XHJcbiAgICB2YXIgd2lkdGg7XHJcbiAgICBpZiAoZml4ZWRCYXJXaWR0aCkge1xyXG4gICAgICAgIHdpZHRoID0gX21pbihmaXhlZEJhcldpZHRoLCBiYXJzQXJlYSAvIGNvdW50KTtcclxuICAgICAgICBzcGFjaW5nID0gY291bnQgPiAxID8gcm91bmQoKGJhcnNBcmVhIC0gcm91bmQod2lkdGgpICogY291bnQpIC8gKGNvdW50IC0gMSkpIDogMFxyXG4gICAgfSBlbHNlIGlmIChpc0RlZmluZWQocGVyY2VudFdpZHRoKSkge1xyXG4gICAgICAgIHdpZHRoID0gYmFyc0FyZWEgKiBwZXJjZW50V2lkdGggLyBjb3VudDtcclxuICAgICAgICBzcGFjaW5nID0gY291bnQgPiAxID8gcm91bmQoKGJhcnNBcmVhIC0gYmFyc0FyZWEgKiBwZXJjZW50V2lkdGgpIC8gKGNvdW50IC0gMSkpIDogMFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzcGFjaW5nID0gcm91bmQoYmFyc0FyZWEgLyBjb3VudCAqIC4yKTtcclxuICAgICAgICB3aWR0aCA9IChiYXJzQXJlYSAtIHNwYWNpbmcgKiAoY291bnQgLSAxKSkgLyBjb3VudFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aDogd2lkdGggPiAxID8gcm91bmQod2lkdGgpIDogMSxcclxuICAgICAgICBzcGFjaW5nOiBzcGFjaW5nLFxyXG4gICAgICAgIG1pZGRsZUluZGV4OiBjb3VudCAvIDIsXHJcbiAgICAgICAgcmF3V2lkdGg6IHdpZHRoXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE9mZnNldChzdGFja0luZGV4LCBwYXJhbWV0ZXJzKSB7XHJcbiAgICB2YXIgd2lkdGggPSBwYXJhbWV0ZXJzLnJhd1dpZHRoIDwgMSA/IHBhcmFtZXRlcnMucmF3V2lkdGggOiBwYXJhbWV0ZXJzLndpZHRoO1xyXG4gICAgcmV0dXJuIChzdGFja0luZGV4IC0gcGFyYW1ldGVycy5taWRkbGVJbmRleCArIC41KSAqIHdpZHRoIC0gKHBhcmFtZXRlcnMubWlkZGxlSW5kZXggLSBzdGFja0luZGV4IC0gLjUpICogcGFyYW1ldGVycy5zcGFjaW5nXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcnJlY3RQb2ludENvb3JkaW5hdGVzKHBvaW50cywgd2lkdGgsIG9mZnNldCkge1xyXG4gICAgX2VhY2gocG9pbnRzLCAoZnVuY3Rpb24oXywgcG9pbnQpIHtcclxuICAgICAgICBwb2ludC5jb3JyZWN0Q29vcmRpbmF0ZXMoe1xyXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XHJcbiAgICAgICAgfSlcclxuICAgIH0pKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRWYWx1ZVR5cGUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA+PSAwID8gXCJwb3NpdGl2ZVwiIDogXCJuZWdhdGl2ZVwiXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFZpc2libGVTZXJpZXModGhhdCkge1xyXG4gICAgcmV0dXJuIHRoYXQuc2VyaWVzLmZpbHRlcigoZnVuY3Rpb24ocykge1xyXG4gICAgICAgIHJldHVybiBzLmlzVmlzaWJsZSgpXHJcbiAgICB9KSlcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0QWJzU3RhY2tTdW1CeUFyZyhzdGFja0tlZXBlcnMsIHN0YWNrTmFtZSwgYXJndW1lbnQpIHtcclxuICAgIHZhciBwb3NpdGl2ZVN0YWNrVmFsdWUgPSAoc3RhY2tLZWVwZXJzLnBvc2l0aXZlW3N0YWNrTmFtZV0gfHwge30pW2FyZ3VtZW50XSB8fCAwO1xyXG4gICAgdmFyIG5lZ2F0aXZlU3RhY2tWYWx1ZSA9IC0oc3RhY2tLZWVwZXJzLm5lZ2F0aXZlW3N0YWNrTmFtZV0gfHwge30pW2FyZ3VtZW50XSB8fCAwO1xyXG4gICAgcmV0dXJuIHBvc2l0aXZlU3RhY2tWYWx1ZSArIG5lZ2F0aXZlU3RhY2tWYWx1ZVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTdGFja1N1bUJ5QXJnKHN0YWNrS2VlcGVycywgc3RhY2tOYW1lLCBhcmd1bWVudCkge1xyXG4gICAgdmFyIHBvc2l0aXZlU3RhY2tWYWx1ZSA9IChzdGFja0tlZXBlcnMucG9zaXRpdmVbc3RhY2tOYW1lXSB8fCB7fSlbYXJndW1lbnRdIHx8IDA7XHJcbiAgICB2YXIgbmVnYXRpdmVTdGFja1ZhbHVlID0gKHN0YWNrS2VlcGVycy5uZWdhdGl2ZVtzdGFja05hbWVdIHx8IHt9KVthcmd1bWVudF0gfHwgMDtcclxuICAgIHJldHVybiBwb3NpdGl2ZVN0YWNrVmFsdWUgKyBuZWdhdGl2ZVN0YWNrVmFsdWVcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U2VyaWVzU3RhY2tJbmRleENhbGxiYWNrKGludmVydGVkKSB7XHJcbiAgICBpZiAoIWludmVydGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleFxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGluZGV4LCBzdGFja0NvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFja0NvdW50IC0gaW5kZXggLSAxXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0ludmVydGVkKHNlcmllcykge1xyXG4gICAgcmV0dXJuIHNlcmllc1swXSAmJiBzZXJpZXNbMF0uZ2V0QXJndW1lbnRBeGlzKCkuZ2V0VHJhbnNsYXRvcigpLmlzSW52ZXJ0ZWQoKVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGp1c3RCYXJTZXJpZXNEaW1lbnNpb25zKCkge1xyXG4gICAgdmFyIHNlcmllcyA9IGdldFZpc2libGVTZXJpZXModGhpcyk7XHJcbiAgICBhZGp1c3RCYXJTZXJpZXNEaW1lbnNpb25zQ29yZShzZXJpZXMsIHRoaXMuX29wdGlvbnMsIGdldFNlcmllc1N0YWNrSW5kZXhDYWxsYmFjayhpc0ludmVydGVkKHNlcmllcykpKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRGaXJzdFZhbHVlU2lnbihzZXJpZXMpIHtcclxuICAgIHZhciBwb2ludHMgPSBzZXJpZXMuZ2V0UG9pbnRzKCk7XHJcbiAgICB2YXIgdmFsdWU7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcclxuICAgICAgICB2YWx1ZSA9IHBvaW50LmluaXRpYWxWYWx1ZSAmJiBwb2ludC5pbml0aWFsVmFsdWUudmFsdWVPZigpO1xyXG4gICAgICAgIGlmIChhYnModmFsdWUpID4gMCkge1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzaWduKHZhbHVlKVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGp1c3RTdGFja2VkU2VyaWVzVmFsdWVzKCkge1xyXG4gICAgdmFyIG5lZ2F0aXZlc0FzWmVyb2VzID0gdGhpcy5fb3B0aW9ucy5uZWdhdGl2ZXNBc1plcm9lcztcclxuICAgIHZhciBzZXJpZXMgPSBnZXRWaXNpYmxlU2VyaWVzKHRoaXMpO1xyXG4gICAgdmFyIHN0YWNrS2VlcGVycyA9IHtcclxuICAgICAgICBwb3NpdGl2ZToge30sXHJcbiAgICAgICAgbmVnYXRpdmU6IHt9XHJcbiAgICB9O1xyXG4gICAgdmFyIGhvbGVzU3RhY2sgPSB7XHJcbiAgICAgICAgbGVmdDoge30sXHJcbiAgICAgICAgcmlnaHQ6IHt9XHJcbiAgICB9O1xyXG4gICAgdmFyIGxhc3RTZXJpZXNJblBvc2l0aXZlU3RhY2sgPSB7fTtcclxuICAgIHZhciBsYXN0U2VyaWVzSW5OZWdhdGl2ZVN0YWNrID0ge307XHJcbiAgICBzZXJpZXMuZm9yRWFjaCgoZnVuY3Rpb24oc2luZ2xlU2VyaWVzKSB7XHJcbiAgICAgICAgdmFyIHN0YWNrTmFtZSA9IGdldFN0YWNrTmFtZShzaW5nbGVTZXJpZXMpO1xyXG4gICAgICAgIHZhciBob2xlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHN0YWNrID0gZ2V0Rmlyc3RWYWx1ZVNpZ24oc2luZ2xlU2VyaWVzKSA8IDAgPyBsYXN0U2VyaWVzSW5OZWdhdGl2ZVN0YWNrIDogbGFzdFNlcmllc0luUG9zaXRpdmVTdGFjaztcclxuICAgICAgICBzaW5nbGVTZXJpZXMuX3ByZXZTZXJpZXMgPSBzdGFja1tzdGFja05hbWVdO1xyXG4gICAgICAgIHN0YWNrW3N0YWNrTmFtZV0gPSBzaW5nbGVTZXJpZXM7XHJcbiAgICAgICAgc2luZ2xlU2VyaWVzLmhvbGVzID0gZXh0ZW5kKHRydWUsIHt9LCBob2xlc1N0YWNrKTtcclxuICAgICAgICBzaW5nbGVTZXJpZXMuZ2V0UG9pbnRzKCkuZm9yRWFjaCgoZnVuY3Rpb24ocG9pbnQsIGluZGV4LCBwb2ludHMpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gcG9pbnQuaW5pdGlhbFZhbHVlICYmIHBvaW50LmluaXRpYWxWYWx1ZS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIHZhciBhcmd1bWVudCA9IHBvaW50LmFyZ3VtZW50LnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgdmFyIHN0YWNrcyA9IHZhbHVlID49IDAgPyBzdGFja0tlZXBlcnMucG9zaXRpdmUgOiBzdGFja0tlZXBlcnMubmVnYXRpdmU7XHJcbiAgICAgICAgICAgIHZhciBpc05vdEJhclNlcmllcyA9IFwiYmFyXCIgIT09IHNpbmdsZVNlcmllcy50eXBlO1xyXG4gICAgICAgICAgICBpZiAobmVnYXRpdmVzQXNaZXJvZXMgJiYgdmFsdWUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFja3MgPSBzdGFja0tlZXBlcnMucG9zaXRpdmU7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBwb2ludC5yZXNldFZhbHVlKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdGFja3Nbc3RhY2tOYW1lXSA9IHN0YWNrc1tzdGFja05hbWVdIHx8IHt9O1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFN0YWNrID0gc3RhY2tzW3N0YWNrTmFtZV07XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhY2tbYXJndW1lbnRdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOb3RCYXJTZXJpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludC5jb3JyZWN0VmFsdWUoY3VycmVudFN0YWNrW2FyZ3VtZW50XSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGFja1thcmd1bWVudF0gKz0gdmFsdWVcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGFja1thcmd1bWVudF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05vdEJhclNlcmllcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnJlc2V0Q29ycmVjdGlvbigpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFwb2ludC5oYXNWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldlBvaW50ID0gcG9pbnRzW2luZGV4IC0gMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhvbGUgJiYgcHJldlBvaW50ICYmIHByZXZQb2ludC5oYXNWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQgPSBwcmV2UG9pbnQuYXJndW1lbnQudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZQb2ludC5fc2tpcFNldFJpZ2h0SG9sZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9sZXNTdGFjay5yaWdodFthcmd1bWVudF0gPSAoaG9sZXNTdGFjay5yaWdodFthcmd1bWVudF0gfHwgMCkgKyAocHJldlBvaW50LnZhbHVlLnZhbHVlT2YoKSAtIChpc0Zpbml0ZShwcmV2UG9pbnQubWluVmFsdWUpID8gcHJldlBvaW50Lm1pblZhbHVlLnZhbHVlT2YoKSA6IDApKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaG9sZSA9IHRydWVcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChob2xlKSB7XHJcbiAgICAgICAgICAgICAgICBob2xlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBob2xlc1N0YWNrLmxlZnRbYXJndW1lbnRdID0gKGhvbGVzU3RhY2subGVmdFthcmd1bWVudF0gfHwgMCkgKyAocG9pbnQudmFsdWUudmFsdWVPZigpIC0gKGlzRmluaXRlKHBvaW50Lm1pblZhbHVlKSA/IHBvaW50Lm1pblZhbHVlLnZhbHVlT2YoKSA6IDApKTtcclxuICAgICAgICAgICAgICAgIHBvaW50Ll9za2lwU2V0TGVmdEhvbGUgPSB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSlcclxuICAgIH0pKTtcclxuICAgIHNlcmllcy5mb3JFYWNoKChmdW5jdGlvbihzaW5nbGVTZXJpZXMpIHtcclxuICAgICAgICB2YXIgaG9sZXMgPSBzaW5nbGVTZXJpZXMuaG9sZXM7XHJcbiAgICAgICAgc2luZ2xlU2VyaWVzLmdldFBvaW50cygpLmZvckVhY2goKGZ1bmN0aW9uKHBvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBhcmd1bWVudCA9IHBvaW50LmFyZ3VtZW50LnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgcG9pbnQucmVzZXRIb2xlcygpO1xyXG4gICAgICAgICAgICAhcG9pbnQuX3NraXBTZXRMZWZ0SG9sZSAmJiBwb2ludC5zZXRIb2xlKGhvbGVzLmxlZnRbYXJndW1lbnRdIHx8IGhvbGVzU3RhY2subGVmdFthcmd1bWVudF0gJiYgMCwgXCJsZWZ0XCIpO1xyXG4gICAgICAgICAgICAhcG9pbnQuX3NraXBTZXRSaWdodEhvbGUgJiYgcG9pbnQuc2V0SG9sZShob2xlcy5yaWdodFthcmd1bWVudF0gfHwgaG9sZXNTdGFjay5yaWdodFthcmd1bWVudF0gJiYgMCwgXCJyaWdodFwiKTtcclxuICAgICAgICAgICAgcG9pbnQuX3NraXBTZXRMZWZ0SG9sZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHBvaW50Ll9za2lwU2V0UmlnaHRIb2xlID0gbnVsbFxyXG4gICAgICAgIH0pKVxyXG4gICAgfSkpO1xyXG4gICAgdGhpcy5fc3RhY2tLZWVwZXJzID0gc3RhY2tLZWVwZXJzO1xyXG4gICAgc2VyaWVzLmZvckVhY2goKGZ1bmN0aW9uKHNpbmdsZVNlcmllcykge1xyXG4gICAgICAgIHNpbmdsZVNlcmllcy5nZXRQb2ludHMoKS5mb3JFYWNoKChmdW5jdGlvbihwb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgYXJndW1lbnQgPSBwb2ludC5hcmd1bWVudC52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIHZhciBzdGFja05hbWUgPSBnZXRTdGFja05hbWUoc2luZ2xlU2VyaWVzKTtcclxuICAgICAgICAgICAgdmFyIGFic1RvdGFsID0gZ2V0QWJzU3RhY2tTdW1CeUFyZyhzdGFja0tlZXBlcnMsIHN0YWNrTmFtZSwgYXJndW1lbnQpO1xyXG4gICAgICAgICAgICB2YXIgdG90YWwgPSBnZXRTdGFja1N1bUJ5QXJnKHN0YWNrS2VlcGVycywgc3RhY2tOYW1lLCBhcmd1bWVudCk7XHJcbiAgICAgICAgICAgIHBvaW50LnNldFBlcmNlbnRWYWx1ZShhYnNUb3RhbCwgdG90YWwsIGhvbGVzU3RhY2subGVmdFthcmd1bWVudF0sIGhvbGVzU3RhY2sucmlnaHRbYXJndW1lbnRdKVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVN0YWNrZWRTZXJpZXNWYWx1ZXMoKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB2YXIgc2VyaWVzID0gZ2V0VmlzaWJsZVNlcmllcyh0aGF0KTtcclxuICAgIHZhciBzdGFjayA9IHRoYXQuX3N0YWNrS2VlcGVycztcclxuICAgIHZhciBzdGFja0tlZXBlcnMgPSB7XHJcbiAgICAgICAgcG9zaXRpdmU6IHt9LFxyXG4gICAgICAgIG5lZ2F0aXZlOiB7fVxyXG4gICAgfTtcclxuICAgIF9lYWNoKHNlcmllcywgKGZ1bmN0aW9uKF8sIHNpbmdsZVNlcmllcykge1xyXG4gICAgICAgIHZhciBtaW5CYXJTaXplID0gc2luZ2xlU2VyaWVzLmdldE9wdGlvbnMoKS5taW5CYXJTaXplO1xyXG4gICAgICAgIHZhciB2YWx1ZUF4aXNUcmFuc2xhdG9yID0gc2luZ2xlU2VyaWVzLmdldFZhbHVlQXhpcygpLmdldFRyYW5zbGF0b3IoKTtcclxuICAgICAgICB2YXIgbWluU2hvd25CdXNpbmVzc1ZhbHVlID0gbWluQmFyU2l6ZSAmJiB2YWx1ZUF4aXNUcmFuc2xhdG9yLmdldE1pbkJhclNpemUobWluQmFyU2l6ZSk7XHJcbiAgICAgICAgdmFyIHN0YWNrTmFtZSA9IHNpbmdsZVNlcmllcy5nZXRTdGFja05hbWUoKTtcclxuICAgICAgICBfZWFjaChzaW5nbGVTZXJpZXMuZ2V0UG9pbnRzKCksIChmdW5jdGlvbihpbmRleCwgcG9pbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFwb2ludC5oYXNWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwb2ludC5pbml0aWFsVmFsdWUgJiYgcG9pbnQuaW5pdGlhbFZhbHVlLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgdmFyIGFyZ3VtZW50ID0gcG9pbnQuYXJndW1lbnQudmFsdWVPZigpO1xyXG4gICAgICAgICAgICBpZiAodGhhdC5mdWxsU3RhY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIGdldEFic1N0YWNrU3VtQnlBcmcoc3RhY2ssIHN0YWNrTmFtZSwgYXJndW1lbnQpIHx8IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdXBkYXRlVmFsdWUgPSB2YWx1ZUF4aXNUcmFuc2xhdG9yLmNoZWNrTWluQmFyU2l6ZSh2YWx1ZSwgbWluU2hvd25CdXNpbmVzc1ZhbHVlLCBwb2ludC52YWx1ZSk7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZVR5cGUgPSBnZXRWYWx1ZVR5cGUodXBkYXRlVmFsdWUpO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFN0YWNrID0gc3RhY2tLZWVwZXJzW3ZhbHVlVHlwZV1bc3RhY2tOYW1lXSA9IHN0YWNrS2VlcGVyc1t2YWx1ZVR5cGVdW3N0YWNrTmFtZV0gfHwge307XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhY2tbYXJndW1lbnRdKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludC5taW5WYWx1ZSA9IGN1cnJlbnRTdGFja1thcmd1bWVudF07XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhY2tbYXJndW1lbnRdICs9IHVwZGF0ZVZhbHVlXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhY2tbYXJndW1lbnRdID0gdXBkYXRlVmFsdWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb2ludC52YWx1ZSA9IGN1cnJlbnRTdGFja1thcmd1bWVudF1cclxuICAgICAgICB9KSlcclxuICAgIH0pKTtcclxuICAgIGlmICh0aGF0LmZ1bGxTdGFja2VkKSB7XHJcbiAgICAgICAgdXBkYXRlRnVsbFN0YWNrZWRTZXJpZXNWYWx1ZXMoc2VyaWVzLCBzdGFja0tlZXBlcnMpXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUZ1bGxTdGFja2VkU2VyaWVzVmFsdWVzKHNlcmllcywgc3RhY2tLZWVwZXJzKSB7XHJcbiAgICBfZWFjaChzZXJpZXMsIChmdW5jdGlvbihfLCBzaW5nbGVTZXJpZXMpIHtcclxuICAgICAgICB2YXIgc3RhY2tOYW1lID0gc2luZ2xlU2VyaWVzLmdldFN0YWNrTmFtZSA/IHNpbmdsZVNlcmllcy5nZXRTdGFja05hbWUoKSA6IFwiZGVmYXVsdFwiO1xyXG4gICAgICAgIF9lYWNoKHNpbmdsZVNlcmllcy5nZXRQb2ludHMoKSwgKGZ1bmN0aW9uKGluZGV4LCBwb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgc3RhY2tTdW0gPSBnZXRBYnNTdGFja1N1bUJ5QXJnKHN0YWNrS2VlcGVycywgc3RhY2tOYW1lLCBwb2ludC5hcmd1bWVudC52YWx1ZU9mKCkpO1xyXG4gICAgICAgICAgICBpZiAoMCAhPT0gc3RhY2tTdW0pIHtcclxuICAgICAgICAgICAgICAgIHBvaW50LnZhbHVlID0gcG9pbnQudmFsdWUgLyBzdGFja1N1bTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bWVyaWMocG9pbnQubWluVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQubWluVmFsdWUgPSBwb2ludC5taW5WYWx1ZSAvIHN0YWNrU3VtXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSlcclxuICAgIH0pKVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVCYXJTZXJpZXNWYWx1ZXMoKSB7XHJcbiAgICBfZWFjaCh0aGlzLnNlcmllcywgKGZ1bmN0aW9uKF8sIHNpbmdsZVNlcmllcykge1xyXG4gICAgICAgIHZhciBtaW5CYXJTaXplID0gc2luZ2xlU2VyaWVzLmdldE9wdGlvbnMoKS5taW5CYXJTaXplO1xyXG4gICAgICAgIHZhciB2YWx1ZUF4aXNUcmFuc2xhdG9yID0gc2luZ2xlU2VyaWVzLmdldFZhbHVlQXhpcygpLmdldFRyYW5zbGF0b3IoKTtcclxuICAgICAgICB2YXIgbWluU2hvd25CdXNpbmVzc1ZhbHVlID0gbWluQmFyU2l6ZSAmJiB2YWx1ZUF4aXNUcmFuc2xhdG9yLmdldE1pbkJhclNpemUobWluQmFyU2l6ZSk7XHJcbiAgICAgICAgaWYgKG1pblNob3duQnVzaW5lc3NWYWx1ZSkge1xyXG4gICAgICAgICAgICBfZWFjaChzaW5nbGVTZXJpZXMuZ2V0UG9pbnRzKCksIChmdW5jdGlvbihpbmRleCwgcG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwb2ludC5oYXNWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQudmFsdWUgPSB2YWx1ZUF4aXNUcmFuc2xhdG9yLmNoZWNrTWluQmFyU2l6ZShwb2ludC5pbml0aWFsVmFsdWUsIG1pblNob3duQnVzaW5lc3NWYWx1ZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfVxyXG4gICAgfSkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkanVzdENhbmRsZXN0aWNrU2VyaWVzRGltZW5zaW9ucygpIHtcclxuICAgIHZhciBzZXJpZXMgPSBnZXRWaXNpYmxlU2VyaWVzKHRoaXMpO1xyXG4gICAgYWRqdXN0QmFyU2VyaWVzRGltZW5zaW9uc0NvcmUoc2VyaWVzLCB7XHJcbiAgICAgICAgYmFyR3JvdXBQYWRkaW5nOiAuM1xyXG4gICAgfSwgZ2V0U2VyaWVzU3RhY2tJbmRleENhbGxiYWNrKGlzSW52ZXJ0ZWQoc2VyaWVzKSkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkanVzdEJ1YmJsZVNlcmllc0RpbWVuc2lvbnMoKSB7XHJcbiAgICB2YXIgc2VyaWVzID0gZ2V0VmlzaWJsZVNlcmllcyh0aGlzKTtcclxuICAgIGlmICghc2VyaWVzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xyXG4gICAgdmFyIHZpc2libGVBcmVhWCA9IHNlcmllc1swXS5nZXRBcmd1bWVudEF4aXMoKS5nZXRWaXNpYmxlQXJlYSgpO1xyXG4gICAgdmFyIHZpc2libGVBcmVhWSA9IHNlcmllc1swXS5nZXRWYWx1ZUF4aXMoKS5nZXRWaXNpYmxlQXJlYSgpO1xyXG4gICAgdmFyIG1pbiA9IF9taW4odmlzaWJsZUFyZWFYWzFdIC0gdmlzaWJsZUFyZWFYWzBdLCB2aXNpYmxlQXJlYVlbMV0gLSB2aXNpYmxlQXJlYVlbMF0pO1xyXG4gICAgdmFyIG1pbkJ1YmJsZUFyZWEgPSBwb3cob3B0aW9ucy5taW5CdWJibGVTaXplLCAyKTtcclxuICAgIHZhciBtYXhCdWJibGVBcmVhID0gcG93KG1pbiAqIG9wdGlvbnMubWF4QnViYmxlU2l6ZSwgMik7XHJcbiAgICB2YXIgZXF1YWxCdWJibGVTaXplID0gKG1pbiAqIG9wdGlvbnMubWF4QnViYmxlU2l6ZSArIG9wdGlvbnMubWluQnViYmxlU2l6ZSkgLyAyO1xyXG4gICAgdmFyIG1pblBvaW50U2l6ZSA9IDEgLyAwO1xyXG4gICAgdmFyIG1heFBvaW50U2l6ZSA9IC0xIC8gMDtcclxuICAgIHZhciBwb2ludFNpemU7XHJcbiAgICB2YXIgYnViYmxlQXJlYTtcclxuICAgIHZhciBzaXplUHJvcG9ydGlvbjtcclxuICAgIF9lYWNoKHNlcmllcywgKGZ1bmN0aW9uKF8sIHNlcmllc0l0ZW0pIHtcclxuICAgICAgICBfZWFjaChzZXJpZXNJdGVtLmdldFBvaW50cygpLCAoZnVuY3Rpb24oXywgcG9pbnQpIHtcclxuICAgICAgICAgICAgbWF4UG9pbnRTaXplID0gbWF4UG9pbnRTaXplID4gcG9pbnQuc2l6ZSA/IG1heFBvaW50U2l6ZSA6IHBvaW50LnNpemU7XHJcbiAgICAgICAgICAgIG1pblBvaW50U2l6ZSA9IG1pblBvaW50U2l6ZSA8IHBvaW50LnNpemUgPyBtaW5Qb2ludFNpemUgOiBwb2ludC5zaXplXHJcbiAgICAgICAgfSkpXHJcbiAgICB9KSk7XHJcbiAgICB2YXIgc2l6ZURpc3BlcnNpb24gPSBtYXhQb2ludFNpemUgLSBtaW5Qb2ludFNpemU7XHJcbiAgICB2YXIgYXJlYURpc3BlcnNpb24gPSBhYnMobWF4QnViYmxlQXJlYSAtIG1pbkJ1YmJsZUFyZWEpO1xyXG4gICAgX2VhY2goc2VyaWVzLCAoZnVuY3Rpb24oXywgc2VyaWVzSXRlbSkge1xyXG4gICAgICAgIF9lYWNoKHNlcmllc0l0ZW0uZ2V0UG9pbnRzKCksIChmdW5jdGlvbihfLCBwb2ludCkge1xyXG4gICAgICAgICAgICBpZiAobWF4UG9pbnRTaXplID09PSBtaW5Qb2ludFNpemUpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50U2l6ZSA9IHJvdW5kKGVxdWFsQnViYmxlU2l6ZSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNpemVQcm9wb3J0aW9uID0gYWJzKHBvaW50LnNpemUgLSBtaW5Qb2ludFNpemUpIC8gc2l6ZURpc3BlcnNpb247XHJcbiAgICAgICAgICAgICAgICBidWJibGVBcmVhID0gYXJlYURpc3BlcnNpb24gKiBzaXplUHJvcG9ydGlvbiArIG1pbkJ1YmJsZUFyZWE7XHJcbiAgICAgICAgICAgICAgICBwb2ludFNpemUgPSByb3VuZChzcXJ0KGJ1YmJsZUFyZWEpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvaW50LmNvcnJlY3RDb29yZGluYXRlcyhwb2ludFNpemUpXHJcbiAgICAgICAgfSkpXHJcbiAgICB9KSlcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gU2VyaWVzRmFtaWx5KG9wdGlvbnMpIHtcclxuICAgIHRoaXMudHlwZSA9IF9ub3JtYWxpemVFbnVtKG9wdGlvbnMudHlwZSk7XHJcbiAgICB0aGlzLnBhbmUgPSBvcHRpb25zLnBhbmU7XHJcbiAgICB0aGlzLnNlcmllcyA9IFtdO1xyXG4gICAgdGhpcy51cGRhdGVPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICBjYXNlIFwiYmFyXCI6XHJcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0U2VyaWVzRGltZW5zaW9ucyA9IGFkanVzdEJhclNlcmllc0RpbWVuc2lvbnM7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VyaWVzVmFsdWVzID0gdXBkYXRlQmFyU2VyaWVzVmFsdWVzO1xyXG4gICAgICAgICAgICB0aGlzLmFkanVzdFNlcmllc1ZhbHVlcyA9IGFkanVzdFN0YWNrZWRTZXJpZXNWYWx1ZXM7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJyYW5nZWJhclwiOlxyXG4gICAgICAgICAgICB0aGlzLmFkanVzdFNlcmllc0RpbWVuc2lvbnMgPSBhZGp1c3RCYXJTZXJpZXNEaW1lbnNpb25zO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiZnVsbHN0YWNrZWRiYXJcIjpcclxuICAgICAgICAgICAgdGhpcy5mdWxsU3RhY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0U2VyaWVzRGltZW5zaW9ucyA9IGFkanVzdEJhclNlcmllc0RpbWVuc2lvbnM7XHJcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0U2VyaWVzVmFsdWVzID0gYWRqdXN0U3RhY2tlZFNlcmllc1ZhbHVlcztcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTZXJpZXNWYWx1ZXMgPSB1cGRhdGVTdGFja2VkU2VyaWVzVmFsdWVzO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwic3RhY2tlZGJhclwiOlxyXG4gICAgICAgICAgICB0aGlzLmFkanVzdFNlcmllc0RpbWVuc2lvbnMgPSBhZGp1c3RCYXJTZXJpZXNEaW1lbnNpb25zO1xyXG4gICAgICAgICAgICB0aGlzLmFkanVzdFNlcmllc1ZhbHVlcyA9IGFkanVzdFN0YWNrZWRTZXJpZXNWYWx1ZXM7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VyaWVzVmFsdWVzID0gdXBkYXRlU3RhY2tlZFNlcmllc1ZhbHVlcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImZ1bGxzdGFja2VkYXJlYVwiOlxyXG4gICAgICAgIGNhc2UgXCJmdWxsc3RhY2tlZGxpbmVcIjpcclxuICAgICAgICBjYXNlIFwiZnVsbHN0YWNrZWRzcGxpbmVcIjpcclxuICAgICAgICBjYXNlIFwiZnVsbHN0YWNrZWRzcGxpbmVhcmVhXCI6XHJcbiAgICAgICAgICAgIHRoaXMuZnVsbFN0YWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmFkanVzdFNlcmllc1ZhbHVlcyA9IGFkanVzdFN0YWNrZWRTZXJpZXNWYWx1ZXM7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJzdGFja2VkYXJlYVwiOlxyXG4gICAgICAgIGNhc2UgXCJzdGFja2Vkc3BsaW5lYXJlYVwiOlxyXG4gICAgICAgIGNhc2UgXCJzdGFja2VkbGluZVwiOlxyXG4gICAgICAgIGNhc2UgXCJzdGFja2Vkc3BsaW5lXCI6XHJcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0U2VyaWVzVmFsdWVzID0gYWRqdXN0U3RhY2tlZFNlcmllc1ZhbHVlcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImNhbmRsZXN0aWNrXCI6XHJcbiAgICAgICAgY2FzZSBcInN0b2NrXCI6XHJcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0U2VyaWVzRGltZW5zaW9ucyA9IGFkanVzdENhbmRsZXN0aWNrU2VyaWVzRGltZW5zaW9ucztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImJ1YmJsZVwiOlxyXG4gICAgICAgICAgICB0aGlzLmFkanVzdFNlcmllc0RpbWVuc2lvbnMgPSBhZGp1c3RCdWJibGVTZXJpZXNEaW1lbnNpb25zXHJcbiAgICB9XHJcbn1cclxuU2VyaWVzRmFtaWx5LnByb3RvdHlwZSA9IHtcclxuICAgIGNvbnN0cnVjdG9yOiBTZXJpZXNGYW1pbHksXHJcbiAgICBhZGp1c3RTZXJpZXNEaW1lbnNpb25zOiBfbm9vcCxcclxuICAgIGFkanVzdFNlcmllc1ZhbHVlczogX25vb3AsXHJcbiAgICB1cGRhdGVTZXJpZXNWYWx1ZXM6IF9ub29wLFxyXG4gICAgdXBkYXRlT3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXHJcbiAgICB9LFxyXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpZXMgPSBudWxsXHJcbiAgICB9LFxyXG4gICAgYWRkOiBmdW5jdGlvbihzZXJpZXMpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcclxuICAgICAgICB0aGlzLnNlcmllcyA9IF9tYXAoc2VyaWVzLCBzaW5nbGVTZXJpZXMgPT4gc2luZ2xlU2VyaWVzLnR5cGUgPT09IHR5cGUgPyBzaW5nbGVTZXJpZXMgOiBudWxsKVxyXG4gICAgfVxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/core/series_family.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/translators/category_translator.js":
/*!****************************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/translators/category_translator.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/math */ \"./node_modules/devextreme/esm/core/utils/math.js\");\n/**\r\n * DevExtreme (esm/viz/translators/category_translator.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\nvar round = Math.round;\r\n\r\nfunction getValue(value) {\r\n    return value\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    translate: function(category, directionOffset) {\r\n        var canvasOptions = this._canvasOptions;\r\n        var categoryIndex = this._categoriesToPoints[null === category || void 0 === category ? void 0 : category.valueOf()];\r\n        var specialValue = this.translateSpecialCase(category);\r\n        var startPointIndex = canvasOptions.startPointIndex || 0;\r\n        var stickInterval = this._options.stick ? 0 : .5;\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(specialValue)) {\r\n            return round(specialValue)\r\n        }\r\n        if (!categoryIndex && 0 !== categoryIndex) {\r\n            return null\r\n        }\r\n        directionOffset = directionOffset || 0;\r\n        var stickDelta = categoryIndex + stickInterval - startPointIndex + .5 * directionOffset;\r\n        return round(this._calculateProjection(canvasOptions.interval * stickDelta))\r\n    },\r\n    getInterval: function() {\r\n        return this._canvasOptions.interval\r\n    },\r\n    getEventScale: function(zoomEvent) {\r\n        var scale = zoomEvent.deltaScale || 1;\r\n        return 1 - (1 - scale) / (.75 + this.visibleCategories.length / this._categories.length)\r\n    },\r\n    zoom: function(translate, scale) {\r\n        var categories = this._categories;\r\n        var canvasOptions = this._canvasOptions;\r\n        var stick = this._options.stick;\r\n        var invert = canvasOptions.invert;\r\n        var interval = canvasOptions.interval * scale;\r\n        var translateCategories = translate / interval;\r\n        var visibleCount = (this.visibleCategories || []).length;\r\n        var startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + translateCategories + .5);\r\n        var categoriesLength = parseInt(Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_1__[\"adjust\"])(canvasOptions.canvasLength / interval) + (stick ? 1 : 0)) || 1;\r\n        var endCategoryIndex;\r\n        if (invert) {\r\n            startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + visibleCount - translateCategories + .5) - categoriesLength\r\n        }\r\n        if (startCategoryIndex < 0) {\r\n            startCategoryIndex = 0\r\n        }\r\n        endCategoryIndex = startCategoryIndex + categoriesLength;\r\n        if (endCategoryIndex > categories.length) {\r\n            endCategoryIndex = categories.length;\r\n            startCategoryIndex = endCategoryIndex - categoriesLength;\r\n            if (startCategoryIndex < 0) {\r\n                startCategoryIndex = 0\r\n            }\r\n        }\r\n        var newVisibleCategories = categories.slice(parseInt(startCategoryIndex), parseInt(endCategoryIndex));\r\n        var newInterval = this._getDiscreteInterval(newVisibleCategories.length, canvasOptions);\r\n        scale = newInterval / canvasOptions.interval;\r\n        translate = this.translate(!invert ? newVisibleCategories[0] : newVisibleCategories[newVisibleCategories.length - 1]) * scale - (canvasOptions.startPoint + (stick ? 0 : newInterval / 2));\r\n        return {\r\n            min: newVisibleCategories[0],\r\n            max: newVisibleCategories[newVisibleCategories.length - 1],\r\n            translate: translate,\r\n            scale: scale\r\n        }\r\n    },\r\n    getMinScale: function(zoom) {\r\n        var canvasOptions = this._canvasOptions;\r\n        var categoriesLength = (this.visibleCategories || this._categories).length;\r\n        categoriesLength += (parseInt(.1 * categoriesLength) || 1) * (zoom ? -2 : 2);\r\n        return canvasOptions.canvasLength / (Math.max(categoriesLength, 1) * canvasOptions.interval)\r\n    },\r\n    getScale: function(min, max) {\r\n        var canvasOptions = this._canvasOptions;\r\n        var visibleArea = this.getCanvasVisibleArea();\r\n        var stickOffset = !this._options.stick && 1;\r\n        var minPoint = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(min) ? this.translate(min, -stickOffset) : null;\r\n        var maxPoint = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(max) ? this.translate(max, +stickOffset) : null;\r\n        if (null === minPoint) {\r\n            minPoint = canvasOptions.invert ? visibleArea.max : visibleArea.min\r\n        }\r\n        if (null === maxPoint) {\r\n            maxPoint = canvasOptions.invert ? visibleArea.min : visibleArea.max\r\n        }\r\n        return this.canvasLength / Math.abs(maxPoint - minPoint)\r\n    },\r\n    isValid: function(value) {\r\n        return Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(value) ? this._categoriesToPoints[value.valueOf()] >= 0 : false\r\n    },\r\n    getCorrectValue: getValue,\r\n    to: function(value, direction) {\r\n        var canvasOptions = this._canvasOptions;\r\n        var categoryIndex = this._categoriesToPoints[null === value || void 0 === value ? void 0 : value.valueOf()];\r\n        var startPointIndex = canvasOptions.startPointIndex || 0;\r\n        var stickDelta = categoryIndex + (this._options.stick ? 0 : .5) - startPointIndex + (this._businessRange.invert ? -1 : 1) * direction * .5;\r\n        return round(this._calculateProjection(canvasOptions.interval * stickDelta))\r\n    },\r\n    from: function(position) {\r\n        var direction = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\r\n        var canvasOptions = this._canvasOptions;\r\n        var startPoint = canvasOptions.startPoint;\r\n        var categories = this.visibleCategories || this._categories;\r\n        var categoriesLength = categories.length;\r\n        var stickInterval = this._options.stick ? .5 : 0;\r\n        var result = round((position - startPoint) / canvasOptions.interval + stickInterval - .5 - .5 * direction);\r\n        if (result >= categoriesLength) {\r\n            result = categoriesLength - 1\r\n        }\r\n        if (result < 0) {\r\n            result = 0\r\n        }\r\n        if (canvasOptions.invert) {\r\n            result = categoriesLength - result - 1\r\n        }\r\n        return categories[result]\r\n    },\r\n    _add: function() {\r\n        return NaN\r\n    },\r\n    toValue: getValue,\r\n    isValueProlonged: true,\r\n    getRangeByMinZoomValue(minZoom, visualRange) {\r\n        var categories = this._categories;\r\n        var minVisibleIndex = categories.indexOf(visualRange.minVisible);\r\n        var maxVisibleIndex = categories.indexOf(visualRange.maxVisible);\r\n        var startIndex = minVisibleIndex + minZoom - 1;\r\n        var endIndex = maxVisibleIndex - minZoom + 1;\r\n        if (categories[startIndex]) {\r\n            return [visualRange.minVisible, categories[startIndex]]\r\n        } else {\r\n            return [categories[endIndex], visualRange.maxVisible]\r\n        }\r\n    }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L3RyYW5zbGF0b3JzL2NhdGVnb3J5X3RyYW5zbGF0b3IuanM/NGEzZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRytCO0FBR0E7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtEQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0VBQVM7QUFDaEMsdUJBQXVCLGtFQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSxrRUFBUztBQUN4QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RldmV4dHJlbWUvZXNtL3Zpei90cmFuc2xhdG9ycy9jYXRlZ29yeV90cmFuc2xhdG9yLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS92aXovdHJhbnNsYXRvcnMvY2F0ZWdvcnlfdHJhbnNsYXRvci5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IHtcclxuICAgIGlzRGVmaW5lZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL3R5cGVcIjtcclxuaW1wb3J0IHtcclxuICAgIGFkanVzdFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL21hdGhcIjtcclxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxuXHJcbmZ1bmN0aW9uIGdldFZhbHVlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWVcclxufVxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKGNhdGVnb3J5LCBkaXJlY3Rpb25PZmZzZXQpIHtcclxuICAgICAgICB2YXIgY2FudmFzT3B0aW9ucyA9IHRoaXMuX2NhbnZhc09wdGlvbnM7XHJcbiAgICAgICAgdmFyIGNhdGVnb3J5SW5kZXggPSB0aGlzLl9jYXRlZ29yaWVzVG9Qb2ludHNbbnVsbCA9PT0gY2F0ZWdvcnkgfHwgdm9pZCAwID09PSBjYXRlZ29yeSA/IHZvaWQgMCA6IGNhdGVnb3J5LnZhbHVlT2YoKV07XHJcbiAgICAgICAgdmFyIHNwZWNpYWxWYWx1ZSA9IHRoaXMudHJhbnNsYXRlU3BlY2lhbENhc2UoY2F0ZWdvcnkpO1xyXG4gICAgICAgIHZhciBzdGFydFBvaW50SW5kZXggPSBjYW52YXNPcHRpb25zLnN0YXJ0UG9pbnRJbmRleCB8fCAwO1xyXG4gICAgICAgIHZhciBzdGlja0ludGVydmFsID0gdGhpcy5fb3B0aW9ucy5zdGljayA/IDAgOiAuNTtcclxuICAgICAgICBpZiAoaXNEZWZpbmVkKHNwZWNpYWxWYWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHNwZWNpYWxWYWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjYXRlZ29yeUluZGV4ICYmIDAgIT09IGNhdGVnb3J5SW5kZXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlyZWN0aW9uT2Zmc2V0ID0gZGlyZWN0aW9uT2Zmc2V0IHx8IDA7XHJcbiAgICAgICAgdmFyIHN0aWNrRGVsdGEgPSBjYXRlZ29yeUluZGV4ICsgc3RpY2tJbnRlcnZhbCAtIHN0YXJ0UG9pbnRJbmRleCArIC41ICogZGlyZWN0aW9uT2Zmc2V0O1xyXG4gICAgICAgIHJldHVybiByb3VuZCh0aGlzLl9jYWxjdWxhdGVQcm9qZWN0aW9uKGNhbnZhc09wdGlvbnMuaW50ZXJ2YWwgKiBzdGlja0RlbHRhKSlcclxuICAgIH0sXHJcbiAgICBnZXRJbnRlcnZhbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc09wdGlvbnMuaW50ZXJ2YWxcclxuICAgIH0sXHJcbiAgICBnZXRFdmVudFNjYWxlOiBmdW5jdGlvbih6b29tRXZlbnQpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSB6b29tRXZlbnQuZGVsdGFTY2FsZSB8fCAxO1xyXG4gICAgICAgIHJldHVybiAxIC0gKDEgLSBzY2FsZSkgLyAoLjc1ICsgdGhpcy52aXNpYmxlQ2F0ZWdvcmllcy5sZW5ndGggLyB0aGlzLl9jYXRlZ29yaWVzLmxlbmd0aClcclxuICAgIH0sXHJcbiAgICB6b29tOiBmdW5jdGlvbih0cmFuc2xhdGUsIHNjYWxlKSB7XHJcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSB0aGlzLl9jYXRlZ29yaWVzO1xyXG4gICAgICAgIHZhciBjYW52YXNPcHRpb25zID0gdGhpcy5fY2FudmFzT3B0aW9ucztcclxuICAgICAgICB2YXIgc3RpY2sgPSB0aGlzLl9vcHRpb25zLnN0aWNrO1xyXG4gICAgICAgIHZhciBpbnZlcnQgPSBjYW52YXNPcHRpb25zLmludmVydDtcclxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBjYW52YXNPcHRpb25zLmludGVydmFsICogc2NhbGU7XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZUNhdGVnb3JpZXMgPSB0cmFuc2xhdGUgLyBpbnRlcnZhbDtcclxuICAgICAgICB2YXIgdmlzaWJsZUNvdW50ID0gKHRoaXMudmlzaWJsZUNhdGVnb3JpZXMgfHwgW10pLmxlbmd0aDtcclxuICAgICAgICB2YXIgc3RhcnRDYXRlZ29yeUluZGV4ID0gcGFyc2VJbnQoKGNhbnZhc09wdGlvbnMuc3RhcnRQb2ludEluZGV4IHx8IDApICsgdHJhbnNsYXRlQ2F0ZWdvcmllcyArIC41KTtcclxuICAgICAgICB2YXIgY2F0ZWdvcmllc0xlbmd0aCA9IHBhcnNlSW50KGFkanVzdChjYW52YXNPcHRpb25zLmNhbnZhc0xlbmd0aCAvIGludGVydmFsKSArIChzdGljayA/IDEgOiAwKSkgfHwgMTtcclxuICAgICAgICB2YXIgZW5kQ2F0ZWdvcnlJbmRleDtcclxuICAgICAgICBpZiAoaW52ZXJ0KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0Q2F0ZWdvcnlJbmRleCA9IHBhcnNlSW50KChjYW52YXNPcHRpb25zLnN0YXJ0UG9pbnRJbmRleCB8fCAwKSArIHZpc2libGVDb3VudCAtIHRyYW5zbGF0ZUNhdGVnb3JpZXMgKyAuNSkgLSBjYXRlZ29yaWVzTGVuZ3RoXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydENhdGVnb3J5SW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0Q2F0ZWdvcnlJbmRleCA9IDBcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5kQ2F0ZWdvcnlJbmRleCA9IHN0YXJ0Q2F0ZWdvcnlJbmRleCArIGNhdGVnb3JpZXNMZW5ndGg7XHJcbiAgICAgICAgaWYgKGVuZENhdGVnb3J5SW5kZXggPiBjYXRlZ29yaWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBlbmRDYXRlZ29yeUluZGV4ID0gY2F0ZWdvcmllcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHN0YXJ0Q2F0ZWdvcnlJbmRleCA9IGVuZENhdGVnb3J5SW5kZXggLSBjYXRlZ29yaWVzTGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRDYXRlZ29yeUluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRDYXRlZ29yeUluZGV4ID0gMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXdWaXNpYmxlQ2F0ZWdvcmllcyA9IGNhdGVnb3JpZXMuc2xpY2UocGFyc2VJbnQoc3RhcnRDYXRlZ29yeUluZGV4KSwgcGFyc2VJbnQoZW5kQ2F0ZWdvcnlJbmRleCkpO1xyXG4gICAgICAgIHZhciBuZXdJbnRlcnZhbCA9IHRoaXMuX2dldERpc2NyZXRlSW50ZXJ2YWwobmV3VmlzaWJsZUNhdGVnb3JpZXMubGVuZ3RoLCBjYW52YXNPcHRpb25zKTtcclxuICAgICAgICBzY2FsZSA9IG5ld0ludGVydmFsIC8gY2FudmFzT3B0aW9ucy5pbnRlcnZhbDtcclxuICAgICAgICB0cmFuc2xhdGUgPSB0aGlzLnRyYW5zbGF0ZSghaW52ZXJ0ID8gbmV3VmlzaWJsZUNhdGVnb3JpZXNbMF0gOiBuZXdWaXNpYmxlQ2F0ZWdvcmllc1tuZXdWaXNpYmxlQ2F0ZWdvcmllcy5sZW5ndGggLSAxXSkgKiBzY2FsZSAtIChjYW52YXNPcHRpb25zLnN0YXJ0UG9pbnQgKyAoc3RpY2sgPyAwIDogbmV3SW50ZXJ2YWwgLyAyKSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWluOiBuZXdWaXNpYmxlQ2F0ZWdvcmllc1swXSxcclxuICAgICAgICAgICAgbWF4OiBuZXdWaXNpYmxlQ2F0ZWdvcmllc1tuZXdWaXNpYmxlQ2F0ZWdvcmllcy5sZW5ndGggLSAxXSxcclxuICAgICAgICAgICAgdHJhbnNsYXRlOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgICAgIHNjYWxlOiBzY2FsZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBnZXRNaW5TY2FsZTogZnVuY3Rpb24oem9vbSkge1xyXG4gICAgICAgIHZhciBjYW52YXNPcHRpb25zID0gdGhpcy5fY2FudmFzT3B0aW9ucztcclxuICAgICAgICB2YXIgY2F0ZWdvcmllc0xlbmd0aCA9ICh0aGlzLnZpc2libGVDYXRlZ29yaWVzIHx8IHRoaXMuX2NhdGVnb3JpZXMpLmxlbmd0aDtcclxuICAgICAgICBjYXRlZ29yaWVzTGVuZ3RoICs9IChwYXJzZUludCguMSAqIGNhdGVnb3JpZXNMZW5ndGgpIHx8IDEpICogKHpvb20gPyAtMiA6IDIpO1xyXG4gICAgICAgIHJldHVybiBjYW52YXNPcHRpb25zLmNhbnZhc0xlbmd0aCAvIChNYXRoLm1heChjYXRlZ29yaWVzTGVuZ3RoLCAxKSAqIGNhbnZhc09wdGlvbnMuaW50ZXJ2YWwpXHJcbiAgICB9LFxyXG4gICAgZ2V0U2NhbGU6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgdmFyIGNhbnZhc09wdGlvbnMgPSB0aGlzLl9jYW52YXNPcHRpb25zO1xyXG4gICAgICAgIHZhciB2aXNpYmxlQXJlYSA9IHRoaXMuZ2V0Q2FudmFzVmlzaWJsZUFyZWEoKTtcclxuICAgICAgICB2YXIgc3RpY2tPZmZzZXQgPSAhdGhpcy5fb3B0aW9ucy5zdGljayAmJiAxO1xyXG4gICAgICAgIHZhciBtaW5Qb2ludCA9IGlzRGVmaW5lZChtaW4pID8gdGhpcy50cmFuc2xhdGUobWluLCAtc3RpY2tPZmZzZXQpIDogbnVsbDtcclxuICAgICAgICB2YXIgbWF4UG9pbnQgPSBpc0RlZmluZWQobWF4KSA/IHRoaXMudHJhbnNsYXRlKG1heCwgK3N0aWNrT2Zmc2V0KSA6IG51bGw7XHJcbiAgICAgICAgaWYgKG51bGwgPT09IG1pblBvaW50KSB7XHJcbiAgICAgICAgICAgIG1pblBvaW50ID0gY2FudmFzT3B0aW9ucy5pbnZlcnQgPyB2aXNpYmxlQXJlYS5tYXggOiB2aXNpYmxlQXJlYS5taW5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG51bGwgPT09IG1heFBvaW50KSB7XHJcbiAgICAgICAgICAgIG1heFBvaW50ID0gY2FudmFzT3B0aW9ucy5pbnZlcnQgPyB2aXNpYmxlQXJlYS5taW4gOiB2aXNpYmxlQXJlYS5tYXhcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTGVuZ3RoIC8gTWF0aC5hYnMobWF4UG9pbnQgLSBtaW5Qb2ludClcclxuICAgIH0sXHJcbiAgICBpc1ZhbGlkOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBpc0RlZmluZWQodmFsdWUpID8gdGhpcy5fY2F0ZWdvcmllc1RvUG9pbnRzW3ZhbHVlLnZhbHVlT2YoKV0gPj0gMCA6IGZhbHNlXHJcbiAgICB9LFxyXG4gICAgZ2V0Q29ycmVjdFZhbHVlOiBnZXRWYWx1ZSxcclxuICAgIHRvOiBmdW5jdGlvbih2YWx1ZSwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIGNhbnZhc09wdGlvbnMgPSB0aGlzLl9jYW52YXNPcHRpb25zO1xyXG4gICAgICAgIHZhciBjYXRlZ29yeUluZGV4ID0gdGhpcy5fY2F0ZWdvcmllc1RvUG9pbnRzW251bGwgPT09IHZhbHVlIHx8IHZvaWQgMCA9PT0gdmFsdWUgPyB2b2lkIDAgOiB2YWx1ZS52YWx1ZU9mKCldO1xyXG4gICAgICAgIHZhciBzdGFydFBvaW50SW5kZXggPSBjYW52YXNPcHRpb25zLnN0YXJ0UG9pbnRJbmRleCB8fCAwO1xyXG4gICAgICAgIHZhciBzdGlja0RlbHRhID0gY2F0ZWdvcnlJbmRleCArICh0aGlzLl9vcHRpb25zLnN0aWNrID8gMCA6IC41KSAtIHN0YXJ0UG9pbnRJbmRleCArICh0aGlzLl9idXNpbmVzc1JhbmdlLmludmVydCA/IC0xIDogMSkgKiBkaXJlY3Rpb24gKiAuNTtcclxuICAgICAgICByZXR1cm4gcm91bmQodGhpcy5fY2FsY3VsYXRlUHJvamVjdGlvbihjYW52YXNPcHRpb25zLmludGVydmFsICogc3RpY2tEZWx0YSkpXHJcbiAgICB9LFxyXG4gICAgZnJvbTogZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiAwO1xyXG4gICAgICAgIHZhciBjYW52YXNPcHRpb25zID0gdGhpcy5fY2FudmFzT3B0aW9ucztcclxuICAgICAgICB2YXIgc3RhcnRQb2ludCA9IGNhbnZhc09wdGlvbnMuc3RhcnRQb2ludDtcclxuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IHRoaXMudmlzaWJsZUNhdGVnb3JpZXMgfHwgdGhpcy5fY2F0ZWdvcmllcztcclxuICAgICAgICB2YXIgY2F0ZWdvcmllc0xlbmd0aCA9IGNhdGVnb3JpZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzdGlja0ludGVydmFsID0gdGhpcy5fb3B0aW9ucy5zdGljayA/IC41IDogMDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gcm91bmQoKHBvc2l0aW9uIC0gc3RhcnRQb2ludCkgLyBjYW52YXNPcHRpb25zLmludGVydmFsICsgc3RpY2tJbnRlcnZhbCAtIC41IC0gLjUgKiBkaXJlY3Rpb24pO1xyXG4gICAgICAgIGlmIChyZXN1bHQgPj0gY2F0ZWdvcmllc0xlbmd0aCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBjYXRlZ29yaWVzTGVuZ3RoIC0gMVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0IDwgMCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSAwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYW52YXNPcHRpb25zLmludmVydCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBjYXRlZ29yaWVzTGVuZ3RoIC0gcmVzdWx0IC0gMVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2F0ZWdvcmllc1tyZXN1bHRdXHJcbiAgICB9LFxyXG4gICAgX2FkZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIE5hTlxyXG4gICAgfSxcclxuICAgIHRvVmFsdWU6IGdldFZhbHVlLFxyXG4gICAgaXNWYWx1ZVByb2xvbmdlZDogdHJ1ZSxcclxuICAgIGdldFJhbmdlQnlNaW5ab29tVmFsdWUobWluWm9vbSwgdmlzdWFsUmFuZ2UpIHtcclxuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IHRoaXMuX2NhdGVnb3JpZXM7XHJcbiAgICAgICAgdmFyIG1pblZpc2libGVJbmRleCA9IGNhdGVnb3JpZXMuaW5kZXhPZih2aXN1YWxSYW5nZS5taW5WaXNpYmxlKTtcclxuICAgICAgICB2YXIgbWF4VmlzaWJsZUluZGV4ID0gY2F0ZWdvcmllcy5pbmRleE9mKHZpc3VhbFJhbmdlLm1heFZpc2libGUpO1xyXG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gbWluVmlzaWJsZUluZGV4ICsgbWluWm9vbSAtIDE7XHJcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gbWF4VmlzaWJsZUluZGV4IC0gbWluWm9vbSArIDE7XHJcbiAgICAgICAgaWYgKGNhdGVnb3JpZXNbc3RhcnRJbmRleF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt2aXN1YWxSYW5nZS5taW5WaXNpYmxlLCBjYXRlZ29yaWVzW3N0YXJ0SW5kZXhdXVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbY2F0ZWdvcmllc1tlbmRJbmRleF0sIHZpc3VhbFJhbmdlLm1heFZpc2libGVdXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/translators/category_translator.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/translators/datetime_translator.js":
/*!****************************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/translators/datetime_translator.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_utils_date__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/utils/date */ \"./node_modules/devextreme/esm/core/utils/date.js\");\n/**\r\n * DevExtreme (esm/viz/translators/datetime_translator.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\nfunction parse(value) {\r\n    return null !== value ? new Date(value) : value\r\n}\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    fromValue: parse,\r\n    toValue: parse,\r\n    _add: _core_utils_date__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addDateInterval,\r\n    convert: _core_utils_date__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dateToMilliseconds\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L3RyYW5zbGF0b3JzL2RhdGV0aW1lX3RyYW5zbGF0b3IuanM/NzFhMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0EsVUFBVSx3REFBUztBQUNuQixhQUFhLHdEQUFTO0FBQ3RCLENBQUMsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kZXZleHRyZW1lL2VzbS92aXovdHJhbnNsYXRvcnMvZGF0ZXRpbWVfdHJhbnNsYXRvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdml6L3RyYW5zbGF0b3JzL2RhdGV0aW1lX3RyYW5zbGF0b3IuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCBkYXRlVXRpbHMgZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvZGF0ZVwiO1xyXG5cclxuZnVuY3Rpb24gcGFyc2UodmFsdWUpIHtcclxuICAgIHJldHVybiBudWxsICE9PSB2YWx1ZSA/IG5ldyBEYXRlKHZhbHVlKSA6IHZhbHVlXHJcbn1cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgZnJvbVZhbHVlOiBwYXJzZSxcclxuICAgIHRvVmFsdWU6IHBhcnNlLFxyXG4gICAgX2FkZDogZGF0ZVV0aWxzLmFkZERhdGVJbnRlcnZhbCxcclxuICAgIGNvbnZlcnQ6IGRhdGVVdGlscy5kYXRlVG9NaWxsaXNlY29uZHNcclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/translators/datetime_translator.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/translators/interval_translator.js":
/*!****************************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/translators/interval_translator.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_date__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/date */ \"./node_modules/devextreme/esm/core/utils/date.js\");\n/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/utils/math */ \"./node_modules/devextreme/esm/core/utils/math.js\");\n/**\r\n * DevExtreme (esm/viz/translators/interval_translator.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\nvar floor = Math.floor;\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    _intervalize: function(value, interval) {\r\n        if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(value)) {\r\n            return\r\n        }\r\n        if (\"datetime\" === this._businessRange.dataType) {\r\n            if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isNumeric\"])(value)) {\r\n                value = new Date(value)\r\n            } else {\r\n                value = new Date(value.getTime())\r\n            }\r\n            value = _core_utils_date__WEBPACK_IMPORTED_MODULE_1__[\"default\"].correctDateWithUnitBeginning(value, interval, null, this._options.firstDayOfWeek)\r\n        } else {\r\n            value = Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_2__[\"adjust\"])(floor(Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_2__[\"adjust\"])(value / interval)) * interval, interval)\r\n        }\r\n        return value\r\n    },\r\n    translate: function(bp, direction, interval) {\r\n        var specialValue = this.translateSpecialCase(bp);\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isDefined\"])(specialValue)) {\r\n            return Math.round(specialValue)\r\n        }\r\n        interval = interval || this._options.interval;\r\n        if (!this.isValid(bp, interval)) {\r\n            return null\r\n        }\r\n        return this.to(bp, direction, interval)\r\n    },\r\n    getInterval: function() {\r\n        return Math.round(this._canvasOptions.ratioOfCanvasRange * (this._businessRange.interval || Math.abs(this._canvasOptions.rangeMax - this._canvasOptions.rangeMin)))\r\n    },\r\n    zoom: function() {},\r\n    getMinScale: function() {},\r\n    getScale: function() {},\r\n    _parse: function(value) {\r\n        return \"datetime\" === this._businessRange.dataType ? new Date(value) : Number(value)\r\n    },\r\n    fromValue: function(value) {\r\n        return this._parse(value)\r\n    },\r\n    toValue: function(value) {\r\n        return this._parse(value)\r\n    },\r\n    isValid: function(value, interval) {\r\n        var co = this._canvasOptions;\r\n        var rangeMin = co.rangeMin;\r\n        var rangeMax = co.rangeMax;\r\n        interval = interval || this._options.interval;\r\n        if (null === value || isNaN(value)) {\r\n            return false\r\n        }\r\n        value = \"datetime\" === this._businessRange.dataType && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_0__[\"isNumeric\"])(value) ? new Date(value) : value;\r\n        if (interval !== this._options.interval) {\r\n            rangeMin = this._intervalize(rangeMin, interval);\r\n            rangeMax = this._intervalize(rangeMax, interval)\r\n        }\r\n        if (value.valueOf() < rangeMin || value.valueOf() >= _core_utils_date__WEBPACK_IMPORTED_MODULE_1__[\"default\"].addInterval(rangeMax, interval)) {\r\n            return false\r\n        }\r\n        return true\r\n    },\r\n    to: function(bp, direction, interval) {\r\n        interval = interval || this._options.interval;\r\n        var v1 = this._intervalize(bp, interval);\r\n        var v2 = _core_utils_date__WEBPACK_IMPORTED_MODULE_1__[\"default\"].addInterval(v1, interval);\r\n        var res = this._to(v1);\r\n        var p2 = this._to(v2);\r\n        if (!direction) {\r\n            res = floor((res + p2) / 2)\r\n        } else if (direction > 0) {\r\n            res = p2\r\n        }\r\n        return res\r\n    },\r\n    _to: function(value) {\r\n        var co = this._canvasOptions;\r\n        var rMin = co.rangeMinVisible;\r\n        var rMax = co.rangeMaxVisible;\r\n        var offset = value - rMin;\r\n        if (value < rMin) {\r\n            offset = 0\r\n        } else if (value > rMax) {\r\n            offset = _core_utils_date__WEBPACK_IMPORTED_MODULE_1__[\"default\"].addInterval(rMax, this._options.interval) - rMin\r\n        }\r\n        return this._conversionValue(this._calculateProjection(offset * this._canvasOptions.ratioOfCanvasRange))\r\n    },\r\n    from: function(position, direction) {\r\n        var origInterval = this._options.interval;\r\n        var interval = origInterval;\r\n        var co = this._canvasOptions;\r\n        var rMin = co.rangeMinVisible;\r\n        var rMax = co.rangeMaxVisible;\r\n        var value;\r\n        if (\"datetime\" === this._businessRange.dataType) {\r\n            interval = _core_utils_date__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dateToMilliseconds(origInterval)\r\n        }\r\n        value = this._calculateUnProjection((position - this._canvasOptions.startPoint) / this._canvasOptions.ratioOfCanvasRange);\r\n        value = this._intervalize(_core_utils_date__WEBPACK_IMPORTED_MODULE_1__[\"default\"].addInterval(value, interval / 2, direction > 0), origInterval);\r\n        if (value < rMin) {\r\n            value = rMin\r\n        } else if (value > rMax) {\r\n            value = rMax\r\n        }\r\n        return value\r\n    },\r\n    _add: function() {\r\n        return NaN\r\n    },\r\n    isValueProlonged: true\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L3RyYW5zbGF0b3JzL2ludGVydmFsX3RyYW5zbGF0b3IuanM/ZGI0ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJK0I7QUFDZTtBQUM5QztBQUcrQjtBQUNoQjtBQUNmO0FBQ0EsYUFBYSxrRUFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQVE7QUFDeEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQix3REFBUztBQUM3QixTQUFTO0FBQ1Qsb0JBQW9CLCtEQUFNLE9BQU8sK0RBQU07QUFDdkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxrRUFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsa0VBQVE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsd0RBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCLHdEQUFTO0FBQzlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBUztBQUNoQztBQUNBO0FBQ0Esa0NBQWtDLHdEQUFTO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L3RyYW5zbGF0b3JzL2ludGVydmFsX3RyYW5zbGF0b3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3Zpei90cmFuc2xhdG9ycy9pbnRlcnZhbF90cmFuc2xhdG9yLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQge1xyXG4gICAgaXNOdW1lcmljIGFzIGlzTnVtYmVyLFxyXG4gICAgaXNEZWZpbmVkXHJcbn0gZnJvbSBcIi4uLy4uL2NvcmUvdXRpbHMvdHlwZVwiO1xyXG5pbXBvcnQgZGF0ZVV0aWxzIGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2RhdGVcIjtcclxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcclxuaW1wb3J0IHtcclxuICAgIGFkanVzdFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL21hdGhcIjtcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgX2ludGVydmFsaXplOiBmdW5jdGlvbih2YWx1ZSwgaW50ZXJ2YWwpIHtcclxuICAgICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChcImRhdGV0aW1lXCIgPT09IHRoaXMuX2J1c2luZXNzUmFuZ2UuZGF0YVR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSlcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUuZ2V0VGltZSgpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbHVlID0gZGF0ZVV0aWxzLmNvcnJlY3REYXRlV2l0aFVuaXRCZWdpbm5pbmcodmFsdWUsIGludGVydmFsLCBudWxsLCB0aGlzLl9vcHRpb25zLmZpcnN0RGF5T2ZXZWVrKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gYWRqdXN0KGZsb29yKGFkanVzdCh2YWx1ZSAvIGludGVydmFsKSkgKiBpbnRlcnZhbCwgaW50ZXJ2YWwpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgfSxcclxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oYnAsIGRpcmVjdGlvbiwgaW50ZXJ2YWwpIHtcclxuICAgICAgICB2YXIgc3BlY2lhbFZhbHVlID0gdGhpcy50cmFuc2xhdGVTcGVjaWFsQ2FzZShicCk7XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZChzcGVjaWFsVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHNwZWNpYWxWYWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaW50ZXJ2YWwgPSBpbnRlcnZhbCB8fCB0aGlzLl9vcHRpb25zLmludGVydmFsO1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKGJwLCBpbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oYnAsIGRpcmVjdGlvbiwgaW50ZXJ2YWwpXHJcbiAgICB9LFxyXG4gICAgZ2V0SW50ZXJ2YWw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuX2NhbnZhc09wdGlvbnMucmF0aW9PZkNhbnZhc1JhbmdlICogKHRoaXMuX2J1c2luZXNzUmFuZ2UuaW50ZXJ2YWwgfHwgTWF0aC5hYnModGhpcy5fY2FudmFzT3B0aW9ucy5yYW5nZU1heCAtIHRoaXMuX2NhbnZhc09wdGlvbnMucmFuZ2VNaW4pKSlcclxuICAgIH0sXHJcbiAgICB6b29tOiBmdW5jdGlvbigpIHt9LFxyXG4gICAgZ2V0TWluU2NhbGU6IGZ1bmN0aW9uKCkge30sXHJcbiAgICBnZXRTY2FsZTogZnVuY3Rpb24oKSB7fSxcclxuICAgIF9wYXJzZTogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gXCJkYXRldGltZVwiID09PSB0aGlzLl9idXNpbmVzc1JhbmdlLmRhdGFUeXBlID8gbmV3IERhdGUodmFsdWUpIDogTnVtYmVyKHZhbHVlKVxyXG4gICAgfSxcclxuICAgIGZyb21WYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2UodmFsdWUpXHJcbiAgICB9LFxyXG4gICAgdG9WYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2UodmFsdWUpXHJcbiAgICB9LFxyXG4gICAgaXNWYWxpZDogZnVuY3Rpb24odmFsdWUsIGludGVydmFsKSB7XHJcbiAgICAgICAgdmFyIGNvID0gdGhpcy5fY2FudmFzT3B0aW9ucztcclxuICAgICAgICB2YXIgcmFuZ2VNaW4gPSBjby5yYW5nZU1pbjtcclxuICAgICAgICB2YXIgcmFuZ2VNYXggPSBjby5yYW5nZU1heDtcclxuICAgICAgICBpbnRlcnZhbCA9IGludGVydmFsIHx8IHRoaXMuX29wdGlvbnMuaW50ZXJ2YWw7XHJcbiAgICAgICAgaWYgKG51bGwgPT09IHZhbHVlIHx8IGlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWUgPSBcImRhdGV0aW1lXCIgPT09IHRoaXMuX2J1c2luZXNzUmFuZ2UuZGF0YVR5cGUgJiYgaXNOdW1iZXIodmFsdWUpID8gbmV3IERhdGUodmFsdWUpIDogdmFsdWU7XHJcbiAgICAgICAgaWYgKGludGVydmFsICE9PSB0aGlzLl9vcHRpb25zLmludGVydmFsKSB7XHJcbiAgICAgICAgICAgIHJhbmdlTWluID0gdGhpcy5faW50ZXJ2YWxpemUocmFuZ2VNaW4sIGludGVydmFsKTtcclxuICAgICAgICAgICAgcmFuZ2VNYXggPSB0aGlzLl9pbnRlcnZhbGl6ZShyYW5nZU1heCwgaW50ZXJ2YWwpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZS52YWx1ZU9mKCkgPCByYW5nZU1pbiB8fCB2YWx1ZS52YWx1ZU9mKCkgPj0gZGF0ZVV0aWxzLmFkZEludGVydmFsKHJhbmdlTWF4LCBpbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9LFxyXG4gICAgdG86IGZ1bmN0aW9uKGJwLCBkaXJlY3Rpb24sIGludGVydmFsKSB7XHJcbiAgICAgICAgaW50ZXJ2YWwgPSBpbnRlcnZhbCB8fCB0aGlzLl9vcHRpb25zLmludGVydmFsO1xyXG4gICAgICAgIHZhciB2MSA9IHRoaXMuX2ludGVydmFsaXplKGJwLCBpbnRlcnZhbCk7XHJcbiAgICAgICAgdmFyIHYyID0gZGF0ZVV0aWxzLmFkZEludGVydmFsKHYxLCBpbnRlcnZhbCk7XHJcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuX3RvKHYxKTtcclxuICAgICAgICB2YXIgcDIgPSB0aGlzLl90byh2Mik7XHJcbiAgICAgICAgaWYgKCFkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgcmVzID0gZmxvb3IoKHJlcyArIHAyKSAvIDIpXHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPiAwKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IHAyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNcclxuICAgIH0sXHJcbiAgICBfdG86IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNvID0gdGhpcy5fY2FudmFzT3B0aW9ucztcclxuICAgICAgICB2YXIgck1pbiA9IGNvLnJhbmdlTWluVmlzaWJsZTtcclxuICAgICAgICB2YXIgck1heCA9IGNvLnJhbmdlTWF4VmlzaWJsZTtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gdmFsdWUgLSByTWluO1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IHJNaW4pIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMFxyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiByTWF4KSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IGRhdGVVdGlscy5hZGRJbnRlcnZhbChyTWF4LCB0aGlzLl9vcHRpb25zLmludGVydmFsKSAtIHJNaW5cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnNpb25WYWx1ZSh0aGlzLl9jYWxjdWxhdGVQcm9qZWN0aW9uKG9mZnNldCAqIHRoaXMuX2NhbnZhc09wdGlvbnMucmF0aW9PZkNhbnZhc1JhbmdlKSlcclxuICAgIH0sXHJcbiAgICBmcm9tOiBmdW5jdGlvbihwb3NpdGlvbiwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG9yaWdJbnRlcnZhbCA9IHRoaXMuX29wdGlvbnMuaW50ZXJ2YWw7XHJcbiAgICAgICAgdmFyIGludGVydmFsID0gb3JpZ0ludGVydmFsO1xyXG4gICAgICAgIHZhciBjbyA9IHRoaXMuX2NhbnZhc09wdGlvbnM7XHJcbiAgICAgICAgdmFyIHJNaW4gPSBjby5yYW5nZU1pblZpc2libGU7XHJcbiAgICAgICAgdmFyIHJNYXggPSBjby5yYW5nZU1heFZpc2libGU7XHJcbiAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgIGlmIChcImRhdGV0aW1lXCIgPT09IHRoaXMuX2J1c2luZXNzUmFuZ2UuZGF0YVR5cGUpIHtcclxuICAgICAgICAgICAgaW50ZXJ2YWwgPSBkYXRlVXRpbHMuZGF0ZVRvTWlsbGlzZWNvbmRzKG9yaWdJbnRlcnZhbClcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9jYWxjdWxhdGVVblByb2plY3Rpb24oKHBvc2l0aW9uIC0gdGhpcy5fY2FudmFzT3B0aW9ucy5zdGFydFBvaW50KSAvIHRoaXMuX2NhbnZhc09wdGlvbnMucmF0aW9PZkNhbnZhc1JhbmdlKTtcclxuICAgICAgICB2YWx1ZSA9IHRoaXMuX2ludGVydmFsaXplKGRhdGVVdGlscy5hZGRJbnRlcnZhbCh2YWx1ZSwgaW50ZXJ2YWwgLyAyLCBkaXJlY3Rpb24gPiAwKSwgb3JpZ0ludGVydmFsKTtcclxuICAgICAgICBpZiAodmFsdWUgPCByTWluKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gck1pblxyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiByTWF4KSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gck1heFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWVcclxuICAgIH0sXHJcbiAgICBfYWRkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gTmFOXHJcbiAgICB9LFxyXG4gICAgaXNWYWx1ZVByb2xvbmdlZDogdHJ1ZVxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/translators/interval_translator.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/translators/logarithmic_translator.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/translators/logarithmic_translator.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/**\r\n * DevExtreme (esm/viz/translators/logarithmic_translator.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n    fromValue: function(value) {\r\n        return null !== value ? Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"getLogExt\"])(value, this._canvasOptions.base, this._businessRange.allowNegatives, this._businessRange.linearThreshold) : value\r\n    },\r\n    toValue: function(value) {\r\n        return null !== value ? Object(_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"raiseToExt\"])(value, this._canvasOptions.base, this._businessRange.allowNegatives, this._businessRange.linearThreshold) : value\r\n    },\r\n    getMinBarSize: function(minBarSize) {\r\n        var visibleArea = this.getCanvasVisibleArea();\r\n        var minValue = this.from(visibleArea.min + minBarSize);\r\n        var canvasOptions = this._canvasOptions;\r\n        return Math.pow(canvasOptions.base, canvasOptions.rangeMinVisible + this.fromValue(this.from(visibleArea.min)) - this.fromValue(!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(minValue) ? this.from(visibleArea.max) : minValue))\r\n    },\r\n    checkMinBarSize: function(initialValue, minShownValue, stackValue) {\r\n        var canvasOptions = this._canvasOptions;\r\n        var prevValue = stackValue - initialValue;\r\n        var baseMethod = this.constructor.prototype.checkMinBarSize;\r\n        var minBarSize;\r\n        var updateValue;\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_1__[\"isDefined\"])(minShownValue) && prevValue > 0) {\r\n            minBarSize = baseMethod(this.fromValue(stackValue / prevValue), this.fromValue(minShownValue) - canvasOptions.rangeMinVisible);\r\n            updateValue = Math.pow(canvasOptions.base, this.fromValue(prevValue) + minBarSize) - prevValue\r\n        } else {\r\n            updateValue = baseMethod(initialValue, minShownValue)\r\n        }\r\n        return updateValue\r\n    }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L3RyYW5zbGF0b3JzL2xvZ2FyaXRobWljX3RyYW5zbGF0b3IuanM/NTc3YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSXVCO0FBR1E7QUFDaEI7QUFDZjtBQUNBLGdDQUFnQyw2REFBTTtBQUN0QyxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0MsOERBQU87QUFDdkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUlBQXlJLGtFQUFTO0FBQ2xKLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtFQUFTO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L3RyYW5zbGF0b3JzL2xvZ2FyaXRobWljX3RyYW5zbGF0b3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogRGV2RXh0cmVtZSAoZXNtL3Zpei90cmFuc2xhdG9ycy9sb2dhcml0aG1pY190cmFuc2xhdG9yLmpzKVxyXG4gKiBWZXJzaW9uOiAyMS4yLjdcclxuICogQnVpbGQgZGF0ZTogTW9uIEFwciAxMSAyMDIyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiAtIDIwMjIgRGV2ZWxvcGVyIEV4cHJlc3MgSW5jLiBBTEwgUklHSFRTIFJFU0VSVkVEXHJcbiAqIFJlYWQgYWJvdXQgRGV2RXh0cmVtZSBsaWNlbnNpbmcgaGVyZTogaHR0cHM6Ly9qcy5kZXZleHByZXNzLmNvbS9MaWNlbnNpbmcvXHJcbiAqL1xyXG5pbXBvcnQge1xyXG4gICAgcmFpc2VUb0V4dCBhcyByYWlzZVRvLFxyXG4gICAgZ2V0TG9nRXh0IGFzIGdldExvZ1xyXG59IGZyb20gXCIuLi9jb3JlL3V0aWxzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBpc0RlZmluZWRcclxufSBmcm9tIFwiLi4vLi4vY29yZS91dGlscy90eXBlXCI7XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGZyb21WYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbCAhPT0gdmFsdWUgPyBnZXRMb2codmFsdWUsIHRoaXMuX2NhbnZhc09wdGlvbnMuYmFzZSwgdGhpcy5fYnVzaW5lc3NSYW5nZS5hbGxvd05lZ2F0aXZlcywgdGhpcy5fYnVzaW5lc3NSYW5nZS5saW5lYXJUaHJlc2hvbGQpIDogdmFsdWVcclxuICAgIH0sXHJcbiAgICB0b1ZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsICE9PSB2YWx1ZSA/IHJhaXNlVG8odmFsdWUsIHRoaXMuX2NhbnZhc09wdGlvbnMuYmFzZSwgdGhpcy5fYnVzaW5lc3NSYW5nZS5hbGxvd05lZ2F0aXZlcywgdGhpcy5fYnVzaW5lc3NSYW5nZS5saW5lYXJUaHJlc2hvbGQpIDogdmFsdWVcclxuICAgIH0sXHJcbiAgICBnZXRNaW5CYXJTaXplOiBmdW5jdGlvbihtaW5CYXJTaXplKSB7XHJcbiAgICAgICAgdmFyIHZpc2libGVBcmVhID0gdGhpcy5nZXRDYW52YXNWaXNpYmxlQXJlYSgpO1xyXG4gICAgICAgIHZhciBtaW5WYWx1ZSA9IHRoaXMuZnJvbSh2aXNpYmxlQXJlYS5taW4gKyBtaW5CYXJTaXplKTtcclxuICAgICAgICB2YXIgY2FudmFzT3B0aW9ucyA9IHRoaXMuX2NhbnZhc09wdGlvbnM7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KGNhbnZhc09wdGlvbnMuYmFzZSwgY2FudmFzT3B0aW9ucy5yYW5nZU1pblZpc2libGUgKyB0aGlzLmZyb21WYWx1ZSh0aGlzLmZyb20odmlzaWJsZUFyZWEubWluKSkgLSB0aGlzLmZyb21WYWx1ZSghaXNEZWZpbmVkKG1pblZhbHVlKSA/IHRoaXMuZnJvbSh2aXNpYmxlQXJlYS5tYXgpIDogbWluVmFsdWUpKVxyXG4gICAgfSxcclxuICAgIGNoZWNrTWluQmFyU2l6ZTogZnVuY3Rpb24oaW5pdGlhbFZhbHVlLCBtaW5TaG93blZhbHVlLCBzdGFja1ZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNhbnZhc09wdGlvbnMgPSB0aGlzLl9jYW52YXNPcHRpb25zO1xyXG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBzdGFja1ZhbHVlIC0gaW5pdGlhbFZhbHVlO1xyXG4gICAgICAgIHZhciBiYXNlTWV0aG9kID0gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2hlY2tNaW5CYXJTaXplO1xyXG4gICAgICAgIHZhciBtaW5CYXJTaXplO1xyXG4gICAgICAgIHZhciB1cGRhdGVWYWx1ZTtcclxuICAgICAgICBpZiAoaXNEZWZpbmVkKG1pblNob3duVmFsdWUpICYmIHByZXZWYWx1ZSA+IDApIHtcclxuICAgICAgICAgICAgbWluQmFyU2l6ZSA9IGJhc2VNZXRob2QodGhpcy5mcm9tVmFsdWUoc3RhY2tWYWx1ZSAvIHByZXZWYWx1ZSksIHRoaXMuZnJvbVZhbHVlKG1pblNob3duVmFsdWUpIC0gY2FudmFzT3B0aW9ucy5yYW5nZU1pblZpc2libGUpO1xyXG4gICAgICAgICAgICB1cGRhdGVWYWx1ZSA9IE1hdGgucG93KGNhbnZhc09wdGlvbnMuYmFzZSwgdGhpcy5mcm9tVmFsdWUocHJldlZhbHVlKSArIG1pbkJhclNpemUpIC0gcHJldlZhbHVlXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdXBkYXRlVmFsdWUgPSBiYXNlTWV0aG9kKGluaXRpYWxWYWx1ZSwgbWluU2hvd25WYWx1ZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVZhbHVlXHJcbiAgICB9XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/translators/logarithmic_translator.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/translators/translator2d.js":
/*!*********************************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/translators/translator2d.js ***!
  \*********************************************************************/
/*! exports provided: Translator2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Translator2D\", function() { return _Translator2d; });\n/* harmony import */ var _core_utils_extend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/utils/extend */ \"./node_modules/devextreme/esm/core/utils/extend.js\");\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./range */ \"./node_modules/devextreme/esm/viz/translators/range.js\");\n/* harmony import */ var _category_translator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./category_translator */ \"./node_modules/devextreme/esm/viz/translators/category_translator.js\");\n/* harmony import */ var _interval_translator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interval_translator */ \"./node_modules/devextreme/esm/viz/translators/interval_translator.js\");\n/* harmony import */ var _datetime_translator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./datetime_translator */ \"./node_modules/devextreme/esm/viz/translators/datetime_translator.js\");\n/* harmony import */ var _logarithmic_translator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./logarithmic_translator */ \"./node_modules/devextreme/esm/viz/translators/logarithmic_translator.js\");\n/* harmony import */ var _core_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/utils */ \"./node_modules/devextreme/esm/viz/core/utils.js\");\n/* harmony import */ var _core_utils_type__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/utils/type */ \"./node_modules/devextreme/esm/core/utils/type.js\");\n/* harmony import */ var _core_utils_math__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/utils/math */ \"./node_modules/devextreme/esm/core/utils/math.js\");\n/* harmony import */ var _core_utils_date__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/utils/date */ \"./node_modules/devextreme/esm/core/utils/date.js\");\n/**\r\n * DevExtreme (esm/viz/translators/translator2d.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar _abs = Math.abs;\r\nvar CANVAS_PROP = [\"width\", \"height\", \"left\", \"top\", \"bottom\", \"right\"];\r\nvar dummyTranslator = {\r\n    to(value) {\r\n        var coord = this._canvasOptions.startPoint + (this._options.conversionValue ? value : Math.round(value));\r\n        return coord > this._canvasOptions.endPoint ? this._canvasOptions.endPoint : coord\r\n    },\r\n    from(value) {\r\n        return value - this._canvasOptions.startPoint\r\n    }\r\n};\r\nvar validateCanvas = function(canvas) {\r\n    Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_1__[\"each\"])(CANVAS_PROP, (function(_, prop) {\r\n        canvas[prop] = parseInt(canvas[prop]) || 0\r\n    }));\r\n    return canvas\r\n};\r\nvar makeCategoriesToPoints = function(categories) {\r\n    var categoriesToPoints = {};\r\n    categories.forEach((function(item, i) {\r\n        categoriesToPoints[item.valueOf()] = i\r\n    }));\r\n    return categoriesToPoints\r\n};\r\nvar validateBusinessRange = function(businessRange) {\r\n    if (!(businessRange instanceof _range__WEBPACK_IMPORTED_MODULE_2__[\"Range\"])) {\r\n        businessRange = new _range__WEBPACK_IMPORTED_MODULE_2__[\"Range\"](businessRange)\r\n    }\r\n\r\n    function validate(valueSelector, baseValueSelector) {\r\n        if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(businessRange[valueSelector]) && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(businessRange[baseValueSelector])) {\r\n            businessRange[valueSelector] = businessRange[baseValueSelector]\r\n        }\r\n    }\r\n    validate(\"minVisible\", \"min\");\r\n    validate(\"maxVisible\", \"max\");\r\n    return businessRange\r\n};\r\n\r\nfunction prepareBreaks(breaks, range) {\r\n    var transform = \"logarithmic\" === range.axisType ? function(value) {\r\n        return Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__[\"getLogExt\"])(value, range.base)\r\n    } : function(value) {\r\n        return value\r\n    };\r\n    var array = [];\r\n    var br;\r\n    var transformFrom;\r\n    var transformTo;\r\n    var i;\r\n    var length = breaks.length;\r\n    var sum = 0;\r\n    for (i = 0; i < length; i++) {\r\n        br = breaks[i];\r\n        transformFrom = transform(br.from);\r\n        transformTo = transform(br.to);\r\n        sum += transformTo - transformFrom;\r\n        array.push({\r\n            trFrom: transformFrom,\r\n            trTo: transformTo,\r\n            from: br.from,\r\n            to: br.to,\r\n            length: sum,\r\n            cumulativeWidth: br.cumulativeWidth\r\n        })\r\n    }\r\n    return array\r\n}\r\n\r\nfunction getCanvasBounds(range) {\r\n    var min = range.min;\r\n    var max = range.max;\r\n    var minVisible = range.minVisible;\r\n    var maxVisible = range.maxVisible;\r\n    var isLogarithmic = \"logarithmic\" === range.axisType;\r\n    if (isLogarithmic) {\r\n        maxVisible = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__[\"getLogExt\"])(maxVisible, range.base, range.allowNegatives, range.linearThreshold);\r\n        minVisible = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__[\"getLogExt\"])(minVisible, range.base, range.allowNegatives, range.linearThreshold);\r\n        min = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__[\"getLogExt\"])(min, range.base, range.allowNegatives, range.linearThreshold);\r\n        max = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__[\"getLogExt\"])(max, range.base, range.allowNegatives, range.linearThreshold)\r\n    }\r\n    return {\r\n        base: range.base,\r\n        rangeMin: min,\r\n        rangeMax: max,\r\n        rangeMinVisible: minVisible,\r\n        rangeMaxVisible: maxVisible\r\n    }\r\n}\r\n\r\nfunction getCheckingMethodsAboutBreaks(inverted) {\r\n    return {\r\n        isStartSide: !inverted ? function(pos, breaks, start, end) {\r\n            return pos < breaks[0][start]\r\n        } : function(pos, breaks, start, end) {\r\n            return pos <= breaks[breaks.length - 1][end]\r\n        },\r\n        isEndSide: !inverted ? function(pos, breaks, start, end) {\r\n            return pos >= breaks[breaks.length - 1][end]\r\n        } : function(pos, breaks, start, end) {\r\n            return pos > breaks[0][start]\r\n        },\r\n        isInBreak: !inverted ? function(pos, br, start, end) {\r\n            return pos >= br[start] && pos < br[end]\r\n        } : function(pos, br, start, end) {\r\n            return pos > br[end] && pos <= br[start]\r\n        },\r\n        isBetweenBreaks: !inverted ? function(pos, br, prevBreak, start, end) {\r\n            return pos < br[start] && pos >= prevBreak[end]\r\n        } : function(pos, br, prevBreak, start, end) {\r\n            return pos >= br[end] && pos < prevBreak[start]\r\n        },\r\n        getLength: !inverted ? function(br) {\r\n            return br.length\r\n        } : function(br, lastBreak) {\r\n            return lastBreak.length - br.length\r\n        },\r\n        getBreaksSize: !inverted ? function(br) {\r\n            return br.cumulativeWidth\r\n        } : function(br, lastBreak) {\r\n            return lastBreak.cumulativeWidth - br.cumulativeWidth\r\n        }\r\n    }\r\n}\r\nvar _Translator2d = function(businessRange, canvas, options) {\r\n    this.update(businessRange, canvas, options)\r\n};\r\n_Translator2d.prototype = {\r\n    constructor: _Translator2d,\r\n    reinit: function() {\r\n        var that = this;\r\n        var options = that._options;\r\n        var range = that._businessRange;\r\n        var categories = range.categories || [];\r\n        var script = {};\r\n        var canvasOptions = that._prepareCanvasOptions();\r\n        var visibleCategories = Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__[\"getCategoriesInfo\"])(categories, range.minVisible, range.maxVisible).categories;\r\n        var categoriesLength = visibleCategories.length;\r\n        if (range.isEmpty()) {\r\n            script = dummyTranslator\r\n        } else {\r\n            switch (range.axisType) {\r\n                case \"logarithmic\":\r\n                    script = _logarithmic_translator__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\r\n                    break;\r\n                case \"semidiscrete\":\r\n                    script = _interval_translator__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\r\n                    canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (_core_utils_date__WEBPACK_IMPORTED_MODULE_10__[\"default\"].addInterval(canvasOptions.rangeMaxVisible, options.interval) - canvasOptions.rangeMinVisible);\r\n                    break;\r\n                case \"discrete\":\r\n                    script = _category_translator__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\r\n                    that._categories = categories;\r\n                    canvasOptions.interval = that._getDiscreteInterval(options.addSpiderCategory ? categoriesLength + 1 : categoriesLength, canvasOptions);\r\n                    that._categoriesToPoints = makeCategoriesToPoints(categories);\r\n                    if (categoriesLength) {\r\n                        canvasOptions.startPointIndex = that._categoriesToPoints[visibleCategories[0].valueOf()];\r\n                        that.visibleCategories = visibleCategories\r\n                    }\r\n                    break;\r\n                default:\r\n                    if (\"datetime\" === range.dataType) {\r\n                        script = _datetime_translator__WEBPACK_IMPORTED_MODULE_5__[\"default\"]\r\n                    }\r\n            }\r\n        }(that._oldMethods || []).forEach((function(methodName) {\r\n            delete that[methodName]\r\n        }));\r\n        that._oldMethods = Object.keys(script);\r\n        Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])(that, script);\r\n        that._conversionValue = options.conversionValue ? function(value) {\r\n            return value\r\n        } : function(value) {\r\n            return Math.round(value)\r\n        };\r\n        that.sc = {};\r\n        that._checkingMethodsAboutBreaks = [getCheckingMethodsAboutBreaks(false), getCheckingMethodsAboutBreaks(that.isInverted())];\r\n        that._translateBreaks();\r\n        that._calculateSpecialValues()\r\n    },\r\n    _translateBreaks: function() {\r\n        var breaks = this._breaks;\r\n        var size = this._options.breaksSize;\r\n        var i;\r\n        var b;\r\n        var end;\r\n        var length;\r\n        if (void 0 === breaks) {\r\n            return\r\n        }\r\n        for (i = 0, length = breaks.length; i < length; i++) {\r\n            b = breaks[i];\r\n            end = this.translate(b.to);\r\n            b.end = end;\r\n            b.start = !b.gapSize ? !this.isInverted() ? end - size : end + size : end\r\n        }\r\n    },\r\n    _checkValueAboutBreaks: function(breaks, pos, start, end, methods) {\r\n        var i;\r\n        var length;\r\n        var prop = {\r\n            length: 0,\r\n            breaksSize: void 0,\r\n            inBreak: false\r\n        };\r\n        var br;\r\n        var prevBreak;\r\n        var lastBreak = breaks[breaks.length - 1];\r\n        if (methods.isStartSide(pos, breaks, start, end)) {\r\n            return prop\r\n        } else if (methods.isEndSide(pos, breaks, start, end)) {\r\n            return {\r\n                length: lastBreak.length,\r\n                breaksSize: lastBreak.cumulativeWidth,\r\n                inBreak: false\r\n            }\r\n        }\r\n        for (i = 0, length = breaks.length; i < length; i++) {\r\n            br = breaks[i];\r\n            prevBreak = breaks[i - 1];\r\n            if (methods.isInBreak(pos, br, start, end)) {\r\n                prop.inBreak = true;\r\n                prop.break = br;\r\n                break\r\n            }\r\n            if (prevBreak && methods.isBetweenBreaks(pos, br, prevBreak, start, end)) {\r\n                prop = {\r\n                    length: methods.getLength(prevBreak, lastBreak),\r\n                    breaksSize: methods.getBreaksSize(prevBreak, lastBreak),\r\n                    inBreak: false\r\n                };\r\n                break\r\n            }\r\n        }\r\n        return prop\r\n    },\r\n    isInverted: function() {\r\n        return !(this._options.isHorizontal ^ this._businessRange.invert)\r\n    },\r\n    _getDiscreteInterval: function(categoriesLength, canvasOptions) {\r\n        var correctedCategoriesCount = categoriesLength - (this._options.stick ? 1 : 0);\r\n        return correctedCategoriesCount > 0 ? canvasOptions.canvasLength / correctedCategoriesCount : canvasOptions.canvasLength\r\n    },\r\n    _prepareCanvasOptions() {\r\n        var businessRange = this._businessRange;\r\n        var canvasOptions = this._canvasOptions = getCanvasBounds(businessRange);\r\n        var canvas = this._canvas;\r\n        var breaks = this._breaks;\r\n        var length;\r\n        canvasOptions.startPadding = canvas.startPadding || 0;\r\n        canvasOptions.endPadding = canvas.endPadding || 0;\r\n        if (this._options.isHorizontal) {\r\n            canvasOptions.startPoint = canvas.left + canvasOptions.startPadding;\r\n            length = canvas.width;\r\n            canvasOptions.endPoint = canvas.width - canvas.right - canvasOptions.endPadding;\r\n            canvasOptions.invert = businessRange.invert\r\n        } else {\r\n            canvasOptions.startPoint = canvas.top + canvasOptions.startPadding;\r\n            length = canvas.height;\r\n            canvasOptions.endPoint = canvas.height - canvas.bottom - canvasOptions.endPadding;\r\n            canvasOptions.invert = !businessRange.invert\r\n        }\r\n        this.canvasLength = canvasOptions.canvasLength = canvasOptions.endPoint - canvasOptions.startPoint;\r\n        canvasOptions.rangeDoubleError = Math.pow(10, Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__[\"getPower\"])(canvasOptions.rangeMax - canvasOptions.rangeMin) - Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__[\"getPower\"])(length) - 2);\r\n        canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible);\r\n        if (void 0 !== breaks) {\r\n            canvasOptions.ratioOfCanvasRange = (canvasOptions.canvasLength - breaks[breaks.length - 1].cumulativeWidth) / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible - breaks[breaks.length - 1].length)\r\n        }\r\n        return canvasOptions\r\n    },\r\n    updateCanvas: function(canvas) {\r\n        this._canvas = validateCanvas(canvas);\r\n        this.reinit()\r\n    },\r\n    updateBusinessRange: function(businessRange) {\r\n        var breaks = businessRange.breaks || [];\r\n        this._userBreaks = businessRange.userBreaks || [];\r\n        this._businessRange = validateBusinessRange(businessRange);\r\n        this._breaks = breaks.length ? prepareBreaks(breaks, this._businessRange) : void 0;\r\n        this.reinit()\r\n    },\r\n    update: function(businessRange, canvas, options) {\r\n        this._options = Object(_core_utils_extend__WEBPACK_IMPORTED_MODULE_0__[\"extend\"])(this._options || {}, options);\r\n        this._canvas = validateCanvas(canvas);\r\n        this.updateBusinessRange(businessRange)\r\n    },\r\n    getBusinessRange: function() {\r\n        return this._businessRange\r\n    },\r\n    getEventScale: function(zoomEvent) {\r\n        return zoomEvent.deltaScale || 1\r\n    },\r\n    getCanvasVisibleArea: function() {\r\n        return {\r\n            min: this._canvasOptions.startPoint,\r\n            max: this._canvasOptions.endPoint\r\n        }\r\n    },\r\n    _calculateSpecialValues: function() {\r\n        var canvasOptions = this._canvasOptions;\r\n        var startPoint = canvasOptions.startPoint - canvasOptions.startPadding;\r\n        var endPoint = canvasOptions.endPoint + canvasOptions.endPadding;\r\n        var range = this._businessRange;\r\n        var minVisible = range.minVisible;\r\n        var maxVisible = range.maxVisible;\r\n        var canvas_position_center_middle = startPoint + canvasOptions.canvasLength / 2;\r\n        var canvas_position_default;\r\n        if (minVisible < 0 && maxVisible > 0 && minVisible !== maxVisible) {\r\n            canvas_position_default = this.translate(0, 1)\r\n        }\r\n        if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(canvas_position_default)) {\r\n            var invert = range.invert ^ (minVisible < 0 && maxVisible <= 0);\r\n            if (this._options.isHorizontal) {\r\n                canvas_position_default = invert ? endPoint : startPoint\r\n            } else {\r\n                canvas_position_default = invert ? startPoint : endPoint\r\n            }\r\n        }\r\n        this.sc = {\r\n            canvas_position_default: canvas_position_default,\r\n            canvas_position_left: startPoint,\r\n            canvas_position_top: startPoint,\r\n            canvas_position_center: canvas_position_center_middle,\r\n            canvas_position_middle: canvas_position_center_middle,\r\n            canvas_position_right: endPoint,\r\n            canvas_position_bottom: endPoint,\r\n            canvas_position_start: canvasOptions.invert ? endPoint : startPoint,\r\n            canvas_position_end: canvasOptions.invert ? startPoint : endPoint\r\n        }\r\n    },\r\n    translateSpecialCase(value) {\r\n        return this.sc[value]\r\n    },\r\n    _calculateProjection: function(distance) {\r\n        var canvasOptions = this._canvasOptions;\r\n        return canvasOptions.invert ? canvasOptions.endPoint - distance : canvasOptions.startPoint + distance\r\n    },\r\n    _calculateUnProjection: function(distance) {\r\n        var canvasOptions = this._canvasOptions;\r\n        \"datetime\" === this._businessRange.dataType && (distance = Math.round(distance));\r\n        return canvasOptions.invert ? canvasOptions.rangeMaxVisible.valueOf() - distance : canvasOptions.rangeMinVisible.valueOf() + distance\r\n    },\r\n    getMinBarSize: function(minBarSize) {\r\n        var visibleArea = this.getCanvasVisibleArea();\r\n        var minValue = this.from(visibleArea.min + minBarSize);\r\n        return _abs(this.from(visibleArea.min) - (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(minValue) ? this.from(visibleArea.max) : minValue))\r\n    },\r\n    checkMinBarSize: function(value, minShownValue, stackValue) {\r\n        return _abs(value) < minShownValue ? value >= 0 ? minShownValue : -minShownValue : value\r\n    },\r\n    translate(bp, direction) {\r\n        var specialValue = this.translateSpecialCase(bp);\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(specialValue)) {\r\n            return Math.round(specialValue)\r\n        }\r\n        if (isNaN(bp)) {\r\n            return null\r\n        }\r\n        return this.to(bp, direction)\r\n    },\r\n    getInterval: function(interval) {\r\n        var _interval;\r\n        var canvasOptions = this._canvasOptions;\r\n        interval = null !== (_interval = interval) && void 0 !== _interval ? _interval : this._businessRange.interval;\r\n        if (interval) {\r\n            return Math.round(canvasOptions.ratioOfCanvasRange * interval)\r\n        }\r\n        return Math.round(canvasOptions.endPoint - canvasOptions.startPoint)\r\n    },\r\n    zoom(translate, scale, wholeRange) {\r\n        var canvasOptions = this._canvasOptions;\r\n        if (canvasOptions.rangeMinVisible.valueOf() === canvasOptions.rangeMaxVisible.valueOf() && 0 !== translate) {\r\n            return this.zoomZeroLengthRange(translate, scale)\r\n        }\r\n        var startPoint = canvasOptions.startPoint;\r\n        var endPoint = canvasOptions.endPoint;\r\n        var isInverted = this.isInverted();\r\n        var newStart = (startPoint + translate) / scale;\r\n        var newEnd = (endPoint + translate) / scale;\r\n        wholeRange = wholeRange || {};\r\n        var minPoint = this.to(isInverted ? wholeRange.endValue : wholeRange.startValue);\r\n        var maxPoint = this.to(isInverted ? wholeRange.startValue : wholeRange.endValue);\r\n        var min;\r\n        var max;\r\n        if (minPoint > newStart) {\r\n            newEnd -= newStart - minPoint;\r\n            newStart = minPoint;\r\n            min = isInverted ? wholeRange.endValue : wholeRange.startValue\r\n        }\r\n        if (maxPoint < newEnd) {\r\n            newStart -= newEnd - maxPoint;\r\n            newEnd = maxPoint;\r\n            max = isInverted ? wholeRange.startValue : wholeRange.endValue\r\n        }\r\n        if (maxPoint - minPoint < newEnd - newStart) {\r\n            newStart = minPoint;\r\n            newEnd = maxPoint\r\n        }\r\n        translate = (endPoint - startPoint) * newStart / (newEnd - newStart) - startPoint;\r\n        scale = (startPoint + translate) / newStart || 1;\r\n        min = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(min) ? min : Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_9__[\"adjust\"])(this.from(newStart, 1));\r\n        max = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(max) ? max : Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_9__[\"adjust\"])(this.from(newEnd, -1));\r\n        if (scale <= 1) {\r\n            min = this._correctValueAboutBreaks(min, 1 === scale ? translate : -1);\r\n            max = this._correctValueAboutBreaks(max, 1 === scale ? translate : 1)\r\n        }\r\n        if (min > max) {\r\n            min = min > wholeRange.endValue ? wholeRange.endValue : min;\r\n            max = max < wholeRange.startValue ? wholeRange.startValue : max\r\n        } else {\r\n            min = min < wholeRange.startValue ? wholeRange.startValue : min;\r\n            max = max > wholeRange.endValue ? wholeRange.endValue : max\r\n        }\r\n        return {\r\n            min: min,\r\n            max: max,\r\n            translate: Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_9__[\"adjust\"])(translate),\r\n            scale: Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_9__[\"adjust\"])(scale)\r\n        }\r\n    },\r\n    _correctValueAboutBreaks(value, direction) {\r\n        var br = this._userBreaks.filter(br => value >= br.from && value <= br.to);\r\n        if (br.length) {\r\n            return direction > 0 ? br[0].to : br[0].from\r\n        } else {\r\n            return value\r\n        }\r\n    },\r\n    zoomZeroLengthRange(translate, scale) {\r\n        var canvasOptions = this._canvasOptions;\r\n        var min = canvasOptions.rangeMin;\r\n        var max = canvasOptions.rangeMax;\r\n        var correction = (max.valueOf() !== min.valueOf() ? max.valueOf() - min.valueOf() : _abs(canvasOptions.rangeMinVisible.valueOf() - min.valueOf())) / canvasOptions.canvasLength;\r\n        var isDateTime = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDate\"])(max) || Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDate\"])(min);\r\n        var isLogarithmic = \"logarithmic\" === this._businessRange.axisType;\r\n        var newMin = canvasOptions.rangeMinVisible.valueOf() - correction;\r\n        var newMax = canvasOptions.rangeMaxVisible.valueOf() + correction;\r\n        newMin = isLogarithmic ? Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_9__[\"adjust\"])(Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__[\"raiseToExt\"])(newMin, canvasOptions.base)) : isDateTime ? new Date(newMin) : newMin;\r\n        newMax = isLogarithmic ? Object(_core_utils_math__WEBPACK_IMPORTED_MODULE_9__[\"adjust\"])(Object(_core_utils__WEBPACK_IMPORTED_MODULE_7__[\"raiseToExt\"])(newMax, canvasOptions.base)) : isDateTime ? new Date(newMax) : newMax;\r\n        return {\r\n            min: newMin,\r\n            max: newMax,\r\n            translate: translate,\r\n            scale: scale\r\n        }\r\n    },\r\n    getMinScale: function(zoom) {\r\n        var {\r\n            dataType: dataType,\r\n            interval: interval\r\n        } = this._businessRange;\r\n        if (\"datetime\" === dataType && 1 === interval) {\r\n            return this.getDateTimeMinScale(zoom)\r\n        }\r\n        return zoom ? 1.1 : .9\r\n    },\r\n    getDateTimeMinScale(zoom) {\r\n        var canvasOptions = this._canvasOptions;\r\n        var length = canvasOptions.canvasLength / canvasOptions.ratioOfCanvasRange;\r\n        length += (parseInt(.1 * length) || 1) * (zoom ? -2 : 2);\r\n        return canvasOptions.canvasLength / (Math.max(length, 1) * canvasOptions.ratioOfCanvasRange)\r\n    },\r\n    getScale: function(val1, val2) {\r\n        var canvasOptions = this._canvasOptions;\r\n        if (canvasOptions.rangeMax === canvasOptions.rangeMin) {\r\n            return 1\r\n        }\r\n        val1 = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(val1) ? this.fromValue(val1) : canvasOptions.rangeMin;\r\n        val2 = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(val2) ? this.fromValue(val2) : canvasOptions.rangeMax;\r\n        return (canvasOptions.rangeMax - canvasOptions.rangeMin) / Math.abs(val1 - val2)\r\n    },\r\n    isValid: function(value) {\r\n        var co = this._canvasOptions;\r\n        value = this.fromValue(value);\r\n        return null !== value && !isNaN(value) && value.valueOf() + co.rangeDoubleError >= co.rangeMin && value.valueOf() - co.rangeDoubleError <= co.rangeMax\r\n    },\r\n    getCorrectValue: function(value, direction) {\r\n        var breaks = this._breaks;\r\n        var prop;\r\n        value = this.fromValue(value);\r\n        if (this._breaks) {\r\n            prop = this._checkValueAboutBreaks(breaks, value, \"trFrom\", \"trTo\", this._checkingMethodsAboutBreaks[0]);\r\n            if (true === prop.inBreak) {\r\n                return this.toValue(direction > 0 ? prop.break.trTo : prop.break.trFrom)\r\n            }\r\n        }\r\n        return this.toValue(value)\r\n    },\r\n    to: function(bp, direction) {\r\n        var range = this.getBusinessRange();\r\n        if (Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(range.maxVisible) && Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(range.minVisible) && range.maxVisible.valueOf() === range.minVisible.valueOf()) {\r\n            if (!Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(bp) || range.maxVisible.valueOf() !== bp.valueOf()) {\r\n                return null\r\n            }\r\n            return this.translateSpecialCase(0 === bp && this._options.shiftZeroValue ? \"canvas_position_default\" : \"canvas_position_middle\")\r\n        }\r\n        bp = this.fromValue(bp);\r\n        var canvasOptions = this._canvasOptions;\r\n        var breaks = this._breaks;\r\n        var prop = {\r\n            length: 0\r\n        };\r\n        var commonBreakSize = 0;\r\n        if (void 0 !== breaks) {\r\n            prop = this._checkValueAboutBreaks(breaks, bp, \"trFrom\", \"trTo\", this._checkingMethodsAboutBreaks[0]);\r\n            commonBreakSize = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(prop.breaksSize) ? prop.breaksSize : 0\r\n        }\r\n        if (true === prop.inBreak) {\r\n            if (direction > 0) {\r\n                return prop.break.start\r\n            } else if (direction < 0) {\r\n                return prop.break.end\r\n            } else {\r\n                return null\r\n            }\r\n        }\r\n        return this._conversionValue(this._calculateProjection((bp - canvasOptions.rangeMinVisible - prop.length) * canvasOptions.ratioOfCanvasRange + commonBreakSize))\r\n    },\r\n    from: function(pos, direction) {\r\n        var breaks = this._breaks;\r\n        var prop = {\r\n            length: 0\r\n        };\r\n        var canvasOptions = this._canvasOptions;\r\n        var startPoint = canvasOptions.startPoint;\r\n        var commonBreakSize = 0;\r\n        if (void 0 !== breaks) {\r\n            prop = this._checkValueAboutBreaks(breaks, pos, \"start\", \"end\", this._checkingMethodsAboutBreaks[1]);\r\n            commonBreakSize = Object(_core_utils_type__WEBPACK_IMPORTED_MODULE_8__[\"isDefined\"])(prop.breaksSize) ? prop.breaksSize : 0\r\n        }\r\n        if (true === prop.inBreak) {\r\n            if (direction > 0) {\r\n                return this.toValue(prop.break.trTo)\r\n            } else if (direction < 0) {\r\n                return this.toValue(prop.break.trFrom)\r\n            } else {\r\n                return null\r\n            }\r\n        }\r\n        return this.toValue(this._calculateUnProjection((pos - startPoint - commonBreakSize) / canvasOptions.ratioOfCanvasRange + prop.length))\r\n    },\r\n    isValueProlonged: false,\r\n    getRange: function() {\r\n        return [this.toValue(this._canvasOptions.rangeMin), this.toValue(this._canvasOptions.rangeMax)]\r\n    },\r\n    getScreenRange: function() {\r\n        return [this._canvasOptions.startPoint, this._canvasOptions.endPoint]\r\n    },\r\n    add: function(value, diff, dir) {\r\n        return this._add(value, diff, (this._businessRange.invert ? -1 : 1) * dir)\r\n    },\r\n    _add: function(value, diff, coeff) {\r\n        return this.toValue(this.fromValue(value) + diff * coeff)\r\n    },\r\n    fromValue: function(value) {\r\n        return null !== value ? Number(value) : null\r\n    },\r\n    toValue: function(value) {\r\n        return null !== value ? Number(value) : null\r\n    },\r\n    ratioOfCanvasRange() {\r\n        return this._canvasOptions.ratioOfCanvasRange\r\n    },\r\n    convert: value => value,\r\n    getRangeByMinZoomValue(minZoom, visualRange) {\r\n        if (visualRange.minVisible + minZoom <= this._businessRange.max) {\r\n            return [visualRange.minVisible, visualRange.minVisible + minZoom]\r\n        } else {\r\n            return [visualRange.maxVisible - minZoom, visualRange.maxVisible]\r\n        }\r\n    }\r\n};\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L3RyYW5zbGF0b3JzL3RyYW5zbGF0b3IyZC5qcz8yNmM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdpQztBQUdFO0FBR2xCO0FBQ3NDO0FBQ0E7QUFDQTtBQUNNO0FBTXRDO0FBSVE7QUFHQTtBQUNlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRUFBSTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNENBQUs7QUFDeEMsNEJBQTRCLDRDQUFLO0FBQ2pDOztBQUVBO0FBQ0EsYUFBYSxrRUFBUyxrQ0FBa0Msa0VBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsNkRBQU07QUFDckIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2REFBTTtBQUMzQixxQkFBcUIsNkRBQU07QUFDM0IsY0FBYyw2REFBTTtBQUNwQixjQUFjLDZEQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0VBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0VBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L3RyYW5zbGF0b3JzL3RyYW5zbGF0b3IyZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZXZFeHRyZW1lIChlc20vdml6L3RyYW5zbGF0b3JzL3RyYW5zbGF0b3IyZC5qcylcclxuICogVmVyc2lvbjogMjEuMi43XHJcbiAqIEJ1aWxkIGRhdGU6IE1vbiBBcHIgMTEgMjAyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgLSAyMDIyIERldmVsb3BlciBFeHByZXNzIEluYy4gQUxMIFJJR0hUUyBSRVNFUlZFRFxyXG4gKiBSZWFkIGFib3V0IERldkV4dHJlbWUgbGljZW5zaW5nIGhlcmU6IGh0dHBzOi8vanMuZGV2ZXhwcmVzcy5jb20vTGljZW5zaW5nL1xyXG4gKi9cclxuaW1wb3J0IHtcclxuICAgIGV4dGVuZFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2V4dGVuZFwiO1xyXG5pbXBvcnQge1xyXG4gICAgZWFjaFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL2l0ZXJhdG9yXCI7XHJcbmltcG9ydCB7XHJcbiAgICBSYW5nZVxyXG59IGZyb20gXCIuL3JhbmdlXCI7XHJcbmltcG9ydCBjYXRlZ29yeVRyYW5zbGF0b3IgZnJvbSBcIi4vY2F0ZWdvcnlfdHJhbnNsYXRvclwiO1xyXG5pbXBvcnQgaW50ZXJ2YWxUcmFuc2xhdG9yIGZyb20gXCIuL2ludGVydmFsX3RyYW5zbGF0b3JcIjtcclxuaW1wb3J0IGRhdGV0aW1lVHJhbnNsYXRvciBmcm9tIFwiLi9kYXRldGltZV90cmFuc2xhdG9yXCI7XHJcbmltcG9ydCBsb2dhcml0aG1pY1RyYW5zbGF0b3IgZnJvbSBcIi4vbG9nYXJpdGhtaWNfdHJhbnNsYXRvclwiO1xyXG5pbXBvcnQge1xyXG4gICAgZ2V0TG9nRXh0IGFzIGdldExvZyxcclxuICAgIGdldFBvd2VyLFxyXG4gICAgcmFpc2VUb0V4dCxcclxuICAgIGdldENhdGVnb3JpZXNJbmZvXHJcbn0gZnJvbSBcIi4uL2NvcmUvdXRpbHNcIjtcclxuaW1wb3J0IHtcclxuICAgIGlzRGVmaW5lZCxcclxuICAgIGlzRGF0ZVxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL3R5cGVcIjtcclxuaW1wb3J0IHtcclxuICAgIGFkanVzdFxyXG59IGZyb20gXCIuLi8uLi9jb3JlL3V0aWxzL21hdGhcIjtcclxuaW1wb3J0IGRhdGVVdGlscyBmcm9tIFwiLi4vLi4vY29yZS91dGlscy9kYXRlXCI7XHJcbnZhciBfYWJzID0gTWF0aC5hYnM7XHJcbnZhciBDQU5WQVNfUFJPUCA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwibGVmdFwiLCBcInRvcFwiLCBcImJvdHRvbVwiLCBcInJpZ2h0XCJdO1xyXG52YXIgZHVtbXlUcmFuc2xhdG9yID0ge1xyXG4gICAgdG8odmFsdWUpIHtcclxuICAgICAgICB2YXIgY29vcmQgPSB0aGlzLl9jYW52YXNPcHRpb25zLnN0YXJ0UG9pbnQgKyAodGhpcy5fb3B0aW9ucy5jb252ZXJzaW9uVmFsdWUgPyB2YWx1ZSA6IE1hdGgucm91bmQodmFsdWUpKTtcclxuICAgICAgICByZXR1cm4gY29vcmQgPiB0aGlzLl9jYW52YXNPcHRpb25zLmVuZFBvaW50ID8gdGhpcy5fY2FudmFzT3B0aW9ucy5lbmRQb2ludCA6IGNvb3JkXHJcbiAgICB9LFxyXG4gICAgZnJvbSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSAtIHRoaXMuX2NhbnZhc09wdGlvbnMuc3RhcnRQb2ludFxyXG4gICAgfVxyXG59O1xyXG52YXIgdmFsaWRhdGVDYW52YXMgPSBmdW5jdGlvbihjYW52YXMpIHtcclxuICAgIGVhY2goQ0FOVkFTX1BST1AsIChmdW5jdGlvbihfLCBwcm9wKSB7XHJcbiAgICAgICAgY2FudmFzW3Byb3BdID0gcGFyc2VJbnQoY2FudmFzW3Byb3BdKSB8fCAwXHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gY2FudmFzXHJcbn07XHJcbnZhciBtYWtlQ2F0ZWdvcmllc1RvUG9pbnRzID0gZnVuY3Rpb24oY2F0ZWdvcmllcykge1xyXG4gICAgdmFyIGNhdGVnb3JpZXNUb1BvaW50cyA9IHt9O1xyXG4gICAgY2F0ZWdvcmllcy5mb3JFYWNoKChmdW5jdGlvbihpdGVtLCBpKSB7XHJcbiAgICAgICAgY2F0ZWdvcmllc1RvUG9pbnRzW2l0ZW0udmFsdWVPZigpXSA9IGlcclxuICAgIH0pKTtcclxuICAgIHJldHVybiBjYXRlZ29yaWVzVG9Qb2ludHNcclxufTtcclxudmFyIHZhbGlkYXRlQnVzaW5lc3NSYW5nZSA9IGZ1bmN0aW9uKGJ1c2luZXNzUmFuZ2UpIHtcclxuICAgIGlmICghKGJ1c2luZXNzUmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcclxuICAgICAgICBidXNpbmVzc1JhbmdlID0gbmV3IFJhbmdlKGJ1c2luZXNzUmFuZ2UpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWVTZWxlY3RvciwgYmFzZVZhbHVlU2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoIWlzRGVmaW5lZChidXNpbmVzc1JhbmdlW3ZhbHVlU2VsZWN0b3JdKSAmJiBpc0RlZmluZWQoYnVzaW5lc3NSYW5nZVtiYXNlVmFsdWVTZWxlY3Rvcl0pKSB7XHJcbiAgICAgICAgICAgIGJ1c2luZXNzUmFuZ2VbdmFsdWVTZWxlY3Rvcl0gPSBidXNpbmVzc1JhbmdlW2Jhc2VWYWx1ZVNlbGVjdG9yXVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhbGlkYXRlKFwibWluVmlzaWJsZVwiLCBcIm1pblwiKTtcclxuICAgIHZhbGlkYXRlKFwibWF4VmlzaWJsZVwiLCBcIm1heFwiKTtcclxuICAgIHJldHVybiBidXNpbmVzc1JhbmdlXHJcbn07XHJcblxyXG5mdW5jdGlvbiBwcmVwYXJlQnJlYWtzKGJyZWFrcywgcmFuZ2UpIHtcclxuICAgIHZhciB0cmFuc2Zvcm0gPSBcImxvZ2FyaXRobWljXCIgPT09IHJhbmdlLmF4aXNUeXBlID8gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TG9nKHZhbHVlLCByYW5nZS5iYXNlKVxyXG4gICAgfSA6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICB9O1xyXG4gICAgdmFyIGFycmF5ID0gW107XHJcbiAgICB2YXIgYnI7XHJcbiAgICB2YXIgdHJhbnNmb3JtRnJvbTtcclxuICAgIHZhciB0cmFuc2Zvcm1UbztcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxlbmd0aCA9IGJyZWFrcy5sZW5ndGg7XHJcbiAgICB2YXIgc3VtID0gMDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGJyID0gYnJlYWtzW2ldO1xyXG4gICAgICAgIHRyYW5zZm9ybUZyb20gPSB0cmFuc2Zvcm0oYnIuZnJvbSk7XHJcbiAgICAgICAgdHJhbnNmb3JtVG8gPSB0cmFuc2Zvcm0oYnIudG8pO1xyXG4gICAgICAgIHN1bSArPSB0cmFuc2Zvcm1UbyAtIHRyYW5zZm9ybUZyb207XHJcbiAgICAgICAgYXJyYXkucHVzaCh7XHJcbiAgICAgICAgICAgIHRyRnJvbTogdHJhbnNmb3JtRnJvbSxcclxuICAgICAgICAgICAgdHJUbzogdHJhbnNmb3JtVG8sXHJcbiAgICAgICAgICAgIGZyb206IGJyLmZyb20sXHJcbiAgICAgICAgICAgIHRvOiBici50byxcclxuICAgICAgICAgICAgbGVuZ3RoOiBzdW0sXHJcbiAgICAgICAgICAgIGN1bXVsYXRpdmVXaWR0aDogYnIuY3VtdWxhdGl2ZVdpZHRoXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDYW52YXNCb3VuZHMocmFuZ2UpIHtcclxuICAgIHZhciBtaW4gPSByYW5nZS5taW47XHJcbiAgICB2YXIgbWF4ID0gcmFuZ2UubWF4O1xyXG4gICAgdmFyIG1pblZpc2libGUgPSByYW5nZS5taW5WaXNpYmxlO1xyXG4gICAgdmFyIG1heFZpc2libGUgPSByYW5nZS5tYXhWaXNpYmxlO1xyXG4gICAgdmFyIGlzTG9nYXJpdGhtaWMgPSBcImxvZ2FyaXRobWljXCIgPT09IHJhbmdlLmF4aXNUeXBlO1xyXG4gICAgaWYgKGlzTG9nYXJpdGhtaWMpIHtcclxuICAgICAgICBtYXhWaXNpYmxlID0gZ2V0TG9nKG1heFZpc2libGUsIHJhbmdlLmJhc2UsIHJhbmdlLmFsbG93TmVnYXRpdmVzLCByYW5nZS5saW5lYXJUaHJlc2hvbGQpO1xyXG4gICAgICAgIG1pblZpc2libGUgPSBnZXRMb2cobWluVmlzaWJsZSwgcmFuZ2UuYmFzZSwgcmFuZ2UuYWxsb3dOZWdhdGl2ZXMsIHJhbmdlLmxpbmVhclRocmVzaG9sZCk7XHJcbiAgICAgICAgbWluID0gZ2V0TG9nKG1pbiwgcmFuZ2UuYmFzZSwgcmFuZ2UuYWxsb3dOZWdhdGl2ZXMsIHJhbmdlLmxpbmVhclRocmVzaG9sZCk7XHJcbiAgICAgICAgbWF4ID0gZ2V0TG9nKG1heCwgcmFuZ2UuYmFzZSwgcmFuZ2UuYWxsb3dOZWdhdGl2ZXMsIHJhbmdlLmxpbmVhclRocmVzaG9sZClcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYmFzZTogcmFuZ2UuYmFzZSxcclxuICAgICAgICByYW5nZU1pbjogbWluLFxyXG4gICAgICAgIHJhbmdlTWF4OiBtYXgsXHJcbiAgICAgICAgcmFuZ2VNaW5WaXNpYmxlOiBtaW5WaXNpYmxlLFxyXG4gICAgICAgIHJhbmdlTWF4VmlzaWJsZTogbWF4VmlzaWJsZVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDaGVja2luZ01ldGhvZHNBYm91dEJyZWFrcyhpbnZlcnRlZCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc1N0YXJ0U2lkZTogIWludmVydGVkID8gZnVuY3Rpb24ocG9zLCBicmVha3MsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvcyA8IGJyZWFrc1swXVtzdGFydF1cclxuICAgICAgICB9IDogZnVuY3Rpb24ocG9zLCBicmVha3MsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvcyA8PSBicmVha3NbYnJlYWtzLmxlbmd0aCAtIDFdW2VuZF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzRW5kU2lkZTogIWludmVydGVkID8gZnVuY3Rpb24ocG9zLCBicmVha3MsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvcyA+PSBicmVha3NbYnJlYWtzLmxlbmd0aCAtIDFdW2VuZF1cclxuICAgICAgICB9IDogZnVuY3Rpb24ocG9zLCBicmVha3MsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvcyA+IGJyZWFrc1swXVtzdGFydF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzSW5CcmVhazogIWludmVydGVkID8gZnVuY3Rpb24ocG9zLCBiciwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcG9zID49IGJyW3N0YXJ0XSAmJiBwb3MgPCBicltlbmRdXHJcbiAgICAgICAgfSA6IGZ1bmN0aW9uKHBvcywgYnIsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvcyA+IGJyW2VuZF0gJiYgcG9zIDw9IGJyW3N0YXJ0XVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNCZXR3ZWVuQnJlYWtzOiAhaW52ZXJ0ZWQgPyBmdW5jdGlvbihwb3MsIGJyLCBwcmV2QnJlYWssIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvcyA8IGJyW3N0YXJ0XSAmJiBwb3MgPj0gcHJldkJyZWFrW2VuZF1cclxuICAgICAgICB9IDogZnVuY3Rpb24ocG9zLCBiciwgcHJldkJyZWFrLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3MgPj0gYnJbZW5kXSAmJiBwb3MgPCBwcmV2QnJlYWtbc3RhcnRdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRMZW5ndGg6ICFpbnZlcnRlZCA/IGZ1bmN0aW9uKGJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBici5sZW5ndGhcclxuICAgICAgICB9IDogZnVuY3Rpb24oYnIsIGxhc3RCcmVhaykge1xyXG4gICAgICAgICAgICByZXR1cm4gbGFzdEJyZWFrLmxlbmd0aCAtIGJyLmxlbmd0aFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0QnJlYWtzU2l6ZTogIWludmVydGVkID8gZnVuY3Rpb24oYnIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJyLmN1bXVsYXRpdmVXaWR0aFxyXG4gICAgICAgIH0gOiBmdW5jdGlvbihiciwgbGFzdEJyZWFrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYXN0QnJlYWsuY3VtdWxhdGl2ZVdpZHRoIC0gYnIuY3VtdWxhdGl2ZVdpZHRoXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbnZhciBfVHJhbnNsYXRvcjJkID0gZnVuY3Rpb24oYnVzaW5lc3NSYW5nZSwgY2FudmFzLCBvcHRpb25zKSB7XHJcbiAgICB0aGlzLnVwZGF0ZShidXNpbmVzc1JhbmdlLCBjYW52YXMsIG9wdGlvbnMpXHJcbn07XHJcbl9UcmFuc2xhdG9yMmQucHJvdG90eXBlID0ge1xyXG4gICAgY29uc3RydWN0b3I6IF9UcmFuc2xhdG9yMmQsXHJcbiAgICByZWluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoYXQuX29wdGlvbnM7XHJcbiAgICAgICAgdmFyIHJhbmdlID0gdGhhdC5fYnVzaW5lc3NSYW5nZTtcclxuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IHJhbmdlLmNhdGVnb3JpZXMgfHwgW107XHJcbiAgICAgICAgdmFyIHNjcmlwdCA9IHt9O1xyXG4gICAgICAgIHZhciBjYW52YXNPcHRpb25zID0gdGhhdC5fcHJlcGFyZUNhbnZhc09wdGlvbnMoKTtcclxuICAgICAgICB2YXIgdmlzaWJsZUNhdGVnb3JpZXMgPSBnZXRDYXRlZ29yaWVzSW5mbyhjYXRlZ29yaWVzLCByYW5nZS5taW5WaXNpYmxlLCByYW5nZS5tYXhWaXNpYmxlKS5jYXRlZ29yaWVzO1xyXG4gICAgICAgIHZhciBjYXRlZ29yaWVzTGVuZ3RoID0gdmlzaWJsZUNhdGVnb3JpZXMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgc2NyaXB0ID0gZHVtbXlUcmFuc2xhdG9yXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3dpdGNoIChyYW5nZS5heGlzVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImxvZ2FyaXRobWljXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gbG9nYXJpdGhtaWNUcmFuc2xhdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInNlbWlkaXNjcmV0ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IGludGVydmFsVHJhbnNsYXRvcjtcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXNPcHRpb25zLnJhdGlvT2ZDYW52YXNSYW5nZSA9IGNhbnZhc09wdGlvbnMuY2FudmFzTGVuZ3RoIC8gKGRhdGVVdGlscy5hZGRJbnRlcnZhbChjYW52YXNPcHRpb25zLnJhbmdlTWF4VmlzaWJsZSwgb3B0aW9ucy5pbnRlcnZhbCkgLSBjYW52YXNPcHRpb25zLnJhbmdlTWluVmlzaWJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGlzY3JldGVcIjpcclxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQgPSBjYXRlZ29yeVRyYW5zbGF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzT3B0aW9ucy5pbnRlcnZhbCA9IHRoYXQuX2dldERpc2NyZXRlSW50ZXJ2YWwob3B0aW9ucy5hZGRTcGlkZXJDYXRlZ29yeSA/IGNhdGVnb3JpZXNMZW5ndGggKyAxIDogY2F0ZWdvcmllc0xlbmd0aCwgY2FudmFzT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fY2F0ZWdvcmllc1RvUG9pbnRzID0gbWFrZUNhdGVnb3JpZXNUb1BvaW50cyhjYXRlZ29yaWVzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcmllc0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNPcHRpb25zLnN0YXJ0UG9pbnRJbmRleCA9IHRoYXQuX2NhdGVnb3JpZXNUb1BvaW50c1t2aXNpYmxlQ2F0ZWdvcmllc1swXS52YWx1ZU9mKCldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnZpc2libGVDYXRlZ29yaWVzID0gdmlzaWJsZUNhdGVnb3JpZXNcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcImRhdGV0aW1lXCIgPT09IHJhbmdlLmRhdGFUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IGRhdGV0aW1lVHJhbnNsYXRvclxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0odGhhdC5fb2xkTWV0aG9kcyB8fCBbXSkuZm9yRWFjaCgoZnVuY3Rpb24obWV0aG9kTmFtZSkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhhdFttZXRob2ROYW1lXVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGF0Ll9vbGRNZXRob2RzID0gT2JqZWN0LmtleXMoc2NyaXB0KTtcclxuICAgICAgICBleHRlbmQodGhhdCwgc2NyaXB0KTtcclxuICAgICAgICB0aGF0Ll9jb252ZXJzaW9uVmFsdWUgPSBvcHRpb25zLmNvbnZlcnNpb25WYWx1ZSA/IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAgIH0gOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoYXQuc2MgPSB7fTtcclxuICAgICAgICB0aGF0Ll9jaGVja2luZ01ldGhvZHNBYm91dEJyZWFrcyA9IFtnZXRDaGVja2luZ01ldGhvZHNBYm91dEJyZWFrcyhmYWxzZSksIGdldENoZWNraW5nTWV0aG9kc0Fib3V0QnJlYWtzKHRoYXQuaXNJbnZlcnRlZCgpKV07XHJcbiAgICAgICAgdGhhdC5fdHJhbnNsYXRlQnJlYWtzKCk7XHJcbiAgICAgICAgdGhhdC5fY2FsY3VsYXRlU3BlY2lhbFZhbHVlcygpXHJcbiAgICB9LFxyXG4gICAgX3RyYW5zbGF0ZUJyZWFrczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGJyZWFrcyA9IHRoaXMuX2JyZWFrcztcclxuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX29wdGlvbnMuYnJlYWtzU2l6ZTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgYjtcclxuICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgIHZhciBsZW5ndGg7XHJcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gYnJlYWtzKSB7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBicmVha3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYiA9IGJyZWFrc1tpXTtcclxuICAgICAgICAgICAgZW5kID0gdGhpcy50cmFuc2xhdGUoYi50byk7XHJcbiAgICAgICAgICAgIGIuZW5kID0gZW5kO1xyXG4gICAgICAgICAgICBiLnN0YXJ0ID0gIWIuZ2FwU2l6ZSA/ICF0aGlzLmlzSW52ZXJ0ZWQoKSA/IGVuZCAtIHNpemUgOiBlbmQgKyBzaXplIDogZW5kXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9jaGVja1ZhbHVlQWJvdXRCcmVha3M6IGZ1bmN0aW9uKGJyZWFrcywgcG9zLCBzdGFydCwgZW5kLCBtZXRob2RzKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGxlbmd0aDtcclxuICAgICAgICB2YXIgcHJvcCA9IHtcclxuICAgICAgICAgICAgbGVuZ3RoOiAwLFxyXG4gICAgICAgICAgICBicmVha3NTaXplOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIGluQnJlYWs6IGZhbHNlXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgYnI7XHJcbiAgICAgICAgdmFyIHByZXZCcmVhaztcclxuICAgICAgICB2YXIgbGFzdEJyZWFrID0gYnJlYWtzW2JyZWFrcy5sZW5ndGggLSAxXTtcclxuICAgICAgICBpZiAobWV0aG9kcy5pc1N0YXJ0U2lkZShwb3MsIGJyZWFrcywgc3RhcnQsIGVuZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3BcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZHMuaXNFbmRTaWRlKHBvcywgYnJlYWtzLCBzdGFydCwgZW5kKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBsYXN0QnJlYWsubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgYnJlYWtzU2l6ZTogbGFzdEJyZWFrLmN1bXVsYXRpdmVXaWR0aCxcclxuICAgICAgICAgICAgICAgIGluQnJlYWs6IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYnJlYWtzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJyID0gYnJlYWtzW2ldO1xyXG4gICAgICAgICAgICBwcmV2QnJlYWsgPSBicmVha3NbaSAtIDFdO1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kcy5pc0luQnJlYWsocG9zLCBiciwgc3RhcnQsIGVuZCkpIHtcclxuICAgICAgICAgICAgICAgIHByb3AuaW5CcmVhayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBwcm9wLmJyZWFrID0gYnI7XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcmV2QnJlYWsgJiYgbWV0aG9kcy5pc0JldHdlZW5CcmVha3MocG9zLCBiciwgcHJldkJyZWFrLCBzdGFydCwgZW5kKSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IG1ldGhvZHMuZ2V0TGVuZ3RoKHByZXZCcmVhaywgbGFzdEJyZWFrKSxcclxuICAgICAgICAgICAgICAgICAgICBicmVha3NTaXplOiBtZXRob2RzLmdldEJyZWFrc1NpemUocHJldkJyZWFrLCBsYXN0QnJlYWspLFxyXG4gICAgICAgICAgICAgICAgICAgIGluQnJlYWs6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvcFxyXG4gICAgfSxcclxuICAgIGlzSW52ZXJ0ZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAhKHRoaXMuX29wdGlvbnMuaXNIb3Jpem9udGFsIF4gdGhpcy5fYnVzaW5lc3NSYW5nZS5pbnZlcnQpXHJcbiAgICB9LFxyXG4gICAgX2dldERpc2NyZXRlSW50ZXJ2YWw6IGZ1bmN0aW9uKGNhdGVnb3JpZXNMZW5ndGgsIGNhbnZhc09wdGlvbnMpIHtcclxuICAgICAgICB2YXIgY29ycmVjdGVkQ2F0ZWdvcmllc0NvdW50ID0gY2F0ZWdvcmllc0xlbmd0aCAtICh0aGlzLl9vcHRpb25zLnN0aWNrID8gMSA6IDApO1xyXG4gICAgICAgIHJldHVybiBjb3JyZWN0ZWRDYXRlZ29yaWVzQ291bnQgPiAwID8gY2FudmFzT3B0aW9ucy5jYW52YXNMZW5ndGggLyBjb3JyZWN0ZWRDYXRlZ29yaWVzQ291bnQgOiBjYW52YXNPcHRpb25zLmNhbnZhc0xlbmd0aFxyXG4gICAgfSxcclxuICAgIF9wcmVwYXJlQ2FudmFzT3B0aW9ucygpIHtcclxuICAgICAgICB2YXIgYnVzaW5lc3NSYW5nZSA9IHRoaXMuX2J1c2luZXNzUmFuZ2U7XHJcbiAgICAgICAgdmFyIGNhbnZhc09wdGlvbnMgPSB0aGlzLl9jYW52YXNPcHRpb25zID0gZ2V0Q2FudmFzQm91bmRzKGJ1c2luZXNzUmFuZ2UpO1xyXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XHJcbiAgICAgICAgdmFyIGJyZWFrcyA9IHRoaXMuX2JyZWFrcztcclxuICAgICAgICB2YXIgbGVuZ3RoO1xyXG4gICAgICAgIGNhbnZhc09wdGlvbnMuc3RhcnRQYWRkaW5nID0gY2FudmFzLnN0YXJ0UGFkZGluZyB8fCAwO1xyXG4gICAgICAgIGNhbnZhc09wdGlvbnMuZW5kUGFkZGluZyA9IGNhbnZhcy5lbmRQYWRkaW5nIHx8IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgIGNhbnZhc09wdGlvbnMuc3RhcnRQb2ludCA9IGNhbnZhcy5sZWZ0ICsgY2FudmFzT3B0aW9ucy5zdGFydFBhZGRpbmc7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGNhbnZhcy53aWR0aDtcclxuICAgICAgICAgICAgY2FudmFzT3B0aW9ucy5lbmRQb2ludCA9IGNhbnZhcy53aWR0aCAtIGNhbnZhcy5yaWdodCAtIGNhbnZhc09wdGlvbnMuZW5kUGFkZGluZztcclxuICAgICAgICAgICAgY2FudmFzT3B0aW9ucy5pbnZlcnQgPSBidXNpbmVzc1JhbmdlLmludmVydFxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNhbnZhc09wdGlvbnMuc3RhcnRQb2ludCA9IGNhbnZhcy50b3AgKyBjYW52YXNPcHRpb25zLnN0YXJ0UGFkZGluZztcclxuICAgICAgICAgICAgbGVuZ3RoID0gY2FudmFzLmhlaWdodDtcclxuICAgICAgICAgICAgY2FudmFzT3B0aW9ucy5lbmRQb2ludCA9IGNhbnZhcy5oZWlnaHQgLSBjYW52YXMuYm90dG9tIC0gY2FudmFzT3B0aW9ucy5lbmRQYWRkaW5nO1xyXG4gICAgICAgICAgICBjYW52YXNPcHRpb25zLmludmVydCA9ICFidXNpbmVzc1JhbmdlLmludmVydFxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbnZhc0xlbmd0aCA9IGNhbnZhc09wdGlvbnMuY2FudmFzTGVuZ3RoID0gY2FudmFzT3B0aW9ucy5lbmRQb2ludCAtIGNhbnZhc09wdGlvbnMuc3RhcnRQb2ludDtcclxuICAgICAgICBjYW52YXNPcHRpb25zLnJhbmdlRG91YmxlRXJyb3IgPSBNYXRoLnBvdygxMCwgZ2V0UG93ZXIoY2FudmFzT3B0aW9ucy5yYW5nZU1heCAtIGNhbnZhc09wdGlvbnMucmFuZ2VNaW4pIC0gZ2V0UG93ZXIobGVuZ3RoKSAtIDIpO1xyXG4gICAgICAgIGNhbnZhc09wdGlvbnMucmF0aW9PZkNhbnZhc1JhbmdlID0gY2FudmFzT3B0aW9ucy5jYW52YXNMZW5ndGggLyAoY2FudmFzT3B0aW9ucy5yYW5nZU1heFZpc2libGUgLSBjYW52YXNPcHRpb25zLnJhbmdlTWluVmlzaWJsZSk7XHJcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gYnJlYWtzKSB7XHJcbiAgICAgICAgICAgIGNhbnZhc09wdGlvbnMucmF0aW9PZkNhbnZhc1JhbmdlID0gKGNhbnZhc09wdGlvbnMuY2FudmFzTGVuZ3RoIC0gYnJlYWtzW2JyZWFrcy5sZW5ndGggLSAxXS5jdW11bGF0aXZlV2lkdGgpIC8gKGNhbnZhc09wdGlvbnMucmFuZ2VNYXhWaXNpYmxlIC0gY2FudmFzT3B0aW9ucy5yYW5nZU1pblZpc2libGUgLSBicmVha3NbYnJlYWtzLmxlbmd0aCAtIDFdLmxlbmd0aClcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNhbnZhc09wdGlvbnNcclxuICAgIH0sXHJcbiAgICB1cGRhdGVDYW52YXM6IGZ1bmN0aW9uKGNhbnZhcykge1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IHZhbGlkYXRlQ2FudmFzKGNhbnZhcyk7XHJcbiAgICAgICAgdGhpcy5yZWluaXQoKVxyXG4gICAgfSxcclxuICAgIHVwZGF0ZUJ1c2luZXNzUmFuZ2U6IGZ1bmN0aW9uKGJ1c2luZXNzUmFuZ2UpIHtcclxuICAgICAgICB2YXIgYnJlYWtzID0gYnVzaW5lc3NSYW5nZS5icmVha3MgfHwgW107XHJcbiAgICAgICAgdGhpcy5fdXNlckJyZWFrcyA9IGJ1c2luZXNzUmFuZ2UudXNlckJyZWFrcyB8fCBbXTtcclxuICAgICAgICB0aGlzLl9idXNpbmVzc1JhbmdlID0gdmFsaWRhdGVCdXNpbmVzc1JhbmdlKGJ1c2luZXNzUmFuZ2UpO1xyXG4gICAgICAgIHRoaXMuX2JyZWFrcyA9IGJyZWFrcy5sZW5ndGggPyBwcmVwYXJlQnJlYWtzKGJyZWFrcywgdGhpcy5fYnVzaW5lc3NSYW5nZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgdGhpcy5yZWluaXQoKVxyXG4gICAgfSxcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24oYnVzaW5lc3NSYW5nZSwgY2FudmFzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IGV4dGVuZCh0aGlzLl9vcHRpb25zIHx8IHt9LCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9jYW52YXMgPSB2YWxpZGF0ZUNhbnZhcyhjYW52YXMpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQnVzaW5lc3NSYW5nZShidXNpbmVzc1JhbmdlKVxyXG4gICAgfSxcclxuICAgIGdldEJ1c2luZXNzUmFuZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idXNpbmVzc1JhbmdlXHJcbiAgICB9LFxyXG4gICAgZ2V0RXZlbnRTY2FsZTogZnVuY3Rpb24oem9vbUV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHpvb21FdmVudC5kZWx0YVNjYWxlIHx8IDFcclxuICAgIH0sXHJcbiAgICBnZXRDYW52YXNWaXNpYmxlQXJlYTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWluOiB0aGlzLl9jYW52YXNPcHRpb25zLnN0YXJ0UG9pbnQsXHJcbiAgICAgICAgICAgIG1heDogdGhpcy5fY2FudmFzT3B0aW9ucy5lbmRQb2ludFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBfY2FsY3VsYXRlU3BlY2lhbFZhbHVlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGNhbnZhc09wdGlvbnMgPSB0aGlzLl9jYW52YXNPcHRpb25zO1xyXG4gICAgICAgIHZhciBzdGFydFBvaW50ID0gY2FudmFzT3B0aW9ucy5zdGFydFBvaW50IC0gY2FudmFzT3B0aW9ucy5zdGFydFBhZGRpbmc7XHJcbiAgICAgICAgdmFyIGVuZFBvaW50ID0gY2FudmFzT3B0aW9ucy5lbmRQb2ludCArIGNhbnZhc09wdGlvbnMuZW5kUGFkZGluZztcclxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9idXNpbmVzc1JhbmdlO1xyXG4gICAgICAgIHZhciBtaW5WaXNpYmxlID0gcmFuZ2UubWluVmlzaWJsZTtcclxuICAgICAgICB2YXIgbWF4VmlzaWJsZSA9IHJhbmdlLm1heFZpc2libGU7XHJcbiAgICAgICAgdmFyIGNhbnZhc19wb3NpdGlvbl9jZW50ZXJfbWlkZGxlID0gc3RhcnRQb2ludCArIGNhbnZhc09wdGlvbnMuY2FudmFzTGVuZ3RoIC8gMjtcclxuICAgICAgICB2YXIgY2FudmFzX3Bvc2l0aW9uX2RlZmF1bHQ7XHJcbiAgICAgICAgaWYgKG1pblZpc2libGUgPCAwICYmIG1heFZpc2libGUgPiAwICYmIG1pblZpc2libGUgIT09IG1heFZpc2libGUpIHtcclxuICAgICAgICAgICAgY2FudmFzX3Bvc2l0aW9uX2RlZmF1bHQgPSB0aGlzLnRyYW5zbGF0ZSgwLCAxKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzRGVmaW5lZChjYW52YXNfcG9zaXRpb25fZGVmYXVsdCkpIHtcclxuICAgICAgICAgICAgdmFyIGludmVydCA9IHJhbmdlLmludmVydCBeIChtaW5WaXNpYmxlIDwgMCAmJiBtYXhWaXNpYmxlIDw9IDApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5pc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgIGNhbnZhc19wb3NpdGlvbl9kZWZhdWx0ID0gaW52ZXJ0ID8gZW5kUG9pbnQgOiBzdGFydFBvaW50XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNfcG9zaXRpb25fZGVmYXVsdCA9IGludmVydCA/IHN0YXJ0UG9pbnQgOiBlbmRQb2ludFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2MgPSB7XHJcbiAgICAgICAgICAgIGNhbnZhc19wb3NpdGlvbl9kZWZhdWx0OiBjYW52YXNfcG9zaXRpb25fZGVmYXVsdCxcclxuICAgICAgICAgICAgY2FudmFzX3Bvc2l0aW9uX2xlZnQ6IHN0YXJ0UG9pbnQsXHJcbiAgICAgICAgICAgIGNhbnZhc19wb3NpdGlvbl90b3A6IHN0YXJ0UG9pbnQsXHJcbiAgICAgICAgICAgIGNhbnZhc19wb3NpdGlvbl9jZW50ZXI6IGNhbnZhc19wb3NpdGlvbl9jZW50ZXJfbWlkZGxlLFxyXG4gICAgICAgICAgICBjYW52YXNfcG9zaXRpb25fbWlkZGxlOiBjYW52YXNfcG9zaXRpb25fY2VudGVyX21pZGRsZSxcclxuICAgICAgICAgICAgY2FudmFzX3Bvc2l0aW9uX3JpZ2h0OiBlbmRQb2ludCxcclxuICAgICAgICAgICAgY2FudmFzX3Bvc2l0aW9uX2JvdHRvbTogZW5kUG9pbnQsXHJcbiAgICAgICAgICAgIGNhbnZhc19wb3NpdGlvbl9zdGFydDogY2FudmFzT3B0aW9ucy5pbnZlcnQgPyBlbmRQb2ludCA6IHN0YXJ0UG9pbnQsXHJcbiAgICAgICAgICAgIGNhbnZhc19wb3NpdGlvbl9lbmQ6IGNhbnZhc09wdGlvbnMuaW52ZXJ0ID8gc3RhcnRQb2ludCA6IGVuZFBvaW50XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRyYW5zbGF0ZVNwZWNpYWxDYXNlKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NbdmFsdWVdXHJcbiAgICB9LFxyXG4gICAgX2NhbGN1bGF0ZVByb2plY3Rpb246IGZ1bmN0aW9uKGRpc3RhbmNlKSB7XHJcbiAgICAgICAgdmFyIGNhbnZhc09wdGlvbnMgPSB0aGlzLl9jYW52YXNPcHRpb25zO1xyXG4gICAgICAgIHJldHVybiBjYW52YXNPcHRpb25zLmludmVydCA/IGNhbnZhc09wdGlvbnMuZW5kUG9pbnQgLSBkaXN0YW5jZSA6IGNhbnZhc09wdGlvbnMuc3RhcnRQb2ludCArIGRpc3RhbmNlXHJcbiAgICB9LFxyXG4gICAgX2NhbGN1bGF0ZVVuUHJvamVjdGlvbjogZnVuY3Rpb24oZGlzdGFuY2UpIHtcclxuICAgICAgICB2YXIgY2FudmFzT3B0aW9ucyA9IHRoaXMuX2NhbnZhc09wdGlvbnM7XHJcbiAgICAgICAgXCJkYXRldGltZVwiID09PSB0aGlzLl9idXNpbmVzc1JhbmdlLmRhdGFUeXBlICYmIChkaXN0YW5jZSA9IE1hdGgucm91bmQoZGlzdGFuY2UpKTtcclxuICAgICAgICByZXR1cm4gY2FudmFzT3B0aW9ucy5pbnZlcnQgPyBjYW52YXNPcHRpb25zLnJhbmdlTWF4VmlzaWJsZS52YWx1ZU9mKCkgLSBkaXN0YW5jZSA6IGNhbnZhc09wdGlvbnMucmFuZ2VNaW5WaXNpYmxlLnZhbHVlT2YoKSArIGRpc3RhbmNlXHJcbiAgICB9LFxyXG4gICAgZ2V0TWluQmFyU2l6ZTogZnVuY3Rpb24obWluQmFyU2l6ZSkge1xyXG4gICAgICAgIHZhciB2aXNpYmxlQXJlYSA9IHRoaXMuZ2V0Q2FudmFzVmlzaWJsZUFyZWEoKTtcclxuICAgICAgICB2YXIgbWluVmFsdWUgPSB0aGlzLmZyb20odmlzaWJsZUFyZWEubWluICsgbWluQmFyU2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuIF9hYnModGhpcy5mcm9tKHZpc2libGVBcmVhLm1pbikgLSAoIWlzRGVmaW5lZChtaW5WYWx1ZSkgPyB0aGlzLmZyb20odmlzaWJsZUFyZWEubWF4KSA6IG1pblZhbHVlKSlcclxuICAgIH0sXHJcbiAgICBjaGVja01pbkJhclNpemU6IGZ1bmN0aW9uKHZhbHVlLCBtaW5TaG93blZhbHVlLCBzdGFja1ZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9hYnModmFsdWUpIDwgbWluU2hvd25WYWx1ZSA/IHZhbHVlID49IDAgPyBtaW5TaG93blZhbHVlIDogLW1pblNob3duVmFsdWUgOiB2YWx1ZVxyXG4gICAgfSxcclxuICAgIHRyYW5zbGF0ZShicCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIHNwZWNpYWxWYWx1ZSA9IHRoaXMudHJhbnNsYXRlU3BlY2lhbENhc2UoYnApO1xyXG4gICAgICAgIGlmIChpc0RlZmluZWQoc3BlY2lhbFZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChzcGVjaWFsVmFsdWUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05hTihicCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oYnAsIGRpcmVjdGlvbilcclxuICAgIH0sXHJcbiAgICBnZXRJbnRlcnZhbDogZnVuY3Rpb24oaW50ZXJ2YWwpIHtcclxuICAgICAgICB2YXIgX2ludGVydmFsO1xyXG4gICAgICAgIHZhciBjYW52YXNPcHRpb25zID0gdGhpcy5fY2FudmFzT3B0aW9ucztcclxuICAgICAgICBpbnRlcnZhbCA9IG51bGwgIT09IChfaW50ZXJ2YWwgPSBpbnRlcnZhbCkgJiYgdm9pZCAwICE9PSBfaW50ZXJ2YWwgPyBfaW50ZXJ2YWwgOiB0aGlzLl9idXNpbmVzc1JhbmdlLmludGVydmFsO1xyXG4gICAgICAgIGlmIChpbnRlcnZhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChjYW52YXNPcHRpb25zLnJhdGlvT2ZDYW52YXNSYW5nZSAqIGludGVydmFsKVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChjYW52YXNPcHRpb25zLmVuZFBvaW50IC0gY2FudmFzT3B0aW9ucy5zdGFydFBvaW50KVxyXG4gICAgfSxcclxuICAgIHpvb20odHJhbnNsYXRlLCBzY2FsZSwgd2hvbGVSYW5nZSkge1xyXG4gICAgICAgIHZhciBjYW52YXNPcHRpb25zID0gdGhpcy5fY2FudmFzT3B0aW9ucztcclxuICAgICAgICBpZiAoY2FudmFzT3B0aW9ucy5yYW5nZU1pblZpc2libGUudmFsdWVPZigpID09PSBjYW52YXNPcHRpb25zLnJhbmdlTWF4VmlzaWJsZS52YWx1ZU9mKCkgJiYgMCAhPT0gdHJhbnNsYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnpvb21aZXJvTGVuZ3RoUmFuZ2UodHJhbnNsYXRlLCBzY2FsZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBjYW52YXNPcHRpb25zLnN0YXJ0UG9pbnQ7XHJcbiAgICAgICAgdmFyIGVuZFBvaW50ID0gY2FudmFzT3B0aW9ucy5lbmRQb2ludDtcclxuICAgICAgICB2YXIgaXNJbnZlcnRlZCA9IHRoaXMuaXNJbnZlcnRlZCgpO1xyXG4gICAgICAgIHZhciBuZXdTdGFydCA9IChzdGFydFBvaW50ICsgdHJhbnNsYXRlKSAvIHNjYWxlO1xyXG4gICAgICAgIHZhciBuZXdFbmQgPSAoZW5kUG9pbnQgKyB0cmFuc2xhdGUpIC8gc2NhbGU7XHJcbiAgICAgICAgd2hvbGVSYW5nZSA9IHdob2xlUmFuZ2UgfHwge307XHJcbiAgICAgICAgdmFyIG1pblBvaW50ID0gdGhpcy50byhpc0ludmVydGVkID8gd2hvbGVSYW5nZS5lbmRWYWx1ZSA6IHdob2xlUmFuZ2Uuc3RhcnRWYWx1ZSk7XHJcbiAgICAgICAgdmFyIG1heFBvaW50ID0gdGhpcy50byhpc0ludmVydGVkID8gd2hvbGVSYW5nZS5zdGFydFZhbHVlIDogd2hvbGVSYW5nZS5lbmRWYWx1ZSk7XHJcbiAgICAgICAgdmFyIG1pbjtcclxuICAgICAgICB2YXIgbWF4O1xyXG4gICAgICAgIGlmIChtaW5Qb2ludCA+IG5ld1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIG5ld0VuZCAtPSBuZXdTdGFydCAtIG1pblBvaW50O1xyXG4gICAgICAgICAgICBuZXdTdGFydCA9IG1pblBvaW50O1xyXG4gICAgICAgICAgICBtaW4gPSBpc0ludmVydGVkID8gd2hvbGVSYW5nZS5lbmRWYWx1ZSA6IHdob2xlUmFuZ2Uuc3RhcnRWYWx1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF4UG9pbnQgPCBuZXdFbmQpIHtcclxuICAgICAgICAgICAgbmV3U3RhcnQgLT0gbmV3RW5kIC0gbWF4UG9pbnQ7XHJcbiAgICAgICAgICAgIG5ld0VuZCA9IG1heFBvaW50O1xyXG4gICAgICAgICAgICBtYXggPSBpc0ludmVydGVkID8gd2hvbGVSYW5nZS5zdGFydFZhbHVlIDogd2hvbGVSYW5nZS5lbmRWYWx1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF4UG9pbnQgLSBtaW5Qb2ludCA8IG5ld0VuZCAtIG5ld1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIG5ld1N0YXJ0ID0gbWluUG9pbnQ7XHJcbiAgICAgICAgICAgIG5ld0VuZCA9IG1heFBvaW50XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYW5zbGF0ZSA9IChlbmRQb2ludCAtIHN0YXJ0UG9pbnQpICogbmV3U3RhcnQgLyAobmV3RW5kIC0gbmV3U3RhcnQpIC0gc3RhcnRQb2ludDtcclxuICAgICAgICBzY2FsZSA9IChzdGFydFBvaW50ICsgdHJhbnNsYXRlKSAvIG5ld1N0YXJ0IHx8IDE7XHJcbiAgICAgICAgbWluID0gaXNEZWZpbmVkKG1pbikgPyBtaW4gOiBhZGp1c3QodGhpcy5mcm9tKG5ld1N0YXJ0LCAxKSk7XHJcbiAgICAgICAgbWF4ID0gaXNEZWZpbmVkKG1heCkgPyBtYXggOiBhZGp1c3QodGhpcy5mcm9tKG5ld0VuZCwgLTEpKTtcclxuICAgICAgICBpZiAoc2NhbGUgPD0gMSkge1xyXG4gICAgICAgICAgICBtaW4gPSB0aGlzLl9jb3JyZWN0VmFsdWVBYm91dEJyZWFrcyhtaW4sIDEgPT09IHNjYWxlID8gdHJhbnNsYXRlIDogLTEpO1xyXG4gICAgICAgICAgICBtYXggPSB0aGlzLl9jb3JyZWN0VmFsdWVBYm91dEJyZWFrcyhtYXgsIDEgPT09IHNjYWxlID8gdHJhbnNsYXRlIDogMSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1pbiA+IG1heCkge1xyXG4gICAgICAgICAgICBtaW4gPSBtaW4gPiB3aG9sZVJhbmdlLmVuZFZhbHVlID8gd2hvbGVSYW5nZS5lbmRWYWx1ZSA6IG1pbjtcclxuICAgICAgICAgICAgbWF4ID0gbWF4IDwgd2hvbGVSYW5nZS5zdGFydFZhbHVlID8gd2hvbGVSYW5nZS5zdGFydFZhbHVlIDogbWF4XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWluID0gbWluIDwgd2hvbGVSYW5nZS5zdGFydFZhbHVlID8gd2hvbGVSYW5nZS5zdGFydFZhbHVlIDogbWluO1xyXG4gICAgICAgICAgICBtYXggPSBtYXggPiB3aG9sZVJhbmdlLmVuZFZhbHVlID8gd2hvbGVSYW5nZS5lbmRWYWx1ZSA6IG1heFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtaW46IG1pbixcclxuICAgICAgICAgICAgbWF4OiBtYXgsXHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZTogYWRqdXN0KHRyYW5zbGF0ZSksXHJcbiAgICAgICAgICAgIHNjYWxlOiBhZGp1c3Qoc2NhbGUpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIF9jb3JyZWN0VmFsdWVBYm91dEJyZWFrcyh2YWx1ZSwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIGJyID0gdGhpcy5fdXNlckJyZWFrcy5maWx0ZXIoYnIgPT4gdmFsdWUgPj0gYnIuZnJvbSAmJiB2YWx1ZSA8PSBici50byk7XHJcbiAgICAgICAgaWYgKGJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uID4gMCA/IGJyWzBdLnRvIDogYnJbMF0uZnJvbVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB6b29tWmVyb0xlbmd0aFJhbmdlKHRyYW5zbGF0ZSwgc2NhbGUpIHtcclxuICAgICAgICB2YXIgY2FudmFzT3B0aW9ucyA9IHRoaXMuX2NhbnZhc09wdGlvbnM7XHJcbiAgICAgICAgdmFyIG1pbiA9IGNhbnZhc09wdGlvbnMucmFuZ2VNaW47XHJcbiAgICAgICAgdmFyIG1heCA9IGNhbnZhc09wdGlvbnMucmFuZ2VNYXg7XHJcbiAgICAgICAgdmFyIGNvcnJlY3Rpb24gPSAobWF4LnZhbHVlT2YoKSAhPT0gbWluLnZhbHVlT2YoKSA/IG1heC52YWx1ZU9mKCkgLSBtaW4udmFsdWVPZigpIDogX2FicyhjYW52YXNPcHRpb25zLnJhbmdlTWluVmlzaWJsZS52YWx1ZU9mKCkgLSBtaW4udmFsdWVPZigpKSkgLyBjYW52YXNPcHRpb25zLmNhbnZhc0xlbmd0aDtcclxuICAgICAgICB2YXIgaXNEYXRlVGltZSA9IGlzRGF0ZShtYXgpIHx8IGlzRGF0ZShtaW4pO1xyXG4gICAgICAgIHZhciBpc0xvZ2FyaXRobWljID0gXCJsb2dhcml0aG1pY1wiID09PSB0aGlzLl9idXNpbmVzc1JhbmdlLmF4aXNUeXBlO1xyXG4gICAgICAgIHZhciBuZXdNaW4gPSBjYW52YXNPcHRpb25zLnJhbmdlTWluVmlzaWJsZS52YWx1ZU9mKCkgLSBjb3JyZWN0aW9uO1xyXG4gICAgICAgIHZhciBuZXdNYXggPSBjYW52YXNPcHRpb25zLnJhbmdlTWF4VmlzaWJsZS52YWx1ZU9mKCkgKyBjb3JyZWN0aW9uO1xyXG4gICAgICAgIG5ld01pbiA9IGlzTG9nYXJpdGhtaWMgPyBhZGp1c3QocmFpc2VUb0V4dChuZXdNaW4sIGNhbnZhc09wdGlvbnMuYmFzZSkpIDogaXNEYXRlVGltZSA/IG5ldyBEYXRlKG5ld01pbikgOiBuZXdNaW47XHJcbiAgICAgICAgbmV3TWF4ID0gaXNMb2dhcml0aG1pYyA/IGFkanVzdChyYWlzZVRvRXh0KG5ld01heCwgY2FudmFzT3B0aW9ucy5iYXNlKSkgOiBpc0RhdGVUaW1lID8gbmV3IERhdGUobmV3TWF4KSA6IG5ld01heDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtaW46IG5ld01pbixcclxuICAgICAgICAgICAgbWF4OiBuZXdNYXgsXHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZTogdHJhbnNsYXRlLFxyXG4gICAgICAgICAgICBzY2FsZTogc2NhbGVcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZ2V0TWluU2NhbGU6IGZ1bmN0aW9uKHpvb20pIHtcclxuICAgICAgICB2YXIge1xyXG4gICAgICAgICAgICBkYXRhVHlwZTogZGF0YVR5cGUsXHJcbiAgICAgICAgICAgIGludGVydmFsOiBpbnRlcnZhbFxyXG4gICAgICAgIH0gPSB0aGlzLl9idXNpbmVzc1JhbmdlO1xyXG4gICAgICAgIGlmIChcImRhdGV0aW1lXCIgPT09IGRhdGFUeXBlICYmIDEgPT09IGludGVydmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERhdGVUaW1lTWluU2NhbGUoem9vbSlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHpvb20gPyAxLjEgOiAuOVxyXG4gICAgfSxcclxuICAgIGdldERhdGVUaW1lTWluU2NhbGUoem9vbSkge1xyXG4gICAgICAgIHZhciBjYW52YXNPcHRpb25zID0gdGhpcy5fY2FudmFzT3B0aW9ucztcclxuICAgICAgICB2YXIgbGVuZ3RoID0gY2FudmFzT3B0aW9ucy5jYW52YXNMZW5ndGggLyBjYW52YXNPcHRpb25zLnJhdGlvT2ZDYW52YXNSYW5nZTtcclxuICAgICAgICBsZW5ndGggKz0gKHBhcnNlSW50KC4xICogbGVuZ3RoKSB8fCAxKSAqICh6b29tID8gLTIgOiAyKTtcclxuICAgICAgICByZXR1cm4gY2FudmFzT3B0aW9ucy5jYW52YXNMZW5ndGggLyAoTWF0aC5tYXgobGVuZ3RoLCAxKSAqIGNhbnZhc09wdGlvbnMucmF0aW9PZkNhbnZhc1JhbmdlKVxyXG4gICAgfSxcclxuICAgIGdldFNjYWxlOiBmdW5jdGlvbih2YWwxLCB2YWwyKSB7XHJcbiAgICAgICAgdmFyIGNhbnZhc09wdGlvbnMgPSB0aGlzLl9jYW52YXNPcHRpb25zO1xyXG4gICAgICAgIGlmIChjYW52YXNPcHRpb25zLnJhbmdlTWF4ID09PSBjYW52YXNPcHRpb25zLnJhbmdlTWluKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbDEgPSBpc0RlZmluZWQodmFsMSkgPyB0aGlzLmZyb21WYWx1ZSh2YWwxKSA6IGNhbnZhc09wdGlvbnMucmFuZ2VNaW47XHJcbiAgICAgICAgdmFsMiA9IGlzRGVmaW5lZCh2YWwyKSA/IHRoaXMuZnJvbVZhbHVlKHZhbDIpIDogY2FudmFzT3B0aW9ucy5yYW5nZU1heDtcclxuICAgICAgICByZXR1cm4gKGNhbnZhc09wdGlvbnMucmFuZ2VNYXggLSBjYW52YXNPcHRpb25zLnJhbmdlTWluKSAvIE1hdGguYWJzKHZhbDEgLSB2YWwyKVxyXG4gICAgfSxcclxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNvID0gdGhpcy5fY2FudmFzT3B0aW9ucztcclxuICAgICAgICB2YWx1ZSA9IHRoaXMuZnJvbVZhbHVlKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gbnVsbCAhPT0gdmFsdWUgJiYgIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZS52YWx1ZU9mKCkgKyBjby5yYW5nZURvdWJsZUVycm9yID49IGNvLnJhbmdlTWluICYmIHZhbHVlLnZhbHVlT2YoKSAtIGNvLnJhbmdlRG91YmxlRXJyb3IgPD0gY28ucmFuZ2VNYXhcclxuICAgIH0sXHJcbiAgICBnZXRDb3JyZWN0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICB2YXIgYnJlYWtzID0gdGhpcy5fYnJlYWtzO1xyXG4gICAgICAgIHZhciBwcm9wO1xyXG4gICAgICAgIHZhbHVlID0gdGhpcy5mcm9tVmFsdWUodmFsdWUpO1xyXG4gICAgICAgIGlmICh0aGlzLl9icmVha3MpIHtcclxuICAgICAgICAgICAgcHJvcCA9IHRoaXMuX2NoZWNrVmFsdWVBYm91dEJyZWFrcyhicmVha3MsIHZhbHVlLCBcInRyRnJvbVwiLCBcInRyVG9cIiwgdGhpcy5fY2hlY2tpbmdNZXRob2RzQWJvdXRCcmVha3NbMF0pO1xyXG4gICAgICAgICAgICBpZiAodHJ1ZSA9PT0gcHJvcC5pbkJyZWFrKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b1ZhbHVlKGRpcmVjdGlvbiA+IDAgPyBwcm9wLmJyZWFrLnRyVG8gOiBwcm9wLmJyZWFrLnRyRnJvbSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50b1ZhbHVlKHZhbHVlKVxyXG4gICAgfSxcclxuICAgIHRvOiBmdW5jdGlvbihicCwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRCdXNpbmVzc1JhbmdlKCk7XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZChyYW5nZS5tYXhWaXNpYmxlKSAmJiBpc0RlZmluZWQocmFuZ2UubWluVmlzaWJsZSkgJiYgcmFuZ2UubWF4VmlzaWJsZS52YWx1ZU9mKCkgPT09IHJhbmdlLm1pblZpc2libGUudmFsdWVPZigpKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKGJwKSB8fCByYW5nZS5tYXhWaXNpYmxlLnZhbHVlT2YoKSAhPT0gYnAudmFsdWVPZigpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVNwZWNpYWxDYXNlKDAgPT09IGJwICYmIHRoaXMuX29wdGlvbnMuc2hpZnRaZXJvVmFsdWUgPyBcImNhbnZhc19wb3NpdGlvbl9kZWZhdWx0XCIgOiBcImNhbnZhc19wb3NpdGlvbl9taWRkbGVcIilcclxuICAgICAgICB9XHJcbiAgICAgICAgYnAgPSB0aGlzLmZyb21WYWx1ZShicCk7XHJcbiAgICAgICAgdmFyIGNhbnZhc09wdGlvbnMgPSB0aGlzLl9jYW52YXNPcHRpb25zO1xyXG4gICAgICAgIHZhciBicmVha3MgPSB0aGlzLl9icmVha3M7XHJcbiAgICAgICAgdmFyIHByb3AgPSB7XHJcbiAgICAgICAgICAgIGxlbmd0aDogMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGNvbW1vbkJyZWFrU2l6ZSA9IDA7XHJcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gYnJlYWtzKSB7XHJcbiAgICAgICAgICAgIHByb3AgPSB0aGlzLl9jaGVja1ZhbHVlQWJvdXRCcmVha3MoYnJlYWtzLCBicCwgXCJ0ckZyb21cIiwgXCJ0clRvXCIsIHRoaXMuX2NoZWNraW5nTWV0aG9kc0Fib3V0QnJlYWtzWzBdKTtcclxuICAgICAgICAgICAgY29tbW9uQnJlYWtTaXplID0gaXNEZWZpbmVkKHByb3AuYnJlYWtzU2l6ZSkgPyBwcm9wLmJyZWFrc1NpemUgOiAwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cnVlID09PSBwcm9wLmluQnJlYWspIHtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wLmJyZWFrLnN0YXJ0XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3AuYnJlYWsuZW5kXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJzaW9uVmFsdWUodGhpcy5fY2FsY3VsYXRlUHJvamVjdGlvbigoYnAgLSBjYW52YXNPcHRpb25zLnJhbmdlTWluVmlzaWJsZSAtIHByb3AubGVuZ3RoKSAqIGNhbnZhc09wdGlvbnMucmF0aW9PZkNhbnZhc1JhbmdlICsgY29tbW9uQnJlYWtTaXplKSlcclxuICAgIH0sXHJcbiAgICBmcm9tOiBmdW5jdGlvbihwb3MsIGRpcmVjdGlvbikge1xyXG4gICAgICAgIHZhciBicmVha3MgPSB0aGlzLl9icmVha3M7XHJcbiAgICAgICAgdmFyIHByb3AgPSB7XHJcbiAgICAgICAgICAgIGxlbmd0aDogMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGNhbnZhc09wdGlvbnMgPSB0aGlzLl9jYW52YXNPcHRpb25zO1xyXG4gICAgICAgIHZhciBzdGFydFBvaW50ID0gY2FudmFzT3B0aW9ucy5zdGFydFBvaW50O1xyXG4gICAgICAgIHZhciBjb21tb25CcmVha1NpemUgPSAwO1xyXG4gICAgICAgIGlmICh2b2lkIDAgIT09IGJyZWFrcykge1xyXG4gICAgICAgICAgICBwcm9wID0gdGhpcy5fY2hlY2tWYWx1ZUFib3V0QnJlYWtzKGJyZWFrcywgcG9zLCBcInN0YXJ0XCIsIFwiZW5kXCIsIHRoaXMuX2NoZWNraW5nTWV0aG9kc0Fib3V0QnJlYWtzWzFdKTtcclxuICAgICAgICAgICAgY29tbW9uQnJlYWtTaXplID0gaXNEZWZpbmVkKHByb3AuYnJlYWtzU2l6ZSkgPyBwcm9wLmJyZWFrc1NpemUgOiAwXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cnVlID09PSBwcm9wLmluQnJlYWspIHtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvVmFsdWUocHJvcC5icmVhay50clRvKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvVmFsdWUocHJvcC5icmVhay50ckZyb20pXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRvVmFsdWUodGhpcy5fY2FsY3VsYXRlVW5Qcm9qZWN0aW9uKChwb3MgLSBzdGFydFBvaW50IC0gY29tbW9uQnJlYWtTaXplKSAvIGNhbnZhc09wdGlvbnMucmF0aW9PZkNhbnZhc1JhbmdlICsgcHJvcC5sZW5ndGgpKVxyXG4gICAgfSxcclxuICAgIGlzVmFsdWVQcm9sb25nZWQ6IGZhbHNlLFxyXG4gICAgZ2V0UmFuZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy50b1ZhbHVlKHRoaXMuX2NhbnZhc09wdGlvbnMucmFuZ2VNaW4pLCB0aGlzLnRvVmFsdWUodGhpcy5fY2FudmFzT3B0aW9ucy5yYW5nZU1heCldXHJcbiAgICB9LFxyXG4gICAgZ2V0U2NyZWVuUmFuZ2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy5fY2FudmFzT3B0aW9ucy5zdGFydFBvaW50LCB0aGlzLl9jYW52YXNPcHRpb25zLmVuZFBvaW50XVxyXG4gICAgfSxcclxuICAgIGFkZDogZnVuY3Rpb24odmFsdWUsIGRpZmYsIGRpcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGQodmFsdWUsIGRpZmYsICh0aGlzLl9idXNpbmVzc1JhbmdlLmludmVydCA/IC0xIDogMSkgKiBkaXIpXHJcbiAgICB9LFxyXG4gICAgX2FkZDogZnVuY3Rpb24odmFsdWUsIGRpZmYsIGNvZWZmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9WYWx1ZSh0aGlzLmZyb21WYWx1ZSh2YWx1ZSkgKyBkaWZmICogY29lZmYpXHJcbiAgICB9LFxyXG4gICAgZnJvbVZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsICE9PSB2YWx1ZSA/IE51bWJlcih2YWx1ZSkgOiBudWxsXHJcbiAgICB9LFxyXG4gICAgdG9WYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbCAhPT0gdmFsdWUgPyBOdW1iZXIodmFsdWUpIDogbnVsbFxyXG4gICAgfSxcclxuICAgIHJhdGlvT2ZDYW52YXNSYW5nZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzT3B0aW9ucy5yYXRpb09mQ2FudmFzUmFuZ2VcclxuICAgIH0sXHJcbiAgICBjb252ZXJ0OiB2YWx1ZSA9PiB2YWx1ZSxcclxuICAgIGdldFJhbmdlQnlNaW5ab29tVmFsdWUobWluWm9vbSwgdmlzdWFsUmFuZ2UpIHtcclxuICAgICAgICBpZiAodmlzdWFsUmFuZ2UubWluVmlzaWJsZSArIG1pblpvb20gPD0gdGhpcy5fYnVzaW5lc3NSYW5nZS5tYXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt2aXN1YWxSYW5nZS5taW5WaXNpYmxlLCB2aXN1YWxSYW5nZS5taW5WaXNpYmxlICsgbWluWm9vbV1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gW3Zpc3VhbFJhbmdlLm1heFZpc2libGUgLSBtaW5ab29tLCB2aXN1YWxSYW5nZS5tYXhWaXNpYmxlXVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuZXhwb3J0IHtcclxuICAgIF9UcmFuc2xhdG9yMmQgYXMgVHJhbnNsYXRvcjJEXHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/translators/translator2d.js\n");

/***/ }),

/***/ "./node_modules/devextreme/esm/viz/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/devextreme/esm/viz/utils.js ***!
  \**************************************************/
/*! exports provided: prepareSegmentRectPoints, refreshPaths */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"prepareSegmentRectPoints\", function() { return prepareSegmentRectPoints; });\n/* harmony import */ var _core_renderers_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/renderers/renderer */ \"./node_modules/devextreme/esm/viz/core/renderers/renderer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"refreshPaths\", function() { return _core_renderers_renderer__WEBPACK_IMPORTED_MODULE_0__[\"refreshPaths\"]; });\n\n/* harmony import */ var _core_utils_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/utils/iterator */ \"./node_modules/devextreme/esm/core/utils/iterator.js\");\n/**\r\n * DevExtreme (esm/viz/utils.js)\r\n * Version: 21.2.7\r\n * Build date: Mon Apr 11 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\r\n\r\nvar prepareSegmentRectPoints = function(left, top, width, height, borderOptions) {\r\n    var maxSW = ~~((width < height ? width : height) / 2);\r\n    var sw = borderOptions.width || 0;\r\n    var newSW = sw < maxSW ? sw : maxSW;\r\n    left += newSW / 2;\r\n    top += newSW / 2;\r\n    width -= newSW;\r\n    height -= newSW;\r\n    var right = left + width;\r\n    var bottom = top + height;\r\n    var points = [];\r\n    var segments = [];\r\n    var segmentSequence;\r\n    var visiblyOpt = 0;\r\n    var prevSegmentVisibility = 0;\r\n    var allSegment = {\r\n        top: [\r\n            [left, top],\r\n            [right, top]\r\n        ],\r\n        right: [\r\n            [right, top],\r\n            [right, bottom]\r\n        ],\r\n        bottom: [\r\n            [right, bottom],\r\n            [left, bottom]\r\n        ],\r\n        left: [\r\n            [left, bottom],\r\n            [left, top]\r\n        ]\r\n    };\r\n    Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_1__[\"each\"])(allSegment, (function(seg) {\r\n        var visibility = !!borderOptions[seg];\r\n        visiblyOpt = 2 * visiblyOpt + ~~visibility\r\n    }));\r\n    switch (visiblyOpt) {\r\n        case 13:\r\n        case 9:\r\n            segmentSequence = [\"left\", \"top\", \"right\", \"bottom\"];\r\n            break;\r\n        case 11:\r\n            segmentSequence = [\"bottom\", \"left\", \"top\", \"right\"];\r\n            break;\r\n        default:\r\n            segmentSequence = [\"top\", \"right\", \"bottom\", \"left\"]\r\n    }\r\n    Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_1__[\"each\"])(segmentSequence, (function(_, seg) {\r\n        var segmentVisibility = !!borderOptions[seg];\r\n        if (!prevSegmentVisibility && segments.length) {\r\n            points.push(segments);\r\n            segments = []\r\n        }\r\n        if (segmentVisibility) {\r\n            Object(_core_utils_iterator__WEBPACK_IMPORTED_MODULE_1__[\"each\"])(allSegment[seg].slice(prevSegmentVisibility), (function(_, segment) {\r\n                segments = segments.concat(segment)\r\n            }))\r\n        }\r\n        prevSegmentVisibility = ~~segmentVisibility\r\n    }));\r\n    segments.length && points.push(segments);\r\n    1 === points.length && (points = points[0]);\r\n    return {\r\n        points: points,\r\n        pathType: 15 === visiblyOpt ? \"area\" : \"line\"\r\n    }\r\n};\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L3V0aWxzLmpzPzEyM2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdtQztBQUdIO0FBQ3pCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUVBQUs7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRUFBSztBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGV2ZXh0cmVtZS9lc20vdml6L3V0aWxzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERldkV4dHJlbWUgKGVzbS92aXovdXRpbHMuanMpXHJcbiAqIFZlcnNpb246IDIxLjIuN1xyXG4gKiBCdWlsZCBkYXRlOiBNb24gQXByIDExIDIwMjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMiBEZXZlbG9wZXIgRXhwcmVzcyBJbmMuIEFMTCBSSUdIVFMgUkVTRVJWRURcclxuICogUmVhZCBhYm91dCBEZXZFeHRyZW1lIGxpY2Vuc2luZyBoZXJlOiBodHRwczovL2pzLmRldmV4cHJlc3MuY29tL0xpY2Vuc2luZy9cclxuICovXHJcbmltcG9ydCB7XHJcbiAgICByZWZyZXNoUGF0aHNcclxufSBmcm9tIFwiLi9jb3JlL3JlbmRlcmVycy9yZW5kZXJlclwiO1xyXG5pbXBvcnQge1xyXG4gICAgZWFjaCBhcyBfZWFjaFxyXG59IGZyb20gXCIuLi9jb3JlL3V0aWxzL2l0ZXJhdG9yXCI7XHJcbmV4cG9ydCB2YXIgcHJlcGFyZVNlZ21lbnRSZWN0UG9pbnRzID0gZnVuY3Rpb24obGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LCBib3JkZXJPcHRpb25zKSB7XHJcbiAgICB2YXIgbWF4U1cgPSB+figod2lkdGggPCBoZWlnaHQgPyB3aWR0aCA6IGhlaWdodCkgLyAyKTtcclxuICAgIHZhciBzdyA9IGJvcmRlck9wdGlvbnMud2lkdGggfHwgMDtcclxuICAgIHZhciBuZXdTVyA9IHN3IDwgbWF4U1cgPyBzdyA6IG1heFNXO1xyXG4gICAgbGVmdCArPSBuZXdTVyAvIDI7XHJcbiAgICB0b3AgKz0gbmV3U1cgLyAyO1xyXG4gICAgd2lkdGggLT0gbmV3U1c7XHJcbiAgICBoZWlnaHQgLT0gbmV3U1c7XHJcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XHJcbiAgICB2YXIgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xyXG4gICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgdmFyIHNlZ21lbnRzID0gW107XHJcbiAgICB2YXIgc2VnbWVudFNlcXVlbmNlO1xyXG4gICAgdmFyIHZpc2libHlPcHQgPSAwO1xyXG4gICAgdmFyIHByZXZTZWdtZW50VmlzaWJpbGl0eSA9IDA7XHJcbiAgICB2YXIgYWxsU2VnbWVudCA9IHtcclxuICAgICAgICB0b3A6IFtcclxuICAgICAgICAgICAgW2xlZnQsIHRvcF0sXHJcbiAgICAgICAgICAgIFtyaWdodCwgdG9wXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcmlnaHQ6IFtcclxuICAgICAgICAgICAgW3JpZ2h0LCB0b3BdLFxyXG4gICAgICAgICAgICBbcmlnaHQsIGJvdHRvbV1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGJvdHRvbTogW1xyXG4gICAgICAgICAgICBbcmlnaHQsIGJvdHRvbV0sXHJcbiAgICAgICAgICAgIFtsZWZ0LCBib3R0b21dXHJcbiAgICAgICAgXSxcclxuICAgICAgICBsZWZ0OiBbXHJcbiAgICAgICAgICAgIFtsZWZ0LCBib3R0b21dLFxyXG4gICAgICAgICAgICBbbGVmdCwgdG9wXVxyXG4gICAgICAgIF1cclxuICAgIH07XHJcbiAgICBfZWFjaChhbGxTZWdtZW50LCAoZnVuY3Rpb24oc2VnKSB7XHJcbiAgICAgICAgdmFyIHZpc2liaWxpdHkgPSAhIWJvcmRlck9wdGlvbnNbc2VnXTtcclxuICAgICAgICB2aXNpYmx5T3B0ID0gMiAqIHZpc2libHlPcHQgKyB+fnZpc2liaWxpdHlcclxuICAgIH0pKTtcclxuICAgIHN3aXRjaCAodmlzaWJseU9wdCkge1xyXG4gICAgICAgIGNhc2UgMTM6XHJcbiAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgICAgICBzZWdtZW50U2VxdWVuY2UgPSBbXCJsZWZ0XCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIl07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTE6XHJcbiAgICAgICAgICAgIHNlZ21lbnRTZXF1ZW5jZSA9IFtcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJ0b3BcIiwgXCJyaWdodFwiXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgc2VnbWVudFNlcXVlbmNlID0gW1widG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdXHJcbiAgICB9XHJcbiAgICBfZWFjaChzZWdtZW50U2VxdWVuY2UsIChmdW5jdGlvbihfLCBzZWcpIHtcclxuICAgICAgICB2YXIgc2VnbWVudFZpc2liaWxpdHkgPSAhIWJvcmRlck9wdGlvbnNbc2VnXTtcclxuICAgICAgICBpZiAoIXByZXZTZWdtZW50VmlzaWJpbGl0eSAmJiBzZWdtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goc2VnbWVudHMpO1xyXG4gICAgICAgICAgICBzZWdtZW50cyA9IFtdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWdtZW50VmlzaWJpbGl0eSkge1xyXG4gICAgICAgICAgICBfZWFjaChhbGxTZWdtZW50W3NlZ10uc2xpY2UocHJldlNlZ21lbnRWaXNpYmlsaXR5KSwgKGZ1bmN0aW9uKF8sIHNlZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRzID0gc2VnbWVudHMuY29uY2F0KHNlZ21lbnQpXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2U2VnbWVudFZpc2liaWxpdHkgPSB+fnNlZ21lbnRWaXNpYmlsaXR5XHJcbiAgICB9KSk7XHJcbiAgICBzZWdtZW50cy5sZW5ndGggJiYgcG9pbnRzLnB1c2goc2VnbWVudHMpO1xyXG4gICAgMSA9PT0gcG9pbnRzLmxlbmd0aCAmJiAocG9pbnRzID0gcG9pbnRzWzBdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgcGF0aFR5cGU6IDE1ID09PSB2aXNpYmx5T3B0ID8gXCJhcmVhXCIgOiBcImxpbmVcIlxyXG4gICAgfVxyXG59O1xyXG5leHBvcnQge1xyXG4gICAgcmVmcmVzaFBhdGhzXHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/devextreme/esm/viz/utils.js\n");

/***/ })

}]);